/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_Loader-2173b0c5_js"],{

/***/ "../../react-swift/dist/Loader-2173b0c5.js":
/*!*************************************************!*\
  !*** ../../react-swift/dist/Loader-2173b0c5.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-84678bd5.js */ \"../../react-swift/dist/index-84678bd5.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"../../react-swift/node_modules/react-dom/index.js\");\n\n\n\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * var mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  var materials = [];\n *  var nGeometryGroups = geometry.groups.length;\n *\n *  var colorMap = ...; // Some logic to index colors.\n *\n *  for (var i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tvar material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  var mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nvar STLLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nSTLLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: STLLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView( data );\n\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tvar reader = new DataView( data );\n\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar dataOffset = 84;\n\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tvar faceCounter = 0;\n\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tvar normal = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar result;\n\n\t\t\tvar groupCount = 0;\n\t\t\tvar startVertex = 0;\n\t\t\tvar endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar start = startVertex;\n\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tvar binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n} );\n\nvar GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tGLTFLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar resourcePath;\n\n\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\tresourcePath = this.path;\n\n\t\t\t} else {\n\n\t\t\t\tresourcePath = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url );\n\n\t\t\t}\n\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\n\t\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, _onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t_onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, _onError );\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDDSLoader: function () {\n\n\t\t\tthrow new Error(\n\n\t\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t\t);\n\n\t\t},\n\n\t\tsetKTX2Loader: function ( ktx2Loader ) {\n\n\t\t\tthis.ktx2Loader = ktx2Loader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetMeshoptDecoder: function ( meshoptDecoder ) {\n\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\t\t\tvar plugins = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser( json, {\n\n\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\trequestHeader: this.requestHeader,\n\t\t\t\tmanager: this.manager,\n\t\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t\t} );\n\n\t\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\t\tfor ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\t\tvar plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t\t// Remove this workaround if we move all the existing\n\t\t\t\t// extension handlers to plugin system\n\t\t\t\textensions[ plugin.name ] = true;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.setExtensions( extensions );\n\t\t\tparser.setPlugins( plugins );\n\t\t\tparser.parse( onLoad, onError );\n\n\t\t}\n\n\t} );\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n\t};\n\n\t/**\n\t * Punctual Lights Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t */\n\tfunction GLTFLightsExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\tGLTFLightsExtension.prototype._markDefs = function () {\n\n\t\tvar parser = this.parser;\n\t\tvar nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tGLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar cacheKey = 'light:' + lightIndex;\n\t\tvar dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tvar json = parser.json;\n\t\tvar extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tvar lightDefs = extensions.lights || [];\n\t\tvar lightDef = lightDefs[ lightIndex ];\n\t\tvar lightNode;\n\n\t\tvar color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__._( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Z( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Y( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t};\n\n\tGLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {\n\n\t\tvar self = this;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\t\tvar lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tvar lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Unlit Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t */\n\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Clearcoat Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t */\n\tfunction GLTFMaterialsClearcoatExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tmaterialParams.clearcoatNormalScale = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a( scale, - scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Transmission Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n\t */\n\tfunction GLTFMaterialsTransmissionExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tGLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * BasisU Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n\t */\n\tfunction GLTFTextureBasisUExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tGLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ this.name ];\n\t\tvar source = json.images[ extension.source ];\n\t\tvar loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\t/**\n\t * WebP Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n\t */\n\tfunction GLTFTextureWebPExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tGLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar name = this.name;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ name ];\n\t\tvar source = json.images[ extension.source ];\n\n\t\tvar loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t};\n\n\tGLTFTextureWebPExtension.prototype.detectSupport = function () {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tvar image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t};\n\n\t/**\n\t* meshopt BufferView Compression Extension\n\t*\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n\t*/\n\tfunction GLTFMeshoptCompression( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tGLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {\n\n\t\tvar json = this.parser.json;\n\t\tvar bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tvar extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tvar buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tvar decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tvar byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tvar byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tvar count = extensionDef.count;\n\t\t\t\tvar stride = extensionDef.byteStride;\n\n\t\t\t\tvar result = new ArrayBuffer( count * stride );\n\t\t\t\tvar source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/* BINARY EXTENSION */\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tvar chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t */\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar json = this.json;\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\t\tvar attributeNormalizedMap = {};\n\t\tvar attributeTypeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Texture Transform Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t */\n\tfunction GLTFTextureTransformExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\n\t/**\n\t * A sub class of StandardMaterial with some of the functionality\n\t * changed via the `onBeforeCompile` callback\n\t * @pailhead\n\t */\n\n\tfunction GLTFMeshStandardSGMaterial( params ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.h.call( this );\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tvar specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tvar uniforms = {\n\t\t\tspecular: { value: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( var uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tGLTFMeshStandardSGMaterial.prototype = Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype );\n\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype.copy.call( this, source );\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t};\n\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'normalMapType',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn GLTFMeshStandardSGMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\tmaterialParams.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.emissive = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 0.0, 0.0, 0.0 );\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tmaterialParams.specular = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( materialParams ) {\n\n\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\t\t\tmaterial.fog = true;\n\n\t\t\t\tmaterial.color = materialParams.color;\n\n\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = materialParams.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\t\t\tmaterial.normalMapType = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.i;\n\n\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\t\t\tmaterial.specular = materialParams.specular;\n\n\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\t\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Mesh Quantization Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t */\n\tfunction GLTFMeshQuantizationExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a0.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a0.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\t\tvar s0 = 1 - s2;\n\t\tvar s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a1,\n\t\t9729: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.m,\n\t\t9984: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a2,\n\t\t9985: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a3,\n\t\t9986: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a4,\n\t\t9987: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.n\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5,\n\t\t33648: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a6,\n\t\t10497: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTANGENT: 'tangent',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tJOINTS_0: 'skinIndex',\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\tLINEAR: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.J,\n\t\tSTEP: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a7\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial( cache ) {\n\n\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\t\tcache[ 'DefaultMaterial' ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.h( {\n\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\temissive: 0x000000,\n\t\t\t\tmetalness: 1,\n\t\t\t\troughness: 1,\n\t\t\t\ttransparent: false,\n\t\t\t\tdepthTest: true,\n\t\t\t\tside: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a8\n\t\t\t} );\n\n\t\t}\n\n\t\treturn cache[ 'DefaultMaterial' ];\n\n\t}\n\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @param {Object3D|Material|BufferGeometry} object\n\t * @param {GLTF.definition} gltfDef\n\t */\n\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\tvar pendingPositionAccessors = [];\n\t\tvar pendingNormalAccessors = [];\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( [\n\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\tPromise.all( pendingNormalAccessors )\n\t\t] ).then( function ( accessors ) {\n\n\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t\treturn geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\n\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\tvar geometryKey;\n\n\t\tif ( dracoExtension ) {\n\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t} else {\n\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t}\n\n\t\treturn geometryKey;\n\n\t}\n\n\tfunction createAttributesKey( attributes ) {\n\n\t\tvar attributesKey = '';\n\n\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t}\n\n\t\treturn attributesKey;\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.I( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.j( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tGLTFParser.prototype.setExtensions = function ( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t};\n\n\tGLTFParser.prototype.setPlugins = function ( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t};\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tvar result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype._markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\tGLTFParser.prototype._addNodeRef = function ( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t};\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\tGLTFParser.prototype._getNodeRef = function ( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tvar ref = object.clone();\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t};\n\n\tGLTFParser.prototype._invokeOne = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t};\n\n\tGLTFParser.prototype._invokeAll = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.k( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.l( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureDef = json.textures[ textureIndex ];\n\t\tvar source = json.images[ textureDef.source ];\n\n\t\tvar loader = this.textureLoader;\n\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\tGLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar URL = self.URL || self.webkitURL;\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\t\tvar hasAlpha = true;\n\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\n\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n\t\t\t\t\t// alpha channel. This check is conservative — the image could have an alpha\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\n\t\t\t\t\t// sometimes contains alpha.\n\t\t\t\t\t//\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n\t\t\t\t\tvar colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n\n\t\t\t\t}\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( source.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tvar onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tresolve( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a9( imageBitmap ) );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\t\t\tif ( ! hasAlpha ) texture.format = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.R;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.m;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.n;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\tparser.associations.set( texture, {\n\t\t\t\ttype: 'textures',\n\t\t\t\tindex: textureIndex\n\t\t\t} );\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\tvar parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tvar gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar material = mesh.material;\n\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P();\n\t\t\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tif ( useVertexTangents ) {\n\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t};\n\n\tGLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {\n\n\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.h;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tmaterialParams.normalScale = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, - 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tmaterialParams.emissive = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tGLTFParser.prototype.createUniqueName = function ( originalName ) {\n\n\t\tvar sanitizedName = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( originalName || '' );\n\n\t\tvar name = sanitizedName;\n\n\t\tfor ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t};\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t */\n\tfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar box = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.af();\n\n\t\tif ( attributes.POSITION !== undefined ) {\n\n\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\t\tvar min = accessor.min;\n\t\t\tvar max = accessor.max;\n\n\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\tbox.set(\n\t\t\t\t\tnew _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\t\tnew _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V( max[ 0 ], max[ 1 ], max[ 2 ] ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar targets = primitiveDef.targets;\n\n\t\tif ( targets !== undefined ) {\n\n\t\t\tvar maxDisplacement = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vector = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\t\tvar min = accessor.min;\n\t\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\t\tbox.expandByVector( maxDisplacement );\n\n\t\t}\n\n\t\tgeometry.boundingBox = box;\n\n\t\tvar sphere = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ag();\n\n\t\tbox.getCenter( sphere.center );\n\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\t\tgeometry.boundingSphere = sphere;\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar pending = [];\n\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t} );\n\n\t\t\tpending.push( accessor );\n\n\t\t}\n\n\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\tcomputeBounds( geometry, primitiveDef, parser );\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t: geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {Number} drawMode\n\t * @return {BufferGeometry}\n\t */\n\tfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\tvar index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tvar indices = [];\n\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar numberOfTriangles = index.count - 2;\n\t\tvar newIndices = [];\n\n\t\tif ( drawMode === _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aa ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tvar newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\n\t\treturn newGeometry;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar primitive = primitives[ i ];\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tvar geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\tvar primitives = meshDef.primitives;\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tvar materials = results.slice( 0, results.length - 1 );\n\t\t\tvar geometries = results[ results.length - 1 ];\n\n\t\t\tvar meshes = [];\n\n\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tvar material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material )\n\t\t\t\t\t\t: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ab );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aa );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.y( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tvar group = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.A( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.O( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\tvar pendingNodes = [];\n\t\tvar pendingInputAccessors = [];\n\t\tvar pendingOutputAccessors = [];\n\t\tvar pendingSamplers = [];\n\t\tvar pendingTargets = [];\n\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tvar target = channel.target;\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tvar node = nodes[ i ];\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ae;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ad;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ac;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.J;\n\n\t\t\t\tvar targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tvar outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tvar scale;\n\n\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 127;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 255;\n\n\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 32767;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 65535;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.K( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar parser = this;\n\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tvar nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tvar pending = [];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\tvar node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tvar node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t// build skeleton here as well\n\n\t\t\t\tvar skinEntry;\n\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\tvar mat = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmesh.bind( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t// build node hierachy\n\n\t\t\t\tparentObject.add( node );\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\tvar parser = this;\n\n\t\t\t// Loader returns Group, not Scene.\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\t\tvar scene = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n\nvar TGALoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nTGALoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: TGALoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttexture.image = scope.parse( buffer );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tparse: function ( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tvar pixel_data,\n\t\t\t\tpixel_size,\n\t\t\t\tpixel_total,\n\t\t\t\tpalettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tvar x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tvar content = new Uint8Array( buffer ),\n\t\t\toffset = 0,\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\tcanvas.width = header.width;\n\t\tcanvas.height = header.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n} );\n\nvar ColladaLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nColladaLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: ColladaLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( scope.path === '' ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\toptions: {\n\n\t\tset convertUpAxis( value ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n\t\t}\n\n\t},\n\n\tparse: function ( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tvar array = [];\n\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( var name in data ) {\n\n\t\t\t\tvar object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tvar hasChildren = false;\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tvar target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tvar parts = target.split( '/' );\n\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tvar indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar channels = data.channels;\n\t\t\tvar samplers = data.samplers;\n\t\t\tvar sources = data.sources;\n\n\t\t\tfor ( var target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tvar channel = channels[ target ];\n\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tvar inputSource = sources[ inputId ];\n\t\t\t\t\tvar outputSource = sources[ outputId ];\n\n\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tvar node = library.nodes[ channel.id ];\n\t\t\tvar object3D = getNode( node.id );\n\n\t\t\tvar transform = node.transforms[ channel.sid ];\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tvar time, stride;\n\t\t\tvar i, il, j, jl;\n\n\t\t\tvar data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tvar animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tvar keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( var time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar position = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar scale = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar quaternion = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tvar keyframes = animation.keyframes;\n\t\t\tvar name = animation.name;\n\n\t\t\tvar times = [];\n\t\t\tvar positionData = [];\n\t\t\tvar quaternionData = [];\n\t\t\tvar scaleData = [];\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tvar time = keyframe.time;\n\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ad( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tvar keyframe;\n\n\t\t\tvar empty = true;\n\t\t\tvar i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tvar prev, next;\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar name = data.name;\n\t\t\tvar duration = ( data.end - data.start ) || - 1;\n\t\t\tvar animations = data.animations;\n\n\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.K( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tvar build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tvar geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\tvar build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\tvar v = vertexWeights.v;\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tvar stride = 0;\n\n\t\t\tvar i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\n\t\t\t\t\tvar skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tvar d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tvar name = jointSource.array[ i ];\n\t\t\t\tvar boneInverse = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tvar data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tvar sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tvar loader;\n\n\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tvar effect = getEffect( data.url );\n\t\t\tvar technique = effect.profile.technique;\n\t\t\tvar extra = effect.profile.extra;\n\n\t\t\tvar material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tvar image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tvar loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tvar texture = loader.load( image );\n\n\t\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\t\t\t\ttexture.wrapT = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar parameters = technique.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvar parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar transparent = parameters[ 'transparent' ];\n\t\t\tvar transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\tmaterial.side = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tvar camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.A(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.O(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.A();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tvar data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tvar light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__._();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Z();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Y();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.am();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tvar data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tvar primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tvar set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tvar inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tvar build = {};\n\n\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tvar count = 0;\n\n\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertices = data.vertices;\n\t\t\tvar primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( var type in groupedPrimitives ) {\n\n\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar position = { array: [], stride: 0 };\n\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\tvar uv2 = { array: [], stride: 0 };\n\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar materialKeys = [];\n\n\t\t\tvar start = 0;\n\n\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tvar primitive = primitives[ p ];\n\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( var name in inputs ) {\n\n\t\t\t\t\tvar input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( var key in vertices ) {\n\n\t\t\t\t\t\t\t\tvar id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\tvar indices = primitive.p;\n\t\t\tvar stride = primitive.stride;\n\t\t\tvar vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\n\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tvar data;\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tvar array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tvar visualScene = getVisualScene( visualSceneId );\n\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tvar jointMap = {};\n\n\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tvar axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tvar m0 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tvar transforms = [];\n\n\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar matrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\tvar angle = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tvar elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar matrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar vector = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar angle = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tvar instance = instances[ j ];\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tvar boneData = [];\n\t\t\tvar sortedBoneData = [];\n\n\t\t\tvar i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tvar skeleton = skeletons[ i ];\n\n\t\t\t\tvar root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tvar child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tvar root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tvar bones = [];\n\t\t\tvar boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tvar joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tvar matrix = data.matrix;\n\t\t\tvar nodes = data.nodes;\n\t\t\tvar type = data.type;\n\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\tvar instanceLights = data.instanceLights;\n\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceControllers[ i ];\n\t\t\t\tvar controller = getController( instance.id );\n\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tvar object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.N() : new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tvar fallbackMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tvar materials = [];\n\n\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tfor ( var type in geometries ) {\n\n\t\t\t\tvar geometry = geometries[ type ];\n\n\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tvar elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tvar group = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tgroup.name = data.name;\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tvar clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\tfor ( var id in library.animations ) {\n\n\t\t\t\t\t\tvar animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.K( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tvar result = '';\n\t\t\tvar stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tvar node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ai() };\n\n\t\t}\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tvar parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tvar errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tvar errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tvar version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tvar textureLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tvar tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\n\t\t//\n\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n} );\n\nvar OBJLoader = ( function () {\n\n\t// o object_name | g group_name\n\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t// mtllib file_reference\n\tvar material_library_pattern = /^mtllib /;\n\t// usemtl material_name\n\tvar material_use_pattern = /^usemtl /;\n\t// usemap map_name\n\tvar map_use_pattern = /^usemap /;\n\n\tvar vA = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vB = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vC = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar ab = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar cb = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tfunction ParserState() {\n\n\t\tvar state = {\n\t\t\tobjects: [],\n\t\t\tobject: {},\n\n\t\t\tvertices: [],\n\t\t\tnormals: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\n\t\t\tmaterials: {},\n\t\t\tmaterialLibraries: [],\n\n\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname: name || '',\n\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\thasUVIndices: false\n\t\t\t\t\t},\n\t\t\t\t\tmaterials: [],\n\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t},\n\n\t\t\tfinalize: function () {\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t},\n\n\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexPoint: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tvA.fromArray( src, a );\n\t\t\t\tvB.fromArray( src, b );\n\t\t\t\tvC.fromArray( src, c );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\n\t\t\t},\n\n\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t\t},\n\n\t\t\taddDefaultUV: function () {\n\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\n\t\t\t},\n\n\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t\t},\n\n\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\n\t\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t// normals\n\n\t\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\t\tvar nLen = this.normals.length;\n\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t\t}\n\n\t\t\t\t// uvs\n\n\t\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\t\tthis.addDefaultUV();\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tvar index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\t\tthis.addColor( index );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject( '', false );\n\n\t\treturn state;\n\n\t}\n\n\t//\n\n\tfunction OBJLoader( manager ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tOBJLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: OBJLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetMaterials: function ( materials ) {\n\n\t\t\tthis.materials = materials;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar state = new ParserState();\n\n\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t\t}\n\n\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t\t}\n\n\t\t\tvar lines = text.split( '\\n' );\n\t\t\tvar line = '', lineFirstChar = '';\n\t\t\tvar lineLength = 0;\n\t\t\tvar result = [];\n\n\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tline = lines[ i ];\n\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\tlineLength = line.length;\n\n\t\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\t\tvar data = line.split( /\\s+/ );\n\n\t\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\n\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertexData[ j ];\n\n\t\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\n\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\tvar v1 = faceVertices[ 0 ];\n\n\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar v2 = faceVertices[ j ];\n\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar pointData = lineData.split( ' ' );\n\n\t\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// o object_name\n\t\t\t\t\t// or\n\t\t\t\t\t// g group_name\n\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\tvar name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\t\tstate.startObject( name );\n\n\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\n\n\t\t\t\t\t// mtl file\n\n\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t\t} else if ( map_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t * or\n\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.finalize();\n\n\t\t\tvar container = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\t\tvar hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\t\tif ( hasPrimitives === true ) {\n\n\t\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = state.objects[ i ];\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\t\tvar buffergeometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.vertices, 3 ) );\n\n\t\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.uvs, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create materials\n\n\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tvar materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\t\tvar material = state.materials[ materialHash ];\n\n\t\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q ) ) {\n\n\t\t\t\t\t\t\t\tvar materialLine = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t\t\t\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P ) ) {\n\n\t\t\t\t\t\t\t\tvar materialPoints = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\n\t\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\tcontainer.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\t\tvar material = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\tvar buffergeometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( state.vertices, 3 ) );\n\n\t\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( state.colors, 3 ) );\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar points = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, material );\n\t\t\t\t\tcontainer.add( points );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn container;\n\n\t\t}\n\n\t} );\n\n\treturn OBJLoader;\n\n} )();\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nvar MTLLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nMTLLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: MTLLoader,\n\n\t/**\n\t * Loads and parses a MTL asset from a URL.\n\t *\n\t * @param {String} url - URL to the MTL file.\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t * @param {Function} [onProgress] - Callback for download progress.\n\t * @param {Function} [onError] - Callback for download errors.\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to load.\n\t */\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( this.path === '' ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : this.path;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetMaterialOptions: function ( value ) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Parses a MTL file.\n\t *\n\t * @param {String} text - Content of MTL file\n\t * @return {MTLLoader.MaterialCreator}\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to parse.\n\t */\n\tparse: function ( text, path ) {\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n} );\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a8;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n};\n\nMTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: MTLLoader.MaterialCreator,\n\n\tcrossOrigin: 'anonymous',\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetManager: function ( value ) {\n\n\t\tthis.manager = value;\n\n\t},\n\n\tsetMaterials: function ( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t},\n\n\tconvert: function ( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function ( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function () {\n\n\t\tvar index = 0;\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\t\t\tvar n;\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ke':\n\n\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\tparams.emissive = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( 'map', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( 'specularMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t// Emissive map\n\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType( 'normalMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t// Alpha map\n\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\n\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al( params );\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tgetTextureParams: function ( value, matParams ) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, 1 ),\n\t\t\toffset: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a( 0, 0 )\n\n\t\t };\n\n\t\tvar items = value.split( /\\s+/ );\n\t\tvar pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t},\n\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tvar texture;\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.an;\n\t\tvar loader = manager.getHandler( url );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.j( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n};\n\n/*! chevrotain - v4.6.0 */\n!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"chevrotain\",[],e):\"object\"==typeof exports?exports.chevrotain=e():t.chevrotain=e();}(\"undefined\"!=typeof self?self:undefined,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=18)}([function(t,e,n){function r(t){return t&&0===t.length}function i(t){return null==t?[]:Object.keys(t)}function o(t){for(var e=[],n=Object.keys(t),r=0;r<n.length;r++)e.push(t[n[r]]);return e}function a(t,e){for(var n=[],r=i(t),o=0;o<r.length;o++){var a=r[o];n.push(e.call(null,t[a],a));}return n}function s(t,e){for(var n=[],r=0;r<t.length;r++)n.push(e.call(null,t[r],r));return n}function u(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];Array.isArray(r)?e=e.concat(u(r)):e.push(r);}return e}function c(t){return r(t)?void 0:t[0]}function p(t){var e=t&&t.length;return e?t[e-1]:void 0}function l(t,e){if(Array.isArray(t))for(var n=0;n<t.length;n++)e.call(null,t[n],n);else {if(!C(t))throw Error(\"non exhaustive match\");var r=i(t);for(n=0;n<r.length;n++){var o=r[n],a=t[o];e.call(null,a,o);}}}function h(t){return \"string\"==typeof t}function f(t){return void 0===t}function d(t){return t instanceof Function}function E(t,e){return void 0===e&&(e=1),t.slice(e,t.length)}function m(t,e){return void 0===e&&(e=1),t.slice(0,t.length-e)}function y(t,e){var n=[];if(Array.isArray(t))for(var r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function T(t,e){return y(t,function(t){return !e(t)})}function v(t,e){for(var n=Object.keys(t),r={},i=0;i<n.length;i++){var o=n[i],a=t[o];e(a)&&(r[o]=a);}return r}function g(t,e){return !!C(t)&&t.hasOwnProperty(e)}function _(t,e){return void 0!==N(t,function(t){return t===e})}function R(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n]);return e}function A(t){var e={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}function N(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(e.call(null,r))return r}}function O(t,e){for(var n=[],r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function S(t,e,n){for(var r=Array.isArray(t),a=r?t:o(t),s=r?[]:i(t),u=n,c=0;c<a.length;c++)u=e.call(null,u,a[c],r?c:s[c]);return u}function I(t){return T(t,function(t){return null==t})}function L(t,e){void 0===e&&(e=function(t){return t});var n=[];return S(t,function(t,r){var i=e(r);return _(n,i)?t:(n.push(i),t.concat(r))},[])}function k(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];var r=[null].concat(e);return Function.bind.apply(t,r)}function P(t){return Array.isArray(t)}function x(t){return t instanceof RegExp}function C(t){return t instanceof Object}function M(t,e){for(var n=0;n<t.length;n++)if(!e(t[n],n))return !1;return !0}function F(t,e){return T(t,function(t){return _(e,t)})}function b(t,e){for(var n=0;n<t.length;n++)if(e(t[n]))return !0;return !1}function D(t,e){for(var n=0;n<t.length;n++)if(t[n]===e)return n;return -1}function w(t,e){var n=R(t);return n.sort(function(t,n){return e(t)-e(n)}),n}function U(t,e){if(t.length!==e.length)throw Error(\"can't zipObject with different number of keys and values!\");for(var n={},r=0;r<t.length;r++)n[t[r]]=e[r];return n}function G(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++)for(var o=e[r],a=i(o),s=0;s<a.length;s++){var u=a[s];t[u]=o[u];}return t}function B(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++){var o=e[r];if(!f(o))for(var a=i(o),s=0;s<a.length;s++){var u=a[s];g(t,u)||(t[u]=o[u]);}}return t}function K(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return B.apply(null,[{}].concat(t))}function W(t,e){var n={};return l(t,function(t){var r=e(t),i=n[r];i?i.push(t):n[r]=[t];}),n}function j(t,e){for(var n=A(t),r=i(e),o=0;o<r.length;o++){var a=r[o],s=e[a];n[a]=s;}return n}function V(){}function Y(t){return t}function H(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];e.push(void 0!==r?r:void 0);}return e}function X(t){console&&console.error&&console.error(\"Error: \"+t);}function z(t){console&&console.warn&&console.warn(\"Warning: \"+t);}function q(){return \"function\"==typeof Map}function $(t,e){e.forEach(function(e){var n=e.prototype;Object.getOwnPropertyNames(n).forEach(function(r){if(\"constructor\"!==r){var i=Object.getOwnPropertyDescriptor(n,r);i&&(i.get||i.set)?Object.defineProperty(t.prototype,r,i):t.prototype[r]=e.prototype[r];}});});}function Z(t){function e(){}e.prototype=t;var n=new e;function r(){return typeof n.bar}return r(),r(),t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.isEmpty=r,e.keys=i,e.values=o,e.mapValues=a,e.map=s,e.flatten=u,e.first=c,e.last=p,e.forEach=l,e.isString=h,e.isUndefined=f,e.isFunction=d,e.drop=E,e.dropRight=m,e.filter=y,e.reject=T,e.pick=v,e.has=g,e.contains=_,e.cloneArr=R,e.cloneObj=A,e.find=N,e.findAll=O,e.reduce=S,e.compact=I,e.uniq=L,e.partial=k,e.isArray=P,e.isRegExp=x,e.isObject=C,e.every=M,e.difference=F,e.some=b,e.indexOf=D,e.sortBy=w,e.zipObject=U,e.assign=G,e.assignNoOverwrite=B,e.defaults=K,e.groupBy=W,e.merge=j,e.NOOP=V,e.IDENTITY=Y,e.packArray=H,e.PRINT_ERROR=X,e.PRINT_WARNING=z,e.isES2015MapSupported=q,e.applyMixins=$,e.toFastProperties=Z;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(2),s=function(){function t(t){this.definition=t;}return t.prototype.accept=function(t){t.visit(this),o.forEach(this.definition,function(e){e.accept(t);});},t}();e.AbstractProduction=s;var u=function(t){function e(e){var n=t.call(this,[])||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),Object.defineProperty(e.prototype,\"definition\",{get:function(){return void 0!==this.referencedRule?this.referencedRule.definition:[]},set:function(t){},enumerable:!0,configurable:!0}),e.prototype.accept=function(t){t.visit(this);},e}(s);e.NonTerminal=u;var c=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.orgText=\"\",o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Rule=c;var p=function(t){function e(e){var n=t.call(this,e.definition)||this;return o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Flat=p;var l=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Option=l;var h=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatory=h;var f=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatoryWithSeparator=f;var d=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Repetition=d;var E=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionWithSeparator=E;var m=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Alternation=m;var y=function(){function t(t){this.idx=1,o.assign(this,o.pick(t,function(t){return void 0!==t}));}return t.prototype.accept=function(t){t.visit(this);},t}();function T(t){function e(t){return o.map(t,T)}if(t instanceof u)return {type:\"NonTerminal\",name:t.nonTerminalName,idx:t.idx};if(t instanceof p)return {type:\"Flat\",definition:e(t.definition)};if(t instanceof l)return {type:\"Option\",idx:t.idx,definition:e(t.definition)};if(t instanceof h)return {type:\"RepetitionMandatory\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof f)return {type:\"RepetitionMandatoryWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof E)return {type:\"RepetitionWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof d)return {type:\"Repetition\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof m)return {type:\"Alternation\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof y){var n={type:\"Terminal\",name:a.tokenName(t.terminalType),label:a.tokenLabel(t.terminalType),idx:t.idx},r=t.terminalType.PATTERN;return t.terminalType.PATTERN&&(n.pattern=o.isRegExp(r)?r.source:r),n}if(t instanceof c)return {type:\"Rule\",name:t.name,orgText:t.orgText,definition:e(t.definition)};throw Error(\"non exhaustive match\")}e.Terminal=y,e.serializeGrammar=function(t){return o.map(t,T)},e.serializeProduction=T;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(15),a=n(7);function s(t){return r.isString(t.LABEL)&&\"\"!==t.LABEL}function u(t){return r.isObject(t)&&t.hasOwnProperty(\"tokenName\")&&r.isString(t.tokenName)?t.tokenName:i.functionName(t)}e.tokenLabel=function(t){return s(t)?t.LABEL:u(t)},e.hasTokenLabel=s,e.tokenName=u;var c=\"parent\",p=\"categories\",l=\"label\",h=\"group\",f=\"push_mode\",d=\"pop_mode\",E=\"longer_alt\",m=\"line_breaks\",y=\"start_chars_hint\";function T(t){return function(t){var e=t.name,n=t.pattern,o={};i.defineNameProp(o,e)||(o.tokenName=e);r.isUndefined(n)||(o.PATTERN=n);if(r.has(t,c))throw \"The parent property is no longer supported.\\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.\";r.has(t,p)&&(o.CATEGORIES=t[p]);a.augmentTokenTypes([o]),r.has(t,l)&&(o.LABEL=t[l]);r.has(t,h)&&(o.GROUP=t[h]);r.has(t,d)&&(o.POP_MODE=t[d]);r.has(t,f)&&(o.PUSH_MODE=t[f]);r.has(t,E)&&(o.LONGER_ALT=t[E]);r.has(t,m)&&(o.LINE_BREAKS=t[m]);r.has(t,y)&&(o.START_CHARS_HINT=t[y]);return o}(t)}e.createToken=T,e.EOF=T({name:\"EOF\",pattern:o.Lexer.NA}),a.augmentTokenTypes([e.EOF]),e.createTokenInstance=function(t,e,n,r,i,o,a,s){return {image:e,startOffset:n,endOffset:r,startLine:i,endLine:o,startColumn:a,endColumn:s,tokenTypeIdx:t.tokenTypeIdx,tokenType:t}},e.tokenMatcher=function(t,e){return a.tokenStructuredMatcher(t,e)};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(4),a=n(0),s=n(26),u=n(2),c=n(23),p=n(16),l=n(10),h=n(24),f=n(25),d=n(31),E=n(32),m=n(34),y=n(35),T=n(36),v=n(37),g=n(38);e.END_OF_FILE=u.createTokenInstance(u.EOF,\"\",NaN,NaN,NaN,NaN,NaN,NaN),Object.freeze(e.END_OF_FILE),e.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:4,ignoredIssues:{},dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:l.defaultParserErrorProvider,serializedGrammar:null}),e.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0}),function(t){t[t.INVALID_RULE_NAME=0]=\"INVALID_RULE_NAME\",t[t.DUPLICATE_RULE_NAME=1]=\"DUPLICATE_RULE_NAME\",t[t.INVALID_RULE_OVERRIDE=2]=\"INVALID_RULE_OVERRIDE\",t[t.DUPLICATE_PRODUCTIONS=3]=\"DUPLICATE_PRODUCTIONS\",t[t.UNRESOLVED_SUBRULE_REF=4]=\"UNRESOLVED_SUBRULE_REF\",t[t.LEFT_RECURSION=5]=\"LEFT_RECURSION\",t[t.NONE_LAST_EMPTY_ALT=6]=\"NONE_LAST_EMPTY_ALT\",t[t.AMBIGUOUS_ALTS=7]=\"AMBIGUOUS_ALTS\",t[t.CONFLICT_TOKENS_RULES_NAMESPACE=8]=\"CONFLICT_TOKENS_RULES_NAMESPACE\",t[t.INVALID_TOKEN_NAME=9]=\"INVALID_TOKEN_NAME\",t[t.INVALID_NESTED_RULE_NAME=10]=\"INVALID_NESTED_RULE_NAME\",t[t.DUPLICATE_NESTED_NAME=11]=\"DUPLICATE_NESTED_NAME\",t[t.NO_NON_EMPTY_LOOKAHEAD=12]=\"NO_NON_EMPTY_LOOKAHEAD\",t[t.AMBIGUOUS_PREFIX_ALTS=13]=\"AMBIGUOUS_PREFIX_ALTS\",t[t.TOO_MANY_ALTS=14]=\"TOO_MANY_ALTS\";}(e.ParserDefinitionErrorType||(e.ParserDefinitionErrorType={})),e.EMPTY_ALT=function(t){return void 0===t&&(t=void 0),function(){return t}};var _=function(){function t(t,n){void 0===n&&(n=e.DEFAULT_PARSER_CONFIG),this.ignoredIssues=e.DEFAULT_PARSER_CONFIG.ignoredIssues,this.definitionErrors=[],this.selfAnalysisDone=!1;this.initErrorHandler(n),this.initLexerAdapter(),this.initLooksAhead(n),this.initRecognizerEngine(t,n),this.initRecoverable(n),this.initTreeBuilder(n),this.initContentAssist(),this.ignoredIssues=a.has(n,\"ignoredIssues\")?n.ignoredIssues:e.DEFAULT_PARSER_CONFIG.ignoredIssues,a.toFastProperties(this);}return t.performSelfAnalysis=function(t){t.performSelfAnalysis();},t.prototype.performSelfAnalysis=function(){var e,n=this;this.selfAnalysisDone=!0;var r=o.classNameFromInstance(this),i=this.gastProductionsCache;if(this.serializedGrammar){var u=c.deserializeGrammar(this.serializedGrammar,this.tokensMap);a.forEach(u,function(t){n.gastProductionsCache.put(t.name,t);});}var f=h.resolveGrammar({rules:i.values()});if(this.definitionErrors.push.apply(this.definitionErrors,f),a.isEmpty(f)){var d=h.validateGrammar({rules:i.values(),maxLookahead:this.maxLookahead,tokenTypes:a.values(this.tokensMap),ignoredIssues:this.ignoredIssues,errMsgProvider:l.defaultGrammarValidatorErrorProvider,grammarName:r});this.definitionErrors.push.apply(this.definitionErrors,d);}if(a.isEmpty(this.definitionErrors)){var E=s.computeAllProdsFollows(i.values());this.resyncFollows=E;}var m=p.analyzeCst(i.values(),this.fullRuleNameToShort);if(this.allRuleNames=m.allRuleNames,!t.DEFER_DEFINITION_ERRORS_HANDLING&&!a.isEmpty(this.definitionErrors))throw e=a.map(this.definitionErrors,function(t){return t.message}),new Error(\"Parser Definition Errors detected:\\n \"+e.join(\"\\n-------------------------------\\n\"))},t.DEFER_DEFINITION_ERRORS_HANDLING=!1,t}();e.Parser=_,a.applyMixins(_,[f.Recoverable,d.LooksAhead,E.TreeBuilder,m.LexerAdapter,T.RecognizerEngine,y.RecognizerApi,v.ErrorHandler,g.ContentAssist]);var R=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!0,t.call(this,n,i)||this}return i(n,t),n}(_);e.CstParser=R;var A=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!1,t.call(this,n,i)||this}return i(n,t),n}(_);e.EmbeddedActionsParser=A;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0);e.classNameFromInstance=function(t){return a(t.constructor)};var i=/^\\s*function\\s*(\\S*)\\s*\\(/,o=\"name\";function a(t){var e=t.name;return e||t.toString().match(i)[1]}e.functionName=a,e.defineNameProp=function(t,e){var n=Object.getOwnPropertyDescriptor(t,o);return !(!r.isUndefined(n)&&!n.configurable||(Object.defineProperty(t,o,{enumerable:!1,configurable:!0,writable:!1,value:e}),0))};var s=function(){function t(){this._state={};}return t.prototype.keys=function(){return r.keys(this._state)},t.prototype.values=function(){return r.values(this._state)},t.prototype.put=function(t,e){this._state[t]=e;},t.prototype.putAll=function(t){this._state=r.assign(this._state,t._state);},t.prototype.get=function(t){return this._state[t]},t.prototype.containsKey=function(t){return r.has(this._state,t)},t.prototype.clear=function(){this._state={};},t}();e.HashTable=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(1),i=function(){function t(){}return t.prototype.visit=function(t){if(t instanceof r.NonTerminal)return this.visitNonTerminal(t);if(t instanceof r.Flat)return this.visitFlat(t);if(t instanceof r.Option)return this.visitOption(t);if(t instanceof r.RepetitionMandatory)return this.visitRepetitionMandatory(t);if(t instanceof r.RepetitionMandatoryWithSeparator)return this.visitRepetitionMandatoryWithSeparator(t);if(t instanceof r.RepetitionWithSeparator)return this.visitRepetitionWithSeparator(t);if(t instanceof r.Repetition)return this.visitRepetition(t);if(t instanceof r.Alternation)return this.visitAlternation(t);if(t instanceof r.Terminal)return this.visitTerminal(t);if(t instanceof r.Rule)return this.visitRule(t);throw Error(\"non exhaustive match\")},t.prototype.visitNonTerminal=function(t){},t.prototype.visitFlat=function(t){},t.prototype.visitOption=function(t){},t.prototype.visitRepetition=function(t){},t.prototype.visitRepetitionMandatory=function(t){},t.prototype.visitRepetitionMandatoryWithSeparator=function(t){},t.prototype.visitRepetitionWithSeparator=function(t){},t.prototype.visitAlternation=function(t){},t.prototype.visitTerminal=function(t){},t.prototype.visitRule=function(t){},t}();e.GAstVisitor=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=\"MismatchedTokenException\",o=\"NoViableAltException\",a=\"EarlyExitException\",s=\"NotAllInputParsedException\",u=[i,o,a,s];function c(t,e,n){this.name=i,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function p(t,e,n){this.name=o,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function l(t,e){this.name=s,this.message=t,this.token=e,this.resyncedTokens=[];}function h(t,e,n){this.name=a,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}Object.freeze(u),e.isRecognitionException=function(t){return r.contains(u,t.name)},e.MismatchedTokenException=c,c.prototype=Error.prototype,e.NoViableAltException=p,p.prototype=Error.prototype,e.NotAllInputParsedException=l,l.prototype=Error.prototype,e.EarlyExitException=h,h.prototype=Error.prototype;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(2);function a(t){for(var e=r.cloneArr(t),n=t,i=!0;i;){n=r.compact(r.flatten(r.map(n,function(t){return t.CATEGORIES})));var o=r.difference(n,e);e=e.concat(o),r.isEmpty(o)?i=!1:n=o;}return e}function s(t){r.forEach(t,function(t){l(t)||(e.tokenIdxToClass.put(e.tokenShortNameIdx,t),t.tokenTypeIdx=e.tokenShortNameIdx++),h(t)&&!r.isArray(t.CATEGORIES)&&(t.CATEGORIES=[t.CATEGORIES]),h(t)||(t.CATEGORIES=[]),f(t)||(t.categoryMatches=[]),d(t)||(t.categoryMatchesMap={}),E(t)||(t.tokenName=o.tokenName(t));});}function u(t){r.forEach(t,function(t){t.categoryMatches=[],r.forEach(t.categoryMatchesMap,function(n,r){t.categoryMatches.push(e.tokenIdxToClass.get(r).tokenTypeIdx);});});}function c(t){r.forEach(t,function(t){p([],t);});}function p(t,e){r.forEach(t,function(t){e.categoryMatchesMap[t.tokenTypeIdx]=!0;}),r.forEach(e.CATEGORIES,function(n){var i=t.concat(e);r.contains(i,n)||p(i,n);});}function l(t){return r.has(t,\"tokenTypeIdx\")}function h(t){return r.has(t,\"CATEGORIES\")}function f(t){return r.has(t,\"categoryMatches\")}function d(t){return r.has(t,\"categoryMatchesMap\")}function E(t){return r.has(t,\"tokenName\")}e.tokenStructuredMatcher=function(t,e){var n=t.tokenTypeIdx;return n===e.tokenTypeIdx||!0===e.isParent&&!0===e.categoryMatchesMap[n]},e.tokenStructuredMatcherNoCategories=function(t,e){return t.tokenTypeIdx===e.tokenTypeIdx},e.tokenShortNameIdx=1,e.tokenIdxToClass=new i.HashTable,e.augmentTokenTypes=function(t){var e=a(t);s(e),c(e),u(e),r.forEach(e,function(t){t.isParent=t.categoryMatches.length>0;});},e.expandCategories=a,e.assignTokenDefaultProps=s,e.assignCategoriesTokensProp=u,e.assignCategoriesMapProp=c,e.singleAssignCategoriesToksMap=p,e.hasShortKeyProperty=l,e.hasCategoriesProperty=h,e.hasExtendingTokensTypesProperty=f,e.hasExtendingTokensTypesMapProperty=d,e.hasTokenNameProperty=E,e.isTokenType=function(t){return r.has(t,\"tokenTypeIdx\")};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(1),s=n(5),u=n(2);e.isSequenceProd=function(t){return t instanceof a.Flat||t instanceof a.Option||t instanceof a.Repetition||t instanceof a.RepetitionMandatory||t instanceof a.RepetitionMandatoryWithSeparator||t instanceof a.RepetitionWithSeparator||t instanceof a.Terminal||t instanceof a.Rule},e.isOptionalProd=function t(e,n){return void 0===n&&(n=[]),!!(e instanceof a.Option||e instanceof a.Repetition||e instanceof a.RepetitionWithSeparator)||(e instanceof a.Alternation?o.some(e.definition,function(e){return t(e,n)}):!(e instanceof a.NonTerminal&&o.contains(n,e))&&e instanceof a.AbstractProduction&&(e instanceof a.NonTerminal&&n.push(e),o.every(e.definition,function(e){return t(e,n)})))},e.isBranchingProd=function(t){return t instanceof a.Alternation},e.getProductionDslName=function(t){if(t instanceof a.NonTerminal)return \"SUBRULE\";if(t instanceof a.Option)return \"OPTION\";if(t instanceof a.Alternation)return \"OR\";if(t instanceof a.RepetitionMandatory)return \"AT_LEAST_ONE\";if(t instanceof a.RepetitionMandatoryWithSeparator)return \"AT_LEAST_ONE_SEP\";if(t instanceof a.RepetitionWithSeparator)return \"MANY_SEP\";if(t instanceof a.Repetition)return \"MANY\";if(t instanceof a.Terminal)return \"CONSUME\";throw Error(\"non exhaustive match\")};var c=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.separator=\"-\",e.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},e}return i(e,t),e.prototype.visitTerminal=function(t){var e=u.tokenName(t.terminalType)+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitNonTerminal=function(t){var e=t.nonTerminalName+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitOption=function(t){this.dslMethods.option.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.dslMethods.repetitionWithSeparator.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.dslMethods.repetitionMandatory.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.dslMethods.repetitionMandatoryWithSeparator.push(t);},e.prototype.visitRepetition=function(t){this.dslMethods.repetition.push(t);},e.prototype.visitAlternation=function(t){this.dslMethods.alternation.push(t);},e}(s.GAstVisitor);e.DslMethodsCollectorVisitor=c;},function(t,e,n){function r(t,e,n){return n|e|t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.BITS_FOR_METHOD_IDX=4,e.BITS_FOR_OCCURRENCE_IDX=4,e.BITS_FOR_RULE_IDX=24,e.BITS_FOR_ALT_IDX=8,e.OR_IDX=1<<e.BITS_FOR_METHOD_IDX,e.OPTION_IDX=2<<e.BITS_FOR_METHOD_IDX,e.MANY_IDX=3<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_IDX=4<<e.BITS_FOR_METHOD_IDX,e.MANY_SEP_IDX=5<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_SEP_IDX=6<<e.BITS_FOR_METHOD_IDX,e.getKeyForAutomaticLookahead=r;var i=32-e.BITS_FOR_ALT_IDX;e.getKeyForAltIndex=function(t,e,n,o){var a=o+1<<i;return r(t,e,n)|a};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(0),a=n(1),s=n(8),u=n(11),c=n(17),p=n(3);e.defaultParserErrorProvider={buildMismatchTokenMessage:function(t){var e=t.expected,n=t.actual;t.previous,t.ruleName;return \"Expecting \"+(r.hasTokenLabel(e)?\"--\\x3e \"+r.tokenLabel(e)+\" <--\":\"token of type --\\x3e \"+r.tokenName(e)+\" <--\")+\" but found --\\x3e '\"+n.image+\"' <--\"},buildNotAllInputParsedMessage:function(t){var e=t.firstRedundant;t.ruleName;return \"Redundant input, expecting EOF but found: \"+e.image},buildNoViableAltMessage:function(t){var e=t.expectedPathsPerAlt,n=t.actual,i=(t.previous,t.customUserDescription),a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");if(i)return \"Expecting: \"+i+a;var s=o.reduce(e,function(t,e){return t.concat(e)},[]),u=o.map(s,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\", \")+\"]\"});return \"Expecting: \"+(\"one of these possible Token sequences:\\n\"+o.map(u,function(t,e){return \"  \"+(e+1)+\". \"+t}).join(\"\\n\"))+a},buildEarlyExitMessage:function(t){var e=t.expectedIterationPaths,n=t.actual,i=t.customUserDescription,a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");return i?\"Expecting: \"+i+a:\"Expecting: \"+(\"expecting at least one iteration which starts with one of these possible Token sequences::\\n  <\"+o.map(e,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\",\")+\"]\"}).join(\" ,\")+\">\")+a}},Object.freeze(e.defaultParserErrorProvider),e.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(t,e){return \"Invalid grammar, reference to a rule which is not defined: ->\"+e.nonTerminalName+\"<-\\ninside top level rule: ->\"+t.name+\"<-\"}},e.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(t,e){var n,i=t.name,u=o.first(e),c=u.idx,p=s.getProductionDslName(u),l=(n=u)instanceof a.Terminal?r.tokenName(n.terminalType):n instanceof a.NonTerminal?n.nonTerminalName:\"\",h=\"->\"+p+\"<- with numerical suffix: ->\"+c+\"<-\\n                  \"+(l?\"and argument: ->\"+l+\"<-\":\"\")+\"\\n                  appears more than once (\"+e.length+\" times) in the top level rule: ->\"+i+\"<-.\\n                  \"+(0===c?\"Also note that numerical suffix 0 means \"+p+\" without any suffix.\":\"\")+\"\\n                  To fix this make sure each usage of \"+p+\" \"+(l?\"with the argument: ->\"+l+\"<-\":\"\")+\"\\n                  in the rule ->\"+i+\"<- has a different occurrence index (0-5), as that combination acts as a unique\\n                  position key in the grammar, which is needed by the parsing engine.\\n                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";return h=(h=h.replace(/[ \\t]+/g,\" \")).replace(/\\s\\s+/g,\"\\n\")},buildInvalidNestedRuleNameError:function(t,e){return \"Invalid nested rule name: ->\"+e.name+\"<- inside rule: ->\"+t.name+\"<-\\nit must match the pattern: ->\"+u.validNestedRuleName.toString()+\"<-.\\nNote that this means a nested rule name must start with the '$'(dollar) sign.\"},buildDuplicateNestedRuleNameError:function(t,e){return \"Duplicate nested rule name: ->\"+o.first(e).name+\"<- inside rule: ->\"+t.name+\"<-\\nA nested name must be unique in the scope of a top level grammar rule.\"},buildNamespaceConflictError:function(t){return \"Namespace conflict found in grammar.\\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\"+t.name+\">.\\nTo resolve this make sure each Terminal and Non-Terminal names are unique\\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\nand Non-Terminal names start with a lower case letter.\"},buildAlternationPrefixAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx;return \"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> due to common lookahead prefix\\nin <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\nFor Further details.\"},buildAlternationAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx,i=\"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> in <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\n\",a=c.VERSION.replace(/\\./g,\"_\");return i=i+\"To Resolve this, try one of of the following: \\n1. Refactor your grammar to be LL(K) for the current value of k (by default k=\"+p.DEFAULT_PARSER_CONFIG.maxLookahead+\"})\\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/\"+a+\"/interfaces/iparserconfig.html#ignoredissues for more details\\n\"},buildEmptyRepetitionError:function(t){var e=s.getProductionDslName(t.repetition);return 0!==t.repetition.idx&&(e+=t.repetition.idx),\"The repetition <\"+e+\"> within Rule <\"+t.topLevelRule.name+\"> can never consume any tokens.\\nThis could lead to an infinite loop.\"},buildTokenNameError:function(t){return \"Invalid Grammar Token name: ->\"+r.tokenName(t.tokenType)+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildEmptyAlternationError:function(t){return \"Ambiguous empty alternative: <\"+(t.emptyChoiceIdx+1)+\"> in <OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\nOnly the last alternative may be an empty alternative.\"},buildTooManyAlternativesError:function(t){return \"An Alternation cannot have more than 256 alternatives:\\n<OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\n has \"+(t.alternation.definition.length+1)+\" alternatives.\"},buildLeftRecursionError:function(t){var e=t.topLevelRule.name;return \"Left Recursion found in grammar.\\nrule: <\"+e+\"> can be invoked from itself (directly or indirectly)\\nwithout consuming any Tokens. The grammar path that causes this is: \\n \"+(e+\" --\\x3e \"+i.map(t.leftRecursionPath,function(t){return t.name}).concat([e]).join(\" --\\x3e \"))+\"\\n To fix this refactor your grammar to remove the left recursion.\\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\"},buildInvalidRuleNameError:function(t){return \"Invalid grammar rule name: ->\"+t.topLevelRule.name+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildDuplicateRuleNameError:function(t){return \"Duplicate definition, rule: ->\"+(t.topLevelRule instanceof a.Rule?t.topLevelRule.name:t.topLevelRule)+\"<- is already defined in the grammar: ->\"+t.grammarName+\"<-\"}};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(0),s=n(3),u=n(8),c=n(2),p=n(12),l=n(16),h=n(13),f=n(1),d=n(5);function E(t){return u.getProductionDslName(t)+\"_#_\"+t.idx+\"_#_\"+m(t)}function m(t){return t instanceof f.Terminal?c.tokenName(t.terminalType):t instanceof f.NonTerminal?t.nonTerminalName:\"\"}e.validateGrammar=function(t,e,n,r,i,p){var h=o.map(t,function(t){return function(t,e){var n=new y;t.accept(n);var r=n.allProductions,i=o.groupBy(r,E),a=o.pick(i,function(t){return t.length>1});return o.map(o.values(a),function(n){var r=o.first(n),i=e.buildDuplicateFoundError(t,n),a=u.getProductionDslName(r),c={message:i,type:s.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:t.name,dslName:a,occurrence:r.idx},p=m(r);return p&&(c.parameter=p),c})}(t,i)}),f=o.map(t,function(t){return R(t,t,i)}),d=[],A=[],N=[];a.every(f,a.isEmpty)&&(d=a.map(t,function(t){return O(t,i)}),A=a.map(t,function(t){return S(t,e,r,i)}),N=k(t,e,i));var I=function(t,e,n){var r=[],i=a.map(e,function(t){return c.tokenName(t)});return a.forEach(t,function(t){var e=t.name;if(a.contains(i,e)){var o=n.buildNamespaceConflictError(t);r.push({message:o,type:s.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:e});}}),r}(t,n,i),P=o.map(n,function(t){return g(t,i)}),x=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.map(r.result,function(t){return t.orgProd});n.push(a.map(i,function(n){return v(t,n,e)}));}),a.flatten(n)}(t,i),C=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.groupBy(r.result,function(t){return t.name}),o=a.pick(i,function(t){return t.length>1});a.forEach(a.values(o),function(r){var i=a.map(r,function(t){return t.orgProd}),o=e.buildDuplicateNestedRuleNameError(t,i);n.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,ruleName:t.name});});}),n}(t,i),M=a.map(t,function(t){return L(t,i)}),F=a.map(t,function(t){return T(t,i)}),b=a.map(t,function(e){return _(e,t,p,i)});return o.flatten(h.concat(P,x,C,N,f,d,A,I,M,F,b))},e.identifyProductionForDuplicates=E;var y=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitNonTerminal=function(t){this.allProductions.push(t);},e.prototype.visitOption=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e.prototype.visitAlternation=function(t){this.allProductions.push(t);},e.prototype.visitTerminal=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function T(t,n){var r=[],i=t.name;return i.match(e.validTermsPattern)||r.push({message:n.buildInvalidRuleNameError({topLevelRule:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_RULE_NAME,ruleName:i}),r}function v(t,n,r){var i,o=[];return n.name.match(e.validNestedRuleName)||(i=r.buildInvalidNestedRuleNameError(t,n),o.push({message:i,type:s.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,ruleName:t.name})),o}function g(t,n){var r=[];return c.tokenName(t).match(e.validTermsPattern)||r.push({message:n.buildTokenNameError({tokenType:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_TOKEN_NAME}),r}function _(t,e,n,r){var i=[];if(a.reduce(e,function(e,n){return n.name===t.name?e+1:e},0)>1){var o=r.buildDuplicateRuleNameError({topLevelRule:t,grammarName:n});i.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t.name});}return i}function R(t,e,n,r){void 0===r&&(r=[]);var i=[],a=A(e.definition);if(o.isEmpty(a))return [];var u=t.name;o.contains(a,t)&&i.push({message:n.buildLeftRecursionError({topLevelRule:t,leftRecursionPath:r}),type:s.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:u});var c=o.difference(a,r.concat([t])),p=o.map(c,function(e){var i=o.cloneArr(r);return i.push(e),R(t,e,n,i)});return i.concat(o.flatten(p))}function A(t){var e=[];if(o.isEmpty(t))return e;var n=o.first(t);if(n instanceof f.NonTerminal)e.push(n.referencedRule);else if(n instanceof f.Flat||n instanceof f.Option||n instanceof f.RepetitionMandatory||n instanceof f.RepetitionMandatoryWithSeparator||n instanceof f.RepetitionWithSeparator||n instanceof f.Repetition)e=e.concat(A(n.definition));else if(n instanceof f.Alternation)e=o.flatten(o.map(n.definition,function(t){return A(t.definition)}));else if(!(n instanceof f.Terminal))throw Error(\"non exhaustive match\");var r=u.isOptionalProd(n),i=t.length>1;if(r&&i){var a=o.drop(t);return e.concat(A(a))}return e}e.OccurrenceValidationCollector=y,e.validTermsPattern=/^[a-zA-Z_]\\w*$/,e.validNestedRuleName=new RegExp(e.validTermsPattern.source.replace(\"^\",\"^\\\\$\")),e.validateRuleName=T,e.validateNestedRuleName=v,e.validateTokenName=g,e.validateRuleDoesNotAlreadyExist=_,e.validateRuleIsOverridden=function(t,e,n){var r,i=[];return o.contains(e,t)||(r=\"Invalid rule override, rule: ->\"+t+\"<- cannot be overridden in the grammar: ->\"+n+\"<-as it is not defined in any of the super grammars \",i.push({message:r,type:s.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:t})),i},e.validateNoLeftRecursion=R,e.getFirstNoneTerminal=A;var N=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.alternations=[],e}return i(e,t),e.prototype.visitAlternation=function(t){this.alternations.push(t);},e}(d.GAstVisitor);function O(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){var i=o.dropRight(r.definition),a=o.map(i,function(n,i){var a=h.nextPossibleTokensAfter([n],[],null,1);return o.isEmpty(a)?{message:e.buildEmptyAlternationError({topLevelRule:t,alternation:r,emptyChoiceIdx:i}),type:s.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:t.name,occurrence:r.idx,alternative:i+1}:null});return n.concat(o.compact(a))},[])}function S(t,e,n,r){var i=new N;t.accept(i);var c=i.alternations,l=n[t.name];return l&&(c=a.reject(c,function(t){return l[u.getProductionDslName(t)+(0===t.idx?\"\":t.idx)]})),o.reduce(c,function(n,i){var u=i.idx,c=p.getLookaheadPathsForOr(u,t,e),l=function(t,e,n,r){var i=[],u=a.reduce(t,function(e,n,r){return a.forEach(n,function(n){var o=[r];a.forEach(t,function(t,e){r!==e&&p.containsPath(t,n)&&o.push(e);}),o.length>1&&!p.containsPath(i,n)&&(i.push(n),e.push({alts:o,path:n}));}),e},[]);return o.map(u,function(t){var i=a.map(t.alts,function(t){return t+1}),o=r.buildAlternationAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path});return {message:o,type:s.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:n.name,occurrence:e.idx,alternatives:[t.alts]}})}(c,i,t,r),h=P(c,i,t,r);return n.concat(l,h)},[])}e.validateEmptyOrAlternative=O,e.validateAmbiguousAlternationAlternatives=S;var I=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function L(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){return r.definition.length>255&&n.push({message:e.buildTooManyAlternativesError({topLevelRule:t,alternation:r}),type:s.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:t.name,occurrence:r.idx}),n},[])}function k(t,e,n){var r=[];return a.forEach(t,function(t){var i=new I;t.accept(i);var o=i.allProductions;a.forEach(o,function(i){var o=p.getProdType(i),u=i.idx,c=p.getLookaheadPathsForOptionalProd(u,t,o,e)[0];if(a.isEmpty(a.flatten(c))){var l=n.buildEmptyRepetitionError({topLevelRule:t,repetition:i});r.push({message:l,type:s.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:t.name});}});}),r}function P(t,e,n,r){var i=[],o=a.reduce(t,function(t,e,n){var r=a.map(e,function(t){return {idx:n,path:t}});return t.concat(r)},[]);return a.forEach(o,function(t){var u=t.idx,c=t.path,l=a.findAll(o,function(t){return t.idx<u&&p.isStrictPrefixOfPath(t.path,c)}),h=a.map(l,function(t){var i=[t.idx+1,u+1],o=0===e.idx?\"\":e.idx;return {message:r.buildAlternationPrefixAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:n.name,occurrence:o,alternatives:i}});i=i.concat(h);}),i}e.RepetionCollector=I,e.validateTooManyAlts=L,e.validateSomeNonEmptyLookaheadPath=k,e.checkPrefixAlternativesAmbiguities=P;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o,a=n(0),s=n(13),u=n(14),c=n(7),p=n(1),l=n(5);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.REPETITION=1]=\"REPETITION\",t[t.REPETITION_MANDATORY=2]=\"REPETITION_MANDATORY\",t[t.REPETITION_MANDATORY_WITH_SEPARATOR=3]=\"REPETITION_MANDATORY_WITH_SEPARATOR\",t[t.REPETITION_WITH_SEPARATOR=4]=\"REPETITION_WITH_SEPARATOR\",t[t.ALTERNATION=5]=\"ALTERNATION\";}(o=e.PROD_TYPE||(e.PROD_TYPE={})),e.getProdType=function(t){if(t instanceof p.Option)return o.OPTION;if(t instanceof p.Repetition)return o.REPETITION;if(t instanceof p.RepetitionMandatory)return o.REPETITION_MANDATORY;if(t instanceof p.RepetitionMandatoryWithSeparator)return o.REPETITION_MANDATORY_WITH_SEPARATOR;if(t instanceof p.RepetitionWithSeparator)return o.REPETITION_WITH_SEPARATOR;if(t instanceof p.Alternation)return o.ALTERNATION;throw Error(\"non exhaustive match\")},e.buildLookaheadFuncForOr=function(t,e,n,r,i,o){var a=E(t,e,n);return o(a,r,T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher,i)},e.buildLookaheadFuncForOptionalProd=function(t,e,n,r,i,o){var a=m(t,e,i,n),s=T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher;return o(a[0],s,r)},e.buildAlternativesLookAheadFunc=function(t,e,n,r){var i=t.length,o=a.every(t,function(t){return a.every(t,function(t){return 1===t.length})});if(e)return function(e){for(var r=a.map(e,function(t){return t.GATE}),o=0;o<i;o++){var s=t[o],u=s.length,c=r[o];if(void 0===c||!1!==c.call(this))t:for(var p=0;p<u;p++){for(var l=s[p],h=l.length,f=0;f<h;f++){var d=this.LA(f+1);if(!1===n(d,l[f]))continue t}return o}}};if(o&&!r){var s=a.map(t,function(t){return a.flatten(t)}),u=a.reduce(s,function(t,e,n){return a.forEach(e,function(e){a.has(t,e.tokenTypeIdx)||(t[e.tokenTypeIdx]=n),a.forEach(e.categoryMatches,function(e){a.has(t,e)||(t[e]=n);});}),t},[]);return function(){var t=this.LA(1);return u[t.tokenTypeIdx]}}return function(){for(var e=0;e<i;e++){var r=t[e],o=r.length;t:for(var a=0;a<o;a++){for(var s=r[a],u=s.length,c=0;c<u;c++){var p=this.LA(c+1);if(!1===n(p,s[c]))continue t}return e}}}},e.buildSingleAlternativeLookaheadFunction=function(t,e,n){var r=a.every(t,function(t){return 1===t.length}),i=t.length;if(r&&!n){var o=a.flatten(t);if(1===o.length&&a.isEmpty(o[0].categoryMatches)){var s=o[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}var u=a.reduce(o,function(t,e,n){return t[e.tokenTypeIdx]=!0,a.forEach(e.categoryMatches,function(e){t[e]=!0;}),t},[]);return function(){var t=this.LA(1);return !0===u[t.tokenTypeIdx]}}return function(){t:for(var n=0;n<i;n++){for(var r=t[n],o=r.length,a=0;a<o;a++){var s=this.LA(a+1);if(!1===e(s,r[a]))continue t}return !0}return !1}};var h=function(t){function e(e,n,r){var i=t.call(this)||this;return i.topProd=e,i.targetOccurrence=n,i.targetProdType=r,i}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},e.prototype.checkIsTarget=function(t,e,n,r){return t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.restDef=n.concat(r),!0)},e.prototype.walkOption=function(e,n,r){this.checkIsTarget(e,o.OPTION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOne=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOneSep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkMany=function(e,n,r){this.checkIsTarget(e,o.REPETITION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkManySep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e}(u.RestWalker),f=function(t){function e(e,n){var r=t.call(this)||this;return r.targetOccurrence=e,r.targetProdType=n,r.result=[],r}return i(e,t),e.prototype.checkIsTarget=function(t,e){t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.result=t.definition);},e.prototype.visitOption=function(t){this.checkIsTarget(t,o.OPTION);},e.prototype.visitRepetition=function(t){this.checkIsTarget(t,o.REPETITION);},e.prototype.visitRepetitionMandatory=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY_WITH_SEPARATOR);},e.prototype.visitRepetitionWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_WITH_SEPARATOR);},e.prototype.visitAlternation=function(t){this.checkIsTarget(t,o.ALTERNATION);},e}(l.GAstVisitor);function d(t,e){function n(t,e){return a.reduce(t,function(t,n,r){if(r!==e){var i=a.map(n,function(t){return t.partialPath});return t.concat(i)}return t},[])}function r(t,e){return void 0===a.find(t,function(t){return a.every(e,function(e,n){return r=e,i=t[n],r===i||r&&i&&(r.categoryMatchesMap[i.tokenTypeIdx]||i.categoryMatchesMap[r.tokenTypeIdx]);var r,i;})})}function i(t){for(var e=[],n=0;n<t;n++)e.push([]);return e}for(var o=a.map(t,function(t){return s.possiblePathsFrom([t],1)}),u=i(o.length),c=o,p=1;p<=e;p++){var l=c;c=i(l.length);for(var h=0;h<l.length;h++)for(var f=l[h],d=n(l,h),E=0;E<f.length;E++){var m=f[E].partialPath,T=f[E].suffixDef;if(r(d,m)||a.isEmpty(T)||m.length===e){var v=u[h];y(v,m)||v.push(m);}else {var g=s.possiblePathsFrom(T,p+1,m);c[h]=c[h].concat(g);}}}return u}function E(t,e,n){var r=new f(t,o.ALTERNATION);return e.accept(r),d(r.result,n)}function m(t,e,n,r){var i=new f(t,n);e.accept(i);var o=i.result,a=new h(e,t,n).startWalking();return d([new p.Flat({definition:o}),new p.Flat({definition:a})],r)}function y(t,e){return void 0!==a.find(t,function(t){return e.length===t.length&&a.every(e,function(e,n){return e===t[n]||t[n].categoryMatchesMap[e.tokenTypeIdx]})})}function T(t){return a.every(t,function(t){return a.every(t,function(t){return a.every(t,function(t){return a.isEmpty(t.categoryMatches)})})})}e.lookAheadSequenceFromAlternatives=d,e.getLookaheadPathsForOr=E,e.getLookaheadPathsForOptionalProd=m,e.containsPath=y,e.isStrictPrefixOfPath=function(t,e){return t.length<e.length&&a.every(t,function(t,n){var r=e[n];return t===r||r.categoryMatchesMap[t.tokenTypeIdx]})},e.areTokenCategoriesNotUsed=T;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(0),s=n(2),u=n(21),c=n(1),p=function(t){function e(e,n){var r=t.call(this)||this;return r.topProd=e,r.path=n,r.possibleTokTypes=[],r.nextProductionName=\"\",r.nextProductionOccurrence=0,r.found=!1,r.isAtEndOfPath=!1,r}return i(e,t),e.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error(\"The path does not start with the walker's top Rule!\");return this.ruleStack=a.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=a.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},e.prototype.walk=function(e,n){void 0===n&&(n=[]),this.found||t.prototype.walk.call(this,e,n);},e.prototype.walkProdRef=function(t,e,n){if(t.referencedRule.name===this.nextProductionName&&t.idx===this.nextProductionOccurrence){var r=e.concat(n);this.updateExpectedNext(),this.walk(t.referencedRule,r);}},e.prototype.updateExpectedNext=function(){a.isEmpty(this.ruleStack)?(this.nextProductionName=\"\",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop());},e}(o.RestWalker);e.AbstractNextPossibleTokensWalker=p;var l=function(t){function e(e,n){var r=t.call(this,e,n)||this;return r.path=n,r.nextTerminalName=\"\",r.nextTerminalOccurrence=0,r.nextTerminalName=s.tokenName(r.path.lastTok),r.nextTerminalOccurrence=r.path.lastTokOccurrence,r}return i(e,t),e.prototype.walkTerminal=function(t,e,n){if(this.isAtEndOfPath&&s.tokenName(t.terminalType)===this.nextTerminalName&&t.idx===this.nextTerminalOccurrence&&!this.found){var r=e.concat(n),i=new c.Flat({definition:r});this.possibleTokTypes=u.first(i),this.found=!0;}},e}(p);e.NextAfterTokenWalker=l;var h=function(t){function e(e,n){var r=t.call(this)||this;return r.topRule=e,r.occurrence=n,r.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},r}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topRule),this.result},e}(o.RestWalker);e.AbstractNextTerminalAfterProductionWalker=h;var f=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkMany=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkMany.call(this,e,n,r);},e}(h);e.NextTerminalAfterManyWalker=f;var d=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkManySep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkManySep.call(this,e,n,r);},e}(h);e.NextTerminalAfterManySepWalker=d;var E=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOne=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOne.call(this,e,n,r);},e}(h);e.NextTerminalAfterAtLeastOneWalker=E;var m=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOneSep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOneSep.call(this,e,n,r);},e}(h);function y(t,e,n,r){var i=a.cloneArr(n);i.push(t.name);var o=a.cloneArr(r);return o.push(1),{idx:e,def:t.definition,ruleStack:i,occurrenceStack:o}}e.NextTerminalAfterAtLeastOneSepWalker=m,e.possiblePathsFrom=function t(e,n,r){void 0===r&&(r=[]),r=a.cloneArr(r);var i=[],o=0;function s(s){var u=t(s.concat(a.drop(e,o+1)),n,r);return i.concat(u)}for(;r.length<n&&o<e.length;){var u=e[o];if(u instanceof c.Flat)return s(u.definition);if(u instanceof c.NonTerminal)return s(u.definition);if(u instanceof c.Option)i=s(u.definition);else {if(u instanceof c.RepetitionMandatory)return s(p=u.definition.concat([new c.Repetition({definition:u.definition})]));if(u instanceof c.RepetitionMandatoryWithSeparator)return s(p=[new c.Flat({definition:u.definition}),new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);if(u instanceof c.RepetitionWithSeparator){var p=u.definition.concat([new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);i=s(p);}else if(u instanceof c.Repetition)p=u.definition.concat([new c.Repetition({definition:u.definition})]),i=s(p);else {if(u instanceof c.Alternation)return a.forEach(u.definition,function(t){i=s(t.definition);}),i;if(!(u instanceof c.Terminal))throw Error(\"non exhaustive match\");r.push(u.terminalType);}}o++;}return i.push({partialPath:r,suffixDef:a.drop(e,o)}),i},e.nextPossibleTokensAfter=function(t,e,n,r){var i=[\"EXIT_NONE_TERMINAL\"],o=!1,s=e.length,u=s-r-1,p=[],l=[];for(l.push({idx:-1,def:t,ruleStack:[],occurrenceStack:[]});!a.isEmpty(l);){var h=l.pop();if(\"EXIT_ALTERNATIVE\"!==h){var f=h.def,d=h.idx,E=h.ruleStack,m=h.occurrenceStack;if(!a.isEmpty(f)){var T=f[0];if(\"EXIT_NONE_TERMINAL\"===T){var v={idx:d,def:a.drop(f),ruleStack:a.dropRight(E),occurrenceStack:a.dropRight(m)};l.push(v);}else if(T instanceof c.Terminal)if(d<s-1){var g=d+1;n(e[g],T.terminalType)&&(v={idx:g,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(v));}else {if(d!==s-1)throw Error(\"non exhaustive match\");p.push({nextTokenType:T.terminalType,nextTokenOccurrence:T.idx,ruleStack:E,occurrenceStack:m}),o=!0;}else if(T instanceof c.NonTerminal){var _=a.cloneArr(E);_.push(T.nonTerminalName);var R=a.cloneArr(m);R.push(T.idx),v={idx:d,def:T.definition.concat(i,a.drop(f)),ruleStack:_,occurrenceStack:R},l.push(v);}else if(T instanceof c.Option){var A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m};l.push(A),l.push(\"EXIT_ALTERNATIVE\");var N={idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(N);}else if(T instanceof c.RepetitionMandatory){var O=new c.Repetition({definition:T.definition,idx:T.idx});v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionMandatoryWithSeparator){var S=new c.Terminal({terminalType:T.separator});O=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx}),v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionWithSeparator){A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),S=new c.Terminal({terminalType:T.separator});var I=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx});N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);}else if(T instanceof c.Repetition)A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),I=new c.Repetition({definition:T.definition,idx:T.idx}),N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);else if(T instanceof c.Alternation)for(var L=T.definition.length-1;L>=0;L--){var k={idx:d,def:T.definition[L].definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(k),l.push(\"EXIT_ALTERNATIVE\");}else if(T instanceof c.Flat)l.push({idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m});else {if(!(T instanceof c.Rule))throw Error(\"non exhaustive match\");l.push(y(T,d,E,m));}}}else o&&a.last(l).idx<=u&&l.pop();}return p};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=function(){function t(){}return t.prototype.walk=function(t,e){var n=this;void 0===e&&(e=[]),r.forEach(t.definition,function(o,a){var s=r.drop(t.definition,a+1);if(o instanceof i.NonTerminal)n.walkProdRef(o,s,e);else if(o instanceof i.Terminal)n.walkTerminal(o,s,e);else if(o instanceof i.Flat)n.walkFlat(o,s,e);else if(o instanceof i.Option)n.walkOption(o,s,e);else if(o instanceof i.RepetitionMandatory)n.walkAtLeastOne(o,s,e);else if(o instanceof i.RepetitionMandatoryWithSeparator)n.walkAtLeastOneSep(o,s,e);else if(o instanceof i.RepetitionWithSeparator)n.walkManySep(o,s,e);else if(o instanceof i.Repetition)n.walkMany(o,s,e);else {if(!(o instanceof i.Alternation))throw Error(\"non exhaustive match\");n.walkOr(o,s,e);}});},t.prototype.walkTerminal=function(t,e,n){},t.prototype.walkProdRef=function(t,e,n){},t.prototype.walkFlat=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkOption=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkAtLeastOne=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkAtLeastOneSep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkMany=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkManySep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkOr=function(t,e,n){var o=this,a=e.concat(n);r.forEach(t.definition,function(t){var e=new i.Flat({definition:[t]});o.walk(e,a);});},t}();function a(t,e,n){return [new i.Option({definition:[new i.Terminal({terminalType:t.separator})].concat(t.definition)})].concat(e,n)}e.RestWalker=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(27),i=n(0),o=n(7),a=n(20);!function(t){t[t.MISSING_PATTERN=0]=\"MISSING_PATTERN\",t[t.INVALID_PATTERN=1]=\"INVALID_PATTERN\",t[t.EOI_ANCHOR_FOUND=2]=\"EOI_ANCHOR_FOUND\",t[t.UNSUPPORTED_FLAGS_FOUND=3]=\"UNSUPPORTED_FLAGS_FOUND\",t[t.DUPLICATE_PATTERNS_FOUND=4]=\"DUPLICATE_PATTERNS_FOUND\",t[t.INVALID_GROUP_TYPE_FOUND=5]=\"INVALID_GROUP_TYPE_FOUND\",t[t.PUSH_MODE_DOES_NOT_EXIST=6]=\"PUSH_MODE_DOES_NOT_EXIST\",t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]=\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\",t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]=\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\",t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]=\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\",t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]=\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\",t[t.SOI_ANCHOR_FOUND=11]=\"SOI_ANCHOR_FOUND\",t[t.EMPTY_MATCH_PATTERN=12]=\"EMPTY_MATCH_PATTERN\",t[t.NO_LINE_BREAKS_FLAGS=13]=\"NO_LINE_BREAKS_FLAGS\",t[t.UNREACHABLE_PATTERN=14]=\"UNREACHABLE_PATTERN\",t[t.IDENTIFY_TERMINATOR=15]=\"IDENTIFY_TERMINATOR\",t[t.CUSTOM_LINE_BREAK=16]=\"CUSTOM_LINE_BREAK\";}(e.LexerDefinitionErrorType||(e.LexerDefinitionErrorType={}));var s={deferDefinitionErrorsHandling:!1,positionTracking:\"full\",lineTerminatorsPattern:/\\n|\\r\\n?/g,lineTerminatorCharacters:[\"\\n\",\"\\r\"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:a.defaultLexerErrorProvider};Object.freeze(s);var u=function(){function t(t,e){var n=this;if(void 0===e&&(e=s),this.lexerDefinition=t,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},\"boolean\"==typeof e)throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");if(this.config=i.merge(s,e),this.config.lineTerminatorsPattern===s.lineTerminatorsPattern)this.config.lineTerminatorsPattern=r.LineTerminatorOptimizedTester;else if(this.config.lineTerminatorCharacters===s.lineTerminatorCharacters)throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");if(e.safeMode&&e.ensureOptimizations)throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking);var a,u=!0;i.isArray(t)?((a={modes:{}}).modes[r.DEFAULT_MODE]=i.cloneArr(t),a[r.DEFAULT_MODE]=r.DEFAULT_MODE):(u=!1,a=i.cloneObj(t)),this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(r.performRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(r.performWarningRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),a.modes=a.modes?a.modes:{},i.forEach(a.modes,function(t,e){a.modes[e]=i.reject(t,function(t){return i.isUndefined(t)});});var c=i.keys(a.modes);if(i.forEach(a.modes,function(t,a){if(n.modes.push(a),n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(r.validatePatterns(t,c)),i.isEmpty(n.lexerDefinitionErrors)){o.augmentTokenTypes(t);var s=r.analyzeTokenTypes(t,{lineTerminatorCharacters:n.config.lineTerminatorCharacters,positionTracking:e.positionTracking,ensureOptimizations:e.ensureOptimizations,safeMode:e.safeMode});n.patternIdxToConfig[a]=s.patternIdxToConfig,n.charCodeToPatternIdxToConfig[a]=s.charCodeToPatternIdxToConfig,n.emptyGroups=i.merge(n.emptyGroups,s.emptyGroups),n.hasCustom=s.hasCustom||n.hasCustom,n.canModeBeOptimized[a]=s.canBeOptimized;}}),this.defaultMode=a.defaultMode,!i.isEmpty(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){var p=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Errors detected in definition of Lexer:\\n\"+p)}if(i.forEach(this.lexerDefinitionWarning,function(t){i.PRINT_WARNING(t.message);}),r.SUPPORT_STICKY?(this.chopInput=i.IDENTITY,this.match=this.matchWithTest):(this.updateLastIndex=i.NOOP,this.match=this.matchWithExec),u&&(this.handleModes=i.NOOP),!1===this.trackStartLines&&(this.computeNewColumn=i.IDENTITY),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=i.NOOP),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else {if(!/onlyOffset/i.test(this.config.positionTracking))throw Error('Invalid <positionTracking> config option: \"'+this.config.positionTracking+'\"');this.createTokenInstance=this.createOffsetOnlyToken;}this.hasCustom?this.addToken=this.addTokenUsingPush:this.addToken=this.addTokenUsingMemberAccess;var l=i.reduce(this.canModeBeOptimized,function(t,e,n){return !1===e&&t.push(n),t},[]);if(e.ensureOptimizations&&!i.isEmpty(l))throw Error(\"Lexer Modes: < \"+l.join(\", \")+' > cannot be optimized.\\n\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\\t Or inspect the console log for details on how to resolve these issues.')}return t.prototype.tokenize=function(t,e){if(void 0===e&&(e=this.defaultMode),!i.isEmpty(this.lexerDefinitionErrors)){var n=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\"+n)}return this.tokenizeInternal(t,e)},t.prototype.tokenizeInternal=function(t,e){var n,o,a,s,u,c,p,l,h,f,d,E,m=this,y=t,T=y.length,v=0,g=0,_=this.hasCustom?0:Math.floor(t.length/10),R=new Array(_),A=[],N=this.trackStartLines?1:void 0,O=this.trackStartLines?1:void 0,S=r.cloneEmptyGroups(this.emptyGroups),I=this.trackStartLines,L=this.config.lineTerminatorsPattern,k=0,P=[],x=[],C=[],M=[];Object.freeze(M);var F,b=void 0,D=function(t){if(1===C.length&&void 0===t.tokenType.PUSH_MODE){var e=m.config.errorMessageProvider.buildUnableToPopLexerModeMessage(t);A.push({offset:t.startOffset,line:void 0!==t.startLine?t.startLine:void 0,column:void 0!==t.startColumn?t.startColumn:void 0,length:t.image.length,message:e});}else {C.pop();var n=i.last(C);P=m.patternIdxToConfig[n],x=m.charCodeToPatternIdxToConfig[n],k=P.length;var r=m.canModeBeOptimized[n]&&!1===m.config.safeMode;b=x&&r?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}};function w(t){C.push(t),x=this.charCodeToPatternIdxToConfig[t],P=this.patternIdxToConfig[t],k=P.length,k=P.length;var e=this.canModeBeOptimized[t]&&!1===this.config.safeMode;b=x&&e?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}for(w.call(this,e);v<T;){u=null;var U=y.charCodeAt(v),G=b(U),B=G.length;for(n=0;n<B;n++){var K=(F=G[n]).pattern;if(!1!==(Z=F.short)?U===Z&&(u=K):!0===F.isCustom?u=null!==(E=K.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(K,v),u=this.match(K,t,v)),null!==u){if(void 0!==(s=F.longerAlt)){var W=P[s],j=W.pattern;!0===W.isCustom?a=null!==(E=j.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(j,v),a=this.match(j,t,v)),a&&a.length>u.length&&(u=a,F=W);}break}}if(null!==u){if(c=u.length,void 0!==(p=F.group)&&(l=F.tokenTypeIdx,h=this.createTokenInstance(u,v,l,F.tokenType,N,O,c),!1===p?g=this.addToken(R,g,h):S[p].push(h)),t=this.chopInput(t,c),v+=c,O=this.computeNewColumn(O,c),!0===I&&!0===F.canLineTerminator){var V=0,Y=void 0,H=void 0;L.lastIndex=0;do{!0===(Y=L.test(u))&&(H=L.lastIndex-1,V++);}while(Y);0!==V&&(N+=V,O=c-H,this.updateTokenEndLineColumnLocation(h,p,H,V,N,O,c));}this.handleModes(F,D,w,h);}else {for(var X=v,z=N,q=O,$=!1;!$&&v<T;)for(y.charCodeAt(v),t=this.chopInput(t,1),v++,o=0;o<k;o++){var Z,Q=P[o];K=Q.pattern;if(!1!==(Z=Q.short)?y.charCodeAt(v)===Z&&($=!0):!0===Q.isCustom?$=null!==K.exec(y,v,R,S):(this.updateLastIndex(K,v),$=null!==K.exec(t)),!0===$)break}f=v-X,d=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(y,X,f,z,q),A.push({offset:X,line:z,column:q,length:f,message:d});}}return this.hasCustom||(R.length=g),{tokens:R,groups:S,errors:A}},t.prototype.handleModes=function(t,e,n,r){if(!0===t.pop){var i=t.push;e(r),void 0!==i&&n.call(this,i);}else void 0!==t.push&&n.call(this,t.push);},t.prototype.chopInput=function(t,e){return t.substring(e)},t.prototype.updateLastIndex=function(t,e){t.lastIndex=e;},t.prototype.updateTokenEndLineColumnLocation=function(t,e,n,r,i,o,a){var s,u;void 0!==e&&(u=(s=n===a-1)?-1:0,1===r&&!0===s||(t.endLine=i+u,t.endColumn=o-1-u));},t.prototype.computeNewColumn=function(t,e){return t+e},t.prototype.createTokenInstance=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return null},t.prototype.createOffsetOnlyToken=function(t,e,n,r){return {image:t,startOffset:e,tokenTypeIdx:n,tokenType:r}},t.prototype.createStartOnlyToken=function(t,e,n,r,i,o){return {image:t,startOffset:e,startLine:i,startColumn:o,tokenTypeIdx:n,tokenType:r}},t.prototype.createFullToken=function(t,e,n,r,i,o,a){return {image:t,startOffset:e,endOffset:e+a-1,startLine:i,endLine:i,startColumn:o,endColumn:o+a-1,tokenTypeIdx:n,tokenType:r}},t.prototype.addToken=function(t,e,n){return 666},t.prototype.addTokenUsingPush=function(t,e,n){return t.push(n),e},t.prototype.addTokenUsingMemberAccess=function(t,e,n){return t[e]=n,++e},t.prototype.match=function(t,e,n){return null},t.prototype.matchWithTest=function(t,e,n){return !0===t.test(e)?e.substring(n,t.lastIndex):null},t.prototype.matchWithExec=function(t,e){var n=t.exec(e);return null!==n?n[0]:n},t.SKIPPED=\"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\",t.NA=/NOT_APPLICABLE/,t}();e.Lexer=u;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(4),s=n(9),u=n(1),c=n(5);e.addTerminalToCst=function(t,e,n){void 0===t.children[n]?t.children[n]=[e]:t.children[n].push(e);},e.addNoneTerminalToCst=function(t,e,n){void 0===t.children[e]?t.children[e]=[n]:t.children[e].push(n);};var p=function(t){function e(e){var n=t.call(this)||this;return n.result=[],n.ruleIdx=e,n}return i(e,t),e.prototype.collectNamedDSLMethod=function(t,e,n){if(!o.isUndefined(t.name)){var r=void 0;if(t instanceof u.Option||t instanceof u.Repetition||t instanceof u.RepetitionMandatory||t instanceof u.Alternation)r=new e({definition:t.definition,idx:t.idx});else {if(!(t instanceof u.RepetitionMandatoryWithSeparator||t instanceof u.RepetitionWithSeparator))throw Error(\"non exhaustive match\");r=new e({definition:t.definition,idx:t.idx,separator:t.separator});}var i=[r],a=s.getKeyForAutomaticLookahead(this.ruleIdx,n,t.idx);this.result.push({def:i,key:a,name:t.name,orgProd:t});}},e.prototype.visitOption=function(t){this.collectNamedDSLMethod(t,u.Option,s.OPTION_IDX);},e.prototype.visitRepetition=function(t){this.collectNamedDSLMethod(t,u.Repetition,s.MANY_IDX);},e.prototype.visitRepetitionMandatory=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatory,s.AT_LEAST_ONE_IDX);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatoryWithSeparator,s.AT_LEAST_ONE_SEP_IDX);},e.prototype.visitRepetitionWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionWithSeparator,s.MANY_SEP_IDX);},e.prototype.visitAlternation=function(t){var e=this;this.collectNamedDSLMethod(t,u.Alternation,s.OR_IDX);var n=t.definition.length>1;o.forEach(t.definition,function(r,i){if(!o.isUndefined(r.name)){var a=r.definition;a=n?[new u.Option({definition:r.definition})]:r.definition;var c=s.getKeyForAltIndex(e.ruleIdx,s.OR_IDX,t.idx,i);e.result.push({def:a,key:c,name:r.name,orgProd:r});}});},e}(c.GAstVisitor);e.NamedDSLMethodsCollectorVisitor=p,e.analyzeCst=function(t,e){var n={dictDef:new a.HashTable,allRuleNames:[]};return o.forEach(t,function(t){var r=e.get(t.name);n.allRuleNames.push(t.name);var i=new p(r);t.accept(i),o.forEach(i.result,function(e){e.def,e.key;var r=e.name;n.allRuleNames.push(t.name+r);});}),n};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.VERSION=\"4.6.0\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=n(15),o=n(2),a=n(6),s=n(17),u=n(10),c=n(39),p=n(5),l=n(1),h=n(24),f=n(40),d=n(20),E={};E.VERSION=s.VERSION,E.Parser=r.Parser,E.CstParser=r.CstParser,E.EmbeddedActionsParser=r.EmbeddedActionsParser;E.ParserDefinitionErrorType=r.ParserDefinitionErrorType,E.Lexer=i.Lexer,E.LexerDefinitionErrorType=i.LexerDefinitionErrorType,E.EOF=o.EOF,E.tokenName=o.tokenName,E.tokenLabel=o.tokenLabel,E.tokenMatcher=o.tokenMatcher,E.createToken=o.createToken,E.createTokenInstance=o.createTokenInstance,E.EMPTY_ALT=r.EMPTY_ALT,E.defaultParserErrorProvider=u.defaultParserErrorProvider,E.isRecognitionException=a.isRecognitionException,E.EarlyExitException=a.EarlyExitException,E.MismatchedTokenException=a.MismatchedTokenException,E.NotAllInputParsedException=a.NotAllInputParsedException,E.NoViableAltException=a.NoViableAltException,E.defaultLexerErrorProvider=d.defaultLexerErrorProvider,E.Flat=l.Flat,E.Repetition=l.Repetition,E.RepetitionWithSeparator=l.RepetitionWithSeparator,E.RepetitionMandatory=l.RepetitionMandatory,E.RepetitionMandatoryWithSeparator=l.RepetitionMandatoryWithSeparator,E.Option=l.Option,E.Alternation=l.Alternation,E.NonTerminal=l.NonTerminal,E.Terminal=l.Terminal,E.Rule=l.Rule,E.GAstVisitor=p.GAstVisitor,E.serializeGrammar=l.serializeGrammar,E.serializeProduction=l.serializeProduction,E.resolveGrammar=h.resolveGrammar,E.defaultGrammarResolverErrorProvider=u.defaultGrammarResolverErrorProvider,E.validateGrammar=h.validateGrammar,E.defaultGrammarValidatorErrorProvider=u.defaultGrammarValidatorErrorProvider,E.assignOccurrenceIndices=h.assignOccurrenceIndices,E.clearCache=function(){console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\\n\\t It performs no action other than printing this message.\\n\\t Please avoid using it as it will be completely removed in the future\");},E.createSyntaxDiagramsCode=c.createSyntaxDiagramsCode,E.generateParserFactory=f.generateParserFactory,E.generateParserModule=f.generateParserModule,t.exports=E;},function(t,e,n){var r,i,o;i=[],void 0===(o=\"function\"==typeof(r=function(){function t(){}t.prototype.saveState=function(){return {idx:this.idx,input:this.input,groupIdx:this.groupIdx}},t.prototype.restoreState=function(t){this.idx=t.idx,this.input=t.input,this.groupIdx=t.groupIdx;},t.prototype.pattern=function(t){this.idx=0,this.input=t,this.groupIdx=0,this.consumeChar(\"/\");var e=this.disjunction();this.consumeChar(\"/\");for(var n={type:\"Flags\",global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case\"g\":s(n,\"global\");break;case\"i\":s(n,\"ignoreCase\");break;case\"m\":s(n,\"multiLine\");break;case\"u\":s(n,\"unicode\");break;case\"y\":s(n,\"sticky\");}if(this.idx!==this.input.length)throw Error(\"Redundant input: \"+this.input.substring(this.idx));return {type:\"Pattern\",flags:n,value:e}},t.prototype.disjunction=function(){var t=[];for(t.push(this.alternative());\"|\"===this.peekChar();)this.consumeChar(\"|\"),t.push(this.alternative());return {type:\"Disjunction\",value:t}},t.prototype.alternative=function(){for(var t=[];this.isTerm();)t.push(this.term());return {type:\"Alternative\",value:t}},t.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},t.prototype.assertion=function(){switch(this.popChar()){case\"^\":return {type:\"StartAnchor\"};case\"$\":return {type:\"EndAnchor\"};case\"\\\\\":switch(this.popChar()){case\"b\":return {type:\"WordBoundary\"};case\"B\":return {type:\"NonWordBoundary\"}}throw Error(\"Invalid Assertion Escape\");case\"(\":var t;switch(this.consumeChar(\"?\"),this.popChar()){case\"=\":t=\"Lookahead\";break;case\"!\":t=\"NegativeLookahead\";}u(t);var e=this.disjunction();return this.consumeChar(\")\"),{type:t,value:e}}!function(){throw Error(\"Internal Error - Should never get here!\")}();},t.prototype.quantifier=function(t){var e;switch(this.popChar()){case\"*\":e={atLeast:0,atMost:1/0};break;case\"+\":e={atLeast:1,atMost:1/0};break;case\"?\":e={atLeast:0,atMost:1};break;case\"{\":var n=this.integerIncludingZero();switch(this.popChar()){case\"}\":e={atLeast:n,atMost:n};break;case\",\":var r;this.isDigit()?(r=this.integerIncludingZero(),e={atLeast:n,atMost:r}):e={atLeast:n,atMost:1/0},this.consumeChar(\"}\");}if(!0===t&&void 0===e)return;u(e);}if(!0!==t||void 0!==e)return u(e),\"?\"===this.peekChar(0)?(this.consumeChar(\"?\"),e.greedy=!1):e.greedy=!0,e.type=\"Quantifier\",e},t.prototype.atom=function(){var t;switch(this.peekChar()){case\".\":t=this.dotAll();break;case\"\\\\\":t=this.atomEscape();break;case\"[\":t=this.characterClass();break;case\"(\":t=this.group();}return void 0===t&&this.isPatternCharacter()&&(t=this.patternCharacter()),u(t),this.isQuantifier()&&(t.quantifier=this.quantifier()),t},t.prototype.dotAll=function(){return this.consumeChar(\".\"),{type:\"Set\",complement:!0,value:[o(\"\\n\"),o(\"\\r\"),o(\"\\u2028\"),o(\"\\u2029\")]}},t.prototype.atomEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":return this.decimalEscapeAtom();case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.decimalEscapeAtom=function(){var t=this.positiveInteger();return {type:\"GroupBackReference\",value:t}},t.prototype.characterClassEscape=function(){var t,e=!1;switch(this.popChar()){case\"d\":t=c;break;case\"D\":t=c,e=!0;break;case\"s\":t=l;break;case\"S\":t=l,e=!0;break;case\"w\":t=p;break;case\"W\":t=p,e=!0;}return u(t),{type:\"Set\",value:t,complement:e}},t.prototype.controlEscapeAtom=function(){var t;switch(this.popChar()){case\"f\":t=o(\"\\f\");break;case\"n\":t=o(\"\\n\");break;case\"r\":t=o(\"\\r\");break;case\"t\":t=o(\"\\t\");break;case\"v\":t=o(\"\\v\");}return u(t),{type:\"Character\",value:t}},t.prototype.controlLetterEscapeAtom=function(){this.consumeChar(\"c\");var t=this.popChar();if(!1===/[a-zA-Z]/.test(t))throw Error(\"Invalid \");var e=t.toUpperCase().charCodeAt(0)-64;return {type:\"Character\",value:e}},t.prototype.nulCharacterAtom=function(){return this.consumeChar(\"0\"),{type:\"Character\",value:o(\"\\0\")}},t.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar(\"x\"),this.parseHexDigits(2)},t.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar(\"u\"),this.parseHexDigits(4)},t.prototype.identityEscapeAtom=function(){var t=this.popChar();return {type:\"Character\",value:o(t)}},t.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"\\\\\":case\"]\":throw Error(\"TBD\");default:var t=this.popChar();return {type:\"Character\",value:o(t)}}},t.prototype.characterClass=function(){var t=[],e=!1;for(this.consumeChar(\"[\"),\"^\"===this.peekChar(0)&&(this.consumeChar(\"^\"),e=!0);this.isClassAtom();){var n=this.classAtom(),r=\"Character\"===n.type;if(r&&this.isRangeDash()){this.consumeChar(\"-\");var i=this.classAtom(),s=\"Character\"===i.type;if(s){if(i.value<n.value)throw Error(\"Range out of order in character class\");t.push({from:n.value,to:i.value});}else a(n.value,t),t.push(o(\"-\")),a(i.value,t);}else a(n.value,t);}return this.consumeChar(\"]\"),{type:\"Set\",complement:e,value:t}},t.prototype.classAtom=function(){switch(this.peekChar()){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":throw Error(\"TBD\");case\"\\\\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},t.prototype.classEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"b\":return this.consumeChar(\"b\"),{type:\"Character\",value:o(\"\\b\")};case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.group=function(){var t=!0;switch(this.consumeChar(\"(\"),this.peekChar(0)){case\"?\":this.consumeChar(\"?\"),this.consumeChar(\":\"),t=!1;break;default:this.groupIdx++;}var e=this.disjunction();this.consumeChar(\")\");var n={type:\"Group\",capturing:t,value:e};return t&&(n.idx=this.groupIdx),n},t.prototype.positiveInteger=function(){var t=this.popChar();if(!1===i.test(t))throw Error(\"Expecting a positive integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.integerIncludingZero=function(){var t=this.popChar();if(!1===r.test(t))throw Error(\"Expecting an integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.patternCharacter=function(){var t=this.popChar();switch(t){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":throw Error(\"TBD\");default:return {type:\"Character\",value:o(t)}}},t.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case\"g\":case\"i\":case\"m\":case\"u\":case\"y\":return !0;default:return !1}},t.prototype.isRangeDash=function(){return \"-\"===this.peekChar()&&this.isClassAtom(1)},t.prototype.isDigit=function(){return r.test(this.peekChar(0))},t.prototype.isClassAtom=function(t){switch(void 0===t&&(t=0),this.peekChar(t)){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},t.prototype.isAtom=function(){if(this.isPatternCharacter())return !0;switch(this.peekChar(0)){case\".\":case\"\\\\\":case\"[\":case\"(\":return !0;default:return !1}},t.prototype.isAssertion=function(){switch(this.peekChar(0)){case\"^\":case\"$\":return !0;case\"\\\\\":switch(this.peekChar(1)){case\"b\":case\"B\":return !0;default:return !1}case\"(\":return \"?\"===this.peekChar(1)&&(\"=\"===this.peekChar(2)||\"!\"===this.peekChar(2));default:return !1}},t.prototype.isQuantifier=function(){var t=this.saveState();try{return void 0!==this.quantifier(!0)}catch(t){return !1}finally{this.restoreState(t);}},t.prototype.isPatternCharacter=function(){switch(this.peekChar()){case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":case\"/\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.parseHexDigits=function(t){for(var e=\"\",r=0;r<t;r++){var i=this.popChar();if(!1===n.test(i))throw Error(\"Expecting a HexDecimal digits\");e+=i;}var o=parseInt(e,16);return {type:\"Character\",value:o}},t.prototype.peekChar=function(t){return void 0===t&&(t=0),this.input[this.idx+t]},t.prototype.popChar=function(){var t=this.peekChar(0);return this.consumeChar(),t},t.prototype.consumeChar=function(t){if(void 0!==t&&this.input[this.idx]!==t)throw Error(\"Expected: '\"+t+\"' but found: '\"+this.input[this.idx]+\"' at offset: \"+this.idx);if(this.idx>=this.input.length)throw Error(\"Unexpected end of input\");this.idx++;};var e,n=/[0-9a-fA-F]/,r=/[0-9]/,i=/[1-9]/;function o(t){return t.charCodeAt(0)}function a(t,e){void 0!==t.length?t.forEach(function(t){e.push(t);}):e.push(t);}function s(t,e){if(!0===t[e])throw \"duplicate flag \"+e;t[e]=!0;}function u(t){if(void 0===t)throw Error(\"Internal Error - Should never get here!\")}var c=[];for(e=o(\"0\");e<=o(\"9\");e++)c.push(e);var p=[o(\"_\")].concat(c);for(e=o(\"a\");e<=o(\"z\");e++)p.push(e);for(e=o(\"A\");e<=o(\"Z\");e++)p.push(e);var l=[o(\" \"),o(\"\\f\"),o(\"\\n\"),o(\"\\r\"),o(\"\\t\"),o(\"\\v\"),o(\"\\t\"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\"\\u2028\"),o(\"\\u2029\"),o(\" \"),o(\" \"),o(\"　\"),o(\"\\ufeff\")];function h(){}return h.prototype.visitChildren=function(t){for(var e in t){var n=t[e];t.hasOwnProperty(e)&&(void 0!==n.type?this.visit(n):Array.isArray(n)&&n.forEach(function(t){this.visit(t);},this));}},h.prototype.visit=function(t){switch(t.type){case\"Pattern\":this.visitPattern(t);break;case\"Flags\":this.visitFlags(t);break;case\"Disjunction\":this.visitDisjunction(t);break;case\"Alternative\":this.visitAlternative(t);break;case\"StartAnchor\":this.visitStartAnchor(t);break;case\"EndAnchor\":this.visitEndAnchor(t);break;case\"WordBoundary\":this.visitWordBoundary(t);break;case\"NonWordBoundary\":this.visitNonWordBoundary(t);break;case\"Lookahead\":this.visitLookahead(t);break;case\"NegativeLookahead\":this.visitNegativeLookahead(t);break;case\"Character\":this.visitCharacter(t);break;case\"Set\":this.visitSet(t);break;case\"Group\":this.visitGroup(t);break;case\"GroupBackReference\":this.visitGroupBackReference(t);break;case\"Quantifier\":this.visitQuantifier(t);}this.visitChildren(t);},h.prototype.visitPattern=function(t){},h.prototype.visitFlags=function(t){},h.prototype.visitDisjunction=function(t){},h.prototype.visitAlternative=function(t){},h.prototype.visitStartAnchor=function(t){},h.prototype.visitEndAnchor=function(t){},h.prototype.visitWordBoundary=function(t){},h.prototype.visitNonWordBoundary=function(t){},h.prototype.visitLookahead=function(t){},h.prototype.visitNegativeLookahead=function(t){},h.prototype.visitCharacter=function(t){},h.prototype.visitSet=function(t){},h.prototype.visitGroup=function(t){},h.prototype.visitGroupBackReference=function(t){},h.prototype.visitQuantifier=function(t){},{RegExpParser:t,BaseRegExpVisitor:h,VERSION:\"0.4.0\"}})?r.apply(e,i):r)||(t.exports=o);},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(t){return \"Unable to pop Lexer Mode after encountering Token ->\"+t.image+\"<- The Mode Stack is empty\"},buildUnexpectedCharactersMessage:function(t,e,n,r,i){return \"unexpected character: ->\"+t.charAt(e)+\"<- at offset: \"+e+\", skipped \"+n+\" characters.\"}};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=n(8);function a(t){if(t instanceof i.NonTerminal)return a(t.referencedRule);if(t instanceof i.Terminal)return c(t);if(o.isSequenceProd(t))return s(t);if(o.isBranchingProd(t))return u(t);throw Error(\"non exhaustive match\")}function s(t){for(var e,n=[],i=t.definition,s=0,u=i.length>s,c=!0;u&&c;)e=i[s],c=o.isOptionalProd(e),n=n.concat(a(e)),s+=1,u=i.length>s;return r.uniq(n)}function u(t){var e=r.map(t.definition,function(t){return a(t)});return r.uniq(r.flatten(e))}function c(t){return [t.terminalType]}e.first=a,e.firstForSequence=s,e.firstForBranching=u,e.firstForTerminal=c;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.IN=\"_~IN~_\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(29),o=n(0),a=n(1);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.OR=1]=\"OR\",t[t.MANY=2]=\"MANY\",t[t.MANY_SEP=3]=\"MANY_SEP\",t[t.AT_LEAST_ONE=4]=\"AT_LEAST_ONE\",t[t.AT_LEAST_ONE_SEP=5]=\"AT_LEAST_ONE_SEP\",t[t.REF=6]=\"REF\",t[t.TERMINAL=7]=\"TERMINAL\",t[t.FLAT=8]=\"FLAT\";}(r=e.ProdType||(e.ProdType={}));var s=/(?:\\s*{\\s*NAME\\s*:\\s*[\"'`]([\\w$]*)[\"'`])?/,u=new RegExp(s.source.replace(\"{\",\"\").replace(\")?\",\"\\\\s*,)?\")),c=/\\.\\s*CONSUME(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,p=new RegExp(c.source,\"g\"),l=/\\.\\s*SUBRULE(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,h=new RegExp(l.source,\"g\"),f=/\\.\\s*OPTION(\\d+)?\\s*\\(/,d=new RegExp(f.source+s.source),E=new RegExp(f.source,\"g\"),m=/\\.\\s*MANY(\\d+)?\\s*\\(/,y=new RegExp(m.source+s.source),T=new RegExp(m.source,\"g\"),v=/\\s*SEP\\s*:\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,g=new RegExp(/\\.\\s*MANY_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),_=new RegExp(g.source,\"g\"),R=new RegExp(/\\.\\s*AT_LEAST_ONE_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),A=new RegExp(R.source,\"g\"),N=/\\.\\s*AT_LEAST_ONE(\\d+)?\\s*\\(/,O=new RegExp(N.source+s.source),S=new RegExp(N.source,\"g\"),I=/\\.\\s*OR(\\d+)?\\s*\\(/,L=new RegExp(I.source+s.source),k=new RegExp(I.source,\"g\"),P=new RegExp(u.source+/\\s*(ALT)\\s*:/.source),x=new RegExp(P.source,\"g\");function C(t,n,i){switch(t.type){case r.AT_LEAST_ONE:return function(t,e,n){return M(O,new a.RepetitionMandatory({definition:[]}),t,e,n)}(t,n,i);case r.AT_LEAST_ONE_SEP:return function(t,e,n){return F(t,e,a.RepetitionMandatoryWithSeparator,R,n)}(t,n,i);case r.MANY_SEP:return function(t,e,n){return F(t,e,a.RepetitionWithSeparator,g,n)}(t,n,i);case r.MANY:return function(t,e,n){return M(y,new a.Repetition({definition:[]}),t,e,n)}(t,n,i);case r.OPTION:return function(t,e,n){return M(d,new a.Option({definition:[]}),t,e,n)}(t,n,i);case r.OR:return function(t,e,n){return M(L,new a.Alternation({definition:[]}),t,e,n)}(t,n,i);case r.FLAT:return function(t,e,n){var r=new a.Flat({definition:[]}),i=P.exec(t.text)[1];o.isUndefined(i)||(r.name=i);return b(r,t.range,e,n)}(t,n,i);case r.REF:return function(t){var e=l.exec(t.text),n=void 0===e[1]?0:parseInt(e[1],10),r=e[2];return new a.NonTerminal({nonTerminalName:r,idx:n})}(t);case r.TERMINAL:return function(t,n){var r=c.exec(t.text),i=void 0===r[1]?0:parseInt(r[1],10),o=r[2],s=e.terminalNameToConstructor[o];if(!s)throw Error(\"Terminal Token name: <\"+o+\"> not found in rule: <\"+n+\">  \\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\\n\\tFor Further details.\");return new a.Terminal({terminalType:s,idx:i})}(t,i);default:throw Error(\"non exhaustive match\")}}function M(t,e,n,r,i){var a=t.exec(n.text),s=void 0===a[1];e.idx=s?0:parseInt(a[1],10);var u=a[2];return o.isUndefined(u)||(e.name=u),b(e,n.range,r,i)}function F(t,n,r,i,a){var s=i.exec(t.text),u=void 0===s[1]?0:parseInt(s[1],10),c=s[3],p=e.terminalNameToConstructor[c];if(!p)throw Error(\"Separator Terminal Token name: \"+c+\" not found\");var l=new r({definition:[],separator:p,idx:u}),h=s[2];return o.isUndefined(h)||(l.name=h),b(l,t.range,n,a)}function b(t,e,n,r){var i=D(e,n),a=o.sortBy(i,function(t){return t.range.start}),s=[];return o.forEach(a,function(t){s.push(C(t,n,r));}),t.definition=s,t}function D(t,e){return o.filter(e,function(n){var r=t.strictlyContainsRange(n.range),i=o.every(e,function(e){var r=e.range.strictlyContainsRange(n.range),i=e.range.isStrictlyContainedInRange(t);return !(r&&i)});return r&&i})}e.terminalNameToConstructor={},e.buildTopProduction=function(t,n,r){e.terminalNameToConstructor=r;var o=V(j(K(\"  \"+t)));return function(t,e,n,r){return b(new a.Rule({name:t,definition:[],orgText:r}),e,n,t)}(n,new i.Range(0,t.length+2),o,t)},e.buildProdGast=C,e.getDirectlyContainedRanges=D;var w=/\\/\\/.*/g,U=/\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\//g,G=/(NAME\\s*:\\s*)?\"([^\\\\\"]|\\\\([bfnrtv\"\\\\\\/]|u[0-9a-fA-F]{4}))*\"/g,B=/(NAME\\s*:\\s*)?'([^\\\\']|\\\\([bfnrtv'\\\\\\/]|u[0-9a-fA-F]{4}))*'/g;function K(t){return t.replace(w,\"\").replace(U,\"\")}function W(t,e){return void 0!==e?t:\"\"}function j(t){return t.replace(G,W).replace(B,W)}function V(t){var e=Y(t),n=H(t),r=X(t),i=z(t),o=q(t),a=$(t),s=Z(t),u=Q(t);return [].concat(e,n,r,i,o,a,s,u)}function Y(t){return nt(t,r.TERMINAL,p)}function H(t){return nt(t,r.REF,h)}function X(t){return rt(t,r.AT_LEAST_ONE,S)}function z(t){return rt(t,r.AT_LEAST_ONE_SEP,A)}function q(t){return rt(t,r.MANY,T)}function $(t){return rt(t,r.MANY_SEP,_)}function Z(t){return rt(t,r.OPTION,E)}function Q(t){var e=rt(t,r.OR,k),n=et(e);return e.concat(n)}e.removeComments=K,e.removeStringLiterals=j,e.createRanges=V,e.createTerminalRanges=Y,e.createRefsRanges=H,e.createAtLeastOneRanges=X,e.createAtLeastOneSepRanges=z,e.createManyRanges=q,e.createManySepRanges=$,e.createOptionRanges=Z,e.createOrRanges=Q;var J=o.partial(ot,\"{\",\"}\"),tt=o.partial(ot,\"(\",\")\");function et(t){var e=[];return o.forEach(t,function(t){var n=it(t.text,r.FLAT,x,J),i=t.range.start;o.forEach(n,function(t){t.range.start+=i,t.range.end+=i;}),e=e.concat(n);}),o.uniq(e,function(t){return t.type+\"~\"+t.range.start+\"~\"+t.range.end+\"~\"+t.text})}function nt(t,e,n){for(var r,o=[];r=n.exec(t);){var a=r.index,s=n.lastIndex,u=new i.Range(a,s),c=r[0];o.push({range:u,text:c,type:e});}return o}function rt(t,e,n){return it(t,e,n,tt)}function it(t,e,n,r){for(var o,a=[];o=n.exec(t);){var s=o.index,u=r(s+o[0].length,t),c=new i.Range(s,u),p=t.substr(s,u-s+1);a.push({range:c,text:p,type:e});}return a}function ot(t,e,n,r){for(var i=[1],a=-1;!o.isEmpty(i)&&a+n<r.length;){a++;var s=r.charAt(n+a);s===t?i.push(1):s===e&&i.pop();}if(o.isEmpty(i))return a+n;throw new Error(\"INVALID INPUT TEXT, UNTERMINATED PARENTHESIS\")}function at(t,e){return o.map(t,function(t){return st(t,e)})}function st(t,e){switch(t.type){case\"NonTerminal\":return new a.NonTerminal({nonTerminalName:t.name,idx:t.idx});case\"Flat\":return new a.Flat({name:t.name,definition:at(t.definition,e)});case\"Option\":return new a.Option({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatory\":return new a.RepetitionMandatory({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatoryWithSeparator\":return new a.RepetitionMandatoryWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"RepetitionWithSeparator\":return new a.RepetitionWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"Repetition\":return new a.Repetition({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Alternation\":return new a.Alternation({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Terminal\":return new a.Terminal({terminalType:e[t.name],idx:t.idx});case\"Rule\":return new a.Rule({name:t.name,orgText:t.orgText,definition:at(t.definition,e)});}}e.createOrPartRanges=et,e.findClosingOffset=ot,e.deserializeGrammar=at,e.deserializeProduction=st;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(30),a=n(11),s=n(10),u=n(8);e.resolveGrammar=function(t){t=r.defaults(t,{errMsgProvider:s.defaultGrammarResolverErrorProvider});var e=new i.HashTable;return r.forEach(t.rules,function(t){e.put(t.name,t);}),o.resolveGrammar(e,t.errMsgProvider)},e.validateGrammar=function(t){return t=r.defaults(t,{errMsgProvider:s.defaultGrammarValidatorErrorProvider,ignoredIssues:{}}),a.validateGrammar(t.rules,t.maxLookahead,t.tokenTypes,t.ignoredIssues,t.errMsgProvider,t.grammarName)},e.assignOccurrenceIndices=function(t){r.forEach(t.rules,function(t){var e=new u.DslMethodsCollectorVisitor;t.accept(e),r.forEach(e.dslMethods,function(t){r.forEach(t,function(t,e){t.idx=e+1;});});});};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(6),a=n(22),s=n(4),u=n(3);function c(t){this.name=e.IN_RULE_RECOVERY_EXCEPTION,this.message=t;}e.EOF_FOLLOW_KEY={},e.IN_RULE_RECOVERY_EXCEPTION=\"InRuleRecoveryException\",e.InRuleRecoveryException=c,c.prototype=Error.prototype;var p=function(){function t(){}return t.prototype.initRecoverable=function(t){this.firstAfterRepMap=new s.HashTable,this.resyncFollows=new s.HashTable,this.recoveryEnabled=i.has(t,\"recoveryEnabled\")?t.recoveryEnabled:u.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=l);},t.prototype.getTokenToInsert=function(t){var e=r.createTokenInstance(t,\"\",NaN,NaN,NaN,NaN,NaN,NaN);return e.isInsertedInRecovery=!0,e},t.prototype.canTokenTypeBeInsertedInRecovery=function(t){return !0},t.prototype.tryInRepetitionRecovery=function(t,e,n,r){for(var a=this,s=this.findReSyncTokenType(),u=this.exportLexerState(),c=[],p=!1,l=this.LA(1),h=this.LA(1),f=function(){var t=a.LA(0),e=a.errorMessageProvider.buildMismatchTokenMessage({expected:r,actual:l,previous:t,ruleName:a.getCurrRuleFullName()}),n=new o.MismatchedTokenException(e,l,a.LA(0));n.resyncedTokens=i.dropRight(c),a.SAVE_ERROR(n);};!p;){if(this.tokenMatcher(h,r))return void f();if(n.call(this))return f(),void t.apply(this,e);this.tokenMatcher(h,s)?p=!0:(h=this.SKIP_TOKEN(),this.addToResyncTokens(h,c));}this.importLexerState(u);},t.prototype.shouldInRepetitionRecoveryBeTried=function(t,e){return void 0!==t&&void 0!==e&&(!this.tokenMatcher(this.LA(1),t)&&(!this.isBackTracking()&&!this.canPerformInRuleRecovery(t,this.getFollowsForInRuleRecovery(t,e))))},t.prototype.getFollowsForInRuleRecovery=function(t,e){var n=this.getCurrentGrammarPath(t,e);return this.getNextPossibleTokenTypes(n)},t.prototype.tryInRuleRecovery=function(t,e){if(this.canRecoverWithSingleTokenInsertion(t,e))return this.getTokenToInsert(t);if(this.canRecoverWithSingleTokenDeletion(t)){var n=this.SKIP_TOKEN();return this.consumeToken(),n}throw new c(\"sad sad panda\")},t.prototype.canPerformInRuleRecovery=function(t,e){return this.canRecoverWithSingleTokenInsertion(t,e)||this.canRecoverWithSingleTokenDeletion(t)},t.prototype.canRecoverWithSingleTokenInsertion=function(t,e){var n=this;if(!this.canTokenTypeBeInsertedInRecovery(t))return !1;if(i.isEmpty(e))return !1;var r=this.LA(1);return void 0!==i.find(e,function(t){return n.tokenMatcher(r,t)})},t.prototype.canRecoverWithSingleTokenDeletion=function(t){return this.tokenMatcher(this.LA(2),t)},t.prototype.isInCurrentRuleReSyncSet=function(t){var e=this.getCurrFollowKey(),n=this.getFollowSetFromFollowKey(e);return i.contains(n,t)},t.prototype.findReSyncTokenType=function(){for(var t=this.flattenFollowSet(),e=this.LA(1),n=2;;){var r=e.tokenType;if(i.contains(t,r))return r;e=this.LA(n),n++;}},t.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return e.EOF_FOLLOW_KEY;var t=this.getLastExplicitRuleShortName(),n=this.getLastExplicitRuleOccurrenceIndex(),r=this.getPreviousExplicitRuleShortName();return {ruleName:this.shortRuleNameToFullName(t),idxInCallingRule:n,inRule:this.shortRuleNameToFullName(r)}},t.prototype.buildFullFollowKeyStack=function(){var t=this,n=this.RULE_STACK,r=this.RULE_OCCURRENCE_STACK;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)||(n=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_STACK[e]}),r=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_OCCURRENCE_STACK[e]})),i.map(n,function(i,o){return 0===o?e.EOF_FOLLOW_KEY:{ruleName:t.shortRuleNameToFullName(i),idxInCallingRule:r[o],inRule:t.shortRuleNameToFullName(n[o-1])}})},t.prototype.flattenFollowSet=function(){var t=this,e=i.map(this.buildFullFollowKeyStack(),function(e){return t.getFollowSetFromFollowKey(e)});return i.flatten(e)},t.prototype.getFollowSetFromFollowKey=function(t){if(t===e.EOF_FOLLOW_KEY)return [r.EOF];var n=t.ruleName+t.idxInCallingRule+a.IN+t.inRule;return this.resyncFollows.get(n)},t.prototype.addToResyncTokens=function(t,e){return this.tokenMatcher(t,r.EOF)||e.push(t),e},t.prototype.reSyncTo=function(t){for(var e=[],n=this.LA(1);!1===this.tokenMatcher(n,t);)n=this.SKIP_TOKEN(),this.addToResyncTokens(n,e);return i.dropRight(e)},t.prototype.attemptInRepetitionRecovery=function(t,e,n,r,i,o){},t.prototype.getCurrentGrammarPath=function(t,e){return {ruleStack:this.getHumanReadableRuleStack(),occurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK),lastTok:t,lastTokOccurrence:e}},t.prototype.getHumanReadableRuleStack=function(){var t=this;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)?i.map(this.RULE_STACK,function(e){return t.shortRuleNameToFullName(e)}):i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.shortRuleNameToFullName(t.RULE_STACK[e])})},t}();function l(t,e,n,i,o,a){var s=this.getKeyForAutomaticLookahead(i,o),u=this.firstAfterRepMap.get(s);if(void 0===u){var c=this.getCurrRuleFullName();u=new a(this.getGAstProductions().get(c),o).startWalking(),this.firstAfterRepMap.put(s,u);}var p=u.token,l=u.occurrence,h=u.isEndOfRule;1===this.RULE_STACK.length&&h&&void 0===p&&(p=r.EOF,l=1),this.shouldInRepetitionRecoveryBeTried(p,l)&&this.tryInRepetitionRecovery(t,e,n,p);}e.Recoverable=p,e.attemptInRepetitionRecovery=l;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(4),s=n(21),u=n(0),c=n(22),p=n(2),l=n(1),h=function(t){function e(e){var n=t.call(this)||this;return n.topProd=e,n.follows=new a.HashTable,n}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},e.prototype.walkTerminal=function(t,e,n){},e.prototype.walkProdRef=function(t,e,n){var r=f(t.referencedRule,t.idx)+this.topProd.name,i=e.concat(n),o=new l.Flat({definition:i}),a=s.first(o);this.follows.put(r,a);},e}(o.RestWalker);function f(t,e){return t.name+e+c.IN}e.ResyncFollowsWalker=h,e.computeAllProdsFollows=function(t){var e=new a.HashTable;return u.forEach(t,function(t){var n=new h(t).startWalking();e.putAll(n);}),e},e.buildBetweenProdsFollowPrefix=f,e.buildInProdFollowPrefix=function(t){return p.tokenName(t.terminalType)+t.idx+c.IN};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(2),s=n(15),u=n(0),c=n(28),p=new o.RegExpParser,l=\"PATTERN\";function h(t){var e=u.filter(t,function(t){return !u.has(t,l)});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- missing static 'PATTERN' property\",type:s.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}function f(t){var e=u.filter(t,function(t){var e=t[l];return !(u.isRegExp(e)||u.isFunction(e)||u.has(e,\"exec\")||u.isString(e))});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",type:s.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}e.DEFAULT_MODE=\"defaultMode\",e.MODES=\"modes\",e.SUPPORT_STICKY=\"boolean\"==typeof new RegExp(\"(?:)\").sticky,e.disableSticky=function(){e.SUPPORT_STICKY=!1;},e.enableSticky=function(){e.SUPPORT_STICKY=!0;},e.analyzeTokenTypes=function(t,n){n=u.defaults(n,{useSticky:e.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:\"full\",lineTerminatorCharacters:[\"\\r\",\"\\n\"]});var r=u.reject(t,function(t){return t[l]===s.Lexer.NA}),i=!1,o=u.map(r,function(t){var e=t[l];if(u.isRegExp(e)){var r=e.source;return 1===r.length&&\"^\"!==r&&\"$\"!==r&&\".\"!==r?r:2!==r.length||\"\\\\\"!==r[0]||u.contains([\"d\",\"D\",\"s\",\"S\",\"t\",\"r\",\"n\",\"t\",\"0\",\"c\",\"b\",\"B\",\"f\",\"v\",\"w\",\"W\"],r[1])?n.useSticky?O(e):N(e):r[1]}if(u.isFunction(e))return i=!0,{exec:e};if(u.has(e,\"exec\"))return i=!0,e;if(\"string\"==typeof e){if(1===e.length)return e;var o=e.replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\"),a=new RegExp(o);return n.useSticky?O(a):N(a)}throw Error(\"non exhaustive match\")}),p=u.map(r,function(t){return t.tokenTypeIdx}),h=u.map(r,function(t){var e=t.GROUP;if(e!==s.Lexer.SKIPPED){if(u.isString(e))return e;if(u.isUndefined(e))return !1;throw Error(\"non exhaustive match\")}}),f=u.map(r,function(t){var e=t.LONGER_ALT;if(e)return u.indexOf(r,e)}),d=u.map(r,function(t){return t.PUSH_MODE}),E=u.map(r,function(t){return u.has(t,\"POP_MODE\")}),m=P(n.lineTerminatorCharacters),y=u.map(r,function(t){return !1});\"onlyOffset\"!==n.positionTracking&&(y=u.map(r,function(t){return u.has(t,\"LINE_BREAKS\")?t.LINE_BREAKS:!1===L(t,m)?c.canMatchCharCode(m,t.PATTERN):void 0}));var T=u.map(r,S),v=u.map(o,I),g=u.reduce(r,function(t,e){var n=e.GROUP;return u.isString(n)&&n!==s.Lexer.SKIPPED&&(t[n]=[]),t},{}),_=u.map(o,function(t,e){return {pattern:o[e],longerAlt:f[e],canLineTerminator:y[e],isCustom:T[e],short:v[e],group:h[e],push:d[e],pop:E[e],tokenTypeIdx:p[e],tokenType:r[e]}});function R(t,e,n){void 0===t[e]&&(t[e]=[]),t[e].push(n);}var A=!0,k=[];return n.safeMode||(k=u.reduce(r,function(t,e,r){if(\"string\"==typeof e.PATTERN){var i=e.PATTERN.charCodeAt(0);R(t,i,_[r]);}else if(u.isArray(e.START_CHARS_HINT))u.forEach(e.START_CHARS_HINT,function(e){var n=\"string\"==typeof e?e.charCodeAt(0):e;R(t,n,_[r]);});else if(u.isRegExp(e.PATTERN))if(e.PATTERN.unicode)A=!1,n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tUnable to analyze < \"+e.PATTERN.toString()+\" > pattern.\\n\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");else {var o=c.getStartCodes(e.PATTERN,n.ensureOptimizations);u.isEmpty(o)&&(A=!1),u.forEach(o,function(e){R(t,e,_[r]);});}else n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tTokenType: <\"+a.tokenName(e)+\"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"),A=!1;return t},[])),A&&k.length<65536&&(k=u.packArray(k)),{emptyGroups:g,patternIdxToConfig:_,charCodeToPatternIdxToConfig:k,hasCustom:i,canBeOptimized:A}},e.validatePatterns=function(t,e){var n=[],r=h(t);n=n.concat(r.errors);var i=f(r.valid),o=i.valid;return n=(n=(n=(n=(n=n.concat(i.errors)).concat(function(t){var e=[],n=u.filter(t,function(t){return u.isRegExp(t[l])});return e=(e=(e=(e=(e=e.concat(E(n))).concat(T(n))).concat(v(n))).concat(g(n))).concat(m(n))}(o))).concat(_(o))).concat(R(o,e))).concat(A(o))},e.findMissingPatterns=h,e.findInvalidPatterns=f;var d=/[^\\\\][\\$]/;function E(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitEndAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return d.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[t]}})}function m(t){var e=u.filter(t,function(t){return t[l].test(\"\")});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' must not match an empty string\",type:s.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[t]}})}e.findEndOfInputAnchor=E,e.findEmptyMatchRegExps=m;var y=/[^\\\\[][\\^]|^\\^/;function T(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitStartAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return y.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[t]}})}function v(t){var e=u.filter(t,function(t){var e=t[l];return e instanceof RegExp&&(e.multiline||e.global)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",type:s.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[t]}})}function g(t){var e=[],n=u.map(t,function(n){return u.reduce(t,function(t,r){return n.PATTERN.source!==r.PATTERN.source||u.contains(e,r)||r.PATTERN===s.Lexer.NA?t:(e.push(r),t.push(r),t)},[])});n=u.compact(n);var r=u.filter(n,function(t){return t.length>1});return u.map(r,function(t){var e=u.map(t,function(t){return a.tokenName(t)});return {message:\"The same RegExp pattern ->\"+u.first(t).PATTERN+\"<-has been used in all of the following Token Types: \"+e.join(\", \")+\" <-\",type:s.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:t}})}function _(t){var e=u.filter(t,function(t){if(!u.has(t,\"GROUP\"))return !1;var e=t.GROUP;return e!==s.Lexer.SKIPPED&&e!==s.Lexer.NA&&!u.isString(e)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",type:s.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[t]}})}function R(t,e){var n=u.filter(t,function(t){return void 0!==t.PUSH_MODE&&!u.contains(e,t.PUSH_MODE)});return u.map(n,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\"+t.PUSH_MODE+\"<-which does not exist\",type:s.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[t]}})}function A(t){var e=[],n=u.reduce(t,function(t,e,n){var r,i=e.PATTERN;return i===s.Lexer.NA?t:(u.isString(i)?t.push({str:i,idx:n,tokenType:e}):u.isRegExp(i)&&(r=i,void 0===u.find([\".\",\"\\\\\",\"[\",\"]\",\"|\",\"^\",\"$\",\"(\",\")\",\"?\",\"*\",\"+\",\"{\"],function(t){return -1!==r.source.indexOf(t)}))&&t.push({str:i.source,idx:n,tokenType:e}),t)},[]);return u.forEach(t,function(t,r){u.forEach(n,function(n){var i=n.str,o=n.idx,c=n.tokenType;if(r<o&&function(t,e){if(u.isRegExp(e)){var n=e.exec(t);return null!==n&&0===n.index}if(u.isFunction(e))return e(t,0,[],{});if(u.has(e,\"exec\"))return e.exec(t,0,[],{});if(\"string\"==typeof e)return e===t;throw Error(\"non exhaustive match\")}(i,t.PATTERN)){var p=\"Token: ->\"+a.tokenName(c)+\"<- can never be matched.\\nBecause it appears AFTER the Token Type ->\"+a.tokenName(t)+\"<-in the lexer's definition.\\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";e.push({message:p,type:s.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[t,c]});}});}),e}function N(t){var e=t.ignoreCase?\"i\":\"\";return new RegExp(\"^(?:\"+t.source+\")\",e)}function O(t){var e=t.ignoreCase?\"iy\":\"y\";return new RegExp(\"\"+t.source,e)}function S(t){var e=t.PATTERN;if(u.isRegExp(e))return !1;if(u.isFunction(e))return !0;if(u.has(e,\"exec\"))return !0;if(u.isString(e))return !1;throw Error(\"non exhaustive match\")}function I(t){return !(!u.isString(t)||1!==t.length)&&t.charCodeAt(0)}function L(t,e){if(u.has(t,\"LINE_BREAKS\"))return !1;if(u.isRegExp(t.PATTERN)){try{c.canMatchCharCode(e,t.PATTERN);}catch(t){return {issue:s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:t.message}}return !1}if(u.isString(t.PATTERN))return !1;if(S(t))return {issue:s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error(\"non exhaustive match\")}function k(t,e){if(e.issue===s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return \"Warning: unable to identify line terminator usage in pattern.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\t Root cause: \"+e.errMsg+\".\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";if(e.issue===s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";throw Error(\"non exhaustive match\")}function P(t){return u.map(t,function(t){return u.isString(t)&&t.length>0?t.charCodeAt(0):t})}e.findStartOfInputAnchor=T,e.findUnsupportedFlags=v,e.findDuplicatePatterns=g,e.findInvalidGroupType=_,e.findModesThatDoNotExist=R,e.findUnreachablePatterns=A,e.addStartOfInput=N,e.addStickyFlag=O,e.performRuntimeChecks=function(t,n,r){var i=[];return u.has(t,e.DEFAULT_MODE)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.DEFAULT_MODE+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),u.has(t,e.MODES)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.MODES+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),u.has(t,e.MODES)&&u.has(t,e.DEFAULT_MODE)&&!u.has(t.modes,t.defaultMode)&&i.push({message:\"A MultiMode Lexer cannot be initialized with a \"+e.DEFAULT_MODE+\": <\"+t.defaultMode+\">which does not exist\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),u.has(t,e.MODES)&&u.forEach(t.modes,function(t,e){u.forEach(t,function(t,n){u.isUndefined(t)&&i.push({message:\"A Lexer cannot be initialized using an undefined Token Type. Mode:<\"+e+\"> at index: <\"+n+\">\\n\",type:s.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});});}),i},e.performWarningRuntimeChecks=function(t,e,n){var r=[],i=!1,o=u.compact(u.flatten(u.mapValues(t.modes,function(t){return t}))),a=u.reject(o,function(t){return t[l]===s.Lexer.NA}),p=P(n);return e&&u.forEach(a,function(t){var e=L(t,p);if(!1!==e){var n={message:k(t,e),type:e.issue,tokenType:t};r.push(n);}else u.has(t,\"LINE_BREAKS\")?!0===t.LINE_BREAKS&&(i=!0):c.canMatchCharCode(p,t.PATTERN)&&(i=!0);}),e&&!i&&r.push({message:\"Warning: No LINE_BREAKS Found.\\n\\tThis Lexer has been defined to track line and column information,\\n\\tBut none of the Token Types can be identified as matching a line terminator.\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\\tfor details.\",type:s.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),r},e.cloneEmptyGroups=function(t){var e={},n=u.keys(t);return u.forEach(n,function(n){var r=t[n];if(!u.isArray(r))throw Error(\"non exhaustive match\");e[n]=[];}),e},e.isCustomPattern=S,e.isShortPattern=I,e.LineTerminatorOptimizedTester={test:function(t){for(var e=t.length,n=this.lastIndex;n<e;n++){var r=t.charCodeAt(n);if(10===r)return this.lastIndex=n+1,!0;if(13===r)return 10===t.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return !1},lastIndex:0},e.buildLineBreakIssueMessage=k;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(0),s=new o.RegExpParser,u=\"Complement Sets are not supported for first char optimization\";function c(t){switch(t.type){case\"Disjunction\":return a.flatten(a.map(t.value,c));case\"Alternative\":for(var e=[],n=t.value,r=0;r<n.length;r++){var i=n[r];if(!a.contains([\"GroupBackReference\",\"Lookahead\",\"NegativeLookahead\",\"StartAnchor\",\"EndAnchor\",\"WordBoundary\",\"NonWordBoundary\"],i.type)){var o=i;switch(o.type){case\"Character\":e.push(o.value);break;case\"Set\":if(!0===o.complement)throw Error(u);a.forEach(o.value,function(t){if(\"number\"==typeof t)e.push(t);else for(var n=t,r=n.from;r<=n.to;r++)e.push(r);});break;case\"Group\":var s=c(o.value);a.forEach(s,function(t){return e.push(t)});break;default:throw Error(\"Non Exhaustive Match\")}var p=void 0!==o.quantifier&&0===o.quantifier.atLeast;if(\"Group\"===o.type&&!1===h(o)||\"Group\"!==o.type&&!1===p)break}}return e;default:throw Error(\"non exhaustive match!\")}}function p(t){var e=[];return a.forEach(t,function(t){e.push(t);var n=String.fromCharCode(t);n.toUpperCase()!==n?e.push(n.toUpperCase().charCodeAt(0)):n.toLowerCase()!==n&&e.push(n.toLowerCase().charCodeAt(0));}),e}function l(t,e){return a.find(t.value,function(t){if(\"number\"==typeof t)return a.contains(e,t);var n=t;return void 0!==a.find(e,function(t){return n.from<=t&&t<=n.to})})}function h(t){return !(!t.quantifier||0!==t.quantifier.atLeast)||!!t.value&&(a.isArray(t.value)?a.every(t.value,h):h(t.value))}e.failedOptimizationPrefixMsg='Unable to use \"first char\" lexer optimizations:\\n',e.getStartCodes=function(t,n){void 0===n&&(n=!1);try{var r=s.pattern(t.toString()),i=c(r.value);return r.flags.ignoreCase&&(i=p(i)),i}catch(r){if(r.message===u)n&&a.PRINT_WARNING(e.failedOptimizationPrefixMsg+\"\\tUnable to optimize: < \"+t.toString()+\" >\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");else {var l=\"\";n&&(l=\"\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"),a.PRINT_ERROR(e.failedOptimizationPrefixMsg+\"\\n\\tFailed parsing: < \"+t.toString()+\" >\\n\\tUsing the regexp-to-ast library version: \"+o.VERSION+\"\\n\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\"+l);}}return []},e.firstChar=c,e.applyIgnoreCase=p;var f=function(t){function e(e){var n=t.call(this)||this;return n.targetCharCodes=e,n.found=!1,n}return i(e,t),e.prototype.visitChildren=function(e){switch(e.type){case\"Lookahead\":return void this.visitLookahead(e);case\"NegativeLookahead\":return void this.visitNegativeLookahead(e)}t.prototype.visitChildren.call(this,e);},e.prototype.visitCharacter=function(t){a.contains(this.targetCharCodes,t.value)&&(this.found=!0);},e.prototype.visitSet=function(t){t.complement?void 0===l(t,this.targetCharCodes)&&(this.found=!0):void 0!==l(t,this.targetCharCodes)&&(this.found=!0);},e}(o.BaseRegExpVisitor);e.canMatchCharCode=function(t,e){if(e instanceof RegExp){var n=s.pattern(e.toString()),r=new f(t);return r.visit(n),r.found}return void 0!==a.find(e,function(e){return a.contains(t,e.charCodeAt(0))})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=function(){function t(t,e){if(this.start=t,this.end=e,!i(t,e))throw new Error(\"INVALID RANGE\")}return t.prototype.contains=function(t){return this.start<=t&&this.end>=t},t.prototype.containsRange=function(t){return this.start<=t.start&&this.end>=t.end},t.prototype.isContainedInRange=function(t){return t.containsRange(this)},t.prototype.strictlyContainsRange=function(t){return this.start<t.start&&this.end>t.end},t.prototype.isStrictlyContainedInRange=function(t){return t.strictlyContainsRange(this)},t}();function i(t,e){return !(t<0||e<t)}e.Range=r,e.isValidRange=i;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(3),a=n(0),s=n(5);e.resolveGrammar=function(t,e){var n=new u(t,e);return n.resolveRefs(),n.errors};var u=function(t){function e(e,n){var r=t.call(this)||this;return r.nameToTopRule=e,r.errMsgProvider=n,r.errors=[],r}return i(e,t),e.prototype.resolveRefs=function(){var t=this;a.forEach(this.nameToTopRule.values(),function(e){t.currTopLevel=e,e.accept(t);});},e.prototype.visitNonTerminal=function(t){var e=this.nameToTopRule.get(t.nonTerminalName);if(e)t.referencedRule=e;else {var n=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,t);this.errors.push({message:n,type:o.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:t.nonTerminalName});}},e}(s.GAstVisitor);e.GastRefResolverVisitor=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(12),i=n(0),o=n(3),a=n(9),s=function(){function t(){}return t.prototype.initLooksAhead=function(t){this.dynamicTokensEnabled=i.has(t,\"dynamicTokensEnabled\")?t.dynamicTokensEnabled:o.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=i.has(t,\"maxLookahead\")?t.maxLookahead:o.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=i.isES2015MapSupported()?new Map:[],i.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj);},t.prototype.lookAheadBuilderForOptional=function(t,e,n){return r.buildSingleAlternativeLookaheadFunction(t,e,n)},t.prototype.lookAheadBuilderForAlternatives=function(t,e,n,i){return r.buildAlternativesLookAheadFunc(t,e,n,i)},t.prototype.getKeyForAutomaticLookahead=function(t,e){var n=this.getLastExplicitRuleShortName();return a.getKeyForAutomaticLookahead(n,t,e)},t.prototype.getLookaheadFuncForOr=function(t,e){var n=this.getKeyForAutomaticLookahead(a.OR_IDX,t),o=this.getLaFuncFromCache(n);if(void 0===o){var s=this.getCurrRuleFullName(),u=this.getGAstProductions().get(s),c=i.some(e,function(t){return i.isFunction(t.GATE)});return o=r.buildLookaheadFuncForOr(t,u,this.maxLookahead,c,this.dynamicTokensEnabled,this.lookAheadBuilderForAlternatives),this.setLaFuncCache(n,o),o}return o},t.prototype.getLookaheadFuncForOption=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.OPTION)},t.prototype.getLookaheadFuncForMany=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION)},t.prototype.getLookaheadFuncForManySep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_WITH_SEPARATOR)},t.prototype.getLookaheadFuncForAtLeastOne=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY)},t.prototype.getLookaheadFuncForAtLeastOneSep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)},t.prototype.getLookaheadFuncFor=function(t,e,n,i){var o=this.getLaFuncFromCache(t);if(void 0===o){var a=this.getCurrRuleFullName(),s=this.getGAstProductions().get(a);return o=r.buildLookaheadFuncForOptionalProd(e,s,n,this.dynamicTokensEnabled,i,this.lookAheadBuilderForOptional),this.setLaFuncCache(t,o),o}return o},t.prototype.getLaFuncFromCache=function(t){},t.prototype.getLaFuncFromMap=function(t){return this.lookAheadFuncsCache.get(t)},t.prototype.getLaFuncFromObj=function(t){return this.lookAheadFuncsCache[t]},t.prototype.setLaFuncCache=function(t,e){},t.prototype.setLaFuncCacheUsingMap=function(t,e){this.lookAheadFuncsCache.set(t,e);},t.prototype.setLaFuncUsingObj=function(t,e){this.lookAheadFuncsCache[t]=e;},t}();e.LooksAhead=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(16),i=n(0),o=n(33),a=n(9),s=n(3),u=function(){function t(){}return t.prototype.initTreeBuilder=function(t){this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.outputCst=i.has(t,\"outputCst\")?t.outputCst:s.DEFAULT_PARSER_CONFIG.outputCst,this.outputCst||(this.cstInvocationStateUpdate=i.NOOP,this.cstFinallyStateUpdate=i.NOOP,this.cstPostTerminal=i.NOOP,this.cstPostNonTerminal=i.NOOP,this.getLastExplicitRuleShortName=this.getLastExplicitRuleShortNameNoCst,this.getPreviousExplicitRuleShortName=this.getPreviousExplicitRuleShortNameNoCst,this.getLastExplicitRuleOccurrenceIndex=this.getLastExplicitRuleOccurrenceIndexNoCst,this.manyInternal=this.manyInternalNoCst,this.orInternal=this.orInternalNoCst,this.optionInternal=this.optionInternalNoCst,this.atLeastOneInternal=this.atLeastOneInternalNoCst,this.manySepFirstInternal=this.manySepFirstInternalNoCst,this.atLeastOneSepFirstInternal=this.atLeastOneSepFirstInternalNoCst);},t.prototype.cstNestedInvocationStateUpdate=function(t,e){this.CST_STACK.push({name:t,fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName())+t,children:{}});},t.prototype.cstInvocationStateUpdate=function(t,e){this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length-1),this.CST_STACK.push({name:t,children:{}});},t.prototype.cstFinallyStateUpdate=function(){this.LAST_EXPLICIT_RULE_STACK.pop(),this.CST_STACK.pop();},t.prototype.cstNestedFinallyStateUpdate=function(){this.CST_STACK.pop();},t.prototype.cstPostTerminal=function(t,e){var n=this.CST_STACK[this.CST_STACK.length-1];r.addTerminalToCst(n,e,t);},t.prototype.cstPostNonTerminal=function(t,e){r.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length-1],e,t);},t.prototype.getBaseCstVisitorConstructor=function(){if(i.isUndefined(this.baseCstVisitorConstructor)){var t=o.createBaseSemanticVisitorConstructor(this.className,this.allRuleNames);return this.baseCstVisitorConstructor=t,t}return this.baseCstVisitorConstructor},t.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(i.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var t=o.createBaseVisitorConstructorWithDefaults(this.className,this.allRuleNames,this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=t,t}return this.baseCstVisitorWithDefaultsConstructor},t.prototype.nestedRuleBeforeClause=function(t,e){var n;return void 0!==t.NAME?(n=t.NAME,this.nestedRuleInvocationStateUpdate(n,e),n):void 0},t.prototype.nestedAltBeforeClause=function(t,e,n,r){var i,o=this.getLastExplicitRuleShortName(),s=a.getKeyForAltIndex(o,n,e,r);return void 0!==t.NAME?(i=t.NAME,this.nestedRuleInvocationStateUpdate(i,s),{shortName:s,nestedName:i}):void 0},t.prototype.nestedRuleFinallyClause=function(t,e){var n=this.CST_STACK,i=n[n.length-1];this.nestedRuleFinallyStateUpdate();var o=n[n.length-1];r.addNoneTerminalToCst(o,e,i);},t.prototype.getLastExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_STACK[t]},t.prototype.getLastExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-1]},t.prototype.getPreviousExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-2];return this.RULE_STACK[t]},t.prototype.getPreviousExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-2]},t.prototype.getLastExplicitRuleOccurrenceIndex=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_OCCURRENCE_STACK[t]},t.prototype.getLastExplicitRuleOccurrenceIndexNoCst=function(){var t=this.RULE_OCCURRENCE_STACK;return t[t.length-1]},t.prototype.nestedRuleInvocationStateUpdate=function(t,e){this.RULE_OCCURRENCE_STACK.push(1),this.RULE_STACK.push(e),this.cstNestedInvocationStateUpdate(t,e);},t.prototype.nestedRuleFinallyStateUpdate=function(){this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstNestedFinallyStateUpdate();},t}();e.TreeBuilder=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(0),o=n(4),a=n(11);function s(t,e){for(var n=i.keys(t),r=n.length,o=0;o<r;o++)for(var a=t[n[o]],s=a.length,u=0;u<s;u++){var c=a[u];void 0===c.tokenTypeIdx&&(void 0!==c.fullName?this[c.fullName](c.children,e):this[c.name](c.children,e));}}function u(t,e){var n=c(t,e),r=l(t,e);return n.concat(r)}function c(t,e){var n=i.map(e,function(e){if(!i.isFunction(t[e]))return {msg:\"Missing visitor method: <\"+e+\"> on \"+o.functionName(t.constructor)+\" CST Visitor.\",type:r.MISSING_METHOD,methodName:e}});return i.compact(n)}e.defaultVisit=s,e.createBaseSemanticVisitorConstructor=function(t,e){var n=function(){};return o.defineNameProp(n,t+\"BaseSemantics\"),(n.prototype={visit:function(t,e){if(i.isArray(t)&&(t=t[0]),!i.isUndefined(t))return void 0!==t.fullName?this[t.fullName](t.children,e):this[t.name](t.children,e)},validateVisitor:function(){var t=u(this,e);if(!i.isEmpty(t)){var n=i.map(t,function(t){return t.msg});throw Error(\"Errors Detected in CST Visitor <\"+o.functionName(this.constructor)+\">:\\n\\t\"+n.join(\"\\n\\n\").replace(/\\n/g,\"\\n\\t\"))}}}).constructor=n,n._RULE_NAMES=e,n},e.createBaseVisitorConstructorWithDefaults=function(t,e,n){var r=function(){};o.defineNameProp(r,t+\"BaseSemanticsWithDefaults\");var a=Object.create(n.prototype);return i.forEach(e,function(t){a[t]=s;}),(r.prototype=a).constructor=r,r},function(t){t[t.REDUNDANT_METHOD=0]=\"REDUNDANT_METHOD\",t[t.MISSING_METHOD=1]=\"MISSING_METHOD\";}(r=e.CstVisitorDefinitionError||(e.CstVisitorDefinitionError={})),e.validateVisitor=u,e.validateMissingCstMethods=c;var p=[\"constructor\",\"visit\",\"validateVisitor\"];function l(t,e){var n=[];for(var s in t)a.validTermsPattern.test(s)&&i.isFunction(t[s])&&!i.contains(p,s)&&!i.contains(e,s)&&n.push({msg:\"Redundant visitor method: <\"+s+\"> on \"+o.functionName(t.constructor)+\" CST Visitor\\nThere is no Grammar Rule corresponding to this method's name.\\nFor utility methods on visitor classes use methods names that do not match /\"+a.validTermsPattern.source+\"/.\",type:r.REDUNDANT_METHOD,methodName:s});return n}e.validateRedundantMethods=l;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=function(){function t(){}return t.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1;},Object.defineProperty(t.prototype,\"input\",{get:function(){return this.tokVector},set:function(t){this.reset(),this.tokVector=t,this.tokVectorLength=t.length;},enumerable:!0,configurable:!0}),t.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):r.END_OF_FILE},t.prototype.LA=function(t){return this.currIdx+t<0||this.tokVectorLength<=this.currIdx+t?r.END_OF_FILE:this.tokVector[this.currIdx+t]},t.prototype.consumeToken=function(){this.currIdx++;},t.prototype.exportLexerState=function(){return this.currIdx},t.prototype.importLexerState=function(t){this.currIdx=t;},t.prototype.resetLexerState=function(){this.currIdx=-1;},t.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1;},t.prototype.getLexerPosition=function(){return this.exportLexerState()},t}();e.LexerAdapter=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(6),o=n(3),a=n(10),s=n(23),u=n(11),c=n(1),p=function(){function t(){}return t.prototype.CONSUME=function(t,e){return this.consumeInternal(t,0,e)},t.prototype.CONSUME1=function(t,e){return this.consumeInternal(t,1,e)},t.prototype.CONSUME2=function(t,e){return this.consumeInternal(t,2,e)},t.prototype.CONSUME3=function(t,e){return this.consumeInternal(t,3,e)},t.prototype.CONSUME4=function(t,e){return this.consumeInternal(t,4,e)},t.prototype.CONSUME5=function(t,e){return this.consumeInternal(t,5,e)},t.prototype.CONSUME6=function(t,e){return this.consumeInternal(t,6,e)},t.prototype.CONSUME7=function(t,e){return this.consumeInternal(t,7,e)},t.prototype.CONSUME8=function(t,e){return this.consumeInternal(t,8,e)},t.prototype.CONSUME9=function(t,e){return this.consumeInternal(t,9,e)},t.prototype.SUBRULE=function(t,e){return this.subruleInternal(t,0,e)},t.prototype.SUBRULE1=function(t,e){return this.subruleInternal(t,1,e)},t.prototype.SUBRULE2=function(t,e){return this.subruleInternal(t,2,e)},t.prototype.SUBRULE3=function(t,e){return this.subruleInternal(t,3,e)},t.prototype.SUBRULE4=function(t,e){return this.subruleInternal(t,4,e)},t.prototype.SUBRULE5=function(t,e){return this.subruleInternal(t,5,e)},t.prototype.SUBRULE6=function(t,e){return this.subruleInternal(t,6,e)},t.prototype.SUBRULE7=function(t,e){return this.subruleInternal(t,7,e)},t.prototype.SUBRULE8=function(t,e){return this.subruleInternal(t,8,e)},t.prototype.SUBRULE9=function(t,e){return this.subruleInternal(t,9,e)},t.prototype.OPTION=function(t){return this.optionInternal(t,0)},t.prototype.OPTION1=function(t){return this.optionInternal(t,1)},t.prototype.OPTION2=function(t){return this.optionInternal(t,2)},t.prototype.OPTION3=function(t){return this.optionInternal(t,3)},t.prototype.OPTION4=function(t){return this.optionInternal(t,4)},t.prototype.OPTION5=function(t){return this.optionInternal(t,5)},t.prototype.OPTION6=function(t){return this.optionInternal(t,6)},t.prototype.OPTION7=function(t){return this.optionInternal(t,7)},t.prototype.OPTION8=function(t){return this.optionInternal(t,8)},t.prototype.OPTION9=function(t){return this.optionInternal(t,9)},t.prototype.OR=function(t){return this.orInternal(t,0)},t.prototype.OR1=function(t){return this.orInternal(t,1)},t.prototype.OR2=function(t){return this.orInternal(t,2)},t.prototype.OR3=function(t){return this.orInternal(t,3)},t.prototype.OR4=function(t){return this.orInternal(t,4)},t.prototype.OR5=function(t){return this.orInternal(t,5)},t.prototype.OR6=function(t){return this.orInternal(t,6)},t.prototype.OR7=function(t){return this.orInternal(t,7)},t.prototype.OR8=function(t){return this.orInternal(t,8)},t.prototype.OR9=function(t){return this.orInternal(t,9)},t.prototype.MANY=function(t){this.manyInternal(0,t);},t.prototype.MANY1=function(t){this.manyInternal(1,t);},t.prototype.MANY2=function(t){this.manyInternal(2,t);},t.prototype.MANY3=function(t){this.manyInternal(3,t);},t.prototype.MANY4=function(t){this.manyInternal(4,t);},t.prototype.MANY5=function(t){this.manyInternal(5,t);},t.prototype.MANY6=function(t){this.manyInternal(6,t);},t.prototype.MANY7=function(t){this.manyInternal(7,t);},t.prototype.MANY8=function(t){this.manyInternal(8,t);},t.prototype.MANY9=function(t){this.manyInternal(9,t);},t.prototype.MANY_SEP=function(t){this.manySepFirstInternal(0,t);},t.prototype.MANY_SEP1=function(t){this.manySepFirstInternal(1,t);},t.prototype.MANY_SEP2=function(t){this.manySepFirstInternal(2,t);},t.prototype.MANY_SEP3=function(t){this.manySepFirstInternal(3,t);},t.prototype.MANY_SEP4=function(t){this.manySepFirstInternal(4,t);},t.prototype.MANY_SEP5=function(t){this.manySepFirstInternal(5,t);},t.prototype.MANY_SEP6=function(t){this.manySepFirstInternal(6,t);},t.prototype.MANY_SEP7=function(t){this.manySepFirstInternal(7,t);},t.prototype.MANY_SEP8=function(t){this.manySepFirstInternal(8,t);},t.prototype.MANY_SEP9=function(t){this.manySepFirstInternal(9,t);},t.prototype.AT_LEAST_ONE=function(t){this.atLeastOneInternal(0,t);},t.prototype.AT_LEAST_ONE1=function(t){return this.atLeastOneInternal(1,t)},t.prototype.AT_LEAST_ONE2=function(t){this.atLeastOneInternal(2,t);},t.prototype.AT_LEAST_ONE3=function(t){this.atLeastOneInternal(3,t);},t.prototype.AT_LEAST_ONE4=function(t){this.atLeastOneInternal(4,t);},t.prototype.AT_LEAST_ONE5=function(t){this.atLeastOneInternal(5,t);},t.prototype.AT_LEAST_ONE6=function(t){this.atLeastOneInternal(6,t);},t.prototype.AT_LEAST_ONE7=function(t){this.atLeastOneInternal(7,t);},t.prototype.AT_LEAST_ONE8=function(t){this.atLeastOneInternal(8,t);},t.prototype.AT_LEAST_ONE9=function(t){this.atLeastOneInternal(9,t);},t.prototype.AT_LEAST_ONE_SEP=function(t){this.atLeastOneSepFirstInternal(0,t);},t.prototype.AT_LEAST_ONE_SEP1=function(t){this.atLeastOneSepFirstInternal(1,t);},t.prototype.AT_LEAST_ONE_SEP2=function(t){this.atLeastOneSepFirstInternal(2,t);},t.prototype.AT_LEAST_ONE_SEP3=function(t){this.atLeastOneSepFirstInternal(3,t);},t.prototype.AT_LEAST_ONE_SEP4=function(t){this.atLeastOneSepFirstInternal(4,t);},t.prototype.AT_LEAST_ONE_SEP5=function(t){this.atLeastOneSepFirstInternal(5,t);},t.prototype.AT_LEAST_ONE_SEP6=function(t){this.atLeastOneSepFirstInternal(6,t);},t.prototype.AT_LEAST_ONE_SEP7=function(t){this.atLeastOneSepFirstInternal(7,t);},t.prototype.AT_LEAST_ONE_SEP8=function(t){this.atLeastOneSepFirstInternal(8,t);},t.prototype.AT_LEAST_ONE_SEP9=function(t){this.atLeastOneSepFirstInternal(9,t);},t.prototype.RULE=function(t,e,n){if(void 0===n&&(n=o.DEFAULT_RULE_CONFIG),r.contains(this.definedRulesNames,t)){var i={message:a.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:t,grammarName:this.className}),type:o.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t};this.definitionErrors.push(i);}if(this.definedRulesNames.push(t),!this.gastProductionsCache.containsKey(t)&&!this.serializedGrammar){var u=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,u);}var c=this.defineRule(t,e,n);return this[t]=c,c},t.prototype.OVERRIDE_RULE=function(t,e,n){void 0===n&&(n=o.DEFAULT_RULE_CONFIG);var r=[];if(r=r.concat(u.validateRuleIsOverridden(t,this.definedRulesNames,this.className)),this.definitionErrors.push.apply(this.definitionErrors,r),!this.serializedGrammar){var i=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,i);}var a=this.defineRule(t,e,n);return this[t]=a,a},t.prototype.BACKTRACK=function(t,e){return function(){this.isBackTrackingStack.push(1);var n=this.saveRecogState();try{return t.apply(this,e),!0}catch(t){if(i.isRecognitionException(t))return !1;throw t}finally{this.reloadRecogState(n),this.isBackTrackingStack.pop();}}},t.prototype.getGAstProductions=function(){return this.gastProductionsCache},t.prototype.getSerializedGastProductions=function(){return c.serializeGrammar(this.gastProductionsCache.values())},t}();e.RecognizerApi=p;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(9),o=n(6),a=n(12),s=n(13),u=n(3),c=n(25),p=n(2),l=n(7),h=n(4),f=function(){function t(){}return t.prototype.initRecognizerEngine=function(t,e){if(this.className=h.classNameFromInstance(this),this.shortRuleNameToFull=new h.HashTable,this.fullRuleNameToShort=new h.HashTable,this.ruleShortNameIdx=256,this.tokenMatcher=l.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.allRuleNames=[],this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache=new h.HashTable,this.serializedGrammar=r.has(e,\"serializedGrammar\")?e.serializedGrammar:u.DEFAULT_PARSER_CONFIG.serializedGrammar,r.isArray(t)){if(r.isEmpty(t))throw Error(\"A Token Vocabulary cannot be empty.\\n\\tNote that the first argument for the parser constructor\\n\\tis no longer a Token vector (since v4.0).\");if(\"number\"==typeof t[0].startOffset)throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\\tFor Further details.\")}if(r.isArray(t))this.tokensMap=r.reduce(t,function(t,e){return t[p.tokenName(e)]=e,t},{});else if(r.has(t,\"modes\")&&r.every(r.flatten(r.values(t.modes)),l.isTokenType)){var n=r.flatten(r.values(t.modes)),i=r.uniq(n);this.tokensMap=r.reduce(i,function(t,e){return t[p.tokenName(e)]=e,t},{});}else {if(!r.isObject(t))throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");this.tokensMap=r.cloneObj(t);}this.tokensMap.EOF=p.EOF;var o=r.every(r.values(t),function(t){return r.isEmpty(t.categoryMatches)});this.tokenMatcher=o?l.tokenStructuredMatcherNoCategories:l.tokenStructuredMatcher,l.augmentTokenTypes(r.values(this.tokensMap));},t.prototype.defineRule=function(t,e,n){if(this.selfAnalysisDone)throw Error(\"Grammar rule <\"+t+\"> may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");var a,s=r.has(n,\"resyncEnabled\")?n.resyncEnabled:u.DEFAULT_RULE_CONFIG.resyncEnabled,c=r.has(n,\"recoveryValueFunc\")?n.recoveryValueFunc:u.DEFAULT_RULE_CONFIG.recoveryValueFunc,p=this.ruleShortNameIdx<<i.BITS_FOR_METHOD_IDX+i.BITS_FOR_OCCURRENCE_IDX;this.ruleShortNameIdx++,this.shortRuleNameToFull.put(p,t),this.fullRuleNameToShort.put(t,p);return (a=function(n,r){return void 0===n&&(n=0),this.ruleInvocationStateUpdate(p,t,n),function(t){try{return !0===this.outputCst?(e.apply(this,t),this.CST_STACK[this.CST_STACK.length-1]):e.apply(this,t)}catch(t){var n=1===this.RULE_STACK.length,r=s&&!this.isBackTracking()&&this.recoveryEnabled;if(o.isRecognitionException(t)){if(r){var i,a=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(a))return t.resyncedTokens=this.reSyncTo(a),this.outputCst?((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,i):c();throw this.outputCst&&((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,t.partialCstResult=i),t}if(n)return this.moveToTerminatedState(),c();throw t}throw t}finally{this.ruleFinallyStateUpdate();}}.call(this,r)}).ruleName=t,a},t.prototype.optionInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{return this.optionInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.optionInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e);return this.optionInternalLogic(t,e,n)},t.prototype.optionInternalLogic=function(t,e,n){var r,i,o=this,a=this.getLookaheadFuncForOption(n,e);if(void 0!==t.DEF){if(r=t.DEF,void 0!==(i=t.GATE)){var s=a;a=function(){return i.call(o)&&s.call(o)};}}else r=t;if(!0===a.call(this))return r.call(this)},t.prototype.atLeastOneInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.atLeastOneInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t);this.atLeastOneInternalLogic(t,e,n);},t.prototype.atLeastOneInternalLogic=function(t,e,n){var r,o,u=this,c=this.getLookaheadFuncForAtLeastOne(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var p=c;c=function(){return o.call(u)&&p.call(u)};}}else r=e;if(!0!==c.call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY,e.ERR_MSG);for(var l=this.doSingleRepetition(r);!0===c.call(this)&&!0===l;)l=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[t,e],c,i.AT_LEAST_ONE_IDX,t,s.NextTerminalAfterAtLeastOneWalker);},t.prototype.atLeastOneSepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.atLeastOneSepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneSepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t);this.atLeastOneSepFirstInternalLogic(t,e,n);},t.prototype.atLeastOneSepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,u=e.SEP;if(!0!==this.getLookaheadFuncForAtLeastOneSep(n,t).call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,e.ERR_MSG);o.call(this);for(var c=function(){return r.tokenMatcher(r.LA(1),u)};!0===this.tokenMatcher(this.LA(1),u);)this.CONSUME(u),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,u,c,o,s.NextTerminalAfterAtLeastOneSepWalker],c,i.AT_LEAST_ONE_SEP_IDX,t,s.NextTerminalAfterAtLeastOneSepWalker);},t.prototype.manyInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.manyInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manyInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t);return this.manyInternalLogic(t,e,n)},t.prototype.manyInternalLogic=function(t,e,n){var r,o,a=this,u=this.getLookaheadFuncForMany(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var c=u;u=function(){return o.call(a)&&c.call(a)};}}else r=e;for(var p=!0;!0===u.call(this)&&!0===p;)p=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.manyInternal,[t,e],u,i.MANY_IDX,t,s.NextTerminalAfterManyWalker);},t.prototype.manySepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.manySepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manySepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t);this.manySepFirstInternalLogic(t,e,n);},t.prototype.manySepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,a=e.SEP;if(!0===this.getLookaheadFuncForManySep(n,t).call(this)){o.call(this);for(var u=function(){return r.tokenMatcher(r.LA(1),a)};!0===this.tokenMatcher(this.LA(1),a);)this.CONSUME(a),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,a,u,o,s.NextTerminalAfterManySepWalker],u,i.MANY_SEP_IDX,t,s.NextTerminalAfterManySepWalker);}},t.prototype.repetitionSepSecondInternal=function(t,e,n,r,o){for(;n();)this.CONSUME(e),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,e,n,r,o],n,i.AT_LEAST_ONE_SEP_IDX,t,o);},t.prototype.doSingleRepetition=function(t){var e=this.getLexerPosition();return t.call(this),this.getLexerPosition()>e},t.prototype.orInternalNoCst=function(t,e){var n=r.isArray(t)?t:t.DEF,i=this.getLookaheadFuncForOr(e,n).call(this,n);if(void 0!==i)return n[i].ALT.call(this);this.raiseNoAltException(e,t.ERR_MSG);},t.prototype.orInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OR_IDX,e),o=this.nestedRuleBeforeClause(t,n);try{var a=r.isArray(t)?t:t.DEF,s=this.getLookaheadFuncForOr(e,a).call(this,a);if(void 0!==s){var u=a[s],c=this.nestedAltBeforeClause(u,e,i.OR_IDX,s);try{return u.ALT.call(this)}finally{void 0!==c&&this.nestedRuleFinallyClause(c.shortName,c.nestedName);}}this.raiseNoAltException(e,t.ERR_MSG);}finally{void 0!==o&&this.nestedRuleFinallyClause(n,o);}},t.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),0===this.RULE_STACK.length&&!this.isAtEndOfInput()){var t=this.LA(1),e=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:t,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new o.NotAllInputParsedException(e,t));}},t.prototype.subruleInternal=function(t,e,n){var r;try{var i=void 0!==n?n.ARGS:void 0;return r=t.call(this,e,i),this.cstPostNonTerminal(r,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),r}catch(e){throw o.isRecognitionException(e)&&void 0!==e.partialCstResult&&(this.cstPostNonTerminal(e.partialCstResult,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),delete e.partialCstResult),e}},t.prototype.consumeInternal=function(t,e,n){var r;try{var i=this.LA(1);if(!0!==this.tokenMatcher(i,t)){var a=void 0,s=this.LA(0);throw a=void 0!==n&&n.ERR_MSG?n.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:t,actual:i,previous:s,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new o.MismatchedTokenException(a,i,s))}this.consumeToken(),r=i;}catch(n){if(!this.recoveryEnabled||\"MismatchedTokenException\"!==n.name||this.isBackTracking())throw n;var u=this.getFollowsForInRuleRecovery(t,e);try{r=this.tryInRuleRecovery(t,u);}catch(t){throw t.name===c.IN_RULE_RECOVERY_EXCEPTION?n:t}}return this.cstPostTerminal(void 0!==n&&void 0!==n.LABEL?n.LABEL:t.tokenName,r),r},t.prototype.saveRecogState=function(){var t=this.errors,e=r.cloneArr(this.RULE_STACK);return {errors:t,lexerState:this.exportLexerState(),RULE_STACK:e,CST_STACK:this.CST_STACK,LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK}},t.prototype.reloadRecogState=function(t){this.errors=t.errors,this.importLexerState(t.lexerState),this.RULE_STACK=t.RULE_STACK;},t.prototype.ruleInvocationStateUpdate=function(t,e,n){this.RULE_OCCURRENCE_STACK.push(n),this.RULE_STACK.push(t),this.cstInvocationStateUpdate(e,t);},t.prototype.isBackTracking=function(){return !r.isEmpty(this.isBackTrackingStack)},t.prototype.getCurrRuleFullName=function(){var t=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull.get(t)},t.prototype.shortRuleNameToFullName=function(t){return this.shortRuleNameToFull.get(t)},t.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),p.EOF)},t.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[];},t}();e.RecognizerEngine=f;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(6),i=n(0),o=n(12),a=n(3),s=function(){function t(){}return t.prototype.initErrorHandler=function(t){this._errors=[],this.errorMessageProvider=i.defaults(t.errorMessageProvider,a.DEFAULT_PARSER_CONFIG.errorMessageProvider);},t.prototype.SAVE_ERROR=function(t){if(r.isRecognitionException(t))return t.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(t),t;throw Error(\"Trying to save an Error which is not a RecognitionException\")},Object.defineProperty(t.prototype,\"errors\",{get:function(){return i.cloneArr(this._errors)},set:function(t){this._errors=t;},enumerable:!0,configurable:!0}),t.prototype.raiseEarlyExitException=function(t,e,n){for(var i=this.getCurrRuleFullName(),a=this.getGAstProductions().get(i),s=o.getLookaheadPathsForOptionalProd(t,a,e,this.maxLookahead)[0],u=[],c=1;c<this.maxLookahead;c++)u.push(this.LA(c));var p=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:u,previous:this.LA(0),customUserDescription:n,ruleName:i});throw this.SAVE_ERROR(new r.EarlyExitException(p,this.LA(1),this.LA(0)))},t.prototype.raiseNoAltException=function(t,e){for(var n=this.getCurrRuleFullName(),i=this.getGAstProductions().get(n),a=o.getLookaheadPathsForOr(t,i,this.maxLookahead),s=[],u=1;u<=this.maxLookahead;u++)s.push(this.LA(u));var c=this.LA(0),p=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:a,actual:s,previous:c,customUserDescription:e,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new r.NoViableAltException(p,this.LA(1),c))},t}();e.ErrorHandler=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(13),i=n(0),o=function(){function t(){}return t.prototype.initContentAssist=function(){},t.prototype.computeContentAssist=function(t,e){var n=this.gastProductionsCache.get(t);if(i.isUndefined(n))throw Error(\"Rule ->\"+t+\"<- does not exist in this grammar.\");return r.nextPossibleTokensAfter([n],e,this.tokenMatcher,this.maxLookahead)},t.prototype.getNextPossibleTokenTypes=function(t){var e=i.first(t.ruleStack),n=this.getGAstProductions().get(e);return new r.NextAfterTokenWalker(n,t).startWalking()},t}();e.ContentAssist=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(17);e.createSyntaxDiagramsCode=function(t,e){var n=void 0===e?{}:e,i=n.resourceBase,o=void 0===i?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/\":i,a=n.css;return \"\\n\\x3c!-- This is a generated file --\\x3e\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\\n<link rel='stylesheet' href='\"+(void 0===a?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/diagrams.css\":a)+\"'>\\n\\n<script src='\"+o+\"vendor/railroad-diagrams.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_builder.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_behavior.js'><\\/script>\\n<script src='\"+o+'src/main.js\\'><\\/script>\\n\\n<div id=\"diagrams\" align=\"center\"></div>    \\n\\n<script>\\n    window.serializedGrammar = '+JSON.stringify(t,null,\"  \")+';\\n<\\/script>\\n\\n<script>\\n    var diagramsDiv = document.getElementById(\"diagrams\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n<\\/script>\\n'};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(41);e.generateParserFactory=function(t){var e=r.genWrapperFunction({name:t.name,rules:t.rules}),i=new Function(\"tokenVocabulary\",\"config\",\"chevrotain\",e);return function(e){return i(t.tokenVocabulary,e,n(18))}},e.generateParserModule=function(t){return r.genUmdModule({name:t.name,rules:t.rules})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(2),o=n(1),a=\"\\n\";function s(t){return \"\\nfunction \"+t.name+\"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \"+u(t.rules)+\"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\"+t.name+\".prototype = Object.create(chevrotain.CstParser.prototype)\\n\"+t.name+\".prototype.constructor = \"+t.name+\"    \\n    \"}function u(t){return r.map(t,function(t){return c(t,1)}).join(\"\\n\")}function c(t,e){var n=y(e,'$.RULE(\"'+t.name+'\", function() {')+a;return n+=m(t.definition,e+1),n+=y(e+1,\"})\")+a}function p(t,e){var n=i.tokenName(t.terminalType);return y(e,\"$.CONSUME\"+t.idx+\"(this.tokensMap.\"+n+\")\"+a)}function l(t,e){return y(e,\"$.SUBRULE\"+t.idx+\"($.\"+t.nonTerminalName+\")\"+a)}function h(t,e){var n=y(e,\"$.OR\"+t.idx+\"([\")+a;return n+=r.map(t.definition,function(t){return f(t,e+1)}).join(\",\"+a),n+=a+y(e,\"])\"+a)}function f(t,e){var n=y(e,\"{\")+a;return t.name&&(n+=y(e+1,'NAME: \"'+t.name+'\",')+a),n+=y(e+1,\"ALT: function() {\")+a,n+=m(t.definition,e+1),n+=y(e+1,\"}\")+a,n+=y(e,\"}\")}function d(t,e,n){var r=y(n,\"$.\"+(t+e.idx)+\"(\");return e.name||e.separator?(r+=\"{\"+a,e.name&&(r+=y(n+1,'NAME: \"'+e.name+'\"')+\",\"+a),e.separator&&(r+=y(n+1,\"SEP: this.tokensMap.\"+i.tokenName(e.separator))+\",\"+a),r+=\"DEF: \"+E(e.definition,n+2)+a,r+=y(n,\"}\")+a):r+=E(e.definition,n+1),r+=y(n,\")\")+a}function E(t,e){var n=\"function() {\"+a;return n+=m(t,e),n+=y(e,\"}\")+a}function m(t,e){var n=\"\";return r.forEach(t,function(t){n+=function(t,e){if(t instanceof o.NonTerminal)return l(t,e);if(t instanceof o.Option)return d(\"OPTION\",t,e);if(t instanceof o.RepetitionMandatory)return d(\"AT_LEAST_ONE\",t,e);if(t instanceof o.RepetitionMandatoryWithSeparator)return d(\"AT_LEAST_ONE_SEP\",t,e);if(t instanceof o.RepetitionWithSeparator)return d(\"MANY_SEP\",t,e);if(t instanceof o.Repetition)return d(\"MANY\",t,e);if(t instanceof o.Alternation)return h(t,e);if(t instanceof o.Terminal)return p(t,e);if(t instanceof o.Flat)return m(t.definition,e);throw Error(\"non exhaustive match\")}(t,e+1);}),n}function y(t,e){return Array(4*t+1).join(\" \")+e}e.genUmdModule=function(t){return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\"+s(t)+\"\\n    \\nreturn {\\n    \"+t.name+\": \"+t.name+\" \\n}\\n}));\\n\"},e.genWrapperFunction=function(t){return \"    \\n\"+s(t)+\"\\nreturn new \"+t.name+\"(tokenVocabulary, config)    \\n\"},e.genClass=s,e.genAllRules=u,e.genRule=c,e.genTerminal=p,e.genNonTerminal=l,e.genAlternation=h,e.genSingleAlt=f;}])});\nvar chevrotain = window.chevrotain;\n\nvar VRMLLoader = ( function () {\n\n\t// dependency check\n\n\tif ( typeof chevrotain === 'undefined' ) { // eslint-disable-line no-undef\n\n\t\tthrow Error( 'THREE.VRMLLoader: External library chevrotain.min.js required.' );\n\n\t}\n\n\t// class definitions\n\n\tfunction VRMLLoader( manager ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tVRMLLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: VRMLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, path ) {\n\n\t\t\tvar nodeMap = {};\n\n\t\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t\t// create lexer, parser and visitor\n\n\t\t\t\tvar tokenData = createTokens();\n\n\t\t\t\tvar lexer = new VRMLLexer( tokenData.tokens );\n\t\t\t\tvar parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\t\tvar visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t\t// lexing\n\n\t\t\t\tvar lexingResult = lexer.lex( data );\n\t\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t\t// parsing\n\n\t\t\t\tvar cstOutput = parser.vrml();\n\n\t\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t\t}\n\n\t\t\t\t// actions\n\n\t\t\t\tvar ast = visitor.visit( cstOutput );\n\n\t\t\t\treturn ast;\n\n\t\t\t}\n\n\t\t\tfunction createTokens() {\n\n\t\t\t\tvar createToken = chevrotain.createToken; // eslint-disable-line no-undef\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\t\tvar RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\t\tvar Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } );\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\t\tvar nodeTypes = [\n\t\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t\t];\n\n\t\t\t\t//\n\n\t\t\t\tvar Version = createToken( {\n\t\t\t\t\tname: 'Version',\n\t\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar NodeName = createToken( {\n\t\t\t\t\tname: 'NodeName',\n\t\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar DEF = createToken( {\n\t\t\t\t\tname: 'DEF',\n\t\t\t\t\tpattern: /DEF/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar USE = createToken( {\n\t\t\t\t\tname: 'USE',\n\t\t\t\t\tpattern: /USE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar ROUTE = createToken( {\n\t\t\t\t\tname: 'ROUTE',\n\t\t\t\t\tpattern: /ROUTE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar TO = createToken( {\n\t\t\t\t\tname: 'TO',\n\t\t\t\t\tpattern: /TO/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tvar StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/ } );\n\t\t\t\tvar HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\t\tvar NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\t\tvar TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\t\tvar FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\t\tvar NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\t\tvar LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\t\tvar RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\t\tvar LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\t\tvar RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\t\tvar Comment = createToken( {\n\t\t\t\t\tname: 'Comment',\n\t\t\t\t\tpattern: /#.*/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\t\tvar WhiteSpace = createToken( {\n\t\t\t\t\tname: 'WhiteSpace',\n\t\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\tvar tokens = [\n\t\t\t\t\tWhiteSpace,\n\t\t\t\t\t// keywords appear before the Identifier\n\t\t\t\t\tNodeName,\n\t\t\t\t\tDEF,\n\t\t\t\t\tUSE,\n\t\t\t\t\tROUTE,\n\t\t\t\t\tTO,\n\t\t\t\t\tTrueLiteral,\n\t\t\t\t\tFalseLiteral,\n\t\t\t\t\tNullLiteral,\n\t\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\t\tVersion,\n\t\t\t\t\tIdentifier,\n\t\t\t\t\tRouteIdentifier,\n\t\t\t\t\tStringLiteral,\n\t\t\t\t\tHexLiteral,\n\t\t\t\t\tNumberLiteral,\n\t\t\t\t\tLSquare,\n\t\t\t\t\tRSquare,\n\t\t\t\t\tLCurly,\n\t\t\t\t\tRCurly,\n\t\t\t\t\tComment\n\t\t\t\t];\n\n\t\t\t\tvar tokenVocabulary = {};\n\n\t\t\t\tfor ( var i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar token = tokens[ i ];\n\n\t\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t\t}\n\n\t\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t\t}\n\n\n\t\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\t\tfunction VRMLToASTVisitor() {\n\n\t\t\t\t\tBaseVRMLVisitor.call( this );\n\n\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tVRMLToASTVisitor.prototype = Object.assign( Object.create( BaseVRMLVisitor.prototype ), {\n\n\t\t\t\t\tconstructor: VRMLToASTVisitor,\n\n\t\t\t\t\tvrml: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\troutes: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar route = ctx.route[ i ];\n\n\t\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tversion: function ( ctx ) {\n\n\t\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tnode: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar field = ctx.field[ i ];\n\n\t\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// DEF\n\n\t\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfield: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\tvalues: null\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar result;\n\n\t\t\t\t\t\t// SFValue\n\n\t\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// MFValue\n\n\t\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tdef: function ( ctx ) {\n\n\t\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tuse: function ( ctx ) {\n\n\t\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t\t},\n\n\t\t\t\t\tsingleFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tmultiFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\troute: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\t\tvar field = {\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar use = ctx.use[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn field;\n\n\t\t\t\t}\n\n\t\t\t\treturn new VRMLToASTVisitor();\n\n\t\t\t}\n\n\t\t\tfunction parseTree( tree ) {\n\n\t\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\t\tvar nodes = tree.nodes;\n\t\t\t\tvar scene = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ai();\n\n\t\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\n\t\t\t\t\tbuildNodeMap( node );\n\n\t\t\t\t}\n\n\t\t\t\t// second iteration: build nodes\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\tvar object = getNode( node );\n\n\t\t\t\t\tif ( object instanceof _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U ) scene.add( object );\n\n\t\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction buildNodeMap( node ) {\n\n\t\t\t\tif ( node.DEF ) {\n\n\t\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t\t}\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\n\t\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction getNode( node ) {\n\n\t\t\t\t// handle case where a node refers to a different one\n\n\t\t\t\tif ( node.USE ) {\n\n\t\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\t\tnode.build = buildNode( node );\n\n\t\t\t\treturn node.build;\n\n\t\t\t}\n\n\t\t\t// node builder\n\n\t\t\tfunction buildNode( node ) {\n\n\t\t\t\tvar nodeName = node.name;\n\t\t\t\tvar build;\n\n\t\t\t\tswitch ( nodeName ) {\n\n\t\t\t\t\tcase 'Group':\n\t\t\t\t\tcase 'Transform':\n\t\t\t\t\tcase 'Collision':\n\t\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Background':\n\t\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Shape':\n\t\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Appearance':\n\t\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Material':\n\t\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointSet':\n\t\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Box':\n\t\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cone':\n\t\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cylinder':\n\t\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sphere':\n\t\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Extrusion':\n\t\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\tcase 'Coordinate':\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Anchor':\n\t\t\t\t\tcase 'Billboard':\n\n\t\t\t\t\tcase 'Inline':\n\t\t\t\t\tcase 'LOD':\n\t\t\t\t\tcase 'Switch':\n\n\t\t\t\t\tcase 'AudioClip':\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\tcase 'Script':\n\t\t\t\t\tcase 'Sound':\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tcase 'CylinderSensor':\n\t\t\t\t\tcase 'PlaneSensor':\n\t\t\t\t\tcase 'ProximitySensor':\n\t\t\t\t\tcase 'SphereSensor':\n\t\t\t\t\tcase 'TimeSensor':\n\t\t\t\t\tcase 'TouchSensor':\n\t\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\t\tcase 'Text':\n\n\t\t\t\t\tcase 'FontStyle':\n\t\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\t\tcase 'Fog':\n\t\t\t\t\tcase 'NavigationInfo':\n\t\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t\t// node not supported yet\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGroupingNode( node ) {\n\n\t\t\t\tvar object = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\t//\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'children':\n\t\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\tvar axis = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tvar angle = fieldValues[ 3 ];\n\t\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\t\tvar group = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tvar groundAngle, groundColor;\n\t\t\t\tvar skyAngle, skyColor;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar radius = 10000;\n\n\t\t\t\t// sky\n\n\t\t\t\tif ( skyColor ) {\n\n\t\t\t\t\tvar skyGeometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16 );\n\t\t\t\t\tvar skyMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ap, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar sky = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( skyGeometry, skyMaterial );\n\t\t\t\t\tgroup.add( sky );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\n\t\t\t\tif ( groundColor ) {\n\n\t\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\t\tvar groundGeometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\t\tvar groundMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ap, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\t\tvar ground = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( groundGeometry, groundMaterial );\n\t\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// render background group first\n\n\t\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction buildShapeNode( node ) {\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\tvar material = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\t\t\t\tvar geometry;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\t\tvar type = geometry._type;\n\n\t\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\t\tvar pointsMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, pointsMaterial );\n\n\t\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\t\tvar lineMaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, lineMaterial );\n\n\t\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a8 : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\t\tvar material = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\tvar transformData;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tvar materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tvar textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\t// respect VRML lighting model\n\n\t\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply texture transform\n\n\t\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction buildMaterialNode( node ) {\n\n\t\t\t\tvar materialData = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\t\tmaterialData.diffuseColor = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materialData;\n\n\t\t\t}\n\n\t\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\t\tswitch ( textureType ) {\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\t\tvar value = parseInt( hex );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\t\tvar value = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getTextureType( num_components ) {\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch ( num_components ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn type;\n\n\t\t\t}\n\n\t\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'image':\n\t\t\t\t\t\t\tvar width = fieldValues[ 0 ];\n\t\t\t\t\t\t\tvar height = fieldValues[ 1 ];\n\t\t\t\t\t\t\tvar num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\t\tvar useAlpha = ( num_components === 2 || num_components === 4 );\n\t\t\t\t\t\t\tvar textureType = getTextureType( num_components );\n\n\t\t\t\t\t\t\tvar size = ( ( useAlpha === true ) ? 4 : 3 ) * ( width * height );\n\t\t\t\t\t\t\tvar data = new Uint8Array( size );\n\n\t\t\t\t\t\t\tvar color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\t\tfor ( var j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\t\tif ( useAlpha === true ) {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 4;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 3;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttexture = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aq( data, width, height, ( useAlpha === true ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ar : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.R );\n\t\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\tvar url = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\t\tvar transformData = {\n\t\t\t\t\tcenter: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\trotation: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\tscale: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\ttranslation: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a()\n\t\t\t\t};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn transformData;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometricNode( node ) {\n\n\t\t\t\treturn node.fields[ 0 ].values;\n\n\t\t\t}\n\n\t\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\t\tvar worldInfo = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'title':\n\t\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn worldInfo;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\t\tvar color, coord, normal, texCoord;\n\t\t\t\tvar ccw = true, solid = true, creaseAngle = 0;\n\t\t\t\tvar colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\t\tvar colorPerVertex = true, normalPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B(); // handle VRML files with incomplete geometry definition\n\n\t\t\t\t}\n\n\t\t\t\tvar triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\t\tvar positionAttribute;\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\t\t\t\tvar uvAttribute;\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// consider face normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tvar triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( texCoord, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tpositionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t// optional attributes\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\t\tvar color, coord;\n\t\t\t\tvar colorIndex, coordIndex;\n\t\t\t\tvar colorPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build lines\n\n\t\t\t\tvar colorAttribute;\n\n\t\t\t\tvar expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\t\tvar expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\t\tvar flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\tgeometry._type = 'line';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildPointSetNode( node ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar color, coord;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tif ( color ) geometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\tgeometry._type = 'points';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildBoxNode( node ) {\n\n\t\t\t\tvar size = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V( 2, 2, 2 );\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.as( size.x, size.y, size.z );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildConeNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2, openEnded = false;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.at( radius, height, 16, 1, openEnded );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildCylinderNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.au( radius, radius, height, 16, 1 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildSphereNode( node ) {\n\n\t\t\t\tvar radius = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 16, 16 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\t\tvar color;\n\t\t\t\tvar normal;\n\t\t\t\tvar texCoord;\n\t\t\t\tvar height;\n\n\t\t\t\tvar colorPerVertex = true;\n\t\t\t\tvar normalPerVertex = true;\n\t\t\t\tvar solid = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar xDimension = 2;\n\t\t\t\tvar zDimension = 2;\n\t\t\t\tvar xSpacing = 1;\n\t\t\t\tvar zSpacing = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// vertex data\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar colors = [];\n\t\t\t\tvar uvs = [];\n\n\t\t\t\tfor ( var i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\t\tvar index = ( i * xDimension ) + j;\n\n\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\tvar x = xSpacing * i;\n\t\t\t\t\t\tvar y = height[ index ];\n\t\t\t\t\t\tvar z = zSpacing * j;\n\n\t\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normals\n\n\t\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\t\tvar s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\t\tvar t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\t\tvar a = i + j * xDimension;\n\t\t\t\t\t\tvar b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t\t// faces\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar uvAttribute = toNonIndexedAttribute( indices, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\t// color attribute\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolorAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normal attribute\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\t// build geometry\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\t\tvar crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\t\tvar spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\t\tvar scale;\n\t\t\t\tvar orientation;\n\n\t\t\t\tvar beginCap = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar endCap = true;\n\t\t\t\tvar solid = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar spineVector = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar scaling = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tvar axis = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar vertex = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar quaternion = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\t\t\tfor ( var i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\t\tscaling.y = 1;\n\t\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\t\tvar angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\t\tfor ( var k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t\t// scale\n\n\t\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t\t// rotate\n\n\t\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t\t// translate\n\n\t\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar spineCount = spine.length / 3;\n\t\t\t\tvar crossSectionCount = crossSection.length / 2;\n\n\t\t\t\tfor ( var i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\t\tvar a = j + i * crossSectionCount;\n\t\t\t\t\t\tvar b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\t\tvar c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\t\tvar d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// triangulate cap\n\n\t\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\t\tvar contour = [];\n\n\t\t\t\t\tfor ( var i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tcontour.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar faces = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.av.triangulateShape( contour, [] );\n\t\t\t\t\tvar capIndices = [];\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// begin cap\n\n\t\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// end cap\n\n\t\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\t\tvar indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\t// no uvs yet\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\t// helper functions\n\n\t\t\tfunction resolveUSE( identifier ) {\n\n\t\t\t\tvar node = nodeMap[ identifier ];\n\t\t\t\tvar build = getNode( node );\n\n\t\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t\t// any side effects\n\n\t\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t\t}\n\n\t\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = getNode( children[ i ] );\n\n\t\t\t\t\tif ( object instanceof _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U ) owner.add( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t\t// perform a simple triangulation\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ start ];\n\t\t\t\t\tvar i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\t\tvar i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tfunction flattenData( data, index ) {\n\n\t\t\t\tvar flattenData = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\n\t\t\t\t\tvar stride = i1 * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\treturn flattenData;\n\n\t\t\t}\n\n\t\t\tfunction expandLineIndex( index ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\t\t\t\t\tvar i2 = index[ i + 1 ];\n\n\t\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction expandLineData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tvar vA = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vB = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vC = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar uvA = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvB = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvC = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\t\tfor ( var i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( array, itemSize );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( array2, itemSize );\n\n\t\t\t}\n\n\t\t\tvar ab = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar cb = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\t\tvar faces = [];\n\t\t\t\tvar vertexNormals = {};\n\n\t\t\t\t// prepare face and raw vertex normals\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tvar face = new Face( a, b, c );\n\n\t\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t\t// compute vertex normals and build final geometry\n\n\t\t\t\tvar normals = [];\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tvar nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\t\tvar nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\t\tvar nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t}\n\n\t\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\t\tvar normal = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\t\tnormal.copy( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn normal.normalize();\n\n\t\t\t}\n\n\t\t\tfunction toColorArray( colors ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\t\tarray.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Vertically paints the faces interpolating between the\n\t\t\t * specified colors at the specified angels. This is used for the Background\n\t\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t\t *\n\t\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t\t *\n\t\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t\t * is linear along the Y axis in any case.\n\t\t\t *\n\t\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t\t * This is the color of the Zenith (the top of the shape).\n\t\t\t *\n\t\t\t * @param {BufferGeometry} geometry\n\t\t\t * @param {number} radius\n\t\t\t * @param {array} angles\n\t\t\t * @param {array} colors\n\t\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t\t */\n\t\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t\t// compute threshold values\n\n\t\t\t\tvar thresholds = [];\n\t\t\t\tvar startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\t\tvar point = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\t\tthresholds.push( point );\n\n\t\t\t\t}\n\n\t\t\t\t// generate vertex colors\n\n\t\t\t\tvar indices = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar colorAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\t\tvar position = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C();\n\n\t\t\t\tfor ( var i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\t\tvar index = indices.getX( i );\n\t\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\t\tvar thresholdIndexA, thresholdIndexB;\n\t\t\t\t\tvar t = 1;\n\n\t\t\t\t\tfor ( var j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\t\tvar thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\t\tvar thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar colorA = colors[ thresholdIndexA ];\n\t\t\t\t\tvar colorB = colors[ thresholdIndexB ];\n\n\t\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar textureLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t// check version (only 2.0 is supported)\n\n\t\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t\t}\n\n\t\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\t\tvar tree = generateVRMLTree( data );\n\n\t\t\t// parse the tree structure to a three.js scene\n\n\t\t\tvar scene = parseTree( tree );\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t} );\n\n\tfunction VRMLLexer( tokens ) {\n\n\t\tthis.lexer = new chevrotain.Lexer( tokens ); // eslint-disable-line no-undef\n\n\t}\n\n\tVRMLLexer.prototype = {\n\n\t\tconstructor: VRMLLexer,\n\n\t\tlex: function ( inputText ) {\n\n\t\t\tvar lexingResult = this.lexer.tokenize( inputText );\n\n\t\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t\t}\n\n\t\t\treturn lexingResult;\n\n\t\t}\n\n\t};\n\n\tfunction VRMLParser( tokenVocabulary ) {\n\n\t\tchevrotain.Parser.call( this, tokenVocabulary ); // eslint-disable-line no-undef\n\n\t\tvar $ = this;\n\n\t\tvar Version = tokenVocabulary[ 'Version' ];\n\t\tvar LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tvar RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tvar LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tvar RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tvar Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tvar RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tvar StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tvar HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tvar NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tvar TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tvar FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tvar NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tvar DEF = tokenVocabulary[ 'DEF' ];\n\t\tvar USE = tokenVocabulary[ 'USE' ];\n\t\tvar ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tvar TO = tokenVocabulary[ 'TO' ];\n\t\tvar NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n\tVRMLParser.prototype = Object.create( chevrotain.Parser.prototype ); // eslint-disable-line no-undef\n\tVRMLParser.prototype.constructor = VRMLParser;\n\n\tfunction Face( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t}\n\n\tvar TEXTURE_TYPE = {\n\t\tINTENSITY: 1,\n\t\tINTENSITY_ALPHA: 2,\n\t\tRGB: 3,\n\t\tRGBA: 4\n\t};\n\n\treturn VRMLLoader;\n\n} )();\n\nvar PCDLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.littleEndian = true;\n\n};\n\n\nPCDLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PCDLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data, url ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tvar inLength = inData.length;\n\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\tvar inPtr = 0;\n\t\t\tvar outPtr = 0;\n\t\t\tvar ctrl;\n\t\t\tvar len;\n\t\t\tvar ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar PCDheader = {};\n\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tvar sizeSum = 0;\n\n\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\tvar textData = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t// parse header (always ascii format)\n\n\t\tvar PCDheader = parseHeader( textData );\n\n\t\t// parse data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar color = [];\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tvar offset = PCDheader.offset;\n\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tvar material = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t} else {\n\n\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\tvar mesh = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\tname = /([^\\/]*)/.exec( name );\n\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\tmesh.name = name;\n\n\t\treturn mesh;\n\n\t}\n\n} );\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\nvar PLYLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.propertyNameMapping = {};\n\n};\n\nPLYLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PLYLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\tvar element = {};\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tvar lines = body.split( '\\n' );\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tvar element = {};\n\t\t\tvar result, read = 0;\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\tvar result, loc = 0;\n\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tvar text = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\t\t\tvar header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\n*/\nvar gn={},bn=function(n,r,t,e,i){var a=gn[r]||(gn[r]=URL.createObjectURL(new Blob([n],{type:\"text/javascript\"}))),o=new Worker(a);return o.onerror=function(f){return i(f.error,null)},o.onmessage=function(f){return i(null,f.data)},o.postMessage(t,e),o},A=Uint8Array,R=Uint16Array,nr=Uint32Array,ur=new A([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),lr=new A([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Mr=new A([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),wn=function(n,r){for(var t=new R(31),e=0;e<31;++e)t[e]=r+=1<<n[e-1];for(var i=new nr(t[30]),e=1;e<30;++e)for(var a=t[e];a<t[e+1];++a)i[a]=a-t[e]<<5|e;return [t,i]},yn=wn(ur,2),Nr=yn[0],Ir=yn[1];Nr[28]=258,Ir[258]=28;for(var mn=wn(lr,0),zn=mn[0],Qr=mn[1],Ur=new R(32768),T=0;T<32768;++T){var ir=(T&43690)>>>1|(T&21845)<<1;ir=(ir&52428)>>>2|(ir&13107)<<2,ir=(ir&61680)>>>4|(ir&3855)<<4,Ur[T]=((ir&65280)>>>8|(ir&255)<<8)>>>1;}for(var V=function(n,r,t){for(var e=n.length,i=0,a=new R(r);i<e;++i)++a[n[i]-1];var o=new R(r);for(i=0;i<r;++i)o[i]=o[i-1]+a[i-1]<<1;var f;if(t){f=new R(1<<r);var h=15-r;for(i=0;i<e;++i)if(n[i])for(var s=i<<4|n[i],u=r-n[i],l=o[n[i]-1]++<<u,p=l|(1<<u)-1;l<=p;++l)f[Ur[l]>>>h]=s;}else for(f=new R(e),i=0;i<e;++i)n[i]&&(f[i]=Ur[o[n[i]-1]++]>>>15-n[i]);return f},tr=new A(288),T=0;T<144;++T)tr[T]=8;for(var T=144;T<256;++T)tr[T]=9;for(var T=256;T<280;++T)tr[T]=7;for(var T=280;T<288;++T)tr[T]=8;for(var vr=new A(32),T=0;T<32;++T)vr[T]=5;var xn=V(tr,9,0),An=V(tr,9,1),Dn=V(vr,5,0),Mn=V(vr,5,1),Gr=function(n){for(var r=n[0],t=1;t<n.length;++t)n[t]>r&&(r=n[t]);return r},X=function(n,r,t){var e=r/8|0;return (n[e]|n[e+1]<<8)>>(r&7)&t},Or=function(n,r){var t=r/8|0;return (n[t]|n[t+1]<<8|n[t+2]<<16)>>(r&7)},Cr=function(n){return (n/8|0)+(n&7&&1)},$=function(n,r,t){(r==null||r<0)&&(r=0),(t==null||t>n.length)&&(t=n.length);var e=new(n instanceof R?R:n instanceof nr?nr:A)(t-r);return e.set(n.subarray(r,t)),e},Fr=function(n,r,t){var e=n.length;if(!e||t&&!t.l&&e<5)return r||new A(0);var i=!r||t,a=!t||t.i;t||(t={}),r||(r=new A(e*3));var o=function(Tr){var Dr=r.length;if(Tr>Dr){var hr=new A(Math.max(Dr*2,Tr));hr.set(r),r=hr;}},f=t.f||0,h=t.p||0,s=t.b||0,u=t.l,l=t.d,p=t.m,y=t.n,c=e*8;do{if(!u){t.f=f=X(n,h,1);var g=X(n,h+1,3);if(h+=3,g)if(g==1)u=An,l=Mn,p=9,y=5;else if(g==2){var m=X(n,h,31)+257,D=X(n,h+10,15)+4,C=m+X(n,h+5,31)+1;h+=14;for(var U=new A(C),x=new A(19),v=0;v<D;++v)x[Mr[v]]=X(n,h+v*3,7);h+=D*3;var E=Gr(x),S=(1<<E)-1;if(!a&&h+C*(E+7)>c)break;for(var K=V(x,E,1),v=0;v<C;){var I=K[X(n,h,S)];h+=I&15;var w=I>>>4;if(w<16)U[v++]=w;else {var Z=0,B=0;for(w==16?(B=3+X(n,h,3),h+=2,Z=U[v-1]):w==17?(B=3+X(n,h,7),h+=3):w==18&&(B=11+X(n,h,127),h+=7);B--;)U[v++]=Z;}}var G=U.subarray(0,m),k=U.subarray(m);p=Gr(G),y=Gr(k),u=V(G,p,1),l=V(k,y,1);}else throw \"invalid block type\";else {var w=Cr(h)+4,M=n[w-4]|n[w-3]<<8,z=w+M;if(z>e){if(a)throw \"unexpected EOF\";break}i&&o(s+M),r.set(n.subarray(w,z),s),t.b=s+=M,t.p=h=z*8;continue}if(h>c)throw \"unexpected EOF\"}i&&o(s+131072);for(var O=(1<<p)-1,H=(1<<y)-1,N=p+y+18;a||h+N<c;){var Z=u[Or(n,h)&O],Q=Z>>>4;if(h+=Z&15,h>c)throw \"unexpected EOF\";if(!Z)throw \"invalid length/literal\";if(Q<256)r[s++]=Q;else if(Q==256){u=null;break}else {var W=Q-254;if(Q>264){var v=Q-257,d=ur[v];W=X(n,h,(1<<d)-1)+Nr[v],h+=d;}var _=l[Or(n,h)&H],j=_>>>4;if(!_)throw \"invalid distance\";h+=_&15;var k=zn[j];if(j>3){var d=lr[j];k+=Or(n,h)&(1<<d)-1,h+=d;}if(h>c)throw \"unexpected EOF\";i&&o(s+131072);for(var q=s+W;s<q;s+=4)r[s]=r[s-k],r[s+1]=r[s+1-k],r[s+2]=r[s+2-k],r[s+3]=r[s+3-k];s=q;}}t.l=u,t.p=h,t.b=s,u&&(f=1,t.m=p,t.d=l,t.n=y);}while(!f);return s==r.length?r:$(r,0,s)},b=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8;},cr=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8,n[e+2]|=t>>>16;},Er=function(n,r){for(var t=[],e=0;e<n.length;++e)n[e]&&t.push({s:e,f:n[e]});var i=t.length,a=t.slice();if(!i)return [er,0];if(i==1){var o=new A(t[0].s+1);return o[t[0].s]=1,[o,1]}t.sort(function(C,U){return C.f-U.f}),t.push({s:-1,f:25001});var f=t[0],h=t[1],s=0,u=1,l=2;for(t[0]={s:-1,f:f.f+h.f,l:f,r:h};u!=i-1;)f=t[t[s].f<t[l].f?s++:l++],h=t[s!=u&&t[s].f<t[l].f?s++:l++],t[u++]={s:-1,f:f.f+h.f,l:f,r:h};for(var p=a[0].s,e=1;e<i;++e)a[e].s>p&&(p=a[e].s);var y=new R(p+1),c=Pr(t[u-1],y,0);if(c>r){var e=0,g=0,w=c-r,M=1<<w;for(a.sort(function(U,x){return y[x.s]-y[U.s]||U.f-x.f});e<i;++e){var z=a[e].s;if(y[z]>r)g+=M-(1<<c-y[z]),y[z]=r;else break}for(g>>>=w;g>0;){var m=a[e].s;y[m]<r?g-=1<<r-y[m]++-1:++e;}for(;e>=0&&g;--e){var D=a[e].s;y[D]==r&&(--y[D],++g);}c=r;}return [new A(y),c]},Pr=function(n,r,t){return n.s==-1?Math.max(Pr(n.l,r,t+1),Pr(n.r,r,t+1)):r[n.s]=t},Vr=function(n){for(var r=n.length;r&&!n[--r];);for(var t=new R(++r),e=0,i=n[0],a=1,o=function(h){t[e++]=h;},f=1;f<=r;++f)if(n[f]==i&&f!=r)++a;else {if(!i&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0);}else if(a>3){for(o(i),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0);}for(;a--;)o(i);a=1,i=n[f];}return [t.subarray(0,e),r]},pr=function(n,r){for(var t=0,e=0;e<r.length;++e)t+=n[e]*r[e];return t},Sr=function(n,r,t){var e=t.length,i=Cr(r+2);n[i]=e&255,n[i+1]=e>>>8,n[i+2]=n[i]^255,n[i+3]=n[i+1]^255;for(var a=0;a<e;++a)n[i+a+4]=t[a];return (i+4+e)*8},Xr=function(n,r,t,e,i,a,o,f,h,s,u){b(r,u++,t),++i[256];for(var l=Er(i,15),p=l[0],y=l[1],c=Er(a,15),g=c[0],w=c[1],M=Vr(p),z=M[0],m=M[1],D=Vr(g),C=D[0],U=D[1],x=new R(19),v=0;v<z.length;++v)x[z[v]&31]++;for(var v=0;v<C.length;++v)x[C[v]&31]++;for(var E=Er(x,7),S=E[0],K=E[1],I=19;I>4&&!S[Mr[I-1]];--I);var Z=s+5<<3,B=pr(i,tr)+pr(a,vr)+o,G=pr(i,p)+pr(a,g)+o+14+3*I+pr(x,S)+(2*x[16]+3*x[17]+7*x[18]);if(Z<=B&&Z<=G)return Sr(r,u,n.subarray(h,h+s));var k,O,H,N;if(b(r,u,1+(G<B)),u+=2,G<B){k=V(p,y,0),O=p,H=V(g,w,0),N=g;var Q=V(S,K,0);b(r,u,m-257),b(r,u+5,U-1),b(r,u+10,I-4),u+=14;for(var v=0;v<I;++v)b(r,u+3*v,S[Mr[v]]);u+=3*I;for(var W=[z,C],d=0;d<2;++d)for(var _=W[d],v=0;v<_.length;++v){var j=_[v]&31;b(r,u,Q[j]),u+=S[j],j>15&&(b(r,u,_[v]>>>5&127),u+=_[v]>>>12);}}else k=xn,O=tr,H=Dn,N=vr;for(var v=0;v<f;++v)if(e[v]>255){var j=e[v]>>>18&31;cr(r,u,k[j+257]),u+=O[j+257],j>7&&(b(r,u,e[v]>>>23&31),u+=ur[j]);var q=e[v]&31;cr(r,u,H[q]),u+=N[q],q>3&&(cr(r,u,e[v]>>>5&8191),u+=lr[q]);}else cr(r,u,k[e[v]]),u+=O[e[v]];return cr(r,u,k[256]),u+O[256]},Un=new nr([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),er=new A(0),Cn=function(n,r,t,e,i,a){var o=n.length,f=new A(e+o+5*(1+Math.ceil(o/7e3))+i),h=f.subarray(e,f.length-i),s=0;if(!r||o<8)for(var u=0;u<=o;u+=65535){var l=u+65535;l<o?s=Sr(h,s,n.subarray(u,l)):(h[u]=a,s=Sr(h,s,n.subarray(u,o)));}else {for(var p=Un[r-1],y=p>>>13,c=p&8191,g=(1<<t)-1,w=new R(32768),M=new R(g+1),z=Math.ceil(t/3),m=2*z,D=function(Kr){return (n[Kr]^n[Kr+1]<<z^n[Kr+2]<<m)&g},C=new nr(25e3),U=new R(288),x=new R(32),v=0,E=0,u=0,S=0,K=0,I=0;u<o;++u){var Z=D(u),B=u&32767,G=M[Z];if(w[B]=G,M[Z]=B,K<=u){var k=o-u;if((v>7e3||S>24576)&&k>423){s=Xr(n,h,0,C,U,x,E,S,I,u-I,s),S=v=E=0,I=u;for(var O=0;O<286;++O)U[O]=0;for(var O=0;O<30;++O)x[O]=0;}var H=2,N=0,Q=c,W=B-G&32767;if(k>2&&Z==D(u-W))for(var d=Math.min(y,k)-1,_=Math.min(32767,u),j=Math.min(258,k);W<=_&&--Q&&B!=G;){if(n[u+H]==n[u+H-W]){for(var q=0;q<j&&n[u+q]==n[u+q-W];++q);if(q>H){if(H=q,N=W,q>d)break;for(var Tr=Math.min(W,q-2),Dr=0,O=0;O<Tr;++O){var hr=u-W+O+32768&32767,_n=w[hr],vn=hr-_n+32768&32767;vn>Dr&&(Dr=vn,G=hr);}}}B=G,G=w[B],W+=B-G+32768&32767;}if(N){C[S++]=268435456|Ir[H]<<18|Qr[N];var cn=Ir[H]&31,pn=Qr[N]&31;E+=ur[cn]+lr[pn],++U[257+cn],++x[pn],K=u+H,++v;}else C[S++]=n[u],++U[n[u]];}}s=Xr(n,h,a,C,U,x,E,S,I,u-I,s),!a&&s&7&&(s=Sr(h,s+1,er));}return $(f,0,e+Cr(s)+i)},Fn=function(){for(var n=new nr(256),r=0;r<256;++r){for(var t=r,e=9;--e;)t=(t&1&&3988292384)^t>>>1;n[r]=t;}return n}(),gr=function(){var n=-1;return {p:function(r){for(var t=n,e=0;e<r.length;++e)t=Fn[t&255^r[e]]^t>>>8;n=t;},d:function(){return ~n}}},$r=function(){var n=1,r=0;return {p:function(t){for(var e=n,i=r,a=t.length,o=0;o!=a;){for(var f=Math.min(o+2655,a);o<f;++o)i+=e+=t[o];e=(e&65535)+15*(e>>16),i=(i&65535)+15*(i>>16);}n=e,r=i;},d:function(){return n%=65521,r%=65521,(n>>>8<<16|(r&255)<<8|r>>>8)+((n&255)<<23)*2}}},sr=function(n,r,t,e,i){return Cn(n,r.level==null?6:r.level,r.mem==null?Math.ceil(Math.max(8,Math.min(13,Math.log(n.length)))*1.5):12+r.mem,t,e,!i)},Zr=function(n,r){var t={};for(var e in n)t[e]=n[e];for(var e in r)t[e]=r[e];return t},Sn=function(n,r,t){for(var e=n(),i=n.toString(),a=i.slice(i.indexOf(\"[\")+1,i.lastIndexOf(\"]\")).replace(/ /g,\"\").split(\",\"),o=0;o<e.length;++o){var f=e[o],h=a[o];if(typeof f==\"function\"){r+=\";\"+h+\"=\";var s=f.toString();if(f.prototype)if(s.indexOf(\"[native code]\")!=-1){var u=s.indexOf(\" \",8)+1;r+=s.slice(u,s.indexOf(\"(\",u));}else {r+=s;for(var l in f.prototype)r+=\";\"+h+\".prototype.\"+l+\"=\"+f.prototype[l].toString();}else r+=s;}else t[h]=f;}return [r,t]},Rr=[],rt=function(n){var r=[];for(var t in n)(n[t]instanceof A||n[t]instanceof R||n[t]instanceof nr)&&r.push((n[t]=new n[t].constructor(n[t])).buffer);return r},Zn=function(n,r,t,e){var i;if(!Rr[t]){for(var a=\"\",o={},f=n.length-1,h=0;h<f;++h)i=Sn(n[h],a,o),a=i[0],o=i[1];Rr[t]=Sn(n[f],a,o);}var s=Zr({},Rr[t][1]);return bn(Rr[t][0]+\";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\"+r.toString()+\"}\",t,s,rt(s),e)},wr=function(){return [A,R,nr,ur,lr,Mr,Nr,zn,An,Mn,Ur,V,Gr,X,Or,Cr,$,Fr,xr,ar,Lr]},yr=function(){return [A,R,nr,ur,lr,Mr,Ir,Qr,xn,tr,Dn,vr,Ur,Un,er,V,b,cr,Er,Pr,Vr,pr,Sr,Xr,Cr,$,Cn,sr,kr,ar]},kn=function(){return [_r,rn,F,gr,Fn]},Bn=function(){return [br,Gn]},Tn=function(){return [nn,F,$r]},In=function(){return [On]},ar=function(n){return postMessage(n,[n.buffer])},Lr=function(n){return n&&n.size&&new A(n.size)},mr=function(n,r,t,e,i,a){var o=Zn(t,e,i,function(f,h){o.terminate(),a(f,h);});return o.postMessage([n,r],r.consume?[n.buffer]:[]),function(){o.terminate();}},L=function(n){return n.ondata=function(r,t){return postMessage([r,t],[r.buffer])},function(r){return n.push(r.data[0],r.data[1])}},zr=function(n,r,t,e,i){var a,o=Zn(n,e,i,function(f,h){f?(o.terminate(),r.ondata.call(r,f)):(h[1]&&o.terminate(),r.ondata.call(r,f,h[0],h[1]));});o.postMessage(t),r.push=function(f,h){if(a)throw \"stream finished\";if(!r.ondata)throw \"no stream handler\";o.postMessage([f,a=h],[f.buffer]);},r.terminate=function(){o.terminate();};},Y=function(n,r){return n[r]|n[r+1]<<8},P=function(n,r){return (n[r]|n[r+1]<<8|n[r+2]<<16)+(n[r+3]<<23)*2},dr=function(n,r){return P(n,r)|P(n,r)*4294967296},F=function(n,r,t){for(;t;++r)n[r]=t,t>>>=8;},_r=function(n,r){var t=r.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=r.level<2?4:r.level==9?2:0,n[9]=3,r.mtime!=0&&F(n,4,Math.floor(new Date(r.mtime||Date.now())/1e3)),t){n[3]=8;for(var e=0;e<=t.length;++e)n[e+10]=t.charCodeAt(e);}},br=function(n){if(n[0]!=31||n[1]!=139||n[2]!=8)throw \"invalid gzip data\";var r=n[3],t=10;r&4&&(t+=n[10]|(n[11]<<8)+2);for(var e=(r>>3&1)+(r>>4&1);e>0;e-=!n[t++]);return t+(r&2)},Gn=function(n){var r=n.length;return (n[r-4]|n[r-3]<<8|n[r-2]<<16)+2*(n[r-1]<<23)},rn=function(n){return 10+(n.filename&&n.filename.length+1||0)},nn=function(n,r){var t=r.level,e=t==0?0:t<6?1:t==9?3:2;n[0]=120,n[1]=e<<6|(e?32-2*e:1);},On=function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw \"invalid zlib data\";if(n[1]&32)throw \"invalid zlib data: preset dictionaries not supported\"};function tn(n,r){return !r&&typeof n==\"function\"&&(r=n,n={}),this.ondata=r,n}var rr=function(){function n(r,t){!t&&typeof r==\"function\"&&(t=r,r={}),this.ondata=t,this.o=r||{};}return n.prototype.p=function(r,t){this.ondata(sr(r,this.o,0,0,!t),t);},n.prototype.push=function(r,t){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";this.d=t,this.p(r,t||!1);},n}(),En=function(){function n(r,t){zr([yr,function(){return [L,rr]}],this,tn.call(this,r,t),function(e){var i=new rr(e.data);onmessage=L(i);},6);}return n}();function Pn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr],function(e){return ar(kr(e.data[0],e.data[1]))},0,t)}function kr(n,r){return sr(n,r||{},0,0)}var J=function(){function n(r){this.s={},this.p=new A(0),this.ondata=r;}return n.prototype.e=function(r){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";var t=this.p.length,e=new A(t+r.length);e.set(this.p),e.set(r,t),this.p=e;},n.prototype.c=function(r){this.d=this.s.i=r||!1;var t=this.s.b,e=Fr(this.p,this.o,this.s);this.ondata($(e,t,this.s.b),this.d),this.o=$(e,this.s.b-32768),this.s.b=this.o.length,this.p=$(this.p,this.s.p/8|0),this.s.p&=7;},n.prototype.push=function(r,t){this.e(r),this.c(t);},n}(),en=function(){function n(r){this.ondata=r,zr([wr,function(){return [L,J]}],this,0,function(){var t=new J;onmessage=L(t);},7);}return n}();function an(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr],function(e){return ar(xr(e.data[0],Lr(e.data[1])))},1,t)}function xr(n,r){return Fr(n,r)}var qr=function(){function n(r,t){this.c=gr(),this.l=0,this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r),this.l+=r.length;var e=sr(r,this.o,this.v&&rn(this.o),t&&8,!t);this.v&&(_r(e,this.o),this.v=0),t&&(F(e,e.length-8,this.c.d()),F(e,e.length-4,this.l)),this.ondata(e,t);},n}(),Rn=function(){function n(r,t){zr([yr,kn,function(){return [L,rr,qr]}],this,tn.call(this,r,t),function(e){var i=new qr(e.data);onmessage=L(i);},8);}return n}();function qn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,kn,function(){return [Hr]}],function(e){return ar(Hr(e.data[0],e.data[1]))},2,t)}function Hr(n,r){r||(r={});var t=gr(),e=n.length;t.p(n);var i=sr(n,r,rn(r),8),a=i.length;return _r(i,r),F(i,a-8,t.d()),F(i,a-4,e),i}var Wr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){var e=this.p.length>3?br(this.p):4;if(e>=this.p.length&&!t)return;this.p=this.p.subarray(e),this.v=0;}if(t){if(this.p.length<8)throw \"invalid gzip stream\";this.p=this.p.subarray(0,-8);}J.prototype.c.call(this,t);},n}(),Hn=function(){function n(r){this.ondata=r,zr([wr,Bn,function(){return [L,J,Wr]}],this,0,function(){var t=new Wr;onmessage=L(t);},9);}return n}();function Wn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,Bn,function(){return [Yr]}],function(e){return ar(Yr(e.data[0]))},3,t)}function Yr(n,r){return Fr(n.subarray(br(n),-8),r||new A(Gn(n)))}var on=function(){function n(r,t){this.c=$r(),this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r);var e=sr(r,this.o,this.v&&2,t&&4,!t);this.v&&(nn(e,this.o),this.v=0),t&&F(e,e.length-4,this.c.d()),this.ondata(e,t);},n}(),nt=function(){function n(r,t){zr([yr,Tn,function(){return [L,rr,on]}],this,tn.call(this,r,t),function(e){var i=new on(e.data);onmessage=L(i);},10);}return n}();function tt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,Tn,function(){return [fn]}],function(e){return ar(fn(e.data[0],e.data[1]))},4,t)}function fn(n,r){r||(r={});var t=$r();t.p(n);var e=sr(n,r,2,4);return nn(e,r),F(e,e.length-4,t.d()),e}var jr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0;}if(t){if(this.p.length<4)throw \"invalid zlib stream\";this.p=this.p.subarray(0,-4);}J.prototype.c.call(this,t);},n}(),Yn=function(){function n(r){this.ondata=r,zr([wr,In,function(){return [L,J,jr]}],this,0,function(){var t=new jr;onmessage=L(t);},11);}return n}();function jn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,In,function(){return [Jr]}],function(e){return ar(Jr(e.data[0],Lr(e.data[1])))},5,t)}function Jr(n,r){return Fr((On(n),n.subarray(2,-4)),r)}var Jn=function(){function n(r){this.G=Wr,this.I=J,this.Z=jr,this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no stream handler\";if(this.s)this.s.push(r,t);else {if(this.p&&this.p.length){var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);}else this.p=r;if(this.p.length>2){var i=this,a=function(){i.ondata.apply(i,arguments);};this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(a):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(a):new this.Z(a),this.s.push(this.p,t),this.p=null;}}},n}(),et=function(){function n(r){this.G=Hn,this.I=en,this.Z=Yn,this.ondata=r;}return n.prototype.push=function(r,t){Jn.prototype.push.call(this,r,t);},n}();function it(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return n[0]==31&&n[1]==139&&n[2]==8?Wn(n,r,t):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?an(n,r,t):jn(n,r,t)}function at(n,r){return n[0]==31&&n[1]==139&&n[2]==8?Yr(n,r):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?xr(n,r):Jr(n,r)}var sn=function(n,r,t,e){for(var i in n){var a=n[i],o=r+i;a instanceof A?t[o]=[a,e]:Array.isArray(a)?t[o]=[a[0],Zr(e,a[1])]:sn(a,o+\"/\",t,e);}},Kn=typeof TextEncoder!=\"undefined\"&&new TextEncoder,hn=typeof TextDecoder!=\"undefined\"&&new TextDecoder,Nn=0;try{hn.decode(er,{stream:!0}),Nn=1;}catch(n){}var Qn=function(n){for(var r=\"\",t=0;;){var e=n[t++],i=(e>127)+(e>223)+(e>239);if(t+i>n.length)return [r,$(n,t-1)];i?i==3?(e=((e&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,r+=String.fromCharCode(55296|e>>10,56320|e&1023)):i&1?r+=String.fromCharCode((e&31)<<6|n[t++]&63):r+=String.fromCharCode((e&15)<<12|(n[t++]&63)<<6|n[t++]&63):r+=String.fromCharCode(e);}},ot=function(){function n(r){this.ondata=r,Nn?this.t=new TextDecoder:this.p=er;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";if(t||(t=!1),this.t)return this.ondata(this.t.decode(r,{stream:!t}),t);var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);var i=Qn(e),a=i[0],o=i[1];if(t&&o.length)throw \"invalid utf-8 data\";this.p=o,this.ondata(a,t);},n}(),ft=function(){function n(r){this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";this.ondata(or(r),t||!1);},n}();function or(n,r){if(r){for(var t=new A(n.length),e=0;e<n.length;++e)t[e]=n.charCodeAt(e);return t}if(Kn)return Kn.encode(n);for(var i=n.length,a=new A(n.length+(n.length>>1)),o=0,f=function(u){a[o++]=u;},e=0;e<i;++e){if(o+5>a.length){var h=new A(o+8+(i-e<<1));h.set(a),a=h;}var s=n.charCodeAt(e);s<128||r?f(s):s<2048?(f(192|s>>>6),f(128|s&63)):s>55295&&s<57344?(s=65536+(s&1023<<10)|n.charCodeAt(++e)&1023,f(240|s>>>18),f(128|s>>>12&63),f(128|s>>>6&63),f(128|s&63)):(f(224|s>>>12),f(128|s>>>6&63),f(128|s&63));}return $(a,0,o)}function un(n,r){if(r){for(var t=\"\",e=0;e<n.length;e+=16384)t+=String.fromCharCode.apply(null,n.subarray(e,e+16384));return t}else {if(hn)return hn.decode(n);var i=Qn(n),a=i[0],o=i[1];if(o.length)throw \"invalid utf-8 data\";return a}}var Vn=function(n){return n==1?3:n<6?2:n==9?1:0},Xn=function(n,r){return r+30+Y(n,r+26)+Y(n,r+28)},$n=function(n,r,t){var e=Y(n,r+28),i=un(n.subarray(r+46,r+46+e),!(Y(n,r+8)&2048)),a=r+46+e,o=P(n,r+20),f=t&&o==4294967295?Ln(n,a):[o,P(n,r+24),P(n,r+42)],h=f[0],s=f[1],u=f[2];return [Y(n,r+10),h,s,i,a+Y(n,r+30)+Y(n,r+32),u]},Ln=function(n,r){for(;Y(n,r)!=1;r+=4+Y(n,r+2));return [dr(n,r+12),dr(n,r+4),dr(n,r+20)]},fr=function(n){var r=0;if(n)for(var t in n){var e=n[t].length;if(e>65535)throw \"extra field too long\";r+=e+4;}return r},Ar=function(n,r,t,e,i,a,o,f){var h=e.length,s=t.extra,u=f&&f.length,l=fr(s);F(n,r,o!=null?33639248:67324752),r+=4,o!=null&&(n[r++]=20,n[r++]=t.os),n[r]=20,r+=2,n[r++]=t.flag<<1|(a==null&&8),n[r++]=i&&8,n[r++]=t.compression&255,n[r++]=t.compression>>8;var p=new Date(t.mtime==null?Date.now():t.mtime),y=p.getFullYear()-1980;if(y<0||y>119)throw \"date not in range 1980-2099\";if(F(n,r,(y<<24)*2|p.getMonth()+1<<21|p.getDate()<<16|p.getHours()<<11|p.getMinutes()<<5|p.getSeconds()>>>1),r+=4,a!=null&&(F(n,r,t.crc),F(n,r+4,a),F(n,r+8,t.size)),F(n,r+12,h),F(n,r+14,l),r+=16,o!=null&&(F(n,r,u),F(n,r+6,t.attrs),F(n,r+10,o),r+=14),n.set(e,r),r+=h,l)for(var c in s){var g=s[c],w=g.length;F(n,r,+c),F(n,r+2,w),n.set(g,r+4),r+=4+w;}return u&&(n.set(f,r),r+=u),r},ln=function(n,r,t,e,i){F(n,r,101010256),F(n,r+8,t),F(n,r+10,t),F(n,r+12,e),F(n,r+16,i);},Br=function(){function n(r){this.filename=r,this.c=gr(),this.size=0,this.compression=0;}return n.prototype.process=function(r,t){this.ondata(null,r,t);},n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback - add to ZIP archive before pushing\";this.c.p(r),this.size+=r.length,t&&(this.crc=this.c.d()),this.process(r,t||!1);},n}(),st=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new rr(t,function(i,a){e.ondata(null,i,a);}),this.compression=8,this.flag=Vn(t.level);}return n.prototype.process=function(r,t){try{this.d.push(r,t);}catch(e){this.ondata(e,null,t);}},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ht=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new En(t,function(i,a,o){e.ondata(i,a,o);}),this.compression=8,this.flag=Vn(t.level),this.terminate=this.d.terminate;}return n.prototype.process=function(r,t){this.d.push(r,t);},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ut=function(){function n(r){this.ondata=r,this.u=[],this.d=1;}return n.prototype.add=function(r){var t=this;if(this.d&2)throw \"stream finished\";var e=or(r.filename),i=e.length,a=r.comment,o=a&&or(a),f=i!=r.filename.length||o&&a.length!=o.length,h=i+fr(r.extra)+30;if(i>65535)throw \"filename too long\";var s=new A(h);Ar(s,0,r,e,f);var u=[s],l=function(){for(var w=0,M=u;w<M.length;w++){var z=M[w];t.ondata(null,z,!1);}u=[];},p=this.d;this.d=0;var y=this.u.length,c=Zr(r,{f:e,u:f,o,t:function(){r.terminate&&r.terminate();},r:function(){if(l(),p){var w=t.u[y+1];w?w.r():t.d=1;}p=1;}}),g=0;r.ondata=function(w,M,z){if(w)t.ondata(w,M,z),t.terminate();else if(g+=M.length,u.push(M),z){var m=new A(16);F(m,0,134695760),F(m,4,r.crc),F(m,8,g),F(m,12,r.size),u.push(m),c.c=g,c.b=h+g+16,c.crc=r.crc,c.size=r.size,p&&c.r(),p=1;}else p&&l();},this.u.push(c);},n.prototype.end=function(){var r=this;if(this.d&2)throw this.d&1?\"stream finishing\":\"stream finished\";this.d?this.e():this.u.push({r:function(){if(!(r.d&1))return;r.u.splice(-1,1),r.e();},t:function(){}}),this.d=3;},n.prototype.e=function(){for(var r=0,t=0,e=0,i=0,a=this.u;i<a.length;i++){var o=a[i];e+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0);}for(var f=new A(e+22),h=0,s=this.u;h<s.length;h++){var o=s[h];Ar(f,r,o,o.f,o.u,o.c,t,o.o),r+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0),t+=o.b;}ln(f,r,this.u.length,e,t),this.ondata(null,f,!0),this.d=2;},n.prototype.terminate=function(){for(var r=0,t=this.u;r<t.length;r++){var e=t[r];e.t();}this.d=2;},n}();function lt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";var e={};sn(n,\"\",e,r);var i=Object.keys(e),a=i.length,o=0,f=0,h=a,s=new Array(a),u=[],l=function(){for(var g=0;g<u.length;++g)u[g]();},p=function(){var g=new A(f+22),w=o,M=f-o;f=0;for(var z=0;z<h;++z){var m=s[z];try{var D=m.c.length;Ar(g,f,m,m.f,m.u,D);var C=30+m.f.length+fr(m.extra),U=f+C;g.set(m.c,U),Ar(g,o,m,m.f,m.u,D,f,m.m),o+=16+C+(m.m?m.m.length:0),f=U+D;}catch(x){return t(x,null)}}ln(g,o,s.length,M,w),t(null,g);};a||p();for(var y=function(g){var w=i[g],M=e[w],z=M[0],m=M[1],D=gr(),C=z.length;D.p(z);var U=or(w),x=U.length,v=m.comment,E=v&&or(v),S=E&&E.length,K=fr(m.extra),I=m.level==0?0:8,Z=function(B,G){if(B)l(),t(B,null);else {var k=G.length;s[g]=Zr(m,{size:C,crc:D.d(),c:G,f:U,m:E,u:x!=w.length||E&&v.length!=S,compression:I}),o+=30+x+K+k,f+=76+2*(x+K)+(S||0)+k,--a||p();}};if(x>65535&&Z(\"filename too long\",null),!I)Z(null,z);else if(C<16e4)try{Z(null,kr(z,m));}catch(B){Z(B,null);}else u.push(Pn(z,m,Z));},c=0;c<h;++c)y(c);return l}function vt(n,r){r||(r={});var t={},e=[];sn(n,\"\",t,r);var i=0,a=0;for(var o in t){var f=t[o],h=f[0],s=f[1],u=s.level==0?0:8,l=or(o),p=l.length,y=s.comment,c=y&&or(y),g=c&&c.length,w=fr(s.extra);if(p>65535)throw \"filename too long\";var M=u?kr(h,s):h,z=M.length,m=gr();m.p(h),e.push(Zr(s,{size:h.length,crc:m.d(),c:M,f:l,m:c,u:p!=o.length||c&&y.length!=g,o:i,compression:u})),i+=30+p+w+z,a+=76+2*(p+w)+(g||0)+z;}for(var D=new A(a+22),C=i,U=a-i,x=0;x<e.length;++x){var l=e[x];Ar(D,l.o,l,l.f,l.u,l.c.length);var v=30+l.f.length+fr(l.extra);D.set(l.c,l.o+v),Ar(D,i,l,l.f,l.u,l.c.length,l.o,l.m),i+=16+v+(l.m?l.m.length:0);}return ln(D,i,e.length,U,C),D}var dn=function(){function n(){}return n.prototype.push=function(r,t){this.ondata(null,r,t);},n.compression=0,n}(),ct=function(){function n(){var r=this;this.i=new J(function(t,e){r.ondata(null,t,e);});}return n.prototype.push=function(r,t){try{this.i.push(r,t);}catch(e){this.ondata(e,r,t);}},n.compression=8,n}(),pt=function(){function n(r,t){var e=this;t<32e4?this.i=new J(function(i,a){e.ondata(null,i,a);}):(this.i=new en(function(i,a,o){e.ondata(i,a,o);}),this.terminate=this.i.terminate);}return n.prototype.push=function(r,t){this.i.terminate&&(r=$(r,0)),this.i.push(r,t);},n.compression=8,n}(),gt=function(){function n(r){this.onfile=r,this.k=[],this.o={0:dn},this.p=er;}return n.prototype.push=function(r,t){var e=this;if(!this.onfile)throw \"no callback\";if(this.c>0){var i=Math.min(this.c,r.length),a=r.subarray(0,i);if(this.c-=i,this.d?this.d.push(a,!this.c):this.k[0].push(a),r=r.subarray(i),r.length)return this.push(r,t)}else {var o=0,f=0,h=void 0,s=void 0;this.p.length?r.length?(s=new A(this.p.length+r.length),s.set(this.p),s.set(r,this.p.length)):s=this.p:s=r;for(var u=s.length,l=this.c,p=l&&this.d,y=function(){var M,z=P(s,f);if(z==67324752){o=1,h=f,c.d=null,c.c=0;var m=Y(s,f+6),D=Y(s,f+8),C=m&2048,U=m&8,x=Y(s,f+26),v=Y(s,f+28);if(u>f+30+x+v){var E=[];c.k.unshift(E),o=2;var S=P(s,f+18),K=P(s,f+22),I=un(s.subarray(f+30,f+=30+x),!C);S==4294967295?(M=U?[-2]:Ln(s,f),S=M[0],K=M[1]):U&&(S=-1),f+=v,c.c=S;var Z={name:I,compression:D,start:function(){if(!Z.ondata)throw \"no callback\";if(!S)Z.ondata(null,er,!0);else {var B=e.o[D];if(!B)throw \"unknown compression type \"+D;var G=S<0?new B(I):new B(I,S,K);G.ondata=function(N,Q,W){Z.ondata(N,Q,W);};for(var k=0,O=E;k<O.length;k++){var H=O[k];G.push(H,!1);}e.k[0]==E?e.d=G:G.push(er,!0);}},terminate:function(){e.k[0]==E&&e.d.terminate&&e.d.terminate();}};S>=0&&(Z.size=S,Z.originalSize=K),c.onfile(Z);}return \"break\"}else if(l){if(z==134695760)return h=f+=12+(l==-2&&8),o=2,c.c=0,\"break\";if(z==33639248)return h=f-=4,o=2,c.c=0,\"break\"}},c=this;f<u-4;++f){var g=y();if(g===\"break\")break}if(this.p=er,l<0){var w=o?s.subarray(0,h-12-(l==-2&&8)-(P(s,h-16)==134695760&&4)):s.subarray(0,f);p?p.push(w,!!o):this.k[+(o==2)].push(w);}if(o&2)return this.push(s.subarray(f),t);this.p=s.subarray(f);}if(t&&this.c)throw \"invalid zip file\"},n.prototype.register=function(r){this.o[r.compression]=r;},n}();function wt(n,r){if(typeof r!=\"function\")throw \"no callback\";for(var t=[],e=function(){for(var p=0;p<t.length;++p)t[p]();},i={},a=n.length-22;P(n,a)!=101010256;--a)if(!a||n.length-a>65558){r(\"invalid zip file\",null);return}var o=Y(n,a+8);o||r(null,{});var f=o,h=P(n,a+16),s=h==4294967295;if(s){if(a=P(n,a-12),P(n,a)!=101075792){r(\"invalid zip file\",null);return}f=o=P(n,a+32),h=P(n,a+48);}for(var u=function(p){var y=$n(n,h,s),c=y[0],g=y[1],w=y[2],M=y[3],z=y[4],m=y[5],D=Xn(n,m);h=z;var C=function(x,v){x?(e(),r(x,null)):(i[M]=v,--o||r(null,i));};if(!c)C(null,$(n,D,D+g));else if(c==8){var U=n.subarray(D,D+g);if(g<32e4)try{C(null,xr(U,new A(w)));}catch(x){C(x,null);}else t.push(an(U,{size:w},C));}else C(\"unknown compression type \"+c,null);},l=0;l<f;++l)u();return e}function yt(n){for(var r={},t=n.length-22;P(n,t)!=101010256;--t)if(!t||n.length-t>65558)throw \"invalid zip file\";var e=Y(n,t+8);if(!e)return {};var i=P(n,t+16),a=i==4294967295;if(a){if(t=P(n,t-12),P(n,t)!=101075792)throw \"invalid zip file\";e=P(n,t+32),i=P(n,t+48);}for(var o=0;o<e;++o){var f=$n(n,i,a),h=f[0],s=f[1],u=f[2],l=f[3],p=f[4],y=f[5],c=Xn(n,y);if(i=p,!h)r[l]=$(n,c,c+s);else if(h==8)r[l]=xr(n.subarray(c,c+s),new A(u));else throw \"unknown compression type \"+h}return r}var fflate_module_min = null;\n\nvar fflate = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tAsyncCompress: Rn,\n\tAsyncDecompress: et,\n\tAsyncDeflate: En,\n\tAsyncGunzip: Hn,\n\tAsyncGzip: Rn,\n\tAsyncInflate: en,\n\tAsyncUnzipInflate: pt,\n\tAsyncUnzlib: Yn,\n\tAsyncZipDeflate: ht,\n\tAsyncZlib: nt,\n\tCompress: qr,\n\tDecodeUTF8: ot,\n\tDecompress: Jn,\n\tDeflate: rr,\n\tEncodeUTF8: ft,\n\tGunzip: Wr,\n\tGzip: qr,\n\tInflate: J,\n\tUnzip: gt,\n\tUnzipInflate: ct,\n\tUnzipPassThrough: dn,\n\tUnzlib: jr,\n\tZip: ut,\n\tZipDeflate: st,\n\tZipPassThrough: Br,\n\tZlib: on,\n\tcompress: qn,\n\tcompressSync: Hr,\n\tdecompress: it,\n\tdecompressSync: at,\n\tdeflate: Pn,\n\tdeflateSync: kr,\n\tgunzip: Wn,\n\tgunzipSync: Yr,\n\tgzip: qn,\n\tgzipSync: Hr,\n\tinflate: an,\n\tinflateSync: xr,\n\tstrFromU8: un,\n\tstrToU8: or,\n\tunzip: wt,\n\tunzipSync: yt,\n\tunzlib: jn,\n\tunzlibSync: Jr,\n\tzip: lt,\n\tzipSync: vt,\n\tzlib: tt,\n\tzlibSync: fn,\n\t'default': fflate_module_min\n});\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\nvar NURBSUtils = {\n\n\t/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\n\tfindSpan: function ( p, u, U ) {\n\n\t\tvar n = U.length - p - 1;\n\n\t\tif ( u >= U[ n ] ) {\n\n\t\t\treturn n - 1;\n\n\t\t}\n\n\t\tif ( u <= U[ p ] ) {\n\n\t\t\treturn p;\n\n\t\t}\n\n\t\tvar low = p;\n\t\tvar high = n;\n\t\tvar mid = Math.floor( ( low + high ) / 2 );\n\n\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\thigh = mid;\n\n\t\t\t} else {\n\n\t\t\t\tlow = mid;\n\n\t\t\t}\n\n\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t}\n\n\t\treturn mid;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\tcalcBasisFunctions: function ( span, u, p, U ) {\n\n\t\tvar N = [];\n\t\tvar left = [];\n\t\tvar right = [];\n\t\tN[ 0 ] = 1.0;\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tvar temp = N[ r ] / ( rv + lv );\n\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t }\n\n\t\t\t N[ j ] = saved;\n\n\t\t }\n\n\t\t return N;\n\n\t},\n\n\n\t/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\tcalcBSplinePoint: function ( p, U, P, u ) {\n\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar N = this.calcBasisFunctions( span, u, p, U );\n\t\tvar C = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tvar point = P[ span - p + j ];\n\t\t\tvar Nj = N[ j ];\n\t\t\tvar wNj = point.w * Nj;\n\t\t\tC.x += point.x * wNj;\n\t\t\tC.y += point.y * wNj;\n\t\t\tC.z += point.z * wNj;\n\t\t\tC.w += point.w * Nj;\n\n\t\t}\n\n\t\treturn C;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\tcalcBasisFunctionDerivatives: function ( span, u, p, n, U ) {\n\n\t\tvar zeroArr = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tzeroArr[ i ] = 0.0;\n\n\t\tvar ders = [];\n\t\tfor ( var i = 0; i <= n; ++ i )\n\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\tvar ndu = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\tvar left = zeroArr.slice( 0 );\n\t\tvar right = zeroArr.slice( 0 );\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t}\n\n\t\t\tndu[ j ][ j ] = saved;\n\n\t\t}\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t}\n\n\t\tfor ( var r = 0; r <= p; ++ r ) {\n\n\t\t\tvar s1 = 0;\n\t\t\tvar s2 = 1;\n\n\t\t\tvar a = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i ) {\n\n\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t}\n\n\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\tvar d = 0.0;\n\t\t\t\tvar rk = r - k;\n\t\t\t\tvar pk = p - k;\n\n\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\tvar j = s1;\n\t\t\t\ts1 = s2;\n\t\t\t\ts2 = j;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar r = p;\n\n\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t}\n\n\t\t\tr *= p - k;\n\n\t\t}\n\n\t\treturn ders;\n\n\t},\n\n\n\t/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\tcalcBSplineDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar du = nd < p ? nd : p;\n\t\tvar CK = [];\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\tvar Pw = [];\n\n\t\tfor ( var i = 0; i < P.length; ++ i ) {\n\n\t\t\tvar point = P[ i ].clone();\n\t\t\tvar w = point.w;\n\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\n\t\t\tPw[ i ] = point;\n\n\t\t}\n\n\t\tfor ( var k = 0; k <= du; ++ k ) {\n\n\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = point;\n\n\t\t}\n\n\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\tCK[ k ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\tcalcKoverI: function ( k, i ) {\n\n\t\tvar nom = 1;\n\n\t\tfor ( var j = 2; j <= k; ++ j ) {\n\n\t\t\tnom *= j;\n\n\t\t}\n\n\t\tvar denom = 1;\n\n\t\tfor ( var j = 2; j <= i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\tfor ( var j = 2; j <= k - i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\treturn nom / denom;\n\n\t},\n\n\n\t/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\tcalcRationalCurveDerivatives: function ( Pders ) {\n\n\t\tvar nd = Pders.length;\n\t\tvar Aders = [];\n\t\tvar wders = [];\n\n\t\tfor ( var i = 0; i < nd; ++ i ) {\n\n\t\t\tvar point = Pders[ i ];\n\t\t\tAders[ i ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V( point.x, point.y, point.z );\n\t\t\twders[ i ] = point.w;\n\n\t\t}\n\n\t\tvar CK = [];\n\n\t\tfor ( var k = 0; k < nd; ++ k ) {\n\n\t\t\tvar v = Aders[ k ].clone();\n\n\t\t\tfor ( var i = 1; i <= k; ++ i ) {\n\n\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\tcalcNURBSDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t},\n\n\n\t/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\n\n\t\tvar uspan = this.findSpan( p, u, U );\n\t\tvar vspan = this.findSpan( q, v, V );\n\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\tvar temp = [];\n\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\ttemp[ l ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\t\tfor ( var k = 0; k <= p; ++ k ) {\n\n\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\tvar w = point.w;\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar Sw = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t}\n\n\t\tSw.divideScalar( Sw.w );\n\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t}\n\n};\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nvar NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ax.call( this );\n\n\tthis.degree = degree;\n\tthis.knots = knots;\n\tthis.controlPoints = [];\n\t// Used by periodic NURBS to remove hidden spans\n\tthis.startKnot = startKnot || 0;\n\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t// ensure Vector4 for control points\n\t\tvar point = controlPoints[ i ];\n\t\tthis.controlPoints[ i ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw( point.x, point.y, point.z, point.w );\n\n\t}\n\n};\n\n\nNURBSCurve.prototype = Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ax.prototype );\nNURBSCurve.prototype.constructor = NURBSCurve;\n\n\nNURBSCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t// following results in (wx, wy, wz, w) homogeneous point\n\tvar hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\tif ( hpoint.w != 1.0 ) {\n\n\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\thpoint.divideScalar( hpoint.w );\n\n\t}\n\n\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n};\n\n\nNURBSCurve.prototype.getTangent = function ( t, optionalTarget ) {\n\n\tvar tangent = optionalTarget || new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\tvar ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\ttangent.copy( ders[ 1 ] ).normalize();\n\n\treturn tangent;\n\n};\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nvar FBXLoader = ( function () {\n\n\tvar fbxTree;\n\tvar connections;\n\tvar sceneGraph;\n\n\tfunction FBXLoader( manager ) {\n\n\t\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tFBXLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: FBXLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, path ) {\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( fbxTree );\n\n\t\t\tvar textureLoader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t\t}\n\n\t} );\n\n\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\n\tfunction FBXTreeParser( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tFBXTreeParser.prototype = {\n\n\t\tconstructor: FBXTreeParser,\n\n\t\tparse: function () {\n\n\t\t\tconnections = this.parseConnections();\n\n\t\t\tvar images = this.parseImages();\n\t\t\tvar textures = this.parseTextures( images );\n\t\t\tvar materials = this.parseMaterials( textures );\n\t\t\tvar deformers = this.parseDeformers();\n\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\n\n\t\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t},\n\n\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t// and details the connection type\n\t\tparseConnections: function () {\n\n\t\t\tvar connectionMap = new Map();\n\n\t\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn connectionMap;\n\n\t\t},\n\n\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t// via FBXTree.Connections.\n\t\tparseImages: function () {\n\n\t\t\tvar images = {};\n\t\t\tvar blobs = {};\n\n\t\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\t\tvar image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var id in images ) {\n\n\t\t\t\tvar filename = images[ id ];\n\n\t\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\tparseImage: function ( videoNode ) {\n\n\t\t\tvar content = videoNode.Content;\n\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\t\tvar type;\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'bmp':\n\n\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'jpg':\n\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'png':\n\n\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tif':\n\n\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tga':\n\n\t\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t\t} else { // Binary Format\n\n\t\t\t\tvar array = new Uint8Array( content );\n\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t// to images in FBXTree.Objects.Video\n\t\tparseTextures: function ( images ) {\n\n\t\t\tvar textureMap = new Map();\n\n\t\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\t\tvar texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textureMap;\n\n\t\t},\n\n\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\tparseTexture: function ( textureNode, images ) {\n\n\t\t\tvar texture = this.loadTexture( textureNode, images );\n\n\t\t\ttexture.ID = textureNode.id;\n\n\t\t\ttexture.name = textureNode.attrName;\n\n\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\ttexture.wrapS = valueU === 0 ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\ttexture.wrapT = valueV === 0 ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\t\tloadTexture: function ( textureNode, images ) {\n\n\t\t\tvar fileName;\n\n\t\t\tvar currentPath = this.textureLoader.path;\n\n\t\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar texture;\n\n\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\t\tif ( extension === 'tga' ) {\n\n\t\t\t\tvar loader = this.manager.getHandler( '.tga' );\n\n\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\ttexture = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t\t}\n\n\t\t\t} else if ( extension === 'psd' ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\ttexture = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t} else {\n\n\t\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t\t}\n\n\t\t\tthis.textureLoader.setPath( currentPath );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Material\n\t\tparseMaterials: function ( textureMap ) {\n\n\t\t\tvar materialMap = new Map();\n\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Material\n\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\tparseMaterial: function ( materialNode, textureMap ) {\n\n\t\t\tvar ID = materialNode.id;\n\t\t\tvar name = materialNode.attrName;\n\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\tif ( typeof type === 'object' ) {\n\n\t\t\t\ttype = type.value;\n\n\t\t\t}\n\n\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\t\tvar material;\n\n\t\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.setValues( parameters );\n\t\t\tmaterial.name = name;\n\n\t\t\treturn material;\n\n\t\t},\n\n\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t// Also parse the texture map and return any textures associated with the material\n\t\tparseParameters: function ( materialNode, textureMap, ID ) {\n\n\t\t\tvar parameters = {};\n\n\t\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Diffuse ) {\n\n\t\t\t\tparameters.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Diffuse.value );\n\n\t\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\tparameters.color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.DiffuseColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Emissive ) {\n\n\t\t\t\tparameters.emissive = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Emissive.value );\n\n\t\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\tparameters.emissive = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.EmissiveColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Opacity ) {\n\n\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t\t}\n\n\t\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\t\tparameters.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Shininess ) {\n\n\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Specular ) {\n\n\t\t\t\tparameters.specular = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Specular.value );\n\n\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\tparameters.specular = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.SpecularColor.value );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\t\tvar type = child.relationship;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.map.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.emissiveMap.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.envMap.mapping = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ay;\n\t\t\t\t\t\tparameters.envMap.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.specularMap.encoding = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn parameters;\n\n\t\t},\n\n\t\t// get a texture from the textureMap for use by a material.\n\t\tgetTexture: function ( textureMap, id ) {\n\n\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t\t}\n\n\t\t\treturn textureMap.get( id );\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\tparseDeformers: function () {\n\n\t\t\tvar skeletons = {};\n\t\t\tvar morphTargets = {};\n\n\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\t\tvar skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\n\t\t\t\tskeletons: skeletons,\n\t\t\t\tmorphTargets: morphTargets,\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\tparseSkeleton: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawBones = [];\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\t\tvar rawBone = {\n\n\t\t\t\t\tID: child.ID,\n\t\t\t\t\tindices: [],\n\t\t\t\t\tweights: [],\n\t\t\t\t\ttransformLink: new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t};\n\n\t\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t\t}\n\n\t\t\t\trawBones.push( rawBone );\n\n\t\t\t} );\n\n\t\t\treturn {\n\n\t\t\t\trawBones: rawBones,\n\t\t\t\tbones: []\n\n\t\t\t};\n\n\t\t},\n\n\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawMorphTargets = [];\n\n\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\t\tvar child = relationships.children[ i ];\n\n\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t};\n\n\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t\t}\n\n\t\t\treturn rawMorphTargets;\n\n\t\t},\n\n\t\t// create the main Group() to be returned by the loader\n\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\n\n\t\t\tsceneGraph = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tvar scope = this;\n\t\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( model.parent === null ) {\n\n\t\t\t\t\tsceneGraph.add( model );\n\n\t\t\t\t}\n\n\n\t\t\t} );\n\n\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\t\tthis.createAmbientLight();\n\n\t\t\tthis.setupMorphMaterials();\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar transform = generateTransform( node.userData.transformData );\n\n\t\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t\t}\n\n\t\t\tsceneGraph.animations = animations;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.Model\n\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\n\t\t\tvar modelMap = new Map();\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\t\tvar id = parseInt( nodeID );\n\t\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\t\tvar relationships = connections.get( id );\n\n\t\t\t\tvar model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.name = node.attrName ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\t\tmodel.ID = id;\n\n\t\t\t\t}\n\n\t\t\t\tthis.getTransformData( model, node );\n\t\t\t\tmodelMap.set( id, model );\n\n\t\t\t}\n\n\t\t\treturn modelMap;\n\n\t\t},\n\n\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\n\n\t\t\tvar bone = null;\n\n\t\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\tbone = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\t\tbone.name = name ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn bone;\n\n\t\t},\n\n\t\t// create a PerspectiveCamera or OrthographicCamera\n\t\tcreateCamera: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar cameraAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tcameraAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type = 0;\n\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\t\ttype = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t\t}\n\n\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t\t}\n\n\n\t\t\t\tvar width = window.innerWidth;\n\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar aspect = width / height;\n\n\t\t\t\tvar fov = 45;\n\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Perspective\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.A( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.O( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\t// Create a DirectionalLight, PointLight or SpotLight\n\t\tcreateLight: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar lightAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tlightAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( lightAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type;\n\n\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\t\ttype = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\t\tcolor = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( lightAttribute.Color.value );\n\n\t\t\t\t}\n\n\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t// light disabled\n\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\t\tintensity = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar distance = 0;\n\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\t\tdistance = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\tvar decay = 1;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Point\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity, distance, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Directional\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__._( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2: // Spot\n\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\t\tangle = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\tpenumbra = _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Y( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\t\tmodel.castShadow = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\n\n\t\t\tvar model;\n\t\t\tvar geometry = null;\n\t\t\tvar material = null;\n\t\t\tvar materials = [];\n\n\t\t\t// get geometry and materials(s) from connections\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( materials.length > 1 ) {\n\n\t\t\t\tmaterial = materials;\n\n\t\t\t} else if ( materials.length > 0 ) {\n\n\t\t\t\tmaterial = materials[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.al( { color: 0xcccccc } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t} );\n\n\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material );\n\t\t\t\tmodel.normalizeSkinWeights();\n\n\t\t\t} else {\n\n\t\t\t\tmodel = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateCurve: function ( relationships, geometryMap ) {\n\n\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\t\treturn geo;\n\n\t\t\t}, null );\n\n\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\tvar material = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0x3300ff, linewidth: 1 } );\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t},\n\n\t\t// parse the model node for transform data\n\t\tgetTransformData: function ( model, modelNode ) {\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\tmodel.userData.transformData = transformData;\n\n\t\t},\n\n\t\tsetLookAtProperties: function ( model, modelNode ) {\n\n\t\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\tmodel.lookAt( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( pos ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\n\n\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\t\tmodel.bind( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.X( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparsePoseNodes: function () {\n\n\t\t\tvar bindMatrices = {};\n\n\t\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bindMatrices;\n\n\t\t},\n\n\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\tcreateAmbientLight: function () {\n\n\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\tvar r = ambientColor[ 0 ];\n\t\t\t\tvar g = ambientColor[ 1 ];\n\t\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\tvar color = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.C( r, g, b );\n\t\t\t\t\tsceneGraph.add( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.am( color, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetupMorphMaterials: function () {\n\n\t\t\tvar scope = this;\n\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\t\tscope.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscope.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t},\n\n\t\tsetupMorphMaterial: function ( child, material, index ) {\n\n\t\t\tvar uuid = child.uuid;\n\t\t\tvar matUuid = material.uuid;\n\n\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\tvar sharedMat = false;\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.isMesh ) {\n\n\t\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( sharedMat === true ) {\n\n\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t\t} else material.morphTargets = true;\n\n\t\t}\n\n\t};\n\n\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\tfunction GeometryParser() {}\n\n\tGeometryParser.prototype = {\n\n\t\tconstructor: GeometryParser,\n\n\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\tparse: function ( deformers ) {\n\n\t\t\tvar geometryMap = new Map();\n\n\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\t\tvar geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometryMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tswitch ( geoNode.attrType ) {\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\n\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tvar skeletons = deformers.skeletons;\n\t\t\tvar morphTargets = [];\n\n\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t\t} );\n\n\t\t\t// don't create geometry if it is not associated with any models\n\t\t\tif ( modelNodes.length === 0 ) return;\n\n\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\t\treturn skeleton;\n\n\t\t\t}, null );\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// Assume one model and get the preRotation from that\n\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\tvar transform = generateTransform( transformData );\n\n\t\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t\t},\n\n\t\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\tgenGeometry: function ( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\t\tvar geo = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\t\tvar buffers = this.genBuffers( geoInfo );\n\n\t\t\tvar positionAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertex, 3 );\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\t\tgeo.setAttribute( 'color', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tgeo.setAttribute( 'skinIndex', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.az( buffers.weightsIndices, 4 ) );\n\n\t\t\t\tgeo.setAttribute( 'skinWeight', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertexWeights, 4 ) );\n\n\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t\t}\n\n\t\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\t\tvar normalMatrix = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA().getNormalMatrix( preTransform );\n\n\t\t\t\tvar normalAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.normal, 3 );\n\t\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t\t}\n\n\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tname = 'uv';\n\n\t\t\t\t}\n\n\t\t\t\tgeo.setAttribute( name, new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.uvs[ i ], 2 ) );\n\n\t\t\t} );\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\t\tvar startIndex = 0;\n\n\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t// using one of them\n\t\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\t\treturn geo;\n\n\t\t},\n\n\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\n\t\t\tvar geoInfo = {};\n\n\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\tvar i = 0;\n\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeoInfo.weightTable = {};\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn geoInfo;\n\n\t\t},\n\n\t\tgenBuffers: function ( geoInfo ) {\n\n\t\t\tvar buffers = {\n\t\t\t\tvertex: [],\n\t\t\t\tnormal: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tmaterialIndex: [],\n\t\t\t\tvertexWeights: [],\n\t\t\t\tweightsIndices: [],\n\t\t\t};\n\n\t\t\tvar polygonIndex = 0;\n\t\t\tvar faceLength = 0;\n\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t// these will hold data for a single face\n\t\t\tvar facePositionIndexes = [];\n\t\t\tvar faceNormals = [];\n\t\t\tvar faceColors = [];\n\t\t\tvar faceUVs = [];\n\t\t\tvar faceWeights = [];\n\t\t\tvar faceWeightIndices = [];\n\n\t\t\tvar scope = this;\n\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t//  }\n\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\tendOfFace = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar weightIndices = [];\n\t\t\t\tvar weights = [];\n\n\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\tweights = Weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfaceLength ++;\n\n\t\t\t\tif ( endOfFace ) {\n\n\t\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\t\tpolygonIndex ++;\n\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\tfaceColors = [];\n\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn buffers;\n\n\t\t},\n\n\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\t\tif ( morphTargets.length === 0 ) return;\n\n\t\t\tparentGeo.morphTargetsRelative = true;\n\n\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\tvar scope = this;\n\t\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t},\n\n\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\tvar morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\t\tvar length = parentGeo.attributes.position.count * 3;\n\t\t\tvar morphPositions = new Float32Array( length );\n\n\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t\t}\n\n\t\t\t// TODO: add morph normal support\n\t\t\tvar morphGeoInfo = {\n\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\tvertexPositions: morphPositions,\n\n\t\t\t};\n\n\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\t\tvar positionAttribute = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( morphBuffers.vertex, 3 );\n\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t\t},\n\n\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\tparseNormals: function ( NormalNode ) {\n\n\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 3,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\tparseUVs: function ( UVNode ) {\n\n\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\tvar buffer = UVNode.UV.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 2,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\tparseVertexColors: function ( ColorNode ) {\n\n\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 4,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\tparseMaterialIndices: function ( MaterialNode ) {\n\n\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 1,\n\t\t\t\t\tbuffer: [ 0 ],\n\t\t\t\t\tindices: [ 0 ],\n\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\tvar materialIndices = [];\n\n\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\t\tmaterialIndices.push( i );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\tindices: materialIndices,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\tparseNurbsGeometry: function ( geoNode ) {\n\n\t\t\tif ( NURBSCurve === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar order = parseInt( geoNode.Order );\n\n\t\t\tif ( isNaN( order ) ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar degree = order - 1;\n\n\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\tvar controlPoints = [];\n\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\t\tcontrolPoints.push( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aw().fromArray( pointsValues, i ) );\n\n\t\t\t}\n\n\t\t\tvar startKnot, endKnot;\n\n\t\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\t\tstartKnot = degree;\n\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t} );\n\n\t\t\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.c( positions, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t};\n\n\t// parse animation data from FBXTree\n\tfunction AnimationParser() {}\n\n\tAnimationParser.prototype = {\n\n\t\tconstructor: AnimationParser,\n\n\t\t// take raw animation clips and turn them into three.js animation clips\n\t\tparse: function () {\n\n\t\t\tvar animationClips = [];\n\n\t\t\tvar rawClips = this.parseClips();\n\n\t\t\tif ( rawClips !== undefined ) {\n\n\t\t\t\tfor ( var key in rawClips ) {\n\n\t\t\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\t\t\tvar clip = this.addClip( rawClip );\n\n\t\t\t\t\tanimationClips.push( clip );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn animationClips;\n\n\t\t},\n\n\t\tparseClips: function () {\n\n\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t// and is referenced by an AnimationLayer\n\t\tparseAnimationCurveNodes: function () {\n\n\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\tvar curveNodesMap = new Map();\n\n\t\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\tcurves: {},\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn curveNodesMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t// axis ( e.g. times and values of x rotation)\n\t\tparseAnimationCurves: function ( curveNodesMap ) {\n\n\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t// clearly, this should be optimised to\n\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t\t};\n\n\t\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\n\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\tvar layersMap = new Map();\n\n\t\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn layersMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\t\tparseAnimStacks: function ( layersMap ) {\n\n\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t// connect the stacks (clips) up to the layers\n\t\t\tvar rawClips = {};\n\n\t\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\t\tlayer: layer,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\taddClip: function ( rawClip ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar scope = this;\n\t\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t\t} );\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.K( rawClip.name, - 1, tracks );\n\n\t\t},\n\n\t\tgenerateTracks: function ( rawTracks ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar initialPosition = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar initialRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar initialScale = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\tinitialRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t},\n\n\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ac( modelName + '.' + type, times, values );\n\n\t\t},\n\n\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\t\tif ( curves.x !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.x );\n\t\t\t\tcurves.x.values = curves.x.values.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.y !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.y );\n\t\t\t\tcurves.y.values = curves.y.values.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.z !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.z );\n\t\t\t\tcurves.z.values = curves.z.values.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\tif ( preRotation !== undefined ) {\n\n\t\t\t\tpreRotation = preRotation.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\t\tpreRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( preRotation );\n\t\t\t\tpreRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( preRotation );\n\n\t\t\t}\n\n\t\t\tif ( postRotation !== undefined ) {\n\n\t\t\t\tpostRotation = postRotation.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\t\tpostRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( postRotation );\n\t\t\t\tpostRotation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( postRotation ).invert();\n\n\t\t\t}\n\n\t\t\tvar quaternion = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar euler = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\n\t\t\tvar quaternionValues = [];\n\n\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t\t}\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ad( modelName + '.quaternion', times, quaternionValues );\n\n\t\t},\n\n\t\tgenerateMorphTrack: function ( rawTracks ) {\n\n\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\tvar values = curves.values.map( function ( val ) {\n\n\t\t\t\treturn val / 100;\n\n\t\t\t} );\n\n\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\t\treturn new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.ae( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t\t},\n\n\t\t// For all animated objects, times are defined separately for each axis\n\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\tgetTimesForAllAxes: function ( curves ) {\n\n\t\t\tvar times = [];\n\n\t\t\t// first join together the times for each axis, if defined\n\t\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t\t// then sort them\n\t\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\t\treturn a - b;\n\n\t\t\t} );\n\n\t\t\t// and remove duplicates\n\t\t\tif ( times.length > 1 ) {\n\n\t\t\t\tvar targetIndex = 1;\n\t\t\t\tvar lastValue = times[ 0 ];\n\t\t\t\tfor ( var i = 1; i < times.length; i ++ ) {\n\n\t\t\t\t\tvar currentValue = times[ i ];\n\t\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t\t}\n\n\t\t\treturn times;\n\n\t\t},\n\n\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\n\n\t\t\tvar prevValue = initialValue;\n\n\t\t\tvar values = [];\n\n\t\t\tvar xIndex = - 1;\n\t\t\tvar yIndex = - 1;\n\t\t\tvar zIndex = - 1;\n\n\t\t\ttimes.forEach( function ( time ) {\n\n\t\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\t\tvalues.push( xValue );\n\t\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\t\tvalues.push( yValue );\n\t\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\t\tvalues.push( zValue );\n\t\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn values;\n\n\t\t},\n\n\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t// These will be converted to quaternions which don't support values greater than\n\t\t// PI, so we'll interpolate large rotations\n\t\tinterpolateRotations: function ( curve ) {\n\n\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\t\tnextValue += step;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t};\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tTextParser.prototype = {\n\n\t\tconstructor: TextParser,\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar scope = this;\n\n\t\t\tvar split = text.split( /[\\r\\n]+/ );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tscope.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t};\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tBinaryParser.prototype = {\n\n\t\tconstructor: BinaryParser,\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tif ( version < 6400 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t\t}\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof fflate === 'undefined' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library fflate.min.js required.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = Jr( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tBinaryReader.prototype = {\n\n\t\tconstructor: BinaryReader,\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( a ) );\n\n\t\t}\n\n\t};\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tFBXTree.prototype = {\n\n\t\tconstructor: FBXTree,\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t};\n\n\t// ************** UTILITY FUNCTIONS **************\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\tvar dataArray = [];\n\n\t// extracts the data from the correct position in the FBX array based on indexing type\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\tvar tempEuler = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\tvar tempVec = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t// generate transformation from FBX transform data\n\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\tfunction generateTransform( transformData ) {\n\n\t\tvar lTranslationM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPreRotationM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPostRotationM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lScalingM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingPivotM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingOffsetM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationOffsetM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationPivotM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lParentGX = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentLX = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lGlobalT = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\t\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t\tif ( transformData.preRotation ) {\n\n\t\t\tvar array = transformData.preRotation.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.rotation ) {\n\n\t\t\tvar array = transformData.rotation.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.postRotation ) {\n\n\t\t\tvar array = transformData.postRotation.map( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\t\tlPostRotationM.invert();\n\n\t\t}\n\n\t\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t\t// Pivots and offsets\n\t\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\t\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\t\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\t\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t\t// parent transform\n\t\tif ( transformData.parentMatrixWorld ) {\n\n\t\t\tlParentLX.copy( transformData.parentMatrix );\n\t\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t\t}\n\n\t\tvar lLRM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM );\n\t\t// Global Rotation\n\t\tvar lParentGRM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentGRM.extractRotation( lParentGX );\n\n\t\t// Global Shear*Scaling\n\t\tvar lParentTM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentTM.copyPosition( lParentGX );\n\n\t\tvar lParentGSM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentGRSM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentTM ).invert().multiply( lParentGX );\n\t\tlParentGSM.copy( lParentGRM ).invert().multiply( lParentGRSM );\n\t\tvar lLSM = lScalingM;\n\n\t\tvar lGlobalRS = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tif ( inheritType === 0 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t\t} else if ( inheritType === 1 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t\t} else {\n\n\t\t\tvar lParentLSM = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().scale( new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V().setFromMatrixScale( lParentLX ) );\n\t\t\tvar lParentLSM_inv = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentLSM ).invert();\n\t\t\tvar lParentGSM_noLocal = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGSM ).multiply( lParentLSM_inv );\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t\t}\n\n\t\tvar lRotationPivotM_inv = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlRotationPivotM_inv.copy( lRotationPivotM ).invert();\n\t\tvar lScalingPivotM_inv = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlScalingPivotM_inv.copy( lScalingPivotM ).invert();\n\t\t// Calculate the local transform matrix\n\t\tvar lTransform = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlTransform.copy( lTranslationM ).multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\t\tvar lLocalTWithAllPivotAndOffsetInfo = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copyPosition( lTransform );\n\n\t\tvar lGlobalTranslation = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGX ).multiply( lLocalTWithAllPivotAndOffsetInfo );\n\t\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\t\tlTransform = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lGlobalT ).multiply( lGlobalRS );\n\n\t\t// from global to local\n\t\tlTransform.premultiply( lParentGX.invert() );\n\n\t\treturn lTransform;\n\n\t}\n\n\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\tfunction getEulerOrder( order ) {\n\n\t\torder = order || 0;\n\n\t\tvar enums = [\n\t\t\t'ZYX', // -> XYZ extrinsic\n\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t'XYZ', // -> ZYX extrinsic\n\t\t\t//'SphericXYZ', // not possible to support\n\t\t];\n\n\t\tif ( order === 6 ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\t\treturn enums[ 0 ];\n\n\t\t}\n\n\t\treturn enums[ order ];\n\n\t}\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn FBXLoader;\n\n} )();\n\nvar SVGLoader = function ( manager ) {\n\n\t_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = 'px';\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar traverseChildNodes = true;\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tvar usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tvar usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar point = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar control = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tvar firstPoint = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tvar selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tvar stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tvar RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i\n\t\t\t};\n\n\t\t\t// States\n\t\t\tvar SEP = 0;\n\t\t\tvar INT = 1;\n\t\t\tvar FLOAT = 2;\n\t\t\tvar EXP = 3;\n\n\t\t\tvar state = SEP;\n\t\t\tvar seenComma = true;\n\t\t\tvar result = [], number = '', exponent = '';\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tvar error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tvar current, i = 0, length = input.length;\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state == EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\t\tvar currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tvar tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tvar ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\t\tvar stylesheets = {};\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform1 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform2 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform3 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempV2 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\tvar tempV3 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tvar currentTransform = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\tgeometry.setAttribute( 'position', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_2 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_3 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_4 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_5 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_6 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_7 = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointL = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointR = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0L = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0R = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointL = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointR = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointL = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointR = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar innerPoint = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar outerPoint = new _index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\n_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.U.DefaultUp.set(0, 0, 1);\nvar defaultColor = 'hotpink';\nvar traverseChildren = function (child, opacity, shadow) {\n    if (child.isMesh) {\n        if (Array.isArray(child.material)) {\n            child.material.forEach(function (mat) {\n                mat = mat.clone();\n            });\n        }\n        else {\n            child.material = child.material.clone();\n        }\n        if (shadow) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n        }\n        if (opacity !== 1.0) {\n            if (child.material.isMaterial) {\n                child.material.transparent = true;\n                child.material.opacity = opacity;\n            }\n            else if (Array.isArray(child.material)) {\n                child.material.forEach(function (mat) {\n                    mat.transparent = true;\n                    mat.opacity = opacity;\n                });\n            }\n        }\n    }\n    else if (child.type === 'PointLight') {\n        child.visible = false;\n    }\n    else if (child.isObject3D || child.isGroup) {\n        child.children.forEach(function (child2) {\n            traverseChildren(child2, opacity, shadow);\n        });\n    }\n};\nvar STLAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(STLLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.clone(); }, [model]);\n    // console.log('Loading: ')\n    // console.log(props)\n    // useEffect(() => {\n    //     // scene.children.forEach((child) => {\n    //     //     traverseChildren(child, props.opacity, true)\n    //     // })\n    //     scene.name = 'loaded'\n    // })\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true, name: 'loaded' },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar GLTFAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(GLTFLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model.scene, opacity: props.opacity, castShadow: true, receiveShadow: true })));\n};\nvar ColladaAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ColladaLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.scene.clone(true); }, [model.scene]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n        scene.name = 'loaded';\n    }, [scene]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, position: props.t, scale: props.scale, quaternion: props.q }));\n};\nvar OBJAsset = function (props) {\n    var mtlurl = props.url.slice(0, props.url.length - 3) + 'mtl';\n    var materials = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(MTLLoader, mtlurl);\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(OBJLoader, props.url, function (loader) {\n        materials.preload();\n        // loader.setMaterials(materials)\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar VRMLAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(VRMLLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PCDAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PCDLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        // model.material.color = props.color\n        //     ? new THREE.Color(props.color)\n        //     : new THREE.Color(defaultColor)\n        // model.material.transparent = props.opacity !== 1.0 ? true : false\n        // model.material.opacity = props.opacity ? props.opacity : 1.0\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PLYAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PLYLoader, props.url);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar FBXAsset = function (props) {\n    var model = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(FBXLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar SVGShape = function (_a) {\n    var shape = _a.shape, color = _a.color, index = _a.index, opacity = _a.opacity;\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", null,\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshLambertMaterial\", { attach: \"material\", color: color, polygonOffset: true, polygonOffsetFactor: index * -0.1, transparent: opacity !== 1.0 ? true : false, opacity: opacity ? opacity : 1.0 }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"shapeBufferGeometry\", { attach: \"geometry\", args: [shape] })));\n};\nvar SVGAsset = react__WEBPACK_IMPORTED_MODULE_1__.memo(function (props) {\n    var paths = (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aD)(SVGLoader, props.url).paths;\n    var shapes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return paths.flatMap(function (path, index) {\n            return path\n                .toShapes(true)\n                .map(function (shape) { return ({ index: index, shape: shape, color: path.color }); });\n        });\n    }, [paths]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", { children: shapes.map(function (newProps, key) { return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGShape, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ key: key, opacity: props.opacity }, newProps))); }), scale: [\n            -0.01 * props.scale[0],\n            0.01 * props.scale[1],\n            0.01 * props.scale[2],\n        ], position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]] }));\n});\nvar Loader = function (props) {\n    var ext = props.filename.split('.').pop().toLowerCase();\n    var url = props.filename;\n    url = \"retrieve/\" + url;\n    switch (ext) {\n        case 'stl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(STLAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'gltf':\n        case 'glb':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(GLTFAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'dae':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'obj':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(OBJAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'wrl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(VRMLAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'pcd':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PCDAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'ply':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PLYAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'fbx':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(FBXAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'svg':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        default:\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_84678bd5_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\n//# sourceMappingURL=Loader-2173b0c5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvTG9hZGVyLTIxNzNiMGM1LmpzP2Y4MzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUF3ekQ7QUFDN3ZEO0FBQ3hDOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUYsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxzREFBYTs7QUFFZDs7QUFFQSxvREFBb0QsMkRBQWtCOztBQUV0RTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsNERBQXNCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBLGNBQWMsaURBQWE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLE9BQU87O0FBRXpDLGlDQUFpQztBQUNqQzs7QUFFQSxnQkFBZ0IsZ0JBQWdCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHVDQUF1Qzs7QUFFbEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixpREFBTzs7QUFFbEMsSUFBSTs7QUFFSiwyQkFBMkIsaURBQU87O0FBRWxDOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDtBQUNBLDBCQUEwQixpREFBTzs7QUFFakMsd0JBQXdCLHVDQUF1Qzs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTOztBQUV6RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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LHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBLDRCQUE0QixpREFBUTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLGlEQUFLOztBQUUxQjs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztB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O0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFXOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFZOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixrREFBZ0I7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0RBQWM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrREFBTzs7QUFFckIsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7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LEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtGQUFrRjtBQUNsRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsd0RBQXdEO0FBQ3hEOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsNERBQXNCOztBQUVoQzs7QUFFQTs7QUFFQTtB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0NBQWdDOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrREFBSTtBQUN6Qjs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtEQUFJO0FBQ3pCOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixVQUFVOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFPO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELGFBQWE7O0FBRS9EOztBQUVB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7OztBQUdBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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QUFDL0U7QUFDQSxtQkFBbUIsZ0RBQTRCLFlBQVksc0RBQVEsRUFBRSxXQUFXO0FBQ2hGO0FBQ0EsbUJBQW1CLGdEQUE0QixXQUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBLG1CQUFtQixnREFBNEIsV0FBVyxzREFBUSxFQUFFLFdBQVc7QUFDL0U7QUFDQSxtQkFBbUIsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxXQUFXO0FBQy9FO0FBQ0EsbUJBQW1CLGdEQUE0QixXQUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBLG1CQUFtQixnREFBNEIsZUFBZSxzREFBUSxFQUFFLFdBQVc7QUFDbkY7QUFDQTs7QUFFQSwrREFBZSxNQUFNLEVBQUM7QUFDdEIiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9Mb2FkZXItMjE3M2IwYzUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMIGFzIExvYWRlciQxLCBGIGFzIEZpbGVMb2FkZXIsIEIgYXMgQnVmZmVyR2VvbWV0cnksIGMgYXMgQnVmZmVyQXR0cmlidXRlLCBWIGFzIFZlY3RvcjMsIGQgYXMgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgZiBhcyBMb2FkZXJVdGlscywgZyBhcyBNZXNoQmFzaWNNYXRlcmlhbCwgQyBhcyBDb2xvciwgaCBhcyBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgaSBhcyBUYW5nZW50U3BhY2VOb3JtYWxNYXAsIEkgYXMgSW1hZ2VCaXRtYXBMb2FkZXIsIGogYXMgVGV4dHVyZUxvYWRlciwgayBhcyBJbnRlcmxlYXZlZEJ1ZmZlciwgbCBhcyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgUiBhcyBSR0JGb3JtYXQsIG0gYXMgTGluZWFyRmlsdGVyLCBuIGFzIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgbyBhcyBSZXBlYXRXcmFwcGluZywgUCBhcyBQb2ludHNNYXRlcmlhbCwgcCBhcyBNYXRlcmlhbCwgcSBhcyBMaW5lQmFzaWNNYXRlcmlhbCwgRCBhcyBEb3VibGVTaWRlLCBhIGFzIFZlY3RvcjIsIHMgYXMgc1JHQkVuY29kaW5nLCByIGFzIFByb3BlcnR5QmluZGluZywgdCBhcyBTa2lubmVkTWVzaCwgdiBhcyBNZXNoLCB3IGFzIExpbmVTZWdtZW50cywgeCBhcyBMaW5lLCB5IGFzIExpbmVMb29wLCB6IGFzIFBvaW50cywgRyBhcyBHcm91cCwgQSBhcyBQZXJzcGVjdGl2ZUNhbWVyYSwgSCBhcyBNYXRoVXRpbHMsIE8gYXMgT3J0aG9ncmFwaGljQ2FtZXJhLCBKIGFzIEludGVycG9sYXRlTGluZWFyLCBLIGFzIEFuaW1hdGlvbkNsaXAsIE4gYXMgQm9uZSwgVSBhcyBPYmplY3QzRCwgVyBhcyBNYXRyaXg0LCBYIGFzIFNrZWxldG9uLCBZIGFzIFNwb3RMaWdodCwgWiBhcyBQb2ludExpZ2h0LCBfIGFzIERpcmVjdGlvbmFsTGlnaHQsICQgYXMgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIGEwIGFzIEludGVycG9sYW50LCBhMSBhcyBOZWFyZXN0RmlsdGVyLCBhMiBhcyBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciwgYTMgYXMgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgYTQgYXMgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgYTUgYXMgQ2xhbXBUb0VkZ2VXcmFwcGluZywgYTYgYXMgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgYTcgYXMgSW50ZXJwb2xhdGVEaXNjcmV0ZSwgYTggYXMgRnJvbnRTaWRlLCBhOSBhcyBDYW52YXNUZXh0dXJlLCBhYSBhcyBUcmlhbmdsZUZhbkRyYXdNb2RlLCBhYiBhcyBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIGFjIGFzIFZlY3RvcktleWZyYW1lVHJhY2ssIGFkIGFzIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBhZSBhcyBOdW1iZXJLZXlmcmFtZVRyYWNrLCBhZiBhcyBCb3gzLCBhZyBhcyBTcGhlcmUsIGFoIGFzIFRleHR1cmUsIFEgYXMgUXVhdGVybmlvbiwgYWkgYXMgU2NlbmUsIGFqIGFzIEV1bGVyLCBhayBhcyBNZXNoTGFtYmVydE1hdGVyaWFsLCBhbCBhcyBNZXNoUGhvbmdNYXRlcmlhbCwgYW0gYXMgQW1iaWVudExpZ2h0LCBhbiBhcyBEZWZhdWx0TG9hZGluZ01hbmFnZXIsIGFvIGFzIFNwaGVyZUdlb21ldHJ5LCBhcCBhcyBCYWNrU2lkZSwgYXEgYXMgRGF0YVRleHR1cmUsIGFyIGFzIFJHQkFGb3JtYXQsIGFzIGFzIEJveEdlb21ldHJ5LCBhdCBhcyBDb25lR2VvbWV0cnksIGF1IGFzIEN5bGluZGVyR2VvbWV0cnksIGF2IGFzIFNoYXBlVXRpbHMsIGF3IGFzIFZlY3RvcjQsIGF4IGFzIEN1cnZlLCBheSBhcyBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgYXogYXMgVWludDE2QnVmZmVyQXR0cmlidXRlLCBhQSBhcyBNYXRyaXgzLCBhQiBhcyBTaGFwZVBhdGgsIGFDIGFzIFBhdGgsIGFEIGFzIHVzZUxvYWRlciwgYUUgYXMgX19hc3NpZ24gfSBmcm9tICcuL2luZGV4LTg0Njc4YmQ1LmpzJztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogRGVzY3JpcHRpb246IEEgVEhSRUUgbG9hZGVyIGZvciBTVEwgQVNDSUkgZmlsZXMsIGFzIGNyZWF0ZWQgYnkgU29saWR3b3JrcyBhbmQgb3RoZXIgQ0FEIHByb2dyYW1zLlxuICpcbiAqIFN1cHBvcnRzIGJvdGggYmluYXJ5IGFuZCBBU0NJSSBlbmNvZGVkIGZpbGVzLCB3aXRoIGF1dG9tYXRpYyBkZXRlY3Rpb24gb2YgdHlwZS5cbiAqXG4gKiBUaGUgbG9hZGVyIHJldHVybnMgYSBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnkuXG4gKlxuICogTGltaXRhdGlvbnM6XG4gKiAgQmluYXJ5IGRlY29kaW5nIHN1cHBvcnRzIFwiTWFnaWNzXCIgY29sb3IgZm9ybWF0IChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NUTF8oZmlsZV9mb3JtYXQpI0NvbG9yX2luX2JpbmFyeV9TVEwpLlxuICogIFRoZXJlIGlzIHBlcmhhcHMgc29tZSBxdWVzdGlvbiBhcyB0byBob3cgdmFsaWQgaXQgaXMgdG8gYWx3YXlzIGFzc3VtZSBsaXR0bGUtZW5kaWFuLW5lc3MuXG4gKiAgQVNDSUkgZGVjb2RpbmcgYXNzdW1lcyBmaWxlIGlzIFVURi04LlxuICpcbiAqIFVzYWdlOlxuICogIHZhciBsb2FkZXIgPSBuZXcgU1RMTG9hZGVyKCk7XG4gKiAgbG9hZGVyLmxvYWQoICcuL21vZGVscy9zdGwvc2xvdHRlZF9kaXNrLnN0bCcsIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG4gKiAgICBzY2VuZS5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSApICk7XG4gKiAgfSk7XG4gKlxuICogRm9yIGJpbmFyeSBTVExzIGdlb21ldHJ5IG1pZ2h0IGNvbnRhaW4gY29sb3JzIGZvciB2ZXJ0aWNlcy4gVG8gdXNlIGl0OlxuICogIC8vIHVzZSB0aGUgc2FtZSBjb2RlIHRvIGxvYWQgU1RMIGFzIGFib3ZlXG4gKiAgaWYgKGdlb21ldHJ5Lmhhc0NvbG9ycykge1xuICogICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoeyBvcGFjaXR5OiBnZW9tZXRyeS5hbHBoYSwgdmVydGV4Q29sb3JzOiB0cnVlIH0pO1xuICogIH0gZWxzZSB7IC4uLi4gfVxuICogIHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICpcbiAqIEZvciBBU0NJSSBTVExzIGNvbnRhaW5pbmcgbXVsdGlwbGUgc29saWRzLCBlYWNoIHNvbGlkIGlzIGFzc2lnbmVkIHRvIGEgZGlmZmVyZW50IGdyb3VwLlxuICogR3JvdXBzIGNhbiBiZSB1c2VkIHRvIGFzc2lnbiBhIGRpZmZlcmVudCBjb2xvciBieSBkZWZpbmluZyBhbiBhcnJheSBvZiBtYXRlcmlhbHMgd2l0aCB0aGUgc2FtZSBsZW5ndGggb2ZcbiAqIGdlb21ldHJ5Lmdyb3VwcyBhbmQgcGFzc2luZyBpdCB0byB0aGUgTWVzaCBjb25zdHJ1Y3RvcjpcbiAqXG4gKiB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIG1hdGVyaWFscyA9IFtdO1xuICogIHZhciBuR2VvbWV0cnlHcm91cHMgPSBnZW9tZXRyeS5ncm91cHMubGVuZ3RoO1xuICpcbiAqICB2YXIgY29sb3JNYXAgPSAuLi47IC8vIFNvbWUgbG9naWMgdG8gaW5kZXggY29sb3JzLlxuICpcbiAqICBmb3IgKHZhciBpID0gMDsgaSA8IG5HZW9tZXRyeUdyb3VwczsgaSsrKSB7XG4gKlxuICpcdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcbiAqXHRcdFx0Y29sb3I6IGNvbG9yTWFwW2ldLFxuICpcdFx0XHR3aXJlZnJhbWU6IGZhbHNlXG4gKlx0XHR9KTtcbiAqXG4gKiAgfVxuICpcbiAqICBtYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7XG4gKiAgdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWxzKTtcbiAqL1xuXG5cbnZhciBTVExMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG59O1xuXG5TVExMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogU1RMTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0ZnVuY3Rpb24gaXNCaW5hcnkoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBleHBlY3QsIGZhY2Vfc2l6ZSwgbl9mYWNlcywgcmVhZGVyO1xuXHRcdFx0cmVhZGVyID0gbmV3IERhdGFWaWV3KCBkYXRhICk7XG5cdFx0XHRmYWNlX3NpemUgPSAoIDMyIC8gOCAqIDMgKSArICggKCAzMiAvIDggKiAzICkgKiAzICkgKyAoIDE2IC8gOCApO1xuXHRcdFx0bl9mYWNlcyA9IHJlYWRlci5nZXRVaW50MzIoIDgwLCB0cnVlICk7XG5cdFx0XHRleHBlY3QgPSA4MCArICggMzIgLyA4ICkgKyAoIG5fZmFjZXMgKiBmYWNlX3NpemUgKTtcblxuXHRcdFx0aWYgKCBleHBlY3QgPT09IHJlYWRlci5ieXRlTGVuZ3RoICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFuIEFTQ0lJIFNUTCBkYXRhIG11c3QgYmVnaW4gd2l0aCAnc29saWQgJyBhcyB0aGUgZmlyc3Qgc2l4IGJ5dGVzLlxuXHRcdFx0Ly8gSG93ZXZlciwgQVNDSUkgU1RMcyBsYWNraW5nIHRoZSBTUEFDRSBhZnRlciB0aGUgJ2QnIGFyZSBrbm93biB0byBiZVxuXHRcdFx0Ly8gcGxlbnRpZnVsLiAgU28sIGNoZWNrIHRoZSBmaXJzdCA1IGJ5dGVzIGZvciAnc29saWQnLlxuXG5cdFx0XHQvLyBTZXZlcmFsIGVuY29kaW5ncywgc3VjaCBhcyBVVEYtOCwgcHJlY2VkZSB0aGUgdGV4dCB3aXRoIHVwIHRvIDUgYnl0ZXM6XG5cdFx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CeXRlX29yZGVyX21hcmsjQnl0ZV9vcmRlcl9tYXJrc19ieV9lbmNvZGluZ1xuXHRcdFx0Ly8gU2VhcmNoIGZvciBcInNvbGlkXCIgdG8gc3RhcnQgYW55d2hlcmUgYWZ0ZXIgdGhvc2UgcHJlZml4ZXMuXG5cblx0XHRcdC8vIFVTLUFTQ0lJIG9yZGluYWwgdmFsdWVzIGZvciAncycsICdvJywgJ2wnLCAnaScsICdkJ1xuXG5cdFx0XHR2YXIgc29saWQgPSBbIDExNSwgMTExLCAxMDgsIDEwNSwgMTAwIF07XG5cblx0XHRcdGZvciAoIHZhciBvZmYgPSAwOyBvZmYgPCA1OyBvZmYgKysgKSB7XG5cblx0XHRcdFx0Ly8gSWYgXCJzb2xpZFwiIHRleHQgaXMgbWF0Y2hlZCB0byB0aGUgY3VycmVudCBvZmZzZXQsIGRlY2xhcmUgaXQgdG8gYmUgYW4gQVNDSUkgU1RMLlxuXG5cdFx0XHRcdGlmICggbWF0Y2hEYXRhVmlld0F0KCBzb2xpZCwgcmVhZGVyLCBvZmYgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3VsZG4ndCBmaW5kIFwic29saWRcIiB0ZXh0IGF0IHRoZSBiZWdpbm5pbmc7IGl0IGlzIGJpbmFyeSBTVEwuXG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWF0Y2hEYXRhVmlld0F0KCBxdWVyeSwgcmVhZGVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdC8vIENoZWNrIGlmIGVhY2ggYnl0ZSBpbiBxdWVyeSBtYXRjaGVzIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGUgZnJvbSB0aGUgY3VycmVudCBvZmZzZXRcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcXVlcnlbIGkgXSAhPT0gcmVhZGVyLmdldFVpbnQ4KCBvZmZzZXQgKyBpLCBmYWxzZSApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VCaW5hcnkoIGRhdGEgKSB7XG5cblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRGF0YVZpZXcoIGRhdGEgKTtcblx0XHRcdHZhciBmYWNlcyA9IHJlYWRlci5nZXRVaW50MzIoIDgwLCB0cnVlICk7XG5cblx0XHRcdHZhciByLCBnLCBiLCBoYXNDb2xvcnMgPSBmYWxzZSwgY29sb3JzO1xuXHRcdFx0dmFyIGRlZmF1bHRSLCBkZWZhdWx0RywgZGVmYXVsdEIsIGFscGhhO1xuXG5cdFx0XHQvLyBwcm9jZXNzIFNUTCBoZWFkZXJcblx0XHRcdC8vIGNoZWNrIGZvciBkZWZhdWx0IGNvbG9yIGluIGhlYWRlciAoXCJDT0xPUj1yZ2JhXCIgc2VxdWVuY2UpLlxuXG5cdFx0XHRmb3IgKCB2YXIgaW5kZXggPSAwOyBpbmRleCA8IDgwIC0gMTA7IGluZGV4ICsrICkge1xuXG5cdFx0XHRcdGlmICggKCByZWFkZXIuZ2V0VWludDMyKCBpbmRleCwgZmFsc2UgKSA9PSAweDQzNEY0QzRGIC8qQ09MTyovICkgJiZcblx0XHRcdFx0XHQoIHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA0ICkgPT0gMHg1MiAvKidSJyovICkgJiZcblx0XHRcdFx0XHQoIHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA1ICkgPT0gMHgzRCAvKic9JyovICkgKSB7XG5cblx0XHRcdFx0XHRoYXNDb2xvcnMgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzICogMyAqIDMgKTtcblxuXHRcdFx0XHRcdGRlZmF1bHRSID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDYgKSAvIDI1NTtcblx0XHRcdFx0XHRkZWZhdWx0RyA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA3ICkgLyAyNTU7XG5cdFx0XHRcdFx0ZGVmYXVsdEIgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgOCApIC8gMjU1O1xuXHRcdFx0XHRcdGFscGhhID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDkgKSAvIDI1NTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRhdGFPZmZzZXQgPSA4NDtcblx0XHRcdHZhciBmYWNlTGVuZ3RoID0gMTIgKiA0ICsgMjtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGZhY2VzICogMyAqIDMgKTtcblx0XHRcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlczsgZmFjZSArKyApIHtcblxuXHRcdFx0XHR2YXIgc3RhcnQgPSBkYXRhT2Zmc2V0ICsgZmFjZSAqIGZhY2VMZW5ndGg7XG5cdFx0XHRcdHZhciBub3JtYWxYID0gcmVhZGVyLmdldEZsb2F0MzIoIHN0YXJ0LCB0cnVlICk7XG5cdFx0XHRcdHZhciBub3JtYWxZID0gcmVhZGVyLmdldEZsb2F0MzIoIHN0YXJ0ICsgNCwgdHJ1ZSApO1xuXHRcdFx0XHR2YXIgbm9ybWFsWiA9IHJlYWRlci5nZXRGbG9hdDMyKCBzdGFydCArIDgsIHRydWUgKTtcblxuXHRcdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRcdHZhciBwYWNrZWRDb2xvciA9IHJlYWRlci5nZXRVaW50MTYoIHN0YXJ0ICsgNDgsIHRydWUgKTtcblxuXHRcdFx0XHRcdGlmICggKCBwYWNrZWRDb2xvciAmIDB4ODAwMCApID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmYWNldCBoYXMgaXRzIG93biB1bmlxdWUgY29sb3JcblxuXHRcdFx0XHRcdFx0ciA9ICggcGFja2VkQ29sb3IgJiAweDFGICkgLyAzMTtcblx0XHRcdFx0XHRcdGcgPSAoICggcGFja2VkQ29sb3IgPj4gNSApICYgMHgxRiApIC8gMzE7XG5cdFx0XHRcdFx0XHRiID0gKCAoIHBhY2tlZENvbG9yID4+IDEwICkgJiAweDFGICkgLyAzMTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHIgPSBkZWZhdWx0Ujtcblx0XHRcdFx0XHRcdGcgPSBkZWZhdWx0Rztcblx0XHRcdFx0XHRcdGIgPSBkZWZhdWx0QjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4c3RhcnQgPSBzdGFydCArIGkgKiAxMjtcblx0XHRcdFx0XHR2YXIgY29tcG9uZW50SWR4ID0gKCBmYWNlICogMyAqIDMgKSArICggKCBpIC0gMSApICogMyApO1xuXG5cdFx0XHRcdFx0dmVydGljZXNbIGNvbXBvbmVudElkeCBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0LCB0cnVlICk7XG5cdFx0XHRcdFx0dmVydGljZXNbIGNvbXBvbmVudElkeCArIDEgXSA9IHJlYWRlci5nZXRGbG9hdDMyKCB2ZXJ0ZXhzdGFydCArIDQsIHRydWUgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4ICsgMiBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0ICsgOCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4IF0gPSBub3JtYWxYO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGNvbXBvbmVudElkeCArIDEgXSA9IG5vcm1hbFk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4ICsgMiBdID0gbm9ybWFsWjtcblxuXHRcdFx0XHRcdGlmICggaGFzQ29sb3JzICkge1xuXG5cdFx0XHRcdFx0XHRjb2xvcnNbIGNvbXBvbmVudElkeCBdID0gcjtcblx0XHRcdFx0XHRcdGNvbG9yc1sgY29tcG9uZW50SWR4ICsgMSBdID0gZztcblx0XHRcdFx0XHRcdGNvbG9yc1sgY29tcG9uZW50SWR4ICsgMiBdID0gYjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0aWYgKCBoYXNDb2xvcnMgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXHRcdFx0XHRnZW9tZXRyeS5oYXNDb2xvcnMgPSB0cnVlO1xuXHRcdFx0XHRnZW9tZXRyeS5hbHBoYSA9IGFscGhhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQVNDSUkoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dmFyIHBhdHRlcm5Tb2xpZCA9IC9zb2xpZChbXFxzXFxTXSo/KWVuZHNvbGlkL2c7XG5cdFx0XHR2YXIgcGF0dGVybkZhY2UgPSAvZmFjZXQoW1xcc1xcU10qPyllbmRmYWNldC9nO1xuXHRcdFx0dmFyIGZhY2VDb3VudGVyID0gMDtcblxuXHRcdFx0dmFyIHBhdHRlcm5GbG9hdCA9IC9bXFxzXSsoWystXT8oPzpcXGQqKSg/OlxcLlxcZCopPyg/OltlRV1bKy1dP1xcZCspPykvLnNvdXJjZTtcblx0XHRcdHZhciBwYXR0ZXJuVmVydGV4ID0gbmV3IFJlZ0V4cCggJ3ZlcnRleCcgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQsICdnJyApO1xuXHRcdFx0dmFyIHBhdHRlcm5Ob3JtYWwgPSBuZXcgUmVnRXhwKCAnbm9ybWFsJyArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCwgJ2cnICk7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcblxuXHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdHZhciBncm91cENvdW50ID0gMDtcblx0XHRcdHZhciBzdGFydFZlcnRleCA9IDA7XG5cdFx0XHR2YXIgZW5kVmVydGV4ID0gMDtcblxuXHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5Tb2xpZC5leGVjKCBkYXRhICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRzdGFydFZlcnRleCA9IGVuZFZlcnRleDtcblxuXHRcdFx0XHR2YXIgc29saWQgPSByZXN1bHRbIDAgXTtcblxuXHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVybkZhY2UuZXhlYyggc29saWQgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dmFyIHZlcnRleENvdW50UGVyRmFjZSA9IDA7XG5cdFx0XHRcdFx0dmFyIG5vcm1hbENvdW50UGVyRmFjZSA9IDA7XG5cblx0XHRcdFx0XHR2YXIgdGV4dCA9IHJlc3VsdFsgMCBdO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5Ob3JtYWwuZXhlYyggdGV4dCApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbC54ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbC55ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbC56ID0gcGFyc2VGbG9hdCggcmVzdWx0WyAzIF0gKTtcblx0XHRcdFx0XHRcdG5vcm1hbENvdW50UGVyRmFjZSArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuVmVydGV4LmV4ZWMoIHRleHQgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLCBwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApLCBwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApICk7XG5cdFx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblx0XHRcdFx0XHRcdHZlcnRleENvdW50UGVyRmFjZSArKztcblx0XHRcdFx0XHRcdGVuZFZlcnRleCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGV2ZXJ5IGZhY2UgaGF2ZSB0byBvd24gT05FIHZhbGlkIG5vcm1hbFxuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxDb3VudFBlckZhY2UgIT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TVExMb2FkZXI6IFNvbWV0aGluZyBpc25cXCd0IHJpZ2h0IHdpdGggdGhlIG5vcm1hbCBvZiBmYWNlIG51bWJlciAnICsgZmFjZUNvdW50ZXIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVhY2ggZmFjZSBoYXZlIHRvIG93biBUSFJFRSB2YWxpZCB2ZXJ0aWNlc1xuXG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb3VudFBlckZhY2UgIT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TVExMb2FkZXI6IFNvbWV0aGluZyBpc25cXCd0IHJpZ2h0IHdpdGggdGhlIHZlcnRpY2VzIG9mIGZhY2UgbnVtYmVyICcgKyBmYWNlQ291bnRlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZmFjZUNvdW50ZXIgKys7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzdGFydCA9IHN0YXJ0VmVydGV4O1xuXHRcdFx0XHR2YXIgY291bnQgPSBlbmRWZXJ0ZXggLSBzdGFydFZlcnRleDtcblxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggc3RhcnQsIGNvdW50LCBncm91cENvdW50ICk7XG5cdFx0XHRcdGdyb3VwQ291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbnN1cmVTdHJpbmcoIGJ1ZmZlciApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgYnVmZmVyICE9PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHRyZXR1cm4gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuc3VyZUJpbmFyeSggYnVmZmVyICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdHZhciBhcnJheV9idWZmZXIgPSBuZXcgVWludDhBcnJheSggYnVmZmVyLmxlbmd0aCApO1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXlfYnVmZmVyWyBpIF0gPSBidWZmZXIuY2hhckNvZGVBdCggaSApICYgMHhmZjsgLy8gaW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW5cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5X2J1ZmZlci5idWZmZXIgfHwgYXJyYXlfYnVmZmVyO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHN0YXJ0XG5cblx0XHR2YXIgYmluRGF0YSA9IGVuc3VyZUJpbmFyeSggZGF0YSApO1xuXG5cdFx0cmV0dXJuIGlzQmluYXJ5KCBiaW5EYXRhICkgPyBwYXJzZUJpbmFyeSggYmluRGF0YSApIDogcGFyc2VBU0NJSSggZW5zdXJlU3RyaW5nKCBkYXRhICkgKTtcblxuXHR9XG5cbn0gKTtcblxudmFyIEdMVEZMb2FkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRmdW5jdGlvbiBHTFRGTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdFx0dGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG5cdFx0dGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcblx0XHR0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcblxuXHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzID0gW107XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZMaWdodHNFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURk1lc2hvcHRDb21wcmVzc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdEdMVEZMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBHTFRGTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHJlc291cmNlUGF0aDtcblxuXHRcdFx0aWYgKCB0aGlzLnJlc291cmNlUGF0aCAhPT0gJycgKSB7XG5cblx0XHRcdFx0cmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMucGF0aCAhPT0gJycgKSB7XG5cblx0XHRcdFx0cmVzb3VyY2VQYXRoID0gdGhpcy5wYXRoO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlc291cmNlUGF0aCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUZWxscyB0aGUgTG9hZGluZ01hbmFnZXIgdG8gdHJhY2sgYW4gZXh0cmEgaXRlbSwgd2hpY2ggcmVzb2x2ZXMgYWZ0ZXJcblx0XHRcdC8vIHRoZSBtb2RlbCBpcyBmdWxseSBsb2FkZWQuIFRoaXMgbWVhbnMgdGhlIGNvdW50IG9mIGl0ZW1zIGxvYWRlZCB3aWxsXG5cdFx0XHQvLyBiZSBpbmNvcnJlY3QsIGJ1dCBlbnN1cmVzIG1hbmFnZXIub25Mb2FkKCkgZG9lcyBub3QgZmlyZSBlYXJseS5cblx0XHRcdHRoaXMubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHR2YXIgX29uRXJyb3IgPSBmdW5jdGlvbiAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblxuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRzY29wZS5wYXJzZSggZGF0YSwgcmVzb3VyY2VQYXRoLCBmdW5jdGlvbiAoIGdsdGYgKSB7XG5cblx0XHRcdFx0XHRcdG9uTG9hZCggZ2x0ZiApO1xuXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHRcdFx0fSwgX29uRXJyb3IgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdF9vbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBfb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHNldERSQUNPTG9hZGVyOiBmdW5jdGlvbiAoIGRyYWNvTG9hZGVyICkge1xuXG5cdFx0XHR0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRzZXRERFNMb2FkZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXG5cdFx0XHRcdCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJ1xuXG5cdFx0XHQpO1xuXG5cdFx0fSxcblxuXHRcdHNldEtUWDJMb2FkZXI6IGZ1bmN0aW9uICgga3R4MkxvYWRlciApIHtcblxuXHRcdFx0dGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldE1lc2hvcHREZWNvZGVyOiBmdW5jdGlvbiAoIG1lc2hvcHREZWNvZGVyICkge1xuXG5cdFx0XHR0aGlzLm1lc2hvcHREZWNvZGVyID0gbWVzaG9wdERlY29kZXI7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRyZWdpc3RlcjogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKCBjYWxsYmFjayApID09PSAtIDEgKSB7XG5cblx0XHRcdFx0dGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaCggY2FsbGJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHR1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRpZiAoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICksIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCBkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBjb250ZW50O1xuXHRcdFx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblx0XHRcdHZhciBwbHVnaW5zID0ge307XG5cblx0XHRcdGlmICggdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdGNvbnRlbnQgPSBkYXRhO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBtYWdpYyA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhLCAwLCA0ICkgKTtcblxuXHRcdFx0XHRpZiAoIG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyApIHtcblxuXHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbiggZGF0YSApO1xuXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlcnJvciApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGVudCA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uY29udGVudDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29udGVudCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCBjb250ZW50ICk7XG5cblx0XHRcdGlmICgganNvbi5hc3NldCA9PT0gdW5kZWZpbmVkIHx8IGpzb24uYXNzZXQudmVyc2lvblsgMCBdIDwgMiApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBhc3NldC4gZ2xURiB2ZXJzaW9ucyA+PTIuMCBhcmUgc3VwcG9ydGVkLicgKSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcnNlciA9IG5ldyBHTFRGUGFyc2VyKCBqc29uLCB7XG5cblx0XHRcdFx0cGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCAnJyxcblx0XHRcdFx0Y3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG5cdFx0XHRcdHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcblx0XHRcdFx0bWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuXHRcdFx0XHRrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG5cdFx0XHRcdG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5DYWxsYmFja3NbIGkgXSggcGFyc2VyICk7XG5cdFx0XHRcdHBsdWdpbnNbIHBsdWdpbi5uYW1lIF0gPSBwbHVnaW47XG5cblx0XHRcdFx0Ly8gV29ya2Fyb3VuZCB0byBhdm9pZCBkZXRlcm1pbmluZyBhcyB1bmtub3duIGV4dGVuc2lvblxuXHRcdFx0XHQvLyBpbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoKS5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCBpZiB3ZSBtb3ZlIGFsbCB0aGUgZXhpc3Rpbmdcblx0XHRcdFx0Ly8gZXh0ZW5zaW9uIGhhbmRsZXJzIHRvIHBsdWdpbiBzeXN0ZW1cblx0XHRcdFx0ZXh0ZW5zaW9uc1sgcGx1Z2luLm5hbWUgXSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNVc2VkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRcdFx0dmFyIGV4dGVuc2lvbk5hbWUgPSBqc29uLmV4dGVuc2lvbnNVc2VkWyBpIF07XG5cdFx0XHRcdFx0dmFyIGV4dGVuc2lvbnNSZXF1aXJlZCA9IGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZXh0ZW5zaW9uTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ6XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURk1hdGVyaWFsc1BiclNwZWN1bGFyR2xvc3NpbmVzc0V4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKCBqc29uLCB0aGlzLmRyYWNvTG9hZGVyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNOlxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb25zWyBleHRlbnNpb25OYW1lIF0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCBleHRlbnNpb25OYW1lICkgPj0gMCAmJiBwbHVnaW5zWyBleHRlbnNpb25OYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IFVua25vd24gZXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIuJyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLnNldEV4dGVuc2lvbnMoIGV4dGVuc2lvbnMgKTtcblx0XHRcdHBhcnNlci5zZXRQbHVnaW5zKCBwbHVnaW5zICk7XG5cdFx0XHRwYXJzZXIucGFyc2UoIG9uTG9hZCwgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHQvKiBHTFRGUkVHSVNUUlkgKi9cblxuXHRmdW5jdGlvbiBHTFRGUmVnaXN0cnkoKSB7XG5cblx0XHR2YXIgb2JqZWN0cyA9IHt9O1xuXG5cdFx0cmV0dXJuXHR7XG5cblx0XHRcdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdHNbIGtleSBdO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBvYmplY3QgKSB7XG5cblx0XHRcdFx0b2JqZWN0c1sga2V5IF0gPSBvYmplY3Q7XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdFx0ZGVsZXRlIG9iamVjdHNbIGtleSBdO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRvYmplY3RzID0ge307XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqIEVYVEVOU0lPTlMgKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0dmFyIEVYVEVOU0lPTlMgPSB7XG5cdFx0S0hSX0JJTkFSWV9HTFRGOiAnS0hSX2JpbmFyeV9nbFRGJyxcblx0XHRLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjogJ0tIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uJyxcblx0XHRLSFJfTElHSFRTX1BVTkNUVUFMOiAnS0hSX2xpZ2h0c19wdW5jdHVhbCcsXG5cdFx0S0hSX01BVEVSSUFMU19DTEVBUkNPQVQ6ICdLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdCcsXG5cdFx0S0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUzogJ0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzJyxcblx0XHRLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogJ0tIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uJyxcblx0XHRLSFJfTUFURVJJQUxTX1VOTElUOiAnS0hSX21hdGVyaWFsc191bmxpdCcsXG5cdFx0S0hSX1RFWFRVUkVfQkFTSVNVOiAnS0hSX3RleHR1cmVfYmFzaXN1Jyxcblx0XHRLSFJfVEVYVFVSRV9UUkFOU0ZPUk06ICdLSFJfdGV4dHVyZV90cmFuc2Zvcm0nLFxuXHRcdEtIUl9NRVNIX1FVQU5USVpBVElPTjogJ0tIUl9tZXNoX3F1YW50aXphdGlvbicsXG5cdFx0RVhUX1RFWFRVUkVfV0VCUDogJ0VYVF90ZXh0dXJlX3dlYnAnLFxuXHRcdEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OOiAnRVhUX21lc2hvcHRfY29tcHJlc3Npb24nXG5cdH07XG5cblx0LyoqXG5cdCAqIFB1bmN0dWFsIExpZ2h0cyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2xpZ2h0c19wdW5jdHVhbFxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURkxpZ2h0c0V4dGVuc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMO1xuXG5cdFx0Ly8gT2JqZWN0M0QgaW5zdGFuY2UgY2FjaGVzXG5cdFx0dGhpcy5jYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cblx0fVxuXG5cdEdMVEZMaWdodHNFeHRlbnNpb24ucHJvdG90eXBlLl9tYXJrRGVmcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuXG5cdFx0Zm9yICggdmFyIG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0dmFyIG5vZGVEZWYgPSBub2RlRGVmc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdGlmICggbm9kZURlZi5leHRlbnNpb25zXG5cdFx0XHRcdCYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF1cblx0XHRcdFx0JiYgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5saWdodCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBhcnNlci5fYWRkTm9kZVJlZiggdGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5saWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRHTFRGTGlnaHRzRXh0ZW5zaW9uLnByb3RvdHlwZS5fbG9hZExpZ2h0ID0gZnVuY3Rpb24gKCBsaWdodEluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBjYWNoZUtleSA9ICdsaWdodDonICsgbGlnaHRJbmRleDtcblx0XHR2YXIgZGVwZW5kZW5jeSA9IHBhcnNlci5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRpZiAoIGRlcGVuZGVuY3kgKSByZXR1cm4gZGVwZW5kZW5jeTtcblxuXHRcdHZhciBqc29uID0gcGFyc2VyLmpzb247XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSAoIGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgfHwge307XG5cdFx0dmFyIGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuXHRcdHZhciBsaWdodERlZiA9IGxpZ2h0RGVmc1sgbGlnaHRJbmRleCBdO1xuXHRcdHZhciBsaWdodE5vZGU7XG5cblx0XHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmNvbG9yICE9PSB1bmRlZmluZWQgKSBjb2xvci5mcm9tQXJyYXkoIGxpZ2h0RGVmLmNvbG9yICk7XG5cblx0XHR2YXIgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuXG5cdFx0c3dpdGNoICggbGlnaHREZWYudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnZGlyZWN0aW9uYWwnOlxuXHRcdFx0XHRsaWdodE5vZGUgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCggY29sb3IgKTtcblx0XHRcdFx0bGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoIDAsIDAsIC0gMSApO1xuXHRcdFx0XHRsaWdodE5vZGUuYWRkKCBsaWdodE5vZGUudGFyZ2V0ICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdwb2ludCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRsaWdodE5vZGUgPSBuZXcgU3BvdExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcblx0XHRcdFx0Ly8gSGFuZGxlIHNwb3RsaWdodCBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcblx0XHRcdFx0bGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHVuZGVmaW5lZCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuXHRcdFx0XHRsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0LjA7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5wZW51bWJyYSA9IDEuMCAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuZXhwZWN0ZWQgbGlnaHQgdHlwZTogJyArIGxpZ2h0RGVmLnR5cGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIFNvbWUgbGlnaHRzIChlLmcuIHNwb3QpIGRlZmF1bHQgdG8gYSBwb3NpdGlvbiBvdGhlciB0aGFuIHRoZSBvcmlnaW4uIFJlc2V0IHRoZSBwb3NpdGlvblxuXHRcdC8vIGhlcmUsIGJlY2F1c2Ugbm9kZS1sZXZlbCBwYXJzaW5nIHdpbGwgb25seSBvdmVycmlkZSBwb3NpdGlvbiBpZiBleHBsaWNpdGx5IHNwZWNpZmllZC5cblx0XHRsaWdodE5vZGUucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XG5cblx0XHRsaWdodE5vZGUuZGVjYXkgPSAyO1xuXG5cdFx0aWYgKCBsaWdodERlZi5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG5cblx0XHRsaWdodE5vZGUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKCBsaWdodERlZi5uYW1lIHx8ICggJ2xpZ2h0XycgKyBsaWdodEluZGV4ICkgKTtcblxuXHRcdGRlcGVuZGVuY3kgPSBQcm9taXNlLnJlc29sdmUoIGxpZ2h0Tm9kZSApO1xuXG5cdFx0cGFyc2VyLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH07XG5cblx0R0xURkxpZ2h0c0V4dGVuc2lvbi5wcm90b3R5cGUuY3JlYXRlTm9kZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAoIG5vZGVJbmRleCApIHtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIGpzb24gPSBwYXJzZXIuanNvbjtcblx0XHR2YXIgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJbmRleCBdO1xuXHRcdHZhciBsaWdodERlZiA9ICggbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB8fCB7fTtcblx0XHR2YXIgbGlnaHRJbmRleCA9IGxpZ2h0RGVmLmxpZ2h0O1xuXG5cdFx0aWYgKCBsaWdodEluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLl9sb2FkTGlnaHQoIGxpZ2h0SW5kZXggKS50aGVuKCBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKCBzZWxmLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFVubGl0IE1hdGVyaWFscyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc191bmxpdFxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUO1xuXG5cdH1cblxuXHRHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ucHJvdG90eXBlLmdldE1hdGVyaWFsVHlwZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcblxuXHR9O1xuXG5cdEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kUGFyYW1zID0gZnVuY3Rpb24gKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlciApIHtcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHR2YXIgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcblxuXHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MgKSB7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQ2xlYXJjb2F0IE1hdGVyaWFscyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19jbGVhcmNvYXRcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ7XG5cblx0fVxuXG5cdEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ucHJvdG90eXBlLmdldE1hdGVyaWFsVHlwZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuXHR9O1xuXG5cdEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ucHJvdG90eXBlLmV4dGVuZE1hdGVyaWFsUGFyYW1zID0gZnVuY3Rpb24gKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdGlmICggISBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuXHRcdH1cblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0ID0gZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvcjtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdjbGVhcmNvYXRNYXAnLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Um91Z2huZXNzID0gZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdjbGVhcmNvYXRSb3VnaG5lc3NNYXAnLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnY2xlYXJjb2F0Tm9ybWFsTWFwJywgZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgKSApO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG5cblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTE0MzgjaXNzdWVjb21tZW50LTUwNzAwMzk5NVxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXROb3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCBzY2FsZSwgLSBzY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc21pc3Npb24gTWF0ZXJpYWxzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblxuXHQgKiBEcmFmdDogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3B1bGwvMTY5OFxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjtcblxuXHR9XG5cblx0R0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxUeXBlID0gZnVuY3Rpb24gKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG5cdH07XG5cblx0R0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdHZhciBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3RyYW5zbWlzc2lvbk1hcCcsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEJhc2lzVSBUZXh0dXJlIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfdGV4dHVyZV9iYXNpc3Vcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcblxuXHR9XG5cblx0R0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdHZhciB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cblx0XHRpZiAoICEgdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICEgdGV4dHVyZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblx0XHR2YXIgc291cmNlID0ganNvbi5pbWFnZXNbIGV4dGVuc2lvbi5zb3VyY2UgXTtcblx0XHR2YXIgbG9hZGVyID0gcGFyc2VyLm9wdGlvbnMua3R4MkxvYWRlcjtcblxuXHRcdGlmICggISBsb2FkZXIgKSB7XG5cblx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggdGhpcy5uYW1lICkgPj0gMCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBzZXRLVFgyTG9hZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIEtUWDIgdGV4dHVyZXMnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lcyB0aGF0IHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwgYW5kIHRoYXQgYSBmYWxsYmFjayB0ZXh0dXJlIGlzIHByZXNlbnRcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSggdGV4dHVyZUluZGV4LCBzb3VyY2UsIGxvYWRlciApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFdlYlAgVGV4dHVyZSBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfdGV4dHVyZV93ZWJwXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcblx0XHR0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcblxuXHR9XG5cblx0R0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uLnByb3RvdHlwZS5sb2FkVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZUluZGV4ICkge1xuXG5cdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBqc29uID0gcGFyc2VyLmpzb247XG5cblx0XHR2YXIgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbIHRleHR1cmVJbmRleCBdO1xuXG5cdFx0aWYgKCAhIHRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhIHRleHR1cmVEZWYuZXh0ZW5zaW9uc1sgbmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHZhciBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblx0XHR2YXIgc291cmNlID0ganNvbi5pbWFnZXNbIGV4dGVuc2lvbi5zb3VyY2UgXTtcblxuXHRcdHZhciBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcblx0XHRpZiAoIHNvdXJjZS51cmkgKSB7XG5cblx0XHRcdHZhciBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKCBzb3VyY2UudXJpICk7XG5cdFx0XHRpZiAoIGhhbmRsZXIgIT09IG51bGwgKSBsb2FkZXIgPSBoYW5kbGVyO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZGV0ZWN0U3VwcG9ydCgpLnRoZW4oIGZ1bmN0aW9uICggaXNTdXBwb3J0ZWQgKSB7XG5cblx0XHRcdGlmICggaXNTdXBwb3J0ZWQgKSByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKTtcblxuXHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCBuYW1lICkgPj0gMCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBXZWJQIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIFBORyBvciBKUEVHLlxuXHRcdFx0cmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZSggdGV4dHVyZUluZGV4ICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHRHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ucHJvdG90eXBlLmRldGVjdFN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoICEgdGhpcy5pc1N1cHBvcnRlZCApIHtcblxuXHRcdFx0dGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUgKSB7XG5cblx0XHRcdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0Ly8gTG9zc3kgdGVzdCBpbWFnZS4gU3VwcG9ydCBmb3IgbG9zc3kgaW1hZ2VzIGRvZXNuJ3QgZ3VhcmFudGVlIHN1cHBvcnQgZm9yIGFsbFxuXHRcdFx0XHQvLyBXZWJQIGltYWdlcywgdW5mb3J0dW5hdGVseS5cblx0XHRcdFx0aW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JpSUFBQUJYUlVKUVZsQTRJQllBQUFBd0FRQ2RBU29CQUFFQURzRCtKYVFBQTNBQUFBQUEnO1xuXG5cdFx0XHRcdGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXNvbHZlKCBpbWFnZS5oZWlnaHQgPT09IDEgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcblxuXHR9O1xuXG5cdC8qKlxuXHQqIG1lc2hvcHQgQnVmZmVyVmlldyBDb21wcmVzc2lvbiBFeHRlbnNpb25cblx0KlxuXHQqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9WZW5kb3IvRVhUX21lc2hvcHRfY29tcHJlc3Npb25cblx0Ki9cblx0ZnVuY3Rpb24gR0xURk1lc2hvcHRDb21wcmVzc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblxuXHR9XG5cblx0R0xURk1lc2hvcHRDb21wcmVzc2lvbi5wcm90b3R5cGUubG9hZEJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuXHRcdHZhciBidWZmZXJWaWV3ID0ganNvbi5idWZmZXJWaWV3c1sgaW5kZXggXTtcblxuXHRcdGlmICggYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlcicsIGV4dGVuc2lvbkRlZi5idWZmZXIgKTtcblx0XHRcdHZhciBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcblxuXHRcdFx0aWYgKCAhIGRlY29kZXIgfHwgISBkZWNvZGVyLnN1cHBvcnRlZCApIHtcblxuXHRcdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIHRoaXMubmFtZSApID49IDAgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBzZXRNZXNob3B0RGVjb2RlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBjb21wcmVzc2VkIGZpbGVzJyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBvcHRpb25hbCBhbmQgdGhhdCBmYWxsYmFjayBidWZmZXIgZGF0YSBpcyBwcmVzZW50XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggWyBidWZmZXIsIGRlY29kZXIucmVhZHkgXSApLnRoZW4oIGZ1bmN0aW9uICggcmVzICkge1xuXG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdFx0dmFyIGJ5dGVMZW5ndGggPSBleHRlbnNpb25EZWYuYnl0ZUxlbmd0aCB8fCAwO1xuXG5cdFx0XHRcdHZhciBjb3VudCA9IGV4dGVuc2lvbkRlZi5jb3VudDtcblx0XHRcdFx0dmFyIHN0cmlkZSA9IGV4dGVuc2lvbkRlZi5ieXRlU3RyaWRlO1xuXG5cdFx0XHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoIGNvdW50ICogc3RyaWRlICk7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBuZXcgVWludDhBcnJheSggcmVzWyAwIF0sIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggKTtcblxuXHRcdFx0XHRkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXIoIG5ldyBVaW50OEFycmF5KCByZXN1bHQgKSwgY291bnQsIHN0cmlkZSwgc291cmNlLCBleHRlbnNpb25EZWYubW9kZSwgZXh0ZW5zaW9uRGVmLmZpbHRlciApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8qIEJJTkFSWSBFWFRFTlNJT04gKi9cblx0dmFyIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDID0gJ2dsVEYnO1xuXHR2YXIgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5cdHZhciBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAweDRFNEY1MzRBLCBCSU46IDB4MDA0RTQ5NDIgfTtcblxuXHRmdW5jdGlvbiBHTFRGQmluYXJ5RXh0ZW5zaW9uKCBkYXRhICkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG5cdFx0dGhpcy5jb250ZW50ID0gbnVsbDtcblx0XHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdFx0dmFyIGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoIGRhdGEsIDAsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCApO1xuXG5cdFx0dGhpcy5oZWFkZXIgPSB7XG5cdFx0XHRtYWdpYzogTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEuc2xpY2UoIDAsIDQgKSApICksXG5cdFx0XHR2ZXJzaW9uOiBoZWFkZXJWaWV3LmdldFVpbnQzMiggNCwgdHJ1ZSApLFxuXHRcdFx0bGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMiggOCwgdHJ1ZSApXG5cdFx0fTtcblxuXHRcdGlmICggdGhpcy5oZWFkZXIubWFnaWMgIT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBnbFRGLUJpbmFyeSBoZWFkZXIuJyApO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5oZWFkZXIudmVyc2lvbiA8IDIuMCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuXHRcdHZhciBjaHVua1ZpZXcgPSBuZXcgRGF0YVZpZXcoIGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCApO1xuXHRcdHZhciBjaHVua0luZGV4ID0gMDtcblxuXHRcdHdoaWxlICggY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGggKSB7XG5cblx0XHRcdHZhciBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0dmFyIGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoIGNodW5rSW5kZXgsIHRydWUgKTtcblx0XHRcdGNodW5rSW5kZXggKz0gNDtcblxuXHRcdFx0aWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuSlNPTiApIHtcblxuXHRcdFx0XHR2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoICk7XG5cdFx0XHRcdHRoaXMuY29udGVudCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIGNvbnRlbnRBcnJheSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOICkge1xuXG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0ID0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleDtcblx0XHRcdFx0dGhpcy5ib2R5ID0gZGF0YS5zbGljZSggYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xpZW50cyBtdXN0IGlnbm9yZSBjaHVua3Mgd2l0aCB1bmtub3duIHR5cGVzLlxuXG5cdFx0XHRjaHVua0luZGV4ICs9IGNodW5rTGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmNvbnRlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogRFJBQ08gTWVzaCBDb21wcmVzc2lvbiBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbigganNvbiwgZHJhY29Mb2FkZXIgKSB7XG5cblx0XHRpZiAoICEgZHJhY29Mb2FkZXIgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IE5vIERSQUNPTG9hZGVyIGluc3RhbmNlIHByb3ZpZGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG5cdFx0dGhpcy5qc29uID0ganNvbjtcblx0XHR0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG5cdFx0dGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG5cblx0fVxuXG5cdEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbi5wcm90b3R5cGUuZGVjb2RlUHJpbWl0aXZlID0gZnVuY3Rpb24gKCBwcmltaXRpdmUsIHBhcnNlciApIHtcblxuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG5cdFx0dmFyIGJ1ZmZlclZpZXdJbmRleCA9IHByaW1pdGl2ZS5leHRlbnNpb25zWyB0aGlzLm5hbWUgXS5idWZmZXJWaWV3O1xuXHRcdHZhciBnbHRmQXR0cmlidXRlTWFwID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmF0dHJpYnV0ZXM7XG5cdFx0dmFyIHRocmVlQXR0cmlidXRlTWFwID0ge307XG5cdFx0dmFyIGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAgPSB7fTtcblx0XHR2YXIgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCApIHtcblxuXHRcdFx0dmFyIHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGF0dHJpYnV0ZU5hbWUgXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdHRocmVlQXR0cmlidXRlTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGdsdGZBdHRyaWJ1dGVNYXBbIGF0dHJpYnV0ZU5hbWUgXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTWyBhdHRyaWJ1dGVOYW1lIF0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIGdsdGZBdHRyaWJ1dGVNYXBbIGF0dHJpYnV0ZU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzWyBwcmltaXRpdmUuYXR0cmlidXRlc1sgYXR0cmlidXRlTmFtZSBdIF07XG5cdFx0XHRcdHZhciBjb21wb25lbnRUeXBlID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdFx0YXR0cmlidXRlVHlwZU1hcFsgdGhyZWVBdHRyaWJ1dGVOYW1lIF0gPSBjb21wb25lbnRUeXBlO1xuXHRcdFx0XHRhdHRyaWJ1dGVOb3JtYWxpemVkTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBidWZmZXJWaWV3SW5kZXggKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXcgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlICkge1xuXG5cdFx0XHRcdGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZSggYnVmZmVyVmlldywgZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF07XG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbIGF0dHJpYnV0ZU5hbWUgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtYWxpemVkICE9PSB1bmRlZmluZWQgKSBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH0sIHRocmVlQXR0cmlidXRlTWFwLCBhdHRyaWJ1dGVUeXBlTWFwICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUZXh0dXJlIFRyYW5zZm9ybSBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX3RleHR1cmVfdHJhbnNmb3JtXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigpIHtcblxuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNO1xuXG5cdH1cblxuXHRHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgdHJhbnNmb3JtICkge1xuXG5cdFx0dGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcblxuXHRcdGlmICggdHJhbnNmb3JtLm9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5vZmZzZXQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHRyYW5zZm9ybS5zY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogQ3VzdG9tIFVWIHNldHMgaW4gXCInICsgdGhpcy5uYW1lICsgJ1wiIGV4dGVuc2lvbiBub3QgeWV0IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWN1bGFyLUdsb3NzaW5lc3MgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfcGJyU3BlY3VsYXJHbG9zc2luZXNzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBIHN1YiBjbGFzcyBvZiBTdGFuZGFyZE1hdGVyaWFsIHdpdGggc29tZSBvZiB0aGUgZnVuY3Rpb25hbGl0eVxuXHQgKiBjaGFuZ2VkIHZpYSB0aGUgYG9uQmVmb3JlQ29tcGlsZWAgY2FsbGJhY2tcblx0ICogQHBhaWxoZWFkXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsKCBwYXJhbXMgKSB7XG5cblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0XHR0aGlzLmlzR0xURlNwZWN1bGFyR2xvc3NpbmVzc01hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdC8vdmFyaW91cyBjaHVua3MgdGhhdCBuZWVkIHJlcGxhY2luZ1xuXHRcdHZhciBzcGVjdWxhck1hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0JyNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAnLFxuXHRcdFx0J1x0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0dmFyIGdsb3NzaW5lc3NNYXBQYXJzRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0J1x0dW5pZm9ybSBzYW1wbGVyMkQgZ2xvc3NpbmVzc01hcDsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR2YXIgc3BlY3VsYXJNYXBGcmFnbWVudENodW5rID0gW1xuXHRcdFx0J3ZlYzMgc3BlY3VsYXJGYWN0b3IgPSBzcGVjdWxhcjsnLFxuXHRcdFx0JyNpZmRlZiBVU0VfU1BFQ1VMQVJNQVAnLFxuXHRcdFx0J1x0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7Jyxcblx0XHRcdCdcdHRleGVsU3BlY3VsYXIgPSBzUkdCVG9MaW5lYXIoIHRleGVsU3BlY3VsYXIgKTsnLFxuXHRcdFx0J1x0Ly8gcmVhZHMgY2hhbm5lbCBSR0IsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZScsXG5cdFx0XHQnXHRzcGVjdWxhckZhY3RvciAqPSB0ZXhlbFNwZWN1bGFyLnJnYjsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR2YXIgZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQnZmxvYXQgZ2xvc3NpbmVzc0ZhY3RvciA9IGdsb3NzaW5lc3M7Jyxcblx0XHRcdCcjaWZkZWYgVVNFX0dMT1NTSU5FU1NNQVAnLFxuXHRcdFx0J1x0dmVjNCB0ZXhlbEdsb3NzaW5lc3MgPSB0ZXh0dXJlMkQoIGdsb3NzaW5lc3NNYXAsIHZVdiApOycsXG5cdFx0XHQnXHQvLyByZWFkcyBjaGFubmVsIEEsIGNvbXBhdGlibGUgd2l0aCBhIGdsVEYgU3BlY3VsYXItR2xvc3NpbmVzcyAoUkdCQSkgdGV4dHVyZScsXG5cdFx0XHQnXHRnbG9zc2luZXNzRmFjdG9yICo9IHRleGVsR2xvc3NpbmVzcy5hOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdHZhciBsaWdodFBoeXNpY2FsRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCdQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsOycsXG5cdFx0XHQnbWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4gLSBtYXgoIHNwZWN1bGFyRmFjdG9yLnIsIG1heCggc3BlY3VsYXJGYWN0b3IuZywgc3BlY3VsYXJGYWN0b3IuYiApICkgKTsnLFxuXHRcdFx0J3ZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIGdlb21ldHJ5Tm9ybWFsICkgKSwgYWJzKCBkRmR5KCBnZW9tZXRyeU5vcm1hbCApICkgKTsnLFxuXHRcdFx0J2Zsb2F0IGdlb21ldHJ5Um91Z2huZXNzID0gbWF4KCBtYXgoIGR4eS54LCBkeHkueSApLCBkeHkueiApOycsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBtYXgoIDEuMCAtIGdsb3NzaW5lc3NGYWN0b3IsIDAuMDUyNSApOyAvLyAwLjA1MjUgY29ycmVzcG9uZHMgdG8gdGhlIGJhc2UgbWlwIG9mIGEgMjU2IGN1YmVtYXAuJyxcblx0XHRcdCdtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyArPSBnZW9tZXRyeVJvdWdobmVzczsnLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcywgMS4wICk7Jyxcblx0XHRcdCdtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXJGYWN0b3I7Jyxcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB7XG5cdFx0XHRzcGVjdWxhcjogeyB2YWx1ZTogbmV3IENvbG9yKCkuc2V0SGV4KCAweGZmZmZmZiApIH0sXG5cdFx0XHRnbG9zc2luZXNzOiB7IHZhbHVlOiAxIH0sXG5cdFx0XHRzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0Z2xvc3NpbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XG5cdFx0fTtcblxuXHRcdHRoaXMuX2V4dHJhVW5pZm9ybXMgPSB1bmlmb3JtcztcblxuXHRcdHRoaXMub25CZWZvcmVDb21waWxlID0gZnVuY3Rpb24gKCBzaGFkZXIgKSB7XG5cblx0XHRcdGZvciAoIHZhciB1bmlmb3JtTmFtZSBpbiB1bmlmb3JtcyApIHtcblxuXHRcdFx0XHRzaGFkZXIudW5pZm9ybXNbIHVuaWZvcm1OYW1lIF0gPSB1bmlmb3Jtc1sgdW5pZm9ybU5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcblx0XHRcdFx0LnJlcGxhY2UoICd1bmlmb3JtIGZsb2F0IHJvdWdobmVzczsnLCAndW5pZm9ybSB2ZWMzIHNwZWN1bGFyOycgKVxuXHRcdFx0XHQucmVwbGFjZSggJ3VuaWZvcm0gZmxvYXQgbWV0YWxuZXNzOycsICd1bmlmb3JtIGZsb2F0IGdsb3NzaW5lc3M7JyApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PicsIHNwZWN1bGFyTWFwUGFyc0ZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD4nLCBnbG9zc2luZXNzTWFwUGFyc0ZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PicsIGdsb3NzaW5lc3NNYXBGcmFnbWVudENodW5rIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PicsIGxpZ2h0UGh5c2ljYWxGcmFnbWVudENodW5rICk7XG5cblx0XHR9O1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuXHRcdFx0c3BlY3VsYXI6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuc3BlY3VsYXIudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IHY7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0c3BlY3VsYXJNYXA6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWU7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IHY7XG5cblx0XHRcdFx0XHRpZiAoIHYgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfU1BFQ1VMQVJNQVAgPSAnJzsgLy8gVVNFX1VWIGlzIHNldCBieSB0aGUgcmVuZGVyZXIgZm9yIHNwZWN1bGFyIG1hcHNcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX1NQRUNVTEFSTUFQO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGdsb3NzaW5lc3M6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuZ2xvc3NpbmVzcy52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmdsb3NzaW5lc3MudmFsdWUgPSB2O1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGdsb3NzaW5lc3NNYXA6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gdW5pZm9ybXMuZ2xvc3NpbmVzc01hcC52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLmdsb3NzaW5lc3NNYXAudmFsdWUgPSB2O1xuXG5cdFx0XHRcdFx0aWYgKCB2ICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVAgPSAnJztcblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfVVYgPSAnJztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX0dMT1NTSU5FU1NNQVA7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5kZWZpbmVzLlVTRV9VVjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzc01hcDtcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3NNYXA7XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1zICk7XG5cblx0fVxuXG5cdEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSApO1xuXHRHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbDtcblxuXHRHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHRcdHRoaXMuZ2xvc3NpbmVzc01hcCA9IHNvdXJjZS5nbG9zc2luZXNzTWFwO1xuXHRcdHRoaXMuZ2xvc3NpbmVzcyA9IHNvdXJjZS5nbG9zc2luZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzcztcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzTWFwO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzc01hcDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEdMVEZNYXRlcmlhbHNQYnJTcGVjdWxhckdsb3NzaW5lc3NFeHRlbnNpb24oKSB7XG5cblx0XHRyZXR1cm4ge1xuXG5cdFx0XHRuYW1lOiBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MsXG5cblx0XHRcdHNwZWN1bGFyR2xvc3NpbmVzc1BhcmFtczogW1xuXHRcdFx0XHQnY29sb3InLFxuXHRcdFx0XHQnbWFwJyxcblx0XHRcdFx0J2xpZ2h0TWFwJyxcblx0XHRcdFx0J2xpZ2h0TWFwSW50ZW5zaXR5Jyxcblx0XHRcdFx0J2FvTWFwJyxcblx0XHRcdFx0J2FvTWFwSW50ZW5zaXR5Jyxcblx0XHRcdFx0J2VtaXNzaXZlJyxcblx0XHRcdFx0J2VtaXNzaXZlSW50ZW5zaXR5Jyxcblx0XHRcdFx0J2VtaXNzaXZlTWFwJyxcblx0XHRcdFx0J2J1bXBNYXAnLFxuXHRcdFx0XHQnYnVtcFNjYWxlJyxcblx0XHRcdFx0J25vcm1hbE1hcCcsXG5cdFx0XHRcdCdub3JtYWxNYXBUeXBlJyxcblx0XHRcdFx0J2Rpc3BsYWNlbWVudE1hcCcsXG5cdFx0XHRcdCdkaXNwbGFjZW1lbnRTY2FsZScsXG5cdFx0XHRcdCdkaXNwbGFjZW1lbnRCaWFzJyxcblx0XHRcdFx0J3NwZWN1bGFyTWFwJyxcblx0XHRcdFx0J3NwZWN1bGFyJyxcblx0XHRcdFx0J2dsb3NzaW5lc3NNYXAnLFxuXHRcdFx0XHQnZ2xvc3NpbmVzcycsXG5cdFx0XHRcdCdhbHBoYU1hcCcsXG5cdFx0XHRcdCdlbnZNYXAnLFxuXHRcdFx0XHQnZW52TWFwSW50ZW5zaXR5Jyxcblx0XHRcdFx0J3JlZnJhY3Rpb25SYXRpbycsXG5cdFx0XHRdLFxuXG5cdFx0XHRnZXRNYXRlcmlhbFR5cGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRyZXR1cm4gR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWw7XG5cblx0XHRcdH0sXG5cblx0XHRcdGV4dGVuZFBhcmFtczogZnVuY3Rpb24gKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlciApIHtcblxuXHRcdFx0XHR2YXIgcGJyU3BlY3VsYXJHbG9zc2luZXNzID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDEuMDtcblxuXHRcdFx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VGYWN0b3IgKSApIHtcblxuXHRcdFx0XHRcdHZhciBhcnJheSA9IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlRmFjdG9yO1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZVRleHR1cmUgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMC4wLCAwLjAsIDAuMCApO1xuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmdsb3NzaW5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IHBiclNwZWN1bGFyR2xvc3NpbmVzcy5nbG9zc2luZXNzRmFjdG9yIDogMS4wO1xuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5zcGVjdWxhciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5zcGVjdWxhci5mcm9tQXJyYXkoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckZhY3RvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5zcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3BlY0dsb3NzTWFwRGVmID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmU7XG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdnbG9zc2luZXNzTWFwJywgc3BlY0dsb3NzTWFwRGVmICkgKTtcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3NwZWN1bGFyTWFwJywgc3BlY0dsb3NzTWFwRGVmICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbCggbWF0ZXJpYWxQYXJhbXMgKTtcblx0XHRcdFx0bWF0ZXJpYWwuZm9nID0gdHJ1ZTtcblxuXHRcdFx0XHRtYXRlcmlhbC5jb2xvciA9IG1hdGVyaWFsUGFyYW1zLmNvbG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsUGFyYW1zLm1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLm1hcDtcblxuXHRcdFx0XHRtYXRlcmlhbC5saWdodE1hcCA9IG51bGw7XG5cdFx0XHRcdG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmFvTWFwID0gbWF0ZXJpYWxQYXJhbXMuYW9NYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5hb01hcDtcblx0XHRcdFx0bWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZW1pc3NpdmUgPSBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZTtcblx0XHRcdFx0bWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG5cdFx0XHRcdG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmVNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZU1hcDtcblxuXHRcdFx0XHRtYXRlcmlhbC5idW1wTWFwID0gbWF0ZXJpYWxQYXJhbXMuYnVtcE1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmJ1bXBNYXA7XG5cdFx0XHRcdG1hdGVyaWFsLmJ1bXBTY2FsZSA9IDE7XG5cblx0XHRcdFx0bWF0ZXJpYWwubm9ybWFsTWFwID0gbWF0ZXJpYWxQYXJhbXMubm9ybWFsTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMubm9ybWFsTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgKSBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdFx0XHRcdG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcblx0XHRcdFx0bWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cblx0XHRcdFx0bWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhck1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhciA9IG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmdsb3NzaW5lc3NNYXAgPSBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzc01hcDtcblx0XHRcdFx0bWF0ZXJpYWwuZ2xvc3NpbmVzcyA9IG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3M7XG5cblx0XHRcdFx0bWF0ZXJpYWwuYWxwaGFNYXAgPSBudWxsO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmVudk1hcCA9IG1hdGVyaWFsUGFyYW1zLmVudk1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmVudk1hcDtcblx0XHRcdFx0bWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG5cdFx0XHRcdG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHR9LFxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIE1lc2ggUXVhbnRpemF0aW9uIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWVzaF9xdWFudGl6YXRpb25cblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT047XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqIElOVEVSUE9MQVRJT04gKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Ly8gU3BsaW5lIEludGVycG9sYXRpb25cblx0Ly8gU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhcHBlbmRpeC1jLXNwbGluZS1pbnRlcnBvbGF0aW9uXG5cdGZ1bmN0aW9uIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdH1cblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKTtcblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8gPSBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0Ly8gQ29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyLiBTZWUgZGVzY3JpcHRpb24gb2YgZ2xURlxuXHRcdC8vIENVQklDU1BMSU5FIHZhbHVlcyBsYXlvdXQgaW4gaW50ZXJwb2xhdGVfKCkgZnVuY3Rpb24gYmVsb3cuXG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHZhbHVlU2l6ZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkgKysgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH07XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmJlZm9yZVN0YXJ0XyA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5hZnRlckVuZF8gPSBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXztcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuaW50ZXJwb2xhdGVfID0gZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyO1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcztcblx0XHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cblx0XHR2YXIgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG5cdFx0dmFyIHN0cmlkZTMgPSBzdHJpZGUgKiAzO1xuXG5cdFx0dmFyIHRkID0gdDEgLSB0MDtcblxuXHRcdHZhciBwID0gKCB0IC0gdDAgKSAvIHRkO1xuXHRcdHZhciBwcCA9IHAgKiBwO1xuXHRcdHZhciBwcHAgPSBwcCAqIHA7XG5cblx0XHR2YXIgb2Zmc2V0MSA9IGkxICogc3RyaWRlMztcblx0XHR2YXIgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuXG5cdFx0dmFyIHMyID0gLSAyICogcHBwICsgMyAqIHBwO1xuXHRcdHZhciBzMyA9IHBwcCAtIHBwO1xuXHRcdHZhciBzMCA9IDEgLSBzMjtcblx0XHR2YXIgczEgPSBzMyAtIHBwICsgcDtcblxuXHRcdC8vIExheW91dCBvZiBrZXlmcmFtZSBvdXRwdXQgdmFsdWVzIGZvciBDVUJJQ1NQTElORSBhbmltYXRpb25zOlxuXHRcdC8vICAgWyBpblRhbmdlbnRfMSwgc3BsaW5lVmVydGV4XzEsIG91dFRhbmdlbnRfMSwgaW5UYW5nZW50XzIsIHNwbGluZVZlcnRleF8yLCAuLi4gXVxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcDAgPSB2YWx1ZXNbIG9mZnNldDAgKyBpICsgc3RyaWRlIF07IC8vIHNwbGluZVZlcnRleF9rXG5cdFx0XHR2YXIgbTAgPSB2YWx1ZXNbIG9mZnNldDAgKyBpICsgc3RyaWRlMiBdICogdGQ7IC8vIG91dFRhbmdlbnRfayAqICh0X2srMSAtIHRfaylcblx0XHRcdHZhciBwMSA9IHZhbHVlc1sgb2Zmc2V0MSArIGkgKyBzdHJpZGUgXTsgLy8gc3BsaW5lVmVydGV4X2srMVxuXHRcdFx0dmFyIG0xID0gdmFsdWVzWyBvZmZzZXQxICsgaSBdICogdGQ7IC8vIGluVGFuZ2VudF9rKzEgKiAodF9rKzEgLSB0X2spXG5cblx0XHRcdHJlc3VsdFsgaSBdID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKiBJTlRFUk5BTFMgKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qIENPTlNUQU5UUyAqL1xuXG5cdHZhciBXRUJHTF9DT05TVEFOVFMgPSB7XG5cdFx0RkxPQVQ6IDUxMjYsXG5cdFx0Ly9GTE9BVF9NQVQyOiAzNTY3NCxcblx0XHRGTE9BVF9NQVQzOiAzNTY3NSxcblx0XHRGTE9BVF9NQVQ0OiAzNTY3Nixcblx0XHRGTE9BVF9WRUMyOiAzNTY2NCxcblx0XHRGTE9BVF9WRUMzOiAzNTY2NSxcblx0XHRGTE9BVF9WRUM0OiAzNTY2Nixcblx0XHRMSU5FQVI6IDk3MjksXG5cdFx0UkVQRUFUOiAxMDQ5Nyxcblx0XHRTQU1QTEVSXzJEOiAzNTY3OCxcblx0XHRQT0lOVFM6IDAsXG5cdFx0TElORVM6IDEsXG5cdFx0TElORV9MT09QOiAyLFxuXHRcdExJTkVfU1RSSVA6IDMsXG5cdFx0VFJJQU5HTEVTOiA0LFxuXHRcdFRSSUFOR0xFX1NUUklQOiA1LFxuXHRcdFRSSUFOR0xFX0ZBTjogNixcblx0XHRVTlNJR05FRF9CWVRFOiA1MTIxLFxuXHRcdFVOU0lHTkVEX1NIT1JUOiA1MTIzXG5cdH07XG5cblx0dmFyIFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcblx0XHQ1MTIwOiBJbnQ4QXJyYXksXG5cdFx0NTEyMTogVWludDhBcnJheSxcblx0XHQ1MTIyOiBJbnQxNkFycmF5LFxuXHRcdDUxMjM6IFVpbnQxNkFycmF5LFxuXHRcdDUxMjU6IFVpbnQzMkFycmF5LFxuXHRcdDUxMjY6IEZsb2F0MzJBcnJheVxuXHR9O1xuXG5cdHZhciBXRUJHTF9GSUxURVJTID0ge1xuXHRcdDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG5cdFx0OTcyOTogTGluZWFyRmlsdGVyLFxuXHRcdDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuXHRcdDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0OTk4NjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcblx0XHQ5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcblx0fTtcblxuXHR2YXIgV0VCR0xfV1JBUFBJTkdTID0ge1xuXHRcdDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuXHRcdDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuXHRcdDEwNDk3OiBSZXBlYXRXcmFwcGluZ1xuXHR9O1xuXG5cdHZhciBXRUJHTF9UWVBFX1NJWkVTID0ge1xuXHRcdCdTQ0FMQVInOiAxLFxuXHRcdCdWRUMyJzogMixcblx0XHQnVkVDMyc6IDMsXG5cdFx0J1ZFQzQnOiA0LFxuXHRcdCdNQVQyJzogNCxcblx0XHQnTUFUMyc6IDksXG5cdFx0J01BVDQnOiAxNlxuXHR9O1xuXG5cdHZhciBBVFRSSUJVVEVTID0ge1xuXHRcdFBPU0lUSU9OOiAncG9zaXRpb24nLFxuXHRcdE5PUk1BTDogJ25vcm1hbCcsXG5cdFx0VEFOR0VOVDogJ3RhbmdlbnQnLFxuXHRcdFRFWENPT1JEXzA6ICd1dicsXG5cdFx0VEVYQ09PUkRfMTogJ3V2MicsXG5cdFx0Q09MT1JfMDogJ2NvbG9yJyxcblx0XHRXRUlHSFRTXzA6ICdza2luV2VpZ2h0Jyxcblx0XHRKT0lOVFNfMDogJ3NraW5JbmRleCcsXG5cdH07XG5cblx0dmFyIFBBVEhfUFJPUEVSVElFUyA9IHtcblx0XHRzY2FsZTogJ3NjYWxlJyxcblx0XHR0cmFuc2xhdGlvbjogJ3Bvc2l0aW9uJyxcblx0XHRyb3RhdGlvbjogJ3F1YXRlcm5pb24nLFxuXHRcdHdlaWdodHM6ICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnXG5cdH07XG5cblx0dmFyIElOVEVSUE9MQVRJT04gPSB7XG5cdFx0Q1VCSUNTUExJTkU6IHVuZGVmaW5lZCwgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5ZnJhbWUgdHJhY2sgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGEgZGVmYXVsdCBpbnRlcnBvbGF0aW9uIHR5cGUsIHRoZW4gbW9kaWZpZWQuXG5cdFx0TElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcblx0XHRTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG5cdH07XG5cblx0dmFyIEFMUEhBX01PREVTID0ge1xuXHRcdE9QQVFVRTogJ09QQVFVRScsXG5cdFx0TUFTSzogJ01BU0snLFxuXHRcdEJMRU5EOiAnQkxFTkQnXG5cdH07XG5cblx0LyogVVRJTElUWSBGVU5DVElPTlMgKi9cblxuXHRmdW5jdGlvbiByZXNvbHZlVVJMKCB1cmwsIHBhdGggKSB7XG5cblx0XHQvLyBJbnZhbGlkIFVSTFxuXHRcdGlmICggdHlwZW9mIHVybCAhPT0gJ3N0cmluZycgfHwgdXJsID09PSAnJyApIHJldHVybiAnJztcblxuXHRcdC8vIEhvc3QgUmVsYXRpdmUgVVJMXG5cdFx0aWYgKCAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KCBwYXRoICkgJiYgL15cXC8vLnRlc3QoIHVybCApICkge1xuXG5cdFx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAvKF5odHRwcz86XFwvXFwvW15cXC9dKykuKi9pLCAnJDEnICk7XG5cblx0XHR9XG5cblx0XHQvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXHRcdGlmICggL14oaHR0cHM/Oik/XFwvXFwvL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gRGF0YSBVUklcblx0XHRpZiAoIC9eZGF0YTouKiwuKiQvaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBCbG9iIFVSTFxuXHRcdGlmICggL15ibG9iOi4qJC9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIFJlbGF0aXZlIFVSTFxuXHRcdHJldHVybiBwYXRoICsgdXJsO1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNkZWZhdWx0LW1hdGVyaWFsXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoIGNhY2hlICkge1xuXG5cdFx0aWYgKCBjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCgge1xuXHRcdFx0XHRjb2xvcjogMHhGRkZGRkYsXG5cdFx0XHRcdGVtaXNzaXZlOiAweDAwMDAwMCxcblx0XHRcdFx0bWV0YWxuZXNzOiAxLFxuXHRcdFx0XHRyb3VnaG5lc3M6IDEsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBmYWxzZSxcblx0XHRcdFx0ZGVwdGhUZXN0OiB0cnVlLFxuXHRcdFx0XHRzaWRlOiBGcm9udFNpZGVcblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjYWNoZVsgJ0RlZmF1bHRNYXRlcmlhbCcgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmICkge1xuXG5cdFx0Ly8gQWRkIHVua25vd24gZ2xURiBleHRlbnNpb25zIHRvIGFuIG9iamVjdCdzIHVzZXJEYXRhLlxuXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gb2JqZWN0RGVmLmV4dGVuc2lvbnMgKSB7XG5cblx0XHRcdGlmICgga25vd25FeHRlbnNpb25zWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgPSBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgfHwge307XG5cdFx0XHRcdG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1sgbmFtZSBdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtPYmplY3QzRHxNYXRlcmlhbHxCdWZmZXJHZW9tZXRyeX0gb2JqZWN0XG5cdCAqIEBwYXJhbSB7R0xURi5kZWZpbml0aW9ufSBnbHRmRGVmXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBvYmplY3QsIGdsdGZEZWYgKSB7XG5cblx0XHRpZiAoIGdsdGZEZWYuZXh0cmFzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSAnb2JqZWN0JyApIHtcblxuXHRcdFx0XHRPYmplY3QuYXNzaWduKCBvYmplY3QudXNlckRhdGEsIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgJyArIGdsdGZEZWYuZXh0cmFzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbW9ycGgtdGFyZ2V0c1xuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge0FycmF5PEdMVEYuVGFyZ2V0Pn0gdGFyZ2V0c1xuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckdlb21ldHJ5Pn1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHRhcmdldHMsIHBhcnNlciApIHtcblxuXHRcdHZhciBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG5cdFx0dmFyIGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0aWYgKCB0YXJnZXQuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuXHRcdFx0aWYgKCB0YXJnZXQuTk9STUFMICE9PSB1bmRlZmluZWQgKSBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCApIGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGhhc01vcnBoUG9zaXRpb24gJiYgISBoYXNNb3JwaE5vcm1hbCApIHJldHVybiBQcm9taXNlLnJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0XHR2YXIgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG5cdFx0dmFyIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0LlBPU0lUSU9OIClcblx0XHRcdFx0XHQ6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdFx0cGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2goIHBlbmRpbmdBY2Nlc3NvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFyIHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5OT1JNQUwgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdD8gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHRhcmdldC5OT1JNQUwgKVxuXHRcdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRcdFx0cGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKCBwZW5kaW5nQWNjZXNzb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ05vcm1hbEFjY2Vzc29ycyApXG5cdFx0XSApLnRoZW4oIGZ1bmN0aW9uICggYWNjZXNzb3JzICkge1xuXG5cdFx0XHR2YXIgbW9ycGhQb3NpdGlvbnMgPSBhY2Nlc3NvcnNbIDAgXTtcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbIDEgXTtcblxuXHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uICkgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID0gbW9ycGhQb3NpdGlvbnM7XG5cdFx0XHRpZiAoIGhhc01vcnBoTm9ybWFsICkgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IG1vcnBoTm9ybWFscztcblx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtNZXNofSBtZXNoXG5cdCAqIEBwYXJhbSB7R0xURi5NZXNofSBtZXNoRGVmXG5cdCAqL1xuXHRmdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMoIG1lc2gsIG1lc2hEZWYgKSB7XG5cblx0XHRtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG5cdFx0aWYgKCBtZXNoRGVmLndlaWdodHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID0gbWVzaERlZi53ZWlnaHRzWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIC5leHRyYXMgaGFzIHVzZXItZGVmaW5lZCBkYXRhLCBzbyBjaGVjayB0aGF0IC5leHRyYXMudGFyZ2V0TmFtZXMgaXMgYW4gYXJyYXkuXG5cdFx0aWYgKCBtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KCBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcyApICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcblxuXHRcdFx0aWYgKCBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGggPT09IHRhcmdldE5hbWVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyB0YXJnZXROYW1lc1sgaSBdIF0gPSBpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVLZXkoIHByaW1pdGl2ZURlZiApIHtcblxuXHRcdHZhciBkcmFjb0V4dGVuc2lvbiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zICYmIHByaW1pdGl2ZURlZi5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIF07XG5cdFx0dmFyIGdlb21ldHJ5S2V5O1xuXG5cdFx0aWYgKCBkcmFjb0V4dGVuc2lvbiApIHtcblxuXHRcdFx0Z2VvbWV0cnlLZXkgPSAnZHJhY286JyArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXdcblx0XHRcdFx0KyAnOicgKyBkcmFjb0V4dGVuc2lvbi5pbmRpY2VzXG5cdFx0XHRcdCsgJzonICsgY3JlYXRlQXR0cmlidXRlc0tleSggZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArICc6JyArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoIHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzICkgKyAnOicgKyBwcmltaXRpdmVEZWYubW9kZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeUtleTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleSggYXR0cmlidXRlcyApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzS2V5ID0gJyc7XG5cblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBhdHRyaWJ1dGVzICkuc29ydCgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1sgaSBdICsgJzonICsgYXR0cmlidXRlc1sga2V5c1sgaSBdIF0gKyAnOyc7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXR0cmlidXRlc0tleTtcblxuXHR9XG5cblx0LyogR0xURiBQQVJTRVIgKi9cblxuXHRmdW5jdGlvbiBHTFRGUGFyc2VyKCBqc29uLCBvcHRpb25zICkge1xuXG5cdFx0dGhpcy5qc29uID0ganNvbiB8fCB7fTtcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7fTtcblx0XHR0aGlzLnBsdWdpbnMgPSB7fTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0Ly8gbG9hZGVyIG9iamVjdCBjYWNoZVxuXHRcdHRoaXMuY2FjaGUgPSBuZXcgR0xURlJlZ2lzdHJ5KCk7XG5cblx0XHQvLyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBUaHJlZS5qcyBvYmplY3RzIGFuZCBnbFRGIGVsZW1lbnRzXG5cdFx0dGhpcy5hc3NvY2lhdGlvbnMgPSBuZXcgTWFwKCk7XG5cblx0XHQvLyBCdWZmZXJHZW9tZXRyeSBjYWNoaW5nXG5cdFx0dGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuXG5cdFx0Ly8gT2JqZWN0M0QgaW5zdGFuY2UgY2FjaGVzXG5cdFx0dGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXHRcdHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuXHRcdHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cblx0XHQvLyBUcmFjayBub2RlIG5hbWVzLCB0byBlbnN1cmUgbm8gZHVwbGljYXRlc1xuXHRcdHRoaXMubm9kZU5hbWVzVXNlZCA9IHt9O1xuXG5cdFx0Ly8gVXNlIGFuIEltYWdlQml0bWFwTG9hZGVyIGlmIGltYWdlQml0bWFwcyBhcmUgc3VwcG9ydGVkLiBNb3ZlcyBtdWNoIG9mIHRoZVxuXHRcdC8vIGV4cGVuc2l2ZSB3b3JrIG9mIHVwbG9hZGluZyBhIHRleHR1cmUgdG8gdGhlIEdQVSBvZmYgdGhlIG1haW4gdGhyZWFkLlxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiAvRmlyZWZveC8udGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKCB0aGlzLm9wdGlvbnMubWFuYWdlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMub3B0aW9ucy5tYW5hZ2VyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiApO1xuXHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlciApO1xuXG5cdFx0dGhpcy5maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMub3B0aW9ucy5tYW5hZ2VyICk7XG5cdFx0dGhpcy5maWxlTG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuY3Jvc3NPcmlnaW4gPT09ICd1c2UtY3JlZGVudGlhbHMnICkge1xuXG5cdFx0XHR0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0cnVlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLnNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoIGV4dGVuc2lvbnMgKSB7XG5cblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUuc2V0UGx1Z2lucyA9IGZ1bmN0aW9uICggcGx1Z2lucyApIHtcblxuXHRcdHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggb25Mb2FkLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cblx0XHQvLyBDbGVhciB0aGUgbG9hZGVyIGNhY2hlXG5cdFx0dGhpcy5jYWNoZS5yZW1vdmVBbGwoKTtcblxuXHRcdC8vIE1hcmsgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZVxuXHRcdHRoaXMuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdHJldHVybiBleHQuX21hcmtEZWZzICYmIGV4dC5fbWFya0RlZnMoKTtcblxuXHRcdH0gKTtcblxuXHRcdFByb21pc2UuYWxsKCB0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0LmJlZm9yZVJvb3QgJiYgZXh0LmJlZm9yZVJvb3QoKTtcblxuXHRcdH0gKSApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbXG5cblx0XHRcdFx0cGFyc2VyLmdldERlcGVuZGVuY2llcyggJ3NjZW5lJyApLFxuXHRcdFx0XHRwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKCAnYW5pbWF0aW9uJyApLFxuXHRcdFx0XHRwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKCAnY2FtZXJhJyApLFxuXG5cdFx0XHRdICk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHRcdHNjZW5lOiBkZXBlbmRlbmNpZXNbIDAgXVsganNvbi5zY2VuZSB8fCAwIF0sXG5cdFx0XHRcdHNjZW5lczogZGVwZW5kZW5jaWVzWyAwIF0sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sgMSBdLFxuXHRcdFx0XHRjYW1lcmFzOiBkZXBlbmRlbmNpZXNbIDIgXSxcblx0XHRcdFx0YXNzZXQ6IGpzb24uYXNzZXQsXG5cdFx0XHRcdHBhcnNlcjogcGFyc2VyLFxuXHRcdFx0XHR1c2VyRGF0YToge31cblx0XHRcdH07XG5cblx0XHRcdGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uICk7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIHJlc3VsdCwganNvbiApO1xuXG5cdFx0XHRQcm9taXNlLmFsbCggcGFyc2VyLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuYWZ0ZXJSb290ICYmIGV4dC5hZnRlclJvb3QoIHJlc3VsdCApO1xuXG5cdFx0XHR9ICkgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0b25Mb2FkKCByZXN1bHQgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApLmNhdGNoKCBvbkVycm9yICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLl9tYXJrRGVmcyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBub2RlRGVmcyA9IHRoaXMuanNvbi5ub2RlcyB8fCBbXTtcblx0XHR2YXIgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG5cdFx0dmFyIG1lc2hEZWZzID0gdGhpcy5qc29uLm1lc2hlcyB8fCBbXTtcblxuXHRcdC8vIE5vdGhpbmcgaW4gdGhlIG5vZGUgZGVmaW5pdGlvbiBpbmRpY2F0ZXMgd2hldGhlciBpdCBpcyBhIEJvbmUgb3IgYW5cblx0XHQvLyBPYmplY3QzRC4gVXNlIHRoZSBza2lucycgam9pbnQgcmVmZXJlbmNlcyB0byBtYXJrIGJvbmVzLlxuXHRcdGZvciAoIHZhciBza2luSW5kZXggPSAwLCBza2luTGVuZ3RoID0gc2tpbkRlZnMubGVuZ3RoOyBza2luSW5kZXggPCBza2luTGVuZ3RoOyBza2luSW5kZXggKysgKSB7XG5cblx0XHRcdHZhciBqb2ludHMgPSBza2luRGVmc1sgc2tpbkluZGV4IF0uam9pbnRzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG5vZGVEZWZzWyBqb2ludHNbIGkgXSBdLmlzQm9uZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIG1hcmtpbmcgcmVmZXJlbmNlcyB0byBzaGFyZWQgcmVzb3VyY2VzLFxuXHRcdC8vIGFzIHdlbGwgYXMgc2tlbGV0b24gam9pbnRzLlxuXHRcdGZvciAoIHZhciBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXggKysgKSB7XG5cblx0XHRcdHZhciBub2RlRGVmID0gbm9kZURlZnNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRpZiAoIG5vZGVEZWYubWVzaCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2FkZE5vZGVSZWYoIHRoaXMubWVzaENhY2hlLCBub2RlRGVmLm1lc2ggKTtcblxuXHRcdFx0XHQvLyBOb3RoaW5nIGluIHRoZSBtZXNoIGRlZmluaXRpb24gaW5kaWNhdGVzIHdoZXRoZXIgaXQgaXNcblx0XHRcdFx0Ly8gYSBTa2lubmVkTWVzaCBvciBNZXNoLiBVc2UgdGhlIG5vZGUncyBtZXNoIHJlZmVyZW5jZVxuXHRcdFx0XHQvLyB0byBtYXJrIFNraW5uZWRNZXNoIGlmIG5vZGUgaGFzIHNraW4uXG5cdFx0XHRcdGlmICggbm9kZURlZi5za2luICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRtZXNoRGVmc1sgbm9kZURlZi5tZXNoIF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5jYW1lcmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLl9hZGROb2RlUmVmKCB0aGlzLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuXHQgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcblx0ICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuXHQgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuXHQgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cblx0ICpcblx0ICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLl9hZGROb2RlUmVmID0gZnVuY3Rpb24gKCBjYWNoZSwgaW5kZXggKSB7XG5cblx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y2FjaGUucmVmc1sgaW5kZXggXSA9IGNhY2hlLnVzZXNbIGluZGV4IF0gPSAwO1xuXG5cdFx0fVxuXG5cdFx0Y2FjaGUucmVmc1sgaW5kZXggXSArKztcblxuXHR9O1xuXG5cdC8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgc2hhcmVkIHJlc291cmNlLCBjbG9uaW5nIGl0IGlmIG5lY2Vzc2FyeS4gKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuX2dldE5vZGVSZWYgPSBmdW5jdGlvbiAoIGNhY2hlLCBpbmRleCwgb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBjYWNoZS5yZWZzWyBpbmRleCBdIDw9IDEgKSByZXR1cm4gb2JqZWN0O1xuXG5cdFx0dmFyIHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuXG5cdFx0cmVmLm5hbWUgKz0gJ19pbnN0YW5jZV8nICsgKCBjYWNoZS51c2VzWyBpbmRleCBdICsrICk7XG5cblx0XHRyZXR1cm4gcmVmO1xuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUuX2ludm9rZU9uZSA9IGZ1bmN0aW9uICggZnVuYyApIHtcblxuXHRcdHZhciBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyggdGhpcy5wbHVnaW5zICk7XG5cdFx0ZXh0ZW5zaW9ucy5wdXNoKCB0aGlzICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IGZ1bmMoIGV4dGVuc2lvbnNbIGkgXSApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5faW52b2tlQWxsID0gZnVuY3Rpb24gKCBmdW5jICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKCB0aGlzLnBsdWdpbnMgKTtcblx0XHRleHRlbnNpb25zLnVuc2hpZnQoIHRoaXMgKTtcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IGZ1bmMoIGV4dGVuc2lvbnNbIGkgXSApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHBlbmRpbmcucHVzaCggcmVzdWx0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcGVuZGluZztcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0R8TWF0ZXJpYWx8VEhSRUUuVGV4dHVyZXxBbmltYXRpb25DbGlwfEFycmF5QnVmZmVyfE9iamVjdD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKCB0eXBlLCBpbmRleCApIHtcblxuXHRcdHZhciBjYWNoZUtleSA9IHR5cGUgKyAnOicgKyBpbmRleDtcblx0XHR2YXIgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY3kgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2NlbmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTY2VuZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdub2RlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkTm9kZSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtZXNoJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWVzaCAmJiBleHQubG9hZE1lc2goIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYWNjZXNzb3InOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvciggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdidWZmZXJWaWV3Jzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnVmZmVyJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQnVmZmVyKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hdGVyaWFsJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbCggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoIGluZGV4ICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNraW4oIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQW5pbWF0aW9uKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NhbWVyYSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYSggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gdHlwZTogJyArIHR5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGRlcGVuZGVuY3kgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cblx0XHR2YXIgZGVwZW5kZW5jaWVzID0gdGhpcy5jYWNoZS5nZXQoIHR5cGUgKTtcblxuXHRcdGlmICggISBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdFx0dmFyIGRlZnMgPSB0aGlzLmpzb25bIHR5cGUgKyAoIHR5cGUgPT09ICdtZXNoJyA/ICdlcycgOiAncycgKSBdIHx8IFtdO1xuXG5cdFx0XHRkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbCggZGVmcy5tYXAoIGZ1bmN0aW9uICggZGVmLCBpbmRleCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koIHR5cGUsIGluZGV4ICk7XG5cblx0XHRcdH0gKSApO1xuXG5cdFx0XHR0aGlzLmNhY2hlLmFkZCggdHlwZSwgZGVwZW5kZW5jaWVzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRCdWZmZXIgPSBmdW5jdGlvbiAoIGJ1ZmZlckluZGV4ICkge1xuXG5cdFx0dmFyIGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzWyBidWZmZXJJbmRleCBdO1xuXHRcdHZhciBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG5cblx0XHRpZiAoIGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSAnYXJyYXlidWZmZXInICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiAnICsgYnVmZmVyRGVmLnR5cGUgKyAnIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgcHJlc2VudCwgR0xCIGNvbnRhaW5lciBpcyByZXF1aXJlZCB0byBiZSB0aGUgZmlyc3QgYnVmZmVyLlxuXHRcdGlmICggYnVmZmVyRGVmLnVyaSA9PT0gdW5kZWZpbmVkICYmIGJ1ZmZlckluZGV4ID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCB0aGlzLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGIF0uYm9keSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRsb2FkZXIubG9hZCggcmVzb2x2ZVVSTCggYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoICksIHJlc29sdmUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJlamVjdCggbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJyApICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVyVmlld0luZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEJ1ZmZlclZpZXcgPSBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdJbmRleCApIHtcblxuXHRcdHZhciBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzWyBidWZmZXJWaWV3SW5kZXggXTtcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXInLCBidWZmZXJWaWV3RGVmLmJ1ZmZlciApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHR2YXIgYnl0ZUxlbmd0aCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZUxlbmd0aCB8fCAwO1xuXHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdHJldHVybiBidWZmZXIuc2xpY2UoIGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNhY2Nlc3NvcnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY2Vzc29ySW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJBdHRyaWJ1dGV8SW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEFjY2Vzc29yID0gZnVuY3Rpb24gKCBhY2Nlc3NvckluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cblx0XHR2YXIgYWNjZXNzb3JEZWYgPSB0aGlzLmpzb24uYWNjZXNzb3JzWyBhY2Nlc3NvckluZGV4IF07XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHVuZGVmaW5lZCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gSWdub3JlIGVtcHR5IGFjY2Vzc29ycywgd2hpY2ggbWF5IGJlIHVzZWQgdG8gZGVjbGFyZSBydW50aW1lXG5cdFx0XHQvLyBpbmZvcm1hdGlvbiBhYm91dCBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIGFub3RoZXIgc291cmNlIChlLmcuIERyYWNvXG5cdFx0XHQvLyBjb21wcmVzc2lvbiBleHRlbnNpb24pLlxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBlbmRpbmdCdWZmZXJWaWV3cyA9IFtdO1xuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3ICkgKTtcblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3JywgYWNjZXNzb3JEZWYuc3BhcnNlLnZhbHVlcy5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZ0J1ZmZlclZpZXdzICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3cyApIHtcblxuXHRcdFx0dmFyIGJ1ZmZlclZpZXcgPSBidWZmZXJWaWV3c1sgMCBdO1xuXG5cdFx0XHR2YXIgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTWyBhY2Nlc3NvckRlZi50eXBlIF07XG5cdFx0XHR2YXIgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHQvLyBGb3IgVkVDMzogaXRlbVNpemUgaXMgMywgZWxlbWVudEJ5dGVzIGlzIDQsIGl0ZW1CeXRlcyBpcyAxMi5cblx0XHRcdHZhciBlbGVtZW50Qnl0ZXMgPSBUeXBlZEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuXHRcdFx0dmFyIGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuXHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG5cdFx0XHR2YXIgYnl0ZVN0cmlkZSA9IGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCA/IGpzb24uYnVmZmVyVmlld3NbIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgXS5ieXRlU3RyaWRlIDogdW5kZWZpbmVkO1xuXHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuXHRcdFx0dmFyIGFycmF5LCBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHRcdC8vIFRoZSBidWZmZXIgaXMgbm90IGludGVybGVhdmVkIGlmIHRoZSBzdHJpZGUgaXMgdGhlIGl0ZW0gc2l6ZSBpbiBieXRlcy5cblx0XHRcdGlmICggYnl0ZVN0cmlkZSAmJiBieXRlU3RyaWRlICE9PSBpdGVtQnl0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gRWFjaCBcInNsaWNlXCIgb2YgdGhlIGJ1ZmZlciwgYXMgZGVmaW5lZCBieSAnY291bnQnIGVsZW1lbnRzIG9mICdieXRlU3RyaWRlJyBieXRlcywgZ2V0cyBpdHMgb3duIEludGVybGVhdmVkQnVmZmVyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IElCQS5jb3VudCByZWZsZWN0cyBhY2Nlc3Nvci5jb3VudCBwcm9wZXJseVxuXHRcdFx0XHR2YXIgaWJTbGljZSA9IE1hdGguZmxvb3IoIGJ5dGVPZmZzZXQgLyBieXRlU3RyaWRlICk7XG5cdFx0XHRcdHZhciBpYkNhY2hlS2V5ID0gJ0ludGVybGVhdmVkQnVmZmVyOicgKyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICsgJzonICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArICc6JyArIGliU2xpY2UgKyAnOicgKyBhY2Nlc3NvckRlZi5jb3VudDtcblx0XHRcdFx0dmFyIGliID0gcGFyc2VyLmNhY2hlLmdldCggaWJDYWNoZUtleSApO1xuXG5cdFx0XHRcdGlmICggISBpYiApIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMgKTtcblxuXHRcdFx0XHRcdC8vIEludGVnZXIgcGFyYW1ldGVycyB0byBJQi9JQkEgYXJlIGluIGFycmF5IGVsZW1lbnRzLCBub3QgYnl0ZXMuXG5cdFx0XHRcdFx0aWIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoIGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzICk7XG5cblx0XHRcdFx0XHRwYXJzZXIuY2FjaGUuYWRkKCBpYkNhY2hlS2V5LCBpYiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGliLCBpdGVtU2l6ZSwgKCBieXRlT2Zmc2V0ICUgYnl0ZVN0cmlkZSApIC8gZWxlbWVudEJ5dGVzLCBub3JtYWxpemVkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBidWZmZXJWaWV3ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBidWZmZXJWaWV3LCBieXRlT2Zmc2V0LCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjc3BhcnNlLWFjY2Vzc29yc1xuXHRcdFx0aWYgKCBhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG5cdFx0XHRcdHZhciBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1sgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuY29tcG9uZW50VHlwZSBdO1xuXG5cdFx0XHRcdHZhciBieXRlT2Zmc2V0SW5kaWNlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdFx0dmFyIGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcblxuXHRcdFx0XHR2YXIgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyggYnVmZmVyVmlld3NbIDEgXSwgYnl0ZU9mZnNldEluZGljZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplSW5kaWNlcyApO1xuXHRcdFx0XHR2YXIgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoIGJ1ZmZlclZpZXdzWyAyIF0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0aWYgKCBidWZmZXJWaWV3ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0Ly8gQXZvaWQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbCBBcnJheUJ1ZmZlciwgaWYgdGhlIGJ1ZmZlclZpZXcgd2Fzbid0IGluaXRpYWxpemVkIHdpdGggemVyb2VzLlxuXHRcdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zbGljZSgpLCBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsIGJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzcGFyc2VJbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gc3BhcnNlSW5kaWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlLnNldFgoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkgYnVmZmVyQXR0cmlidXRlLnNldFkoIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDEgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAyIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSBidWZmZXJBdHRyaWJ1dGUuc2V0VyggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMyBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA1ICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgaXRlbVNpemUgaW4gc3BhcnNlIEJ1ZmZlckF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0XHR2YXIgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbIHRleHR1cmVJbmRleCBdO1xuXHRcdHZhciBzb3VyY2UgPSBqc29uLmltYWdlc1sgdGV4dHVyZURlZi5zb3VyY2UgXTtcblxuXHRcdHZhciBsb2FkZXIgPSB0aGlzLnRleHR1cmVMb2FkZXI7XG5cblx0XHRpZiAoIHNvdXJjZS51cmkgKSB7XG5cblx0XHRcdHZhciBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoIHNvdXJjZS51cmkgKTtcblx0XHRcdGlmICggaGFuZGxlciAhPT0gbnVsbCApIGxvYWRlciA9IGhhbmRsZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkVGV4dHVyZUltYWdlID0gZnVuY3Rpb24gKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR2YXIgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbIHRleHR1cmVJbmRleCBdO1xuXG5cdFx0dmFyIFVSTCA9IHNlbGYuVVJMIHx8IHNlbGYud2Via2l0VVJMO1xuXG5cdFx0dmFyIHNvdXJjZVVSSSA9IHNvdXJjZS51cmk7XG5cdFx0dmFyIGlzT2JqZWN0VVJMID0gZmFsc2U7XG5cdFx0dmFyIGhhc0FscGhhID0gdHJ1ZTtcblxuXHRcdGlmICggc291cmNlLm1pbWVUeXBlID09PSAnaW1hZ2UvanBlZycgKSBoYXNBbHBoYSA9IGZhbHNlO1xuXG5cdFx0aWYgKCBzb3VyY2UuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBMb2FkIGJpbmFyeSBpbWFnZSBkYXRhIGZyb20gYnVmZmVyVmlldywgaWYgcHJvdmlkZWQuXG5cblx0XHRcdHNvdXJjZVVSSSA9IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIHNvdXJjZS5idWZmZXJWaWV3ICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXJWaWV3ICkge1xuXG5cdFx0XHRcdGlmICggc291cmNlLm1pbWVUeXBlID09PSAnaW1hZ2UvcG5nJyApIHtcblxuXHRcdFx0XHRcdC8vIEluc3BlY3QgdGhlIFBORyAnSUhEUicgY2h1bmsgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGltYWdlIGNvdWxkIGhhdmUgYW5cblx0XHRcdFx0XHQvLyBhbHBoYSBjaGFubmVsLiBUaGlzIGNoZWNrIGlzIGNvbnNlcnZhdGl2ZSDigJQgdGhlIGltYWdlIGNvdWxkIGhhdmUgYW4gYWxwaGFcblx0XHRcdFx0XHQvLyBjaGFubmVsIHdpdGggYWxsIHZhbHVlcyA9PSAxLCBhbmQgdGhlIGluZGV4ZWQgdHlwZSAoY29sb3JUeXBlID09IDMpIG9ubHlcblx0XHRcdFx0XHQvLyBzb21ldGltZXMgY29udGFpbnMgYWxwaGEuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb3J0YWJsZV9OZXR3b3JrX0dyYXBoaWNzI0ZpbGVfaGVhZGVyXG5cdFx0XHRcdFx0dmFyIGNvbG9yVHlwZSA9IG5ldyBEYXRhVmlldyggYnVmZmVyVmlldywgMjUsIDEgKS5nZXRVaW50OCggMCwgZmFsc2UgKTtcblx0XHRcdFx0XHRoYXNBbHBoYSA9IGNvbG9yVHlwZSA9PT0gNiB8fCBjb2xvclR5cGUgPT09IDQgfHwgY29sb3JUeXBlID09PSAzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpc09iamVjdFVSTCA9IHRydWU7XG5cdFx0XHRcdHZhciBibG9iID0gbmV3IEJsb2IoIFsgYnVmZmVyVmlldyBdLCB7IHR5cGU6IHNvdXJjZS5taW1lVHlwZSB9ICk7XG5cdFx0XHRcdHNvdXJjZVVSSSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoIGJsb2IgKTtcblx0XHRcdFx0cmV0dXJuIHNvdXJjZVVSSTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIGlmICggc291cmNlLnVyaSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSAnICsgdGV4dHVyZUluZGV4ICsgJyBpcyBtaXNzaW5nIFVSSSBhbmQgYnVmZmVyVmlldycgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHNvdXJjZVVSSSApLnRoZW4oIGZ1bmN0aW9uICggc291cmNlVVJJICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSwgcmVqZWN0ICkge1xuXG5cdFx0XHRcdHZhciBvbkxvYWQgPSByZXNvbHZlO1xuXG5cdFx0XHRcdGlmICggbG9hZGVyLmlzSW1hZ2VCaXRtYXBMb2FkZXIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQgPSBmdW5jdGlvbiAoIGltYWdlQml0bWFwICkge1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlKCBuZXcgQ2FudmFzVGV4dHVyZSggaW1hZ2VCaXRtYXAgKSApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bG9hZGVyLmxvYWQoIHJlc29sdmVVUkwoIHNvdXJjZVVSSSwgb3B0aW9ucy5wYXRoICksIG9uTG9hZCwgdW5kZWZpbmVkLCByZWplY3QgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgcmVzb3VyY2VzIGFuZCBjb25maWd1cmUgVGV4dHVyZS5cblxuXHRcdFx0aWYgKCBpc09iamVjdFVSTCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKCBzb3VyY2VVUkkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG5cblx0XHRcdGlmICggdGV4dHVyZURlZi5uYW1lICkgdGV4dHVyZS5uYW1lID0gdGV4dHVyZURlZi5uYW1lO1xuXG5cdFx0XHQvLyBXaGVuIHRoZXJlIGlzIGRlZmluaXRlbHkgbm8gYWxwaGEgY2hhbm5lbCBpbiB0aGUgdGV4dHVyZSwgc2V0IFJHQkZvcm1hdCB0byBzYXZlIHNwYWNlLlxuXHRcdFx0aWYgKCAhIGhhc0FscGhhICkgdGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7XG5cblx0XHRcdHZhciBzYW1wbGVycyA9IGpzb24uc2FtcGxlcnMgfHwge307XG5cdFx0XHR2YXIgc2FtcGxlciA9IHNhbXBsZXJzWyB0ZXh0dXJlRGVmLnNhbXBsZXIgXSB8fCB7fTtcblxuXHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTWyBzYW1wbGVyLm1hZ0ZpbHRlciBdIHx8IExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gV0VCR0xfRklMVEVSU1sgc2FtcGxlci5taW5GaWx0ZXIgXSB8fCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gV0VCR0xfV1JBUFBJTkdTWyBzYW1wbGVyLndyYXBTIF0gfHwgUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTWyBzYW1wbGVyLndyYXBUIF0gfHwgUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCB0ZXh0dXJlLCB7XG5cdFx0XHRcdHR5cGU6ICd0ZXh0dXJlcycsXG5cdFx0XHRcdGluZGV4OiB0ZXh0dXJlSW5kZXhcblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQXN5bmNocm9ub3VzbHkgYXNzaWducyBhIHRleHR1cmUgdG8gdGhlIGdpdmVuIG1hdGVyaWFsIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbFBhcmFtc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWFwRGVmXG5cdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5hc3NpZ25UZXh0dXJlID0gZnVuY3Rpb24gKCBtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAndGV4dHVyZScsIG1hcERlZi5pbmRleCApLnRoZW4oIGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuXHRcdFx0Ly8gTWF0ZXJpYWxzIHNhbXBsZSBhb01hcCBmcm9tIFVWIHNldCAxIGFuZCBvdGhlciBtYXBzIGZyb20gVVYgc2V0IDAgLSB0aGlzIGNhbid0IGJlIGNvbmZpZ3VyZWRcblx0XHRcdC8vIEhvd2V2ZXIsIHdlIHdpbGwgY29weSBVViBzZXQgMCB0byBVViBzZXQgMSBvbiBkZW1hbmQgZm9yIGFvTWFwXG5cdFx0XHRpZiAoIG1hcERlZi50ZXhDb29yZCAhPT0gdW5kZWZpbmVkICYmIG1hcERlZi50ZXhDb29yZCAhPSAwICYmICEgKCBtYXBOYW1lID09PSAnYW9NYXAnICYmIG1hcERlZi50ZXhDb29yZCA9PSAxICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogQ3VzdG9tIFVWIHNldCAnICsgbWFwRGVmLnRleENvb3JkICsgJyBmb3IgdGV4dHVyZSAnICsgbWFwTmFtZSArICcgbm90IHlldCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFyc2VyLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0gKSB7XG5cblx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB1bmRlZmluZWQgPyBtYXBEZWYuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXSA6IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRcdHZhciBnbHRmUmVmZXJlbmNlID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQoIHRleHR1cmUgKTtcblx0XHRcdFx0XHR0ZXh0dXJlID0gcGFyc2VyLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNIF0uZXh0ZW5kVGV4dHVyZSggdGV4dHVyZSwgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIHRleHR1cmUsIGdsdGZSZWZlcmVuY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXNbIG1hcE5hbWUgXSA9IHRleHR1cmU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG5cdCAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG5cdCAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG5cdCAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG5cdCAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cblx0ICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuYXNzaWduRmluYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cdFx0dmFyIG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcblxuXHRcdHZhciB1c2VWZXJ0ZXhUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCAhPT0gdW5kZWZpbmVkO1xuXHRcdHZhciB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHVzZUZsYXRTaGFkaW5nID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZDtcblx0XHR2YXIgdXNlU2tpbm5pbmcgPSBtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWU7XG5cdFx0dmFyIHVzZU1vcnBoVGFyZ2V0cyA9IE9iamVjdC5rZXlzKCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKS5sZW5ndGggPiAwO1xuXHRcdHZhciB1c2VNb3JwaE5vcm1hbHMgPSB1c2VNb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCBtZXNoLmlzUG9pbnRzICkge1xuXG5cdFx0XHR2YXIgY2FjaGVLZXkgPSAnUG9pbnRzTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQ7XG5cblx0XHRcdHZhciBwb2ludHNNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgcG9pbnRzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcblx0XHRcdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggcG9pbnRzTWF0ZXJpYWwsIG1hdGVyaWFsICk7XG5cdFx0XHRcdHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0XHRcdHBvaW50c01hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7IC8vIGdsVEYgc3BlYyBzYXlzIHBvaW50cyBzaG91bGQgYmUgMXB4XG5cblx0XHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBwb2ludHNNYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsID0gcG9pbnRzTWF0ZXJpYWw7XG5cblx0XHR9IGVsc2UgaWYgKCBtZXNoLmlzTGluZSApIHtcblxuXHRcdFx0dmFyIGNhY2hlS2V5ID0gJ0xpbmVCYXNpY01hdGVyaWFsOicgKyBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHR2YXIgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBsaW5lTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0bGluZU1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cblx0XHRcdFx0dGhpcy5jYWNoZS5hZGQoIGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSBtYXRlcmlhbCBpZiBpdCB3aWxsIGJlIG1vZGlmaWVkXG5cdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcgfHwgdXNlU2tpbm5pbmcgfHwgdXNlTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHR2YXIgY2FjaGVLZXkgPSAnQ2xvbmVkTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQgKyAnOic7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgKSBjYWNoZUtleSArPSAnc3BlY3VsYXItZ2xvc3NpbmVzczonO1xuXHRcdFx0aWYgKCB1c2VTa2lubmluZyApIGNhY2hlS2V5ICs9ICdza2lubmluZzonO1xuXHRcdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyApIGNhY2hlS2V5ICs9ICd2ZXJ0ZXgtdGFuZ2VudHM6Jztcblx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVLZXkgKz0gJ3ZlcnRleC1jb2xvcnM6Jztcblx0XHRcdGlmICggdXNlRmxhdFNoYWRpbmcgKSBjYWNoZUtleSArPSAnZmxhdC1zaGFkaW5nOic7XG5cdFx0XHRpZiAoIHVzZU1vcnBoVGFyZ2V0cyApIGNhY2hlS2V5ICs9ICdtb3JwaC10YXJnZXRzOic7XG5cdFx0XHRpZiAoIHVzZU1vcnBoTm9ybWFscyApIGNhY2hlS2V5ICs9ICdtb3JwaC1ub3JtYWxzOic7XG5cblx0XHRcdHZhciBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KCBjYWNoZUtleSApO1xuXG5cdFx0XHRpZiAoICEgY2FjaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXG5cdFx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSBjYWNoZWRNYXRlcmlhbC5za2lubmluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlVmVydGV4Q29sb3JzICkgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VGbGF0U2hhZGluZyApIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VNb3JwaFRhcmdldHMgKSBjYWNoZWRNYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHVzZU1vcnBoTm9ybWFscyApIGNhY2hlZE1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCB1c2VWZXJ0ZXhUYW5nZW50cyApIHtcblxuXHRcdFx0XHRcdGNhY2hlZE1hdGVyaWFsLnZlcnRleFRhbmdlbnRzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlICkgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSApIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsICk7XG5cblx0XHRcdFx0dGhpcy5hc3NvY2lhdGlvbnMuc2V0KCBjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KCBtYXRlcmlhbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdC8vIHdvcmthcm91bmRzIGZvciBtZXNoIGFuZCBnZW9tZXRyeVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5hb01hcCAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2MiA9PT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYyJywgZ2VvbWV0cnkuYXR0cmlidXRlcy51diApO1xuXG5cdFx0fVxuXG5cdFx0bWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG5cdH07XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxUeXBlID0gZnVuY3Rpb24gKCAvKiBtYXRlcmlhbEluZGV4ICovICkge1xuXG5cdFx0cmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWF0ZXJpYWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXRlcmlhbEluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8TWF0ZXJpYWw+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0dmFyIG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcblxuXHRcdHZhciBtYXRlcmlhbFR5cGU7XG5cdFx0dmFyIG1hdGVyaWFsUGFyYW1zID0ge307XG5cdFx0dmFyIG1hdGVyaWFsRXh0ZW5zaW9ucyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwge307XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdICkge1xuXG5cdFx0XHR2YXIgc2dFeHRlbnNpb24gPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MgXTtcblx0XHRcdG1hdGVyaWFsVHlwZSA9IHNnRXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuXHRcdFx0cGVuZGluZy5wdXNoKCBzZ0V4dGVuc2lvbi5leHRlbmRQYXJhbXMoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUIF0gKSB7XG5cblx0XHRcdHZhciBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXTtcblx0XHRcdG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcblx0XHRcdHBlbmRpbmcucHVzaCgga211RXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3BlY2lmaWNhdGlvbjpcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNtZXRhbGxpYy1yb3VnaG5lc3MtbWF0ZXJpYWxcblxuXHRcdFx0dmFyIG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciApICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVsgMyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbWFwJywgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMS4wO1xuXHRcdFx0bWF0ZXJpYWxQYXJhbXMucm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yICE9PSB1bmRlZmluZWQgPyBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgOiAxLjA7XG5cblx0XHRcdGlmICggbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtZXRhbG5lc3NNYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgKSApO1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ3JvdWdobmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBQcm9taXNlLmFsbCggdGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zICYmIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fSApICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGFscGhhTW9kZSA9IG1hdGVyaWFsRGVmLmFscGhhTW9kZSB8fCBBTFBIQV9NT0RFUy5PUEFRVUU7XG5cblx0XHRpZiAoIGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuQkxFTkQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNzcwNlxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuZGVwdGhXcml0ZSA9IGZhbHNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLk1BU0sgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuYWxwaGFUZXN0ID0gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmIDogMC41O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ25vcm1hbE1hcCcsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgKSApO1xuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xMTQzOCNpc3N1ZWNvbW1lbnQtNTA3MDAzOTk1XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAtIDEgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KCBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlLCAtIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdhb01hcCcsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgKSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5hb01hcEludGVuc2l0eSA9IG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdlbWlzc2l2ZU1hcCcsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbDtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbFR5cGUgPT09IEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTIF0uY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsUGFyYW1zICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYubmFtZSApIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuXG5cdFx0XHQvLyBiYXNlQ29sb3JUZXh0dXJlLCBlbWlzc2l2ZVRleHR1cmUsIGFuZCBzcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlIHVzZSBzUkdCIGVuY29kaW5nLlxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSBtYXRlcmlhbC5tYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggbWF0ZXJpYWwsIHsgdHlwZTogJ21hdGVyaWFscycsIGluZGV4OiBtYXRlcmlhbEluZGV4IH0gKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmNyZWF0ZVVuaXF1ZU5hbWUgPSBmdW5jdGlvbiAoIG9yaWdpbmFsTmFtZSApIHtcblxuXHRcdHZhciBzYW5pdGl6ZWROYW1lID0gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIG9yaWdpbmFsTmFtZSB8fCAnJyApO1xuXG5cdFx0dmFyIG5hbWUgPSBzYW5pdGl6ZWROYW1lO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAxOyB0aGlzLm5vZGVOYW1lc1VzZWRbIG5hbWUgXTsgKysgaSApIHtcblxuXHRcdFx0bmFtZSA9IHNhbml0aXplZE5hbWUgKyAnXycgKyBpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ub2RlTmFtZXNVc2VkWyBuYW1lIF0gPSB0cnVlO1xuXG5cdFx0cmV0dXJuIG5hbWU7XG5cblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcblx0ICogQHBhcmFtIHtHTFRGLlByaW1pdGl2ZX0gcHJpbWl0aXZlRGVmXG5cdCAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG5cdCAqL1xuXHRmdW5jdGlvbiBjb21wdXRlQm91bmRzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzWyBhdHRyaWJ1dGVzLlBPU0lUSU9OIF07XG5cblx0XHRcdHZhciBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0XHR2YXIgbWF4ID0gYWNjZXNzb3IubWF4O1xuXG5cdFx0XHQvLyBnbFRGIHJlcXVpcmVzICdtaW4nIGFuZCAnbWF4JywgYnV0IFZSTSAod2hpY2ggZXh0ZW5kcyBnbFRGKSBjdXJyZW50bHkgaWdub3JlcyB0aGF0IHJlcXVpcmVtZW50LlxuXG5cdFx0XHRpZiAoIG1pbiAhPT0gdW5kZWZpbmVkICYmIG1heCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJveC5zZXQoXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjMoIG1pblsgMCBdLCBtaW5bIDEgXSwgbWluWyAyIF0gKSxcblx0XHRcdFx0XHRuZXcgVmVjdG9yMyggbWF4WyAwIF0sIG1heFsgMSBdLCBtYXhbIDIgXSApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLicgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciB0YXJnZXRzID0gcHJpbWl0aXZlRGVmLnRhcmdldHM7XG5cblx0XHRpZiAoIHRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIG1heERpc3BsYWNlbWVudCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzWyB0YXJnZXQuUE9TSVRJT04gXTtcblx0XHRcdFx0XHR2YXIgbWluID0gYWNjZXNzb3IubWluO1xuXHRcdFx0XHRcdHZhciBtYXggPSBhY2Nlc3Nvci5tYXg7XG5cblx0XHRcdFx0XHQvLyBnbFRGIHJlcXVpcmVzICdtaW4nIGFuZCAnbWF4JywgYnV0IFZSTSAod2hpY2ggZXh0ZW5kcyBnbFRGKSBjdXJyZW50bHkgaWdub3JlcyB0aGF0IHJlcXVpcmVtZW50LlxuXG5cdFx0XHRcdFx0aWYgKCBtaW4gIT09IHVuZGVmaW5lZCAmJiBtYXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBnZXQgbWF4IG9mIGFic29sdXRlIGNvbXBvbmVudHMgYmVjYXVzZSB0YXJnZXQgd2VpZ2h0IGlzIFstMSwxXVxuXHRcdFx0XHRcdFx0dmVjdG9yLnNldFgoIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAwIF0gKSwgTWF0aC5hYnMoIG1heFsgMCBdICkgKSApO1xuXHRcdFx0XHRcdFx0dmVjdG9yLnNldFkoIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAxIF0gKSwgTWF0aC5hYnMoIG1heFsgMSBdICkgKSApO1xuXHRcdFx0XHRcdFx0dmVjdG9yLnNldFooIE1hdGgubWF4KCBNYXRoLmFicyggbWluWyAyIF0gKSwgTWF0aC5hYnMoIG1heFsgMiBdICkgKSApO1xuXG5cdFx0XHRcdFx0XHQvLyBOb3RlOiB0aGlzIGFzc3VtZXMgdGhhdCB0aGUgc3VtIG9mIGFsbCB3ZWlnaHRzIGlzIGF0IG1vc3QgMS4gVGhpcyBpc24ndCBxdWl0ZSBjb3JyZWN0IC0gaXQncyBtb3JlIGNvbnNlcnZhdGl2ZVxuXHRcdFx0XHRcdFx0Ly8gdG8gYXNzdW1lIHRoYXQgZWFjaCB0YXJnZXQgY2FuIGhhdmUgYSBtYXggd2VpZ2h0IG9mIDEuIEhvd2V2ZXIsIGZvciBzb21lIHVzZSBjYXNlcyAtIG5vdGFibHksIHdoZW4gbW9ycGggdGFyZ2V0c1xuXHRcdFx0XHRcdFx0Ly8gYXJlIHVzZWQgdG8gaW1wbGVtZW50IGtleS1mcmFtZSBhbmltYXRpb25zIGFuZCBhcyBzdWNoIG9ubHkgdHdvIGFyZSBhY3RpdmUgYXQgYSB0aW1lIC0gdGhpcyByZXN1bHRzIGluIHZlcnkgbGFyZ2Vcblx0XHRcdFx0XHRcdC8vIGJveGVzLiBTbyBmb3Igbm93IHdlIG1ha2UgYSBib3ggdGhhdCdzIHNvbWV0aW1lcyBhIHRvdWNoIHRvbyBzbWFsbCBidXQgaXMgaG9wZWZ1bGx5IG1vc3RseSBvZiByZWFzb25hYmxlIHNpemUuXG5cdFx0XHRcdFx0XHRtYXhEaXNwbGFjZW1lbnQubWF4KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFzIHBlciBjb21tZW50IGFib3ZlIHRoaXMgYm94IGlzbid0IGNvbnNlcnZhdGl2ZSwgYnV0IGhhcyBhIHJlYXNvbmFibGUgc2l6ZSBmb3IgYSB2ZXJ5IGxhcmdlIG51bWJlciBvZiBtb3JwaCB0YXJnZXRzLlxuXHRcdFx0Ym94LmV4cGFuZEJ5VmVjdG9yKCBtYXhEaXNwbGFjZW1lbnQgKTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gYm94O1xuXG5cdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuXHRcdGJveC5nZXRDZW50ZXIoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHRzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKCBib3gubWF4ICkgLyAyO1xuXG5cdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge0dMVEYuUHJpbWl0aXZlfSBwcmltaXRpdmVEZWZcblx0ICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcblx0ICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXJHZW9tZXRyeT59XG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzO1xuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZUFjY2Vzc29yKCBhY2Nlc3NvckluZGV4LCBhdHRyaWJ1dGVOYW1lICkge1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIGFjY2Vzc29ySW5kZXggKVxuXHRcdFx0XHQudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSwgYWNjZXNzb3IgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgZ2x0ZkF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0Ly8gU2tpcCBhdHRyaWJ1dGVzIGFscmVhZHkgcHJvdmlkZWQgYnkgZS5nLiBEcmFjbyBleHRlbnNpb24uXG5cdFx0XHRpZiAoIHRocmVlQXR0cmlidXRlTmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkgY29udGludWU7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGF0dHJpYnV0ZXNbIGdsdGZBdHRyaWJ1dGVOYW1lIF0sIHRocmVlQXR0cmlidXRlTmFtZSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHByaW1pdGl2ZURlZi5pbmRpY2VzICE9PSB1bmRlZmluZWQgJiYgISBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0dmFyIGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHByaW1pdGl2ZURlZi5pbmRpY2VzICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvciApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggYWNjZXNzb3IgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIGFjY2Vzc29yICk7XG5cblx0XHR9XG5cblx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmICk7XG5cblx0XHRjb21wdXRlQm91bmRzKCBnZW9tZXRyeSwgcHJpbWl0aXZlRGVmLCBwYXJzZXIgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB1bmRlZmluZWRcblx0XHRcdFx0PyBhZGRNb3JwaFRhcmdldHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyIClcblx0XHRcdFx0OiBnZW9tZXRyeTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkcmF3TW9kZVxuXHQgKiBAcmV0dXJuIHtCdWZmZXJHZW9tZXRyeX1cblx0ICovXG5cdGZ1bmN0aW9uIHRvVHJpYW5nbGVzRHJhd01vZGUoIGdlb21ldHJ5LCBkcmF3TW9kZSApIHtcblxuXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0XHQvLyBnZW5lcmF0ZSBpbmRleCBpZiBub3QgcHJlc2VudFxuXG5cdFx0aWYgKCBpbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cblx0XHRcdGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdFx0XHRpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdMVEZMb2FkZXIudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS4nICk7XG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBudW1iZXJPZlRyaWFuZ2xlcyA9IGluZGV4LmNvdW50IC0gMjtcblx0XHR2YXIgbmV3SW5kaWNlcyA9IFtdO1xuXG5cdFx0aWYgKCBkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSApIHtcblxuXHRcdFx0Ly8gZ2wuVFJJQU5HTEVfRkFOXG5cblx0XHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSBudW1iZXJPZlRyaWFuZ2xlczsgaSArKyApIHtcblxuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIDAgKSApO1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAxICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZ2wuVFJJQU5HTEVfU1RSSVBcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBpICUgMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSApICk7XG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMiApICk7XG5cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMiApICk7XG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICsgMSApICk7XG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggKCBuZXdJbmRpY2VzLmxlbmd0aCAvIDMgKSAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5hYmxlIHRvIGdlbmVyYXRlIGNvcnJlY3QgYW1vdW50IG9mIHRyaWFuZ2xlcy4nICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBmaW5hbCBnZW9tZXRyeVxuXG5cdFx0dmFyIG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcblx0XHRuZXdHZW9tZXRyeS5zZXRJbmRleCggbmV3SW5kaWNlcyApO1xuXG5cdFx0cmV0dXJuIG5ld0dlb21ldHJ5O1xuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuXHQgKlxuXHQgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkR2VvbWV0cmllcyA9IGZ1bmN0aW9uICggcHJpbWl0aXZlcyApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdHZhciBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0XHRyZXR1cm4gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiBdXG5cdFx0XHRcdC5kZWNvZGVQcmltaXRpdmUoIHByaW1pdGl2ZSwgcGFyc2VyIClcblx0XHRcdFx0LnRoZW4oIGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXHRcdFx0dmFyIGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KCBwcmltaXRpdmUgKTtcblxuXHRcdFx0Ly8gU2VlIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCB0aGlzIGdlb21ldHJ5XG5cdFx0XHR2YXIgY2FjaGVkID0gY2FjaGVbIGNhY2hlS2V5IF07XG5cblx0XHRcdGlmICggY2FjaGVkICkge1xuXG5cdFx0XHRcdC8vIFVzZSB0aGUgY2FjaGVkIGdlb21ldHJ5IGlmIGl0IGV4aXN0c1xuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGNhY2hlZC5wcm9taXNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5UHJvbWlzZTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBVc2UgRFJBQ08gZ2VvbWV0cnkgaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUoIHByaW1pdGl2ZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGdlb21ldHJ5XG5cdFx0XHRcdFx0Z2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyggbmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIHRoaXMgZ2VvbWV0cnlcblx0XHRcdFx0Y2FjaGVbIGNhY2hlS2V5IF0gPSB7IHByaW1pdGl2ZTogcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIGdlb21ldHJ5UHJvbWlzZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21lc2hlc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWVzaEluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXB8TWVzaHxTa2lubmVkTWVzaD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkTWVzaCA9IGZ1bmN0aW9uICggbWVzaEluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cblx0XHR2YXIgbWVzaERlZiA9IGpzb24ubWVzaGVzWyBtZXNoSW5kZXggXTtcblx0XHR2YXIgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gcHJpbWl0aXZlc1sgaSBdLm1hdGVyaWFsID09PSB1bmRlZmluZWRcblx0XHRcdFx0PyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoIHRoaXMuY2FjaGUgKVxuXHRcdFx0XHQ6IHRoaXMuZ2V0RGVwZW5kZW5jeSggJ21hdGVyaWFsJywgcHJpbWl0aXZlc1sgaSBdLm1hdGVyaWFsICk7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmxvYWRHZW9tZXRyaWVzKCBwcmltaXRpdmVzICkgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICggcmVzdWx0cyApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoIDAsIHJlc3VsdHMubGVuZ3RoIC0gMSApO1xuXHRcdFx0dmFyIGdlb21ldHJpZXMgPSByZXN1bHRzWyByZXN1bHRzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0dmFyIG1lc2hlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0XHRcdHZhciBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cblx0XHRcdFx0Ly8gMS4gY3JlYXRlIE1lc2hcblxuXHRcdFx0XHR2YXIgbWVzaDtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8XG5cdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fFxuXHRcdFx0XHRcdHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8XG5cdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIC5pc1NraW5uZWRNZXNoIGlzbid0IGluIGdsVEYgc3BlYy4gU2VlIC5fbWFya0RlZnMoKVxuXHRcdFx0XHRcdG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWVcblx0XHRcdFx0XHRcdD8gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKVxuXHRcdFx0XHRcdFx0OiBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSAmJiAhIG1lc2guZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0Lm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHdlIG5vcm1hbGl6ZSBmbG9hdGluZyBwb2ludCBza2luIHdlaWdodCBhcnJheSB0byBmaXggbWFsZm9ybWVkIGFzc2V0cyAoc2VlICMxNTMxOSlcblx0XHRcdFx0XHRcdC8vIGl0J3MgaW1wb3J0YW50IHRvIHNraXAgdGhpcyBmb3Igbm9uLWZsb2F0MzIgZGF0YSBzaW5jZSBub3JtYWxpemVTa2luV2VpZ2h0cyBhc3N1bWVzIG5vbi1ub3JtYWxpemVkIGlucHV0c1xuXHRcdFx0XHRcdFx0bWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZSggbWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiApIHtcblxuXHRcdFx0XHRcdFx0bWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUoIG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1AgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVMb29wKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUyApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6ICcgKyBwcmltaXRpdmUubW9kZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIE9iamVjdC5rZXlzKCBtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHR1cGRhdGVNb3JwaFRhcmdldHMoIG1lc2gsIG1lc2hEZWYgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIG1lc2hEZWYubmFtZSB8fCAoICdtZXNoXycgKyBtZXNoSW5kZXggKSApO1xuXG5cdFx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG1lc2gsIG1lc2hEZWYgKTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUgKTtcblxuXHRcdFx0XHRwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbCggbWVzaCApO1xuXG5cdFx0XHRcdG1lc2hlcy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXNoZXMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdHJldHVybiBtZXNoZXNbIDAgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRncm91cC5hZGQoIG1lc2hlc1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkQ2FtZXJhID0gZnVuY3Rpb24gKCBjYW1lcmFJbmRleCApIHtcblxuXHRcdHZhciBjYW1lcmE7XG5cdFx0dmFyIGNhbWVyYURlZiA9IHRoaXMuanNvbi5jYW1lcmFzWyBjYW1lcmFJbmRleCBdO1xuXHRcdHZhciBwYXJhbXMgPSBjYW1lcmFEZWZbIGNhbWVyYURlZi50eXBlIF07XG5cblx0XHRpZiAoICEgcGFyYW1zICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLicgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggY2FtZXJhRGVmLnR5cGUgPT09ICdwZXJzcGVjdGl2ZScgKSB7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggTWF0aFV0aWxzLnJhZFRvRGVnKCBwYXJhbXMueWZvdiApLCBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSwgcGFyYW1zLnpuZWFyIHx8IDEsIHBhcmFtcy56ZmFyIHx8IDJlNiApO1xuXG5cdFx0fSBlbHNlIGlmICggY2FtZXJhRGVmLnR5cGUgPT09ICdvcnRob2dyYXBoaWMnICkge1xuXG5cdFx0XHRjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIHBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC0gcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY2FtZXJhRGVmLm5hbWUgKSBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZSggY2FtZXJhRGVmLm5hbWUgKTtcblxuXHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIGNhbWVyYSwgY2FtZXJhRGVmICk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBjYW1lcmEgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkU2tpbiA9IGZ1bmN0aW9uICggc2tpbkluZGV4ICkge1xuXG5cdFx0dmFyIHNraW5EZWYgPSB0aGlzLmpzb24uc2tpbnNbIHNraW5JbmRleCBdO1xuXG5cdFx0dmFyIHNraW5FbnRyeSA9IHsgam9pbnRzOiBza2luRGVmLmpvaW50cyB9O1xuXG5cdFx0aWYgKCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggc2tpbkVudHJ5ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcyA9IGFjY2Vzc29yO1xuXG5cdFx0XHRyZXR1cm4gc2tpbkVudHJ5O1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICggYW5pbWF0aW9uSW5kZXggKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblxuXHRcdHZhciBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbIGFuaW1hdGlvbkluZGV4IF07XG5cblx0XHR2YXIgcGVuZGluZ05vZGVzID0gW107XG5cdFx0dmFyIHBlbmRpbmdJbnB1dEFjY2Vzc29ycyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG5cdFx0dmFyIHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nVGFyZ2V0cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbIGkgXTtcblx0XHRcdHZhciBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzWyBjaGFubmVsLnNhbXBsZXIgXTtcblx0XHRcdHZhciB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcblx0XHRcdHZhciBuYW1lID0gdGFyZ2V0Lm5vZGUgIT09IHVuZGVmaW5lZCA/IHRhcmdldC5ub2RlIDogdGFyZ2V0LmlkOyAvLyBOT1RFOiB0YXJnZXQuaWQgaXMgZGVwcmVjYXRlZC5cblx0XHRcdHZhciBpbnB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1sgc2FtcGxlci5pbnB1dCBdIDogc2FtcGxlci5pbnB1dDtcblx0XHRcdHZhciBvdXRwdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbIHNhbXBsZXIub3V0cHV0IF0gOiBzYW1wbGVyLm91dHB1dDtcblxuXHRcdFx0cGVuZGluZ05vZGVzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBuYW1lICkgKTtcblx0XHRcdHBlbmRpbmdJbnB1dEFjY2Vzc29ycy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIGlucHV0ICkgKTtcblx0XHRcdHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCBvdXRwdXQgKSApO1xuXHRcdFx0cGVuZGluZ1NhbXBsZXJzLnB1c2goIHNhbXBsZXIgKTtcblx0XHRcdHBlbmRpbmdUYXJnZXRzLnB1c2goIHRhcmdldCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbXG5cblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nTm9kZXMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ1NhbXBsZXJzICksXG5cdFx0XHRQcm9taXNlLmFsbCggcGVuZGluZ1RhcmdldHMgKVxuXG5cdFx0XSApLnRoZW4oIGZ1bmN0aW9uICggZGVwZW5kZW5jaWVzICkge1xuXG5cdFx0XHR2YXIgbm9kZXMgPSBkZXBlbmRlbmNpZXNbIDAgXTtcblx0XHRcdHZhciBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sgMSBdO1xuXHRcdFx0dmFyIG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sgMiBdO1xuXHRcdFx0dmFyIHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWyAzIF07XG5cdFx0XHR2YXIgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1sgNCBdO1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG5cdFx0XHRcdHZhciBpbnB1dEFjY2Vzc29yID0gaW5wdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0dmFyIG91dHB1dEFjY2Vzc29yID0gb3V0cHV0QWNjZXNzb3JzWyBpIF07XG5cdFx0XHRcdHZhciBzYW1wbGVyID0gc2FtcGxlcnNbIGkgXTtcblx0XHRcdFx0dmFyIHRhcmdldCA9IHRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdG5vZGUudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRcdG5vZGUubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0dmFyIFR5cGVkS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0XHRzd2l0Y2ggKCBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0gKSB7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFBBVEhfUFJPUEVSVElFUy5yb3RhdGlvbjpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnBvc2l0aW9uOlxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRhcmdldE5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUgOiBub2RlLnV1aWQ7XG5cblx0XHRcdFx0dmFyIGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHVuZGVmaW5lZCA/IElOVEVSUE9MQVRJT05bIHNhbXBsZXIuaW50ZXJwb2xhdGlvbiBdIDogSW50ZXJwb2xhdGVMaW5lYXI7XG5cblx0XHRcdFx0dmFyIHRhcmdldE5hbWVzID0gW107XG5cblx0XHRcdFx0aWYgKCBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzICkge1xuXG5cdFx0XHRcdFx0Ly8gTm9kZSBtYXkgYmUgYSBHcm91cCAoZ2xURiBtZXNoIHdpdGggc2V2ZXJhbCBwcmltaXRpdmVzKSBvciBhIE1lc2guXG5cdFx0XHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCA9PT0gdHJ1ZSAmJiBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzICkge1xuXG5cdFx0XHRcdFx0XHRcdHRhcmdldE5hbWVzLnB1c2goIG9iamVjdC5uYW1lID8gb2JqZWN0Lm5hbWUgOiBvYmplY3QudXVpZCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRhcmdldE5hbWVzLnB1c2goIHRhcmdldE5hbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG91dHB1dEFycmF5ID0gb3V0cHV0QWNjZXNzb3IuYXJyYXk7XG5cblx0XHRcdFx0aWYgKCBvdXRwdXRBY2Nlc3Nvci5ub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHNjYWxlO1xuXG5cdFx0XHRcdFx0aWYgKCBvdXRwdXRBcnJheS5jb25zdHJ1Y3RvciA9PT0gSW50OEFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IDEgLyAxMjc7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRBcnJheS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGUgPSAxIC8gMjU1O1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb3V0cHV0QXJyYXkuY29uc3RydWN0b3IgPT0gSW50MTZBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGUgPSAxIC8gMzI3Njc7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRBcnJheS5jb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdHNjYWxlID0gMSAvIDY1NTM1O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgb3V0cHV0IGFjY2Vzc29yIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KCBvdXRwdXRBcnJheS5sZW5ndGggKTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGVkWyBqIF0gPSBvdXRwdXRBcnJheVsgaiBdICogc2NhbGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXRBcnJheSA9IHNjYWxlZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayhcblx0XHRcdFx0XHRcdHRhcmdldE5hbWVzWyBqIF0gKyAnLicgKyBQQVRIX1BST1BFUlRJRVNbIHRhcmdldC5wYXRoIF0sXG5cdFx0XHRcdFx0XHRpbnB1dEFjY2Vzc29yLmFycmF5LFxuXHRcdFx0XHRcdFx0b3V0cHV0QXJyYXksXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGF0aW9uXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIE92ZXJyaWRlIGludGVycG9sYXRpb24gd2l0aCBjdXN0b20gZmFjdG9yeSBtZXRob2QuXG5cdFx0XHRcdFx0aWYgKCBzYW1wbGVyLmludGVycG9sYXRpb24gPT09ICdDVUJJQ1NQTElORScgKSB7XG5cblx0XHRcdFx0XHRcdHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBDVUJJQ1NQTElORSBrZXlmcmFtZSBpbiBnbFRGIGhhcyB0aHJlZSBvdXRwdXQgdmFsdWVzIGZvciBlYWNoIGlucHV0IHZhbHVlLFxuXHRcdFx0XHRcdFx0XHQvLyByZXByZXNlbnRpbmcgaW5UYW5nZW50LCBzcGxpbmVWZXJ0ZXgsIGFuZCBvdXRUYW5nZW50LiBBcyBhIHJlc3VsdCwgdHJhY2suZ2V0VmFsdWVTaXplKClcblx0XHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSBkaXZpZGVkIGJ5IHRocmVlIHRvIGdldCB0aGUgaW50ZXJwb2xhbnQncyBzYW1wbGVTaXplIGFyZ3VtZW50LlxuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpIC8gMywgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIE1hcmsgYXMgQ1VCSUNTUExJTkUuIGB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKClgIGRvZXNuJ3Qgc3VwcG9ydCBjdXN0b20gaW50ZXJwb2xhbnRzLlxuXHRcdFx0XHRcdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJhY2tzLnB1c2goIHRyYWNrICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBuYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6ICdhbmltYXRpb25fJyArIGFuaW1hdGlvbkluZGV4O1xuXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIG5hbWUsIHVuZGVmaW5lZCwgdHJhY2tzICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWROb2RlID0gZnVuY3Rpb24gKCBub2RlSW5kZXggKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblxuXHRcdHZhciBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHQvLyByZXNlcnZlIG5vZGUncyBuYW1lIGJlZm9yZSBpdHMgZGVwZW5kZW5jaWVzLCBzbyB0aGUgcm9vdCBoYXMgdGhlIGludGVuZGVkIG5hbWUuXG5cdFx0dmFyIG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIG5vZGVEZWYubmFtZSApIDogJyc7XG5cblx0XHRyZXR1cm4gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRcdGlmICggbm9kZURlZi5tZXNoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ21lc2gnLCBub2RlRGVmLm1lc2ggKS50aGVuKCBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZiggcGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoICk7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZWlnaHRzIGFyZSBwcm92aWRlZCBvbiB0aGUgbm9kZSwgb3ZlcnJpZGUgd2VpZ2h0cyBvbiB0aGUgbWVzaC5cblx0XHRcdFx0XHRpZiAoIG5vZGVEZWYud2VpZ2h0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG8gKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCAhIG8uaXNNZXNoICkgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdID0gbm9kZURlZi53ZWlnaHRzWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdFx0XHR9ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYuY2FtZXJhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2NhbWVyYScsIG5vZGVEZWYuY2FtZXJhICkudGhlbiggZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKCBwYXJzZXIuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhLCBjYW1lcmEgKTtcblxuXHRcdFx0XHR9ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRwYXJzZXIuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQoIG5vZGVJbmRleCApO1xuXG5cdFx0XHR9ICkuZm9yRWFjaCggZnVuY3Rpb24gKCBwcm9taXNlICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcHJvbWlzZSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdFx0fSgpICkudGhlbiggZnVuY3Rpb24gKCBvYmplY3RzICkge1xuXG5cdFx0XHR2YXIgbm9kZTtcblxuXHRcdFx0Ly8gLmlzQm9uZSBpc24ndCBpbiBnbFRGIHNwZWMuIFNlZSAuX21hcmtEZWZzXG5cdFx0XHRpZiAoIG5vZGVEZWYuaXNCb25lID09PSB0cnVlICkge1xuXG5cdFx0XHRcdG5vZGUgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRub2RlID0gb2JqZWN0c1sgMCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGUgIT09IG9iamVjdHNbIDAgXSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG5vZGUuYWRkKCBvYmplY3RzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlRGVmLm5hbWUgKSB7XG5cblx0XHRcdFx0bm9kZS51c2VyRGF0YS5uYW1lID0gbm9kZURlZi5uYW1lO1xuXHRcdFx0XHRub2RlLm5hbWUgPSBub2RlTmFtZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBub2RlLCBub2RlRGVmICk7XG5cblx0XHRcdGlmICggbm9kZURlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBub2RlLCBub2RlRGVmICk7XG5cblx0XHRcdGlmICggbm9kZURlZi5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggbm9kZURlZi5tYXRyaXggKTtcblx0XHRcdFx0bm9kZS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggbm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkoIG5vZGVEZWYudHJhbnNsYXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KCBub2RlRGVmLnJvdGF0aW9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZURlZi5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5zY2FsZS5mcm9tQXJyYXkoIG5vZGVEZWYuc2NhbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIG5vZGUsIHsgdHlwZTogJ25vZGVzJywgaW5kZXg6IG5vZGVJbmRleCB9ICk7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNzY2VuZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNjZW5lSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxHcm91cD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkU2NlbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBzY2VuZSBub2RlIGhpZXJhY2h5IGJ1aWxkZXJcblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZUhpZXJhY2h5KCBub2RlSWQsIHBhcmVudE9iamVjdCwganNvbiwgcGFyc2VyICkge1xuXG5cdFx0XHR2YXIgbm9kZURlZiA9IGpzb24ubm9kZXNbIG5vZGVJZCBdO1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koICdub2RlJywgbm9kZUlkICkudGhlbiggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdGlmICggbm9kZURlZi5za2luID09PSB1bmRlZmluZWQgKSByZXR1cm4gbm9kZTtcblxuXHRcdFx0XHQvLyBidWlsZCBza2VsZXRvbiBoZXJlIGFzIHdlbGxcblxuXHRcdFx0XHR2YXIgc2tpbkVudHJ5O1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ3NraW4nLCBub2RlRGVmLnNraW4gKS50aGVuKCBmdW5jdGlvbiAoIHNraW4gKSB7XG5cblx0XHRcdFx0XHRza2luRW50cnkgPSBza2luO1xuXG5cdFx0XHRcdFx0dmFyIHBlbmRpbmdKb2ludHMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBza2luRW50cnkuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRwZW5kaW5nSm9pbnRzLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbm9kZScsIHNraW5FbnRyeS5qb2ludHNbIGkgXSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmdKb2ludHMgKTtcblxuXHRcdFx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCBqb2ludE5vZGVzICkge1xuXG5cdFx0XHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgbWVzaC5pc01lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdHZhciBib25lcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gam9pbnROb2Rlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbnROb2RlID0gam9pbnROb2Rlc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggam9pbnROb2RlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ym9uZXMucHVzaCggam9pbnROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0ID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggc2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bWF0LmZyb21BcnJheSggc2tpbkVudHJ5LmludmVyc2VCaW5kTWF0cmljZXMuYXJyYXksIGogKiAxNiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ym9uZUludmVyc2VzLnB1c2goIG1hdCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5FbnRyeS5qb2ludHNbIGogXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtZXNoLmJpbmQoIG5ldyBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcyApLCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gYnVpbGQgbm9kZSBoaWVyYWNoeVxuXG5cdFx0XHRcdHBhcmVudE9iamVjdC5hZGQoIG5vZGUgKTtcblxuXHRcdFx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0XHRcdGlmICggbm9kZURlZi5jaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdHZhciBjaGlsZHJlbiA9IG5vZGVEZWYuY2hpbGRyZW47XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIGJ1aWxkTm9kZUhpZXJhY2h5KCBjaGlsZCwgbm9kZSwganNvbiwgcGFyc2VyICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiBsb2FkU2NlbmUoIHNjZW5lSW5kZXggKSB7XG5cblx0XHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0XHR2YXIgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzWyBzY2VuZUluZGV4IF07XG5cdFx0XHR2YXIgcGFyc2VyID0gdGhpcztcblxuXHRcdFx0Ly8gTG9hZGVyIHJldHVybnMgR3JvdXAsIG5vdCBTY2VuZS5cblx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTgzNDIjaXNzdWVjb21tZW50LTU3ODk4MTE3MlxuXHRcdFx0dmFyIHNjZW5lID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRpZiAoIHNjZW5lRGVmLm5hbWUgKSBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIHNjZW5lRGVmLm5hbWUgKTtcblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRcdGlmICggc2NlbmVEZWYuZXh0ZW5zaW9ucyApIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSggZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmICk7XG5cblx0XHRcdHZhciBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG5cblx0XHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggYnVpbGROb2RlSGllcmFjaHkoIG5vZGVJZHNbIGkgXSwgc2NlbmUsIGpzb24sIHBhcnNlciApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fTtcblxuXHR9KCk7XG5cblx0cmV0dXJuIEdMVEZMb2FkZXI7XG5cbn0gKSgpO1xuXG52YXIgVEdBTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxufTtcblxuVEdBTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFRHQUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBzY29wZS5wYXJzZSggYnVmZmVyICk7XG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHQvLyByZWZlcmVuY2UgZnJvbSB2dGhpYmF1bHQsIGh0dHBzOi8vZ2l0aHViLmNvbS92dGhpYmF1bHQvcm9Ccm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9Mb2FkZXJzL1RhcmdhLmpzXG5cblx0XHRmdW5jdGlvbiB0Z2FDaGVja0hlYWRlciggaGVhZGVyICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBoZWFkZXIuaW1hZ2VfdHlwZSApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpbmRleGVkIHR5cGVcblxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX0lOREVYRUQ6XG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX0lOREVYRUQ6XG5cdFx0XHRcdFx0aWYgKCBoZWFkZXIuY29sb3JtYXBfbGVuZ3RoID4gMjU2IHx8IGhlYWRlci5jb2xvcm1hcF9zaXplICE9PSAyNCB8fCBoZWFkZXIuY29sb3JtYXBfdHlwZSAhPT0gMSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCB0eXBlIGNvbG9ybWFwIGRhdGEgZm9yIGluZGV4ZWQgdHlwZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGNvbG9ybWFwIHR5cGVcblxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JHQjpcblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9HUkVZOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9SR0I6XG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX0dSRVk6XG5cdFx0XHRcdFx0aWYgKCBoZWFkZXIuY29sb3JtYXBfdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogSW52YWxpZCB0eXBlIGNvbG9ybWFwIGRhdGEgZm9yIGNvbG9ybWFwIHR5cGUuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHQvLyBXaGF0IHRoZSBuZWVkIG9mIGEgZmlsZSB3aXRob3V0IGRhdGEgP1xuXG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfTk9fREFUQTpcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBObyBkYXRhLicgKTtcblxuXHRcdFx0XHRcdC8vIEludmFsaWQgdHlwZSA/XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBJbnZhbGlkIHR5cGUgXCIlc1wiLicsIGhlYWRlci5pbWFnZV90eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodFxuXG5cdFx0XHRpZiAoIGhlYWRlci53aWR0aCA8PSAwIHx8IGhlYWRlci5oZWlnaHQgPD0gMCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBJbnZhbGlkIGltYWdlIHNpemUuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGltYWdlIHBpeGVsIHNpemVcblxuXHRcdFx0aWYgKCBoZWFkZXIucGl4ZWxfc2l6ZSAhPT0gOCAmJiBoZWFkZXIucGl4ZWxfc2l6ZSAhPT0gMTYgJiZcblx0XHRcdFx0aGVhZGVyLnBpeGVsX3NpemUgIT09IDI0ICYmIGhlYWRlci5waXhlbF9zaXplICE9PSAzMiApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBJbnZhbGlkIHBpeGVsIHNpemUgXCIlc1wiLicsIGhlYWRlci5waXhlbF9zaXplICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIHRnYSBpbWFnZSBidWZmZXJcblxuXHRcdGZ1bmN0aW9uIHRnYVBhcnNlKCB1c2VfcmxlLCB1c2VfcGFsLCBoZWFkZXIsIG9mZnNldCwgZGF0YSApIHtcblxuXHRcdFx0dmFyIHBpeGVsX2RhdGEsXG5cdFx0XHRcdHBpeGVsX3NpemUsXG5cdFx0XHRcdHBpeGVsX3RvdGFsLFxuXHRcdFx0XHRwYWxldHRlcztcblxuXHRcdFx0cGl4ZWxfc2l6ZSA9IGhlYWRlci5waXhlbF9zaXplID4+IDM7XG5cdFx0XHRwaXhlbF90b3RhbCA9IGhlYWRlci53aWR0aCAqIGhlYWRlci5oZWlnaHQgKiBwaXhlbF9zaXplO1xuXG5cdFx0XHQgLy8gcmVhZCBwYWxldHRlc1xuXG5cdFx0XHQgaWYgKCB1c2VfcGFsICkge1xuXG5cdFx0XHRcdCBwYWxldHRlcyA9IGRhdGEuc3ViYXJyYXkoIG9mZnNldCwgb2Zmc2V0ICs9IGhlYWRlci5jb2xvcm1hcF9sZW5ndGggKiAoIGhlYWRlci5jb2xvcm1hcF9zaXplID4+IDMgKSApO1xuXG5cdFx0XHQgfVxuXG5cdFx0XHQgLy8gcmVhZCBSTEVcblxuXHRcdFx0IGlmICggdXNlX3JsZSApIHtcblxuXHRcdFx0XHQgcGl4ZWxfZGF0YSA9IG5ldyBVaW50OEFycmF5KCBwaXhlbF90b3RhbCApO1xuXG5cdFx0XHRcdHZhciBjLCBjb3VudCwgaTtcblx0XHRcdFx0dmFyIHNoaWZ0ID0gMDtcblx0XHRcdFx0dmFyIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KCBwaXhlbF9zaXplICk7XG5cblx0XHRcdFx0d2hpbGUgKCBzaGlmdCA8IHBpeGVsX3RvdGFsICkge1xuXG5cdFx0XHRcdFx0YyA9IGRhdGFbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdGNvdW50ID0gKCBjICYgMHg3ZiApICsgMTtcblxuXHRcdFx0XHRcdC8vIFJMRSBwaXhlbHNcblxuXHRcdFx0XHRcdGlmICggYyAmIDB4ODAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGJpbmQgcGl4ZWwgdG1wIGFycmF5XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGl4ZWxfc2l6ZTsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0XHRwaXhlbHNbIGkgXSA9IGRhdGFbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGNvcHkgcGl4ZWwgYXJyYXlcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjb3VudDsgKysgaSApIHtcblxuXHRcdFx0XHRcdFx0XHRwaXhlbF9kYXRhLnNldCggcGl4ZWxzLCBzaGlmdCArIGkgKiBwaXhlbF9zaXplICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2hpZnQgKz0gcGl4ZWxfc2l6ZSAqIGNvdW50O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmF3IHBpeGVsc1xuXG5cdFx0XHRcdFx0XHRjb3VudCAqPSBwaXhlbF9zaXplO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNvdW50OyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHBpeGVsX2RhdGFbIHNoaWZ0ICsgaSBdID0gZGF0YVsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2hpZnQgKz0gY291bnQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHQgfSBlbHNlIHtcblxuXHRcdFx0XHQvLyByYXcgcGl4ZWxzXG5cblx0XHRcdFx0cGl4ZWxfZGF0YSA9IGRhdGEuc3ViYXJyYXkoXG5cdFx0XHRcdFx0IG9mZnNldCwgb2Zmc2V0ICs9ICggdXNlX3BhbCA/IGhlYWRlci53aWR0aCAqIGhlYWRlci5oZWlnaHQgOiBwaXhlbF90b3RhbCApXG5cdFx0XHRcdCk7XG5cblx0XHRcdCB9XG5cblx0XHRcdCByZXR1cm4ge1xuXHRcdFx0XHRwaXhlbF9kYXRhOiBwaXhlbF9kYXRhLFxuXHRcdFx0XHRwYWxldHRlczogcGFsZXR0ZXNcblx0XHRcdCB9O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhOGJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UsIHBhbGV0dGVzICkge1xuXG5cdFx0XHR2YXIgY29sb3JtYXAgPSBwYWxldHRlcztcblx0XHRcdHZhciBjb2xvciwgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gaW1hZ2VbIGkgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IDI1NTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGNvbG9ybWFwWyAoIGNvbG9yICogMyApICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gY29sb3JtYXBbICggY29sb3IgKiAzICkgKyAxIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBjb2xvcm1hcFsgKCBjb2xvciAqIDMgKSArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YTE2Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGNvbG9yLCBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDIgKSB7XG5cblx0XHRcdFx0XHRjb2xvciA9IGltYWdlWyBpICsgMCBdICsgKCBpbWFnZVsgaSArIDEgXSA8PCA4ICk7IC8vIEludmVyc2VkID9cblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9ICggY29sb3IgJiAweDdDMDAgKSA+PiA3O1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gKCBjb2xvciAmIDB4MDNFMCApID4+IDI7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSAoIGNvbG9yICYgMHgwMDFGICkgPj4gMztcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9ICggY29sb3IgJiAweDgwMDAgKSA/IDAgOiAyNTU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGEyNGJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IDI1NTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gaW1hZ2VbIGkgKyAxIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAwIF0gPSBpbWFnZVsgaSArIDIgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YTMyYml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gNCApIHtcblxuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBpbWFnZVsgaSArIDEgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGltYWdlWyBpICsgMiBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gaW1hZ2VbIGkgKyAzIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGFHcmV5OGJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBjb2xvciwgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gaW1hZ2VbIGkgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGNvbG9yO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gY29sb3I7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBjb2xvcjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IDI1NTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YUdyZXkxNmJpdHMoIGltYWdlRGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICs9IDIgKSB7XG5cblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMSBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDMgXSA9IGltYWdlWyBpICsgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VGdhUkdCQSggZGF0YSwgd2lkdGgsIGhlaWdodCwgaW1hZ2UsIHBhbGV0dGUgKSB7XG5cblx0XHRcdHZhciB4X3N0YXJ0LFxuXHRcdFx0XHR5X3N0YXJ0LFxuXHRcdFx0XHR4X3N0ZXAsXG5cdFx0XHRcdHlfc3RlcCxcblx0XHRcdFx0eF9lbmQsXG5cdFx0XHRcdHlfZW5kO1xuXG5cdFx0XHRzd2l0Y2ggKCAoIGhlYWRlci5mbGFncyAmIFRHQV9PUklHSU5fTUFTSyApID4+IFRHQV9PUklHSU5fU0hJRlQgKSB7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y2FzZSBUR0FfT1JJR0lOX1VMOlxuXHRcdFx0XHRcdHhfc3RhcnQgPSAwO1xuXHRcdFx0XHRcdHhfc3RlcCA9IDE7XG5cdFx0XHRcdFx0eF9lbmQgPSB3aWR0aDtcblx0XHRcdFx0XHR5X3N0YXJ0ID0gMDtcblx0XHRcdFx0XHR5X3N0ZXAgPSAxO1xuXHRcdFx0XHRcdHlfZW5kID0gaGVpZ2h0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEdBX09SSUdJTl9CTDpcblx0XHRcdFx0XHR4X3N0YXJ0ID0gMDtcblx0XHRcdFx0XHR4X3N0ZXAgPSAxO1xuXHRcdFx0XHRcdHhfZW5kID0gd2lkdGg7XG5cdFx0XHRcdFx0eV9zdGFydCA9IGhlaWdodCAtIDE7XG5cdFx0XHRcdFx0eV9zdGVwID0gLSAxO1xuXHRcdFx0XHRcdHlfZW5kID0gLSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEdBX09SSUdJTl9VUjpcblx0XHRcdFx0XHR4X3N0YXJ0ID0gd2lkdGggLSAxO1xuXHRcdFx0XHRcdHhfc3RlcCA9IC0gMTtcblx0XHRcdFx0XHR4X2VuZCA9IC0gMTtcblx0XHRcdFx0XHR5X3N0YXJ0ID0gMDtcblx0XHRcdFx0XHR5X3N0ZXAgPSAxO1xuXHRcdFx0XHRcdHlfZW5kID0gaGVpZ2h0O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEdBX09SSUdJTl9CUjpcblx0XHRcdFx0XHR4X3N0YXJ0ID0gd2lkdGggLSAxO1xuXHRcdFx0XHRcdHhfc3RlcCA9IC0gMTtcblx0XHRcdFx0XHR4X2VuZCA9IC0gMTtcblx0XHRcdFx0XHR5X3N0YXJ0ID0gaGVpZ2h0IC0gMTtcblx0XHRcdFx0XHR5X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eV9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1c2VfZ3JleSApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBoZWFkZXIucGl4ZWxfc2l6ZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YUdyZXk4Yml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAxNjpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YUdyZXkxNmJpdHMoIGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBGb3JtYXQgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3dpdGNoICggaGVhZGVyLnBpeGVsX3NpemUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHR0Z2FHZXRJbWFnZURhdGE4Yml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UsIHBhbGV0dGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAxNjpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YTE2Yml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAyNDpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YTI0Yml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAzMjpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YTMyYml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEZvcm1hdCBub3Qgc3VwcG9ydGVkLicgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2FkIGltYWdlIGRhdGEgYWNjb3JkaW5nIHRvIHNwZWNpZmljIG1ldGhvZFxuXHRcdFx0Ly8gdmFyIGZ1bmMgPSAndGdhR2V0SW1hZ2VEYXRhJyArICh1c2VfZ3JleSA/ICdHcmV5JyA6ICcnKSArIChoZWFkZXIucGl4ZWxfc2l6ZSkgKyAnYml0cyc7XG5cdFx0XHQvLyBmdW5jKGRhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIHdpZHRoLCBpbWFnZSwgcGFsZXR0ZSApO1xuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBUR0EgY29uc3RhbnRzXG5cblx0XHR2YXIgVEdBX1RZUEVfTk9fREFUQSA9IDAsXG5cdFx0XHRUR0FfVFlQRV9JTkRFWEVEID0gMSxcblx0XHRcdFRHQV9UWVBFX1JHQiA9IDIsXG5cdFx0XHRUR0FfVFlQRV9HUkVZID0gMyxcblx0XHRcdFRHQV9UWVBFX1JMRV9JTkRFWEVEID0gOSxcblx0XHRcdFRHQV9UWVBFX1JMRV9SR0IgPSAxMCxcblx0XHRcdFRHQV9UWVBFX1JMRV9HUkVZID0gMTEsXG5cblx0XHRcdFRHQV9PUklHSU5fTUFTSyA9IDB4MzAsXG5cdFx0XHRUR0FfT1JJR0lOX1NISUZUID0gMHgwNCxcblx0XHRcdFRHQV9PUklHSU5fQkwgPSAweDAwLFxuXHRcdFx0VEdBX09SSUdJTl9CUiA9IDB4MDEsXG5cdFx0XHRUR0FfT1JJR0lOX1VMID0gMHgwMixcblx0XHRcdFRHQV9PUklHSU5fVVIgPSAweDAzO1xuXG5cdFx0aWYgKCBidWZmZXIubGVuZ3RoIDwgMTkgKSBjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBOb3QgZW5vdWdoIGRhdGEgdG8gY29udGFpbiBoZWFkZXIuJyApO1xuXG5cdFx0dmFyIGNvbnRlbnQgPSBuZXcgVWludDhBcnJheSggYnVmZmVyICksXG5cdFx0XHRvZmZzZXQgPSAwLFxuXHRcdFx0aGVhZGVyID0ge1xuXHRcdFx0XHRpZF9sZW5ndGg6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRjb2xvcm1hcF90eXBlOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0aW1hZ2VfdHlwZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGNvbG9ybWFwX2luZGV4OiBjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdGNvbG9ybWFwX2xlbmd0aDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRjb2xvcm1hcF9zaXplOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0b3JpZ2luOiBbXG5cdFx0XHRcdFx0Y29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRcdGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOFxuXHRcdFx0XHRdLFxuXHRcdFx0XHR3aWR0aDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRoZWlnaHQ6IGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0cGl4ZWxfc2l6ZTogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGZsYWdzOiBjb250ZW50WyBvZmZzZXQgKysgXVxuXHRcdFx0fTtcblxuXHRcdC8vIGNoZWNrIHRnYSBpZiBpdCBpcyB2YWxpZCBmb3JtYXRcblxuXHRcdHRnYUNoZWNrSGVhZGVyKCBoZWFkZXIgKTtcblxuXHRcdGlmICggaGVhZGVyLmlkX2xlbmd0aCArIG9mZnNldCA+IGJ1ZmZlci5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IE5vIGRhdGEuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2tpcCB0aGUgbmVlZG4ndCBkYXRhXG5cblx0XHRvZmZzZXQgKz0gaGVhZGVyLmlkX2xlbmd0aDtcblxuXHRcdC8vIGdldCB0YXJnYSBpbmZvcm1hdGlvbiBhYm91dCBSTEUgY29tcHJlc3Npb24gYW5kIHBhbGV0dGVcblxuXHRcdHZhciB1c2VfcmxlID0gZmFsc2UsXG5cdFx0XHR1c2VfcGFsID0gZmFsc2UsXG5cdFx0XHR1c2VfZ3JleSA9IGZhbHNlO1xuXG5cdFx0c3dpdGNoICggaGVhZGVyLmltYWdlX3R5cGUgKSB7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX0lOREVYRUQ6XG5cdFx0XHRcdHVzZV9ybGUgPSB0cnVlO1xuXHRcdFx0XHR1c2VfcGFsID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfSU5ERVhFRDpcblx0XHRcdFx0dXNlX3BhbCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9SR0I6XG5cdFx0XHRcdHVzZV9ybGUgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9SR0I6XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JMRV9HUkVZOlxuXHRcdFx0XHR1c2VfcmxlID0gdHJ1ZTtcblx0XHRcdFx0dXNlX2dyZXkgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9HUkVZOlxuXHRcdFx0XHR1c2VfZ3JleSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciB1c2VPZmZzY3JlZW4gPSB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJztcblxuXHRcdHZhciBjYW52YXMgPSB1c2VPZmZzY3JlZW4gPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKCBoZWFkZXIud2lkdGgsIGhlYWRlci5oZWlnaHQgKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0Y2FudmFzLndpZHRoID0gaGVhZGVyLndpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWFkZXIuaGVpZ2h0O1xuXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggaGVhZGVyLndpZHRoLCBoZWFkZXIuaGVpZ2h0ICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gdGdhUGFyc2UoIHVzZV9ybGUsIHVzZV9wYWwsIGhlYWRlciwgb2Zmc2V0LCBjb250ZW50ICk7XG5cdFx0Z2V0VGdhUkdCQSggaW1hZ2VEYXRhLmRhdGEsIGhlYWRlci53aWR0aCwgaGVhZGVyLmhlaWdodCwgcmVzdWx0LnBpeGVsX2RhdGEsIHJlc3VsdC5wYWxldHRlcyApO1xuXG5cdFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlRGF0YSwgMCwgMCApO1xuXG5cdFx0cmV0dXJuIGNhbnZhcztcblxuXHR9XG5cbn0gKTtcblxudmFyIENvbGxhZGFMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG59O1xuXG5Db2xsYWRhTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IENvbGxhZGFMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgcGF0aCA9ICggc2NvcGUucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHNjb3BlLnBhdGg7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQsIHBhdGggKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRvcHRpb25zOiB7XG5cblx0XHRzZXQgY29udmVydFVwQXhpcyggdmFsdWUgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IG9wdGlvbnMuY29udmVydFVwQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVwIGF4aXMgaXMgY29udmVydGVkIGF1dG9tYXRpY2FsbHkuJyApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCwgcGF0aCApIHtcblxuXHRcdGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsIG5hbWUgKSB7XG5cblx0XHRcdC8vIE5vbiByZWN1cnNpdmUgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkgLi4uXG5cblx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0dmFyIGNoaWxkTm9kZXMgPSB4bWwuY2hpbGROb2RlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVOYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTdHJpbmdzKCB0ZXh0ICkge1xuXG5cdFx0XHRpZiAoIHRleHQubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG5cdFx0XHR2YXIgcGFydHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCggL1xccysvICk7XG5cdFx0XHR2YXIgYXJyYXkgPSBuZXcgQXJyYXkoIHBhcnRzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBwYXJ0c1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRmxvYXRzKCB0ZXh0ICkge1xuXG5cdFx0XHRpZiAoIHRleHQubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG5cdFx0XHR2YXIgcGFydHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCggL1xccysvICk7XG5cdFx0XHR2YXIgYXJyYXkgPSBuZXcgQXJyYXkoIHBhcnRzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBwYXJzZUZsb2F0KCBwYXJ0c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJbnRzKCB0ZXh0ICkge1xuXG5cdFx0XHRpZiAoIHRleHQubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG5cdFx0XHR2YXIgcGFydHMgPSB0ZXh0LnRyaW0oKS5zcGxpdCggL1xccysvICk7XG5cdFx0XHR2YXIgYXJyYXkgPSBuZXcgQXJyYXkoIHBhcnRzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBwYXJzZUludCggcGFydHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhcnJheTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSWQoIHRleHQgKSB7XG5cblx0XHRcdHJldHVybiB0ZXh0LnN1YnN0cmluZyggMSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcblxuXHRcdFx0cmV0dXJuICd0aHJlZV9kZWZhdWx0XycgKyAoIGNvdW50ICsrICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0VtcHR5KCBvYmplY3QgKSB7XG5cblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyggb2JqZWN0ICkubGVuZ3RoID09PSAwO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXNzZXRcblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXNzZXQoIHhtbCApIHtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dW5pdDogcGFyc2VBc3NldFVuaXQoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICd1bml0JyApWyAwIF0gKSxcblx0XHRcdFx0dXBBeGlzOiBwYXJzZUFzc2V0VXBBeGlzKCBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAndXBfYXhpcycgKVsgMCBdIClcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFzc2V0VW5pdCggeG1sICkge1xuXG5cdFx0XHRpZiAoICggeG1sICE9PSB1bmRlZmluZWQgKSAmJiAoIHhtbC5oYXNBdHRyaWJ1dGUoICdtZXRlcicgKSA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCB4bWwuZ2V0QXR0cmlidXRlKCAnbWV0ZXInICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gMTsgLy8gZGVmYXVsdCAxIG1ldGVyXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXNzZXRVcEF4aXMoIHhtbCApIHtcblxuXHRcdFx0cmV0dXJuIHhtbCAhPT0gdW5kZWZpbmVkID8geG1sLnRleHRDb250ZW50IDogJ1lfVVAnO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGlicmFyeVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWJyYXJ5KCB4bWwsIGxpYnJhcnlOYW1lLCBub2RlTmFtZSwgcGFyc2VyICkge1xuXG5cdFx0XHR2YXIgbGlicmFyeSA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsIGxpYnJhcnlOYW1lIClbIDAgXTtcblxuXHRcdFx0aWYgKCBsaWJyYXJ5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGVsZW1lbnRzID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGxpYnJhcnksIG5vZGVOYW1lICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cGFyc2VyKCBlbGVtZW50c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZExpYnJhcnkoIGRhdGEsIGJ1aWxkZXIgKSB7XG5cblx0XHRcdGZvciAoIHZhciBuYW1lIGluIGRhdGEgKSB7XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IGRhdGFbIG5hbWUgXTtcblx0XHRcdFx0b2JqZWN0LmJ1aWxkID0gYnVpbGRlciggZGF0YVsgbmFtZSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdldFxuXG5cdFx0ZnVuY3Rpb24gZ2V0QnVpbGQoIGRhdGEsIGJ1aWxkZXIgKSB7XG5cblx0XHRcdGlmICggZGF0YS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHRcdGRhdGEuYnVpbGQgPSBidWlsZGVyKCBkYXRhICk7XG5cblx0XHRcdHJldHVybiBkYXRhLmJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0aW9uXG5cblx0XHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbiggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0c291cmNlczoge30sXG5cdFx0XHRcdHNhbXBsZXJzOiB7fSxcblx0XHRcdFx0Y2hhbm5lbHM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgaGFzQ2hpbGRyZW4gPSBmYWxzZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgaWQ7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0aWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlc1sgaWQgXSA9IHBhcnNlU291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzYW1wbGVyJzpcblx0XHRcdFx0XHRcdGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0XHRcdFx0XHRkYXRhLnNhbXBsZXJzWyBpZCBdID0gcGFyc2VBbmltYXRpb25TYW1wbGVyKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjaGFubmVsJzpcblx0XHRcdFx0XHRcdGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5jaGFubmVsc1sgaWQgXSA9IHBhcnNlQW5pbWF0aW9uQ2hhbm5lbCggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYW5pbWF0aW9uJzpcblx0XHRcdFx0XHRcdC8vIGhpZXJhcmNoeSBvZiByZWxhdGVkIGFuaW1hdGlvbnNcblx0XHRcdFx0XHRcdHBhcnNlQW5pbWF0aW9uKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0aGFzQ2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzQ2hpbGRyZW4gPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIHNpbmNlICdpZCcgYXR0cmlidXRlcyBjYW4gYmUgb3B0aW9uYWwsIGl0J3MgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIGEgVVVJRCBmb3IgdW5xaXVlIGFzc2lnbm1lbnRcblxuXHRcdFx0XHRsaWJyYXJ5LmFuaW1hdGlvbnNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSB8fCBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEKCkgXSA9IGRhdGE7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uU2FtcGxlciggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aW5wdXRzOiB7fSxcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdHZhciBzZW1hbnRpYyA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NlbWFudGljJyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5pbnB1dHNbIHNlbWFudGljIF0gPSBpZDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uQ2hhbm5lbCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0geG1sLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKTtcblxuXHRcdFx0Ly8gcGFyc2luZyBTSUQgQWRkcmVzc2luZyBTeW50YXhcblxuXHRcdFx0dmFyIHBhcnRzID0gdGFyZ2V0LnNwbGl0KCAnLycgKTtcblxuXHRcdFx0dmFyIGlkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdHZhciBzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHQvLyBjaGVjayBzZWxlY3Rpb24gc3ludGF4XG5cblx0XHRcdHZhciBhcnJheVN5bnRheCA9ICggc2lkLmluZGV4T2YoICcoJyApICE9PSAtIDEgKTtcblx0XHRcdHZhciBtZW1iZXJTeW50YXggPSAoIHNpZC5pbmRleE9mKCAnLicgKSAhPT0gLSAxICk7XG5cblx0XHRcdGlmICggbWVtYmVyU3ludGF4ICkge1xuXG5cdFx0XHRcdC8vICBtZW1iZXIgc2VsZWN0aW9uIGFjY2Vzc1xuXG5cdFx0XHRcdHBhcnRzID0gc2lkLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0c2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdFx0ZGF0YS5tZW1iZXIgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJheVN5bnRheCApIHtcblxuXHRcdFx0XHQvLyBhcnJheS1hY2Nlc3Mgc3ludGF4LiBjYW4gYmUgdXNlZCB0byBleHByZXNzIGZpZWxkcyBpbiBvbmUtZGltZW5zaW9uYWwgdmVjdG9ycyBvciB0d28tZGltZW5zaW9uYWwgbWF0cmljZXMuXG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBzaWQuc3BsaXQoICcoJyApO1xuXHRcdFx0XHRzaWQgPSBpbmRpY2VzLnNoaWZ0KCk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbmRpY2VzWyBpIF0gPSBwYXJzZUludCggaW5kaWNlc1sgaSBdLnJlcGxhY2UoIC9cXCkvLCAnJyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRhdGEuaW5kaWNlcyA9IGluZGljZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGF0YS5pZCA9IGlkO1xuXHRcdFx0ZGF0YS5zaWQgPSBzaWQ7XG5cblx0XHRcdGRhdGEuYXJyYXlTeW50YXggPSBhcnJheVN5bnRheDtcblx0XHRcdGRhdGEubWVtYmVyU3ludGF4ID0gbWVtYmVyU3ludGF4O1xuXG5cdFx0XHRkYXRhLnNhbXBsZXIgPSBwYXJzZUlkKCB4bWwuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRBbmltYXRpb24oIGRhdGEgKSB7XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0dmFyIGNoYW5uZWxzID0gZGF0YS5jaGFubmVscztcblx0XHRcdHZhciBzYW1wbGVycyA9IGRhdGEuc2FtcGxlcnM7XG5cdFx0XHR2YXIgc291cmNlcyA9IGRhdGEuc291cmNlcztcblxuXHRcdFx0Zm9yICggdmFyIHRhcmdldCBpbiBjaGFubmVscyApIHtcblxuXHRcdFx0XHRpZiAoIGNoYW5uZWxzLmhhc093blByb3BlcnR5KCB0YXJnZXQgKSApIHtcblxuXHRcdFx0XHRcdHZhciBjaGFubmVsID0gY2hhbm5lbHNbIHRhcmdldCBdO1xuXHRcdFx0XHRcdHZhciBzYW1wbGVyID0gc2FtcGxlcnNbIGNoYW5uZWwuc2FtcGxlciBdO1xuXG5cdFx0XHRcdFx0dmFyIGlucHV0SWQgPSBzYW1wbGVyLmlucHV0cy5JTlBVVDtcblx0XHRcdFx0XHR2YXIgb3V0cHV0SWQgPSBzYW1wbGVyLmlucHV0cy5PVVRQVVQ7XG5cblx0XHRcdFx0XHR2YXIgaW5wdXRTb3VyY2UgPSBzb3VyY2VzWyBpbnB1dElkIF07XG5cdFx0XHRcdFx0dmFyIG91dHB1dFNvdXJjZSA9IHNvdXJjZXNbIG91dHB1dElkIF07XG5cblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uID0gYnVpbGRBbmltYXRpb25DaGFubmVsKCBjaGFubmVsLCBpbnB1dFNvdXJjZSwgb3V0cHV0U291cmNlICk7XG5cblx0XHRcdFx0XHRjcmVhdGVLZXlmcmFtZVRyYWNrcyggYW5pbWF0aW9uLCB0cmFja3MgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyYWNrcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFuaW1hdGlvbiggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5hbmltYXRpb25zWyBpZCBdLCBidWlsZEFuaW1hdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRBbmltYXRpb25DaGFubmVsKCBjaGFubmVsLCBpbnB1dFNvdXJjZSwgb3V0cHV0U291cmNlICkge1xuXG5cdFx0XHR2YXIgbm9kZSA9IGxpYnJhcnkubm9kZXNbIGNoYW5uZWwuaWQgXTtcblx0XHRcdHZhciBvYmplY3QzRCA9IGdldE5vZGUoIG5vZGUuaWQgKTtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IG5vZGUudHJhbnNmb3Jtc1sgY2hhbm5lbC5zaWQgXTtcblx0XHRcdHZhciBkZWZhdWx0TWF0cml4ID0gbm9kZS5tYXRyaXguY2xvbmUoKS50cmFuc3Bvc2UoKTtcblxuXHRcdFx0dmFyIHRpbWUsIHN0cmlkZTtcblx0XHRcdHZhciBpLCBpbCwgaiwgamw7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdC8vIHRoZSBjb2xsYWRhIHNwZWMgYWxsb3dzIHRoZSBhbmltYXRpb24gb2YgZGF0YSBpbiB2YXJpb3VzIHdheXMuXG5cdFx0XHQvLyBkZXBlbmRpbmcgb24gdGhlIHRyYW5zZm9ybSB0eXBlIChtYXRyaXgsIHRyYW5zbGF0ZSwgcm90YXRlLCBzY2FsZSksIHdlIGV4ZWN1dGUgZGlmZmVyZW50IGxvZ2ljXG5cblx0XHRcdHN3aXRjaCAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gaW5wdXRTb3VyY2UuYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHRpbWUgPSBpbnB1dFNvdXJjZS5hcnJheVsgaSBdO1xuXHRcdFx0XHRcdFx0c3RyaWRlID0gaSAqIG91dHB1dFNvdXJjZS5zdHJpZGU7XG5cblx0XHRcdFx0XHRcdGlmICggZGF0YVsgdGltZSBdID09PSB1bmRlZmluZWQgKSBkYXRhWyB0aW1lIF0gPSB7fTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGFubmVsLmFycmF5U3ludGF4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IG91dHB1dFNvdXJjZS5hcnJheVsgc3RyaWRlIF07XG5cdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IGNoYW5uZWwuaW5kaWNlc1sgMCBdICsgNCAqIGNoYW5uZWwuaW5kaWNlc1sgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGRhdGFbIHRpbWUgXVsgaW5kZXggXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG91dHB1dFNvdXJjZS5zdHJpZGU7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIHRpbWUgXVsgaiBdID0gb3V0cHV0U291cmNlLmFycmF5WyBzdHJpZGUgKyBqIF07XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEFuaW1hdGlvbiB0cmFuc2Zvcm0gdHlwZSBcIiVzXCIgbm90IHlldCBpbXBsZW1lbnRlZC4nLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEFuaW1hdGlvbiB0cmFuc2Zvcm0gdHlwZSBcIiVzXCIgbm90IHlldCBpbXBsZW1lbnRlZC4nLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQW5pbWF0aW9uIHRyYW5zZm9ybSB0eXBlIFwiJXNcIiBub3QgeWV0IGltcGxlbWVudGVkLicsIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlmcmFtZXMgPSBwcmVwYXJlQW5pbWF0aW9uRGF0YSggZGF0YSwgZGVmYXVsdE1hdHJpeCApO1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0ge1xuXHRcdFx0XHRuYW1lOiBvYmplY3QzRC51dWlkLFxuXHRcdFx0XHRrZXlmcmFtZXM6IGtleWZyYW1lc1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByZXBhcmVBbmltYXRpb25EYXRhKCBkYXRhLCBkZWZhdWx0TWF0cml4ICkge1xuXG5cdFx0XHR2YXIga2V5ZnJhbWVzID0gW107XG5cblx0XHRcdC8vIHRyYW5zZmVyIGRhdGEgaW50byBhIHNvcnRhYmxlIGFycmF5XG5cblx0XHRcdGZvciAoIHZhciB0aW1lIGluIGRhdGEgKSB7XG5cblx0XHRcdFx0a2V5ZnJhbWVzLnB1c2goIHsgdGltZTogcGFyc2VGbG9hdCggdGltZSApLCB2YWx1ZTogZGF0YVsgdGltZSBdIH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlbnN1cmUga2V5ZnJhbWVzIGFyZSBzb3J0ZWQgYnkgdGltZVxuXG5cdFx0XHRrZXlmcmFtZXMuc29ydCggYXNjZW5kaW5nICk7XG5cblx0XHRcdC8vIG5vdyB3ZSBjbGVhbiB1cCBhbGwgYW5pbWF0aW9uIGRhdGEsIHNvIHdlIGNhbiB1c2UgdGhlbSBmb3Iga2V5ZnJhbWUgdHJhY2tzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRcdHRyYW5zZm9ybUFuaW1hdGlvbkRhdGEoIGtleWZyYW1lcywgaSwgZGVmYXVsdE1hdHJpeC5lbGVtZW50c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtleWZyYW1lcztcblxuXHRcdFx0Ly8gYXJyYXkgc29ydCBmdW5jdGlvblxuXG5cdFx0XHRmdW5jdGlvbiBhc2NlbmRpbmcoIGEsIGIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUtleWZyYW1lVHJhY2tzKCBhbmltYXRpb24sIHRyYWNrcyApIHtcblxuXHRcdFx0dmFyIGtleWZyYW1lcyA9IGFuaW1hdGlvbi5rZXlmcmFtZXM7XG5cdFx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbi5uYW1lO1xuXG5cdFx0XHR2YXIgdGltZXMgPSBbXTtcblx0XHRcdHZhciBwb3NpdGlvbkRhdGEgPSBbXTtcblx0XHRcdHZhciBxdWF0ZXJuaW9uRGF0YSA9IFtdO1xuXHRcdFx0dmFyIHNjYWxlRGF0YSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIga2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHR2YXIgdGltZSA9IGtleWZyYW1lLnRpbWU7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGtleWZyYW1lLnZhbHVlO1xuXG5cdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIHZhbHVlICkudHJhbnNwb3NlKCk7XG5cdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG5cdFx0XHRcdHRpbWVzLnB1c2goIHRpbWUgKTtcblx0XHRcdFx0cG9zaXRpb25EYXRhLnB1c2goIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcblx0XHRcdFx0cXVhdGVybmlvbkRhdGEucHVzaCggcXVhdGVybmlvbi54LCBxdWF0ZXJuaW9uLnksIHF1YXRlcm5pb24ueiwgcXVhdGVybmlvbi53ICk7XG5cdFx0XHRcdHNjYWxlRGF0YS5wdXNoKCBzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3NpdGlvbkRhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSArICcucG9zaXRpb24nLCB0aW1lcywgcG9zaXRpb25EYXRhICkgKTtcblx0XHRcdGlmICggcXVhdGVybmlvbkRhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG5hbWUgKyAnLnF1YXRlcm5pb24nLCB0aW1lcywgcXVhdGVybmlvbkRhdGEgKSApO1xuXHRcdFx0aWYgKCBzY2FsZURhdGEubGVuZ3RoID4gMCApIHRyYWNrcy5wdXNoKCBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSArICcuc2NhbGUnLCB0aW1lcywgc2NhbGVEYXRhICkgKTtcblxuXHRcdFx0cmV0dXJuIHRyYWNrcztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYW5zZm9ybUFuaW1hdGlvbkRhdGEoIGtleWZyYW1lcywgcHJvcGVydHksIGRlZmF1bHRWYWx1ZSApIHtcblxuXHRcdFx0dmFyIGtleWZyYW1lO1xuXG5cdFx0XHR2YXIgZW1wdHkgPSB0cnVlO1xuXHRcdFx0dmFyIGksIGw7XG5cblx0XHRcdC8vIGNoZWNrLCBpZiB2YWx1ZXMgb2YgYSBwcm9wZXJ0eSBhcmUgbWlzc2luZyBpbiBvdXIga2V5ZnJhbWVzXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0a2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IG51bGw7IC8vIG1hcmsgYXMgbWlzc2luZ1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRlbXB0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVtcHR5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdC8vIG5vIHZhbHVlcyBhdCBhbGwsIHNvIHdlIHNldCBhIGRlZmF1bHQgdmFsdWVcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0a2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gZGVmYXVsdFZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBmaWxsaW5nIGdhcHNcblxuXHRcdFx0XHRjcmVhdGVNaXNzaW5nS2V5ZnJhbWVzKCBrZXlmcmFtZXMsIHByb3BlcnR5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdLZXlmcmFtZXMoIGtleWZyYW1lcywgcHJvcGVydHkgKSB7XG5cblx0XHRcdHZhciBwcmV2LCBuZXh0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIga2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cHJldiA9IGdldFByZXYoIGtleWZyYW1lcywgaSwgcHJvcGVydHkgKTtcblx0XHRcdFx0XHRuZXh0ID0gZ2V0TmV4dCgga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApO1xuXG5cdFx0XHRcdFx0aWYgKCBwcmV2ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IG5leHQudmFsdWVbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbmV4dCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0a2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPSBwcmV2LnZhbHVlWyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnRlcnBvbGF0ZSgga2V5ZnJhbWUsIHByZXYsIG5leHQsIHByb3BlcnR5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQcmV2KCBrZXlmcmFtZXMsIGksIHByb3BlcnR5ICkge1xuXG5cdFx0XHR3aGlsZSAoIGkgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIga2V5ZnJhbWUgPSBrZXlmcmFtZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdICE9PSBudWxsICkgcmV0dXJuIGtleWZyYW1lO1xuXG5cdFx0XHRcdGkgLS07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXROZXh0KCBrZXlmcmFtZXMsIGksIHByb3BlcnR5ICkge1xuXG5cdFx0XHR3aGlsZSAoIGkgPCBrZXlmcmFtZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdHZhciBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gIT09IG51bGwgKSByZXR1cm4ga2V5ZnJhbWU7XG5cblx0XHRcdFx0aSArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBrZXksIHByZXYsIG5leHQsIHByb3BlcnR5ICkge1xuXG5cdFx0XHRpZiAoICggbmV4dC50aW1lIC0gcHJldi50aW1lICkgPT09IDAgKSB7XG5cblx0XHRcdFx0a2V5LnZhbHVlWyBwcm9wZXJ0eSBdID0gcHJldi52YWx1ZVsgcHJvcGVydHkgXTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleS52YWx1ZVsgcHJvcGVydHkgXSA9ICggKCBrZXkudGltZSAtIHByZXYudGltZSApICogKCBuZXh0LnZhbHVlWyBwcm9wZXJ0eSBdIC0gcHJldi52YWx1ZVsgcHJvcGVydHkgXSApIC8gKCBuZXh0LnRpbWUgLSBwcmV2LnRpbWUgKSApICsgcHJldi52YWx1ZVsgcHJvcGVydHkgXTtcblxuXHRcdH1cblxuXHRcdC8vIGFuaW1hdGlvbiBjbGlwc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25DbGlwKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgfHwgJ2RlZmF1bHQnLFxuXHRcdFx0XHRzdGFydDogcGFyc2VGbG9hdCggeG1sLmdldEF0dHJpYnV0ZSggJ3N0YXJ0JyApIHx8IDAgKSxcblx0XHRcdFx0ZW5kOiBwYXJzZUZsb2F0KCB4bWwuZ2V0QXR0cmlidXRlKCAnZW5kJyApIHx8IDAgKSxcblx0XHRcdFx0YW5pbWF0aW9uczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9hbmltYXRpb24nOlxuXHRcdFx0XHRcdFx0ZGF0YS5hbmltYXRpb25zLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5jbGlwc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRBbmltYXRpb25DbGlwKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdHZhciBuYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gKCBkYXRhLmVuZCAtIGRhdGEuc3RhcnQgKSB8fCAtIDE7XG5cdFx0XHR2YXIgYW5pbWF0aW9ucyA9IGRhdGEuYW5pbWF0aW9ucztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGFuaW1hdGlvblRyYWNrcyA9IGdldEFuaW1hdGlvbiggYW5pbWF0aW9uc1sgaSBdICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGFuaW1hdGlvblRyYWNrcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBhbmltYXRpb25UcmFja3NbIGogXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIG5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFuaW1hdGlvbkNsaXAoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkuY2xpcHNbIGlkIF0sIGJ1aWxkQW5pbWF0aW9uQ2xpcCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29udHJvbGxlclxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb250cm9sbGVyKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdza2luJzpcblx0XHRcdFx0XHRcdC8vIHRoZXJlIGlzIGV4YWN0bHkgb25lIHNraW4gcGVyIGNvbnRyb2xsZXJcblx0XHRcdFx0XHRcdGRhdGEuaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdGRhdGEuc2tpbiA9IHBhcnNlU2tpbiggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbW9ycGgnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTW9ycGggdGFyZ2V0IGFuaW1hdGlvbiBub3Qgc3VwcG9ydGVkIHlldC4nICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5jb250cm9sbGVyc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTa2luKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRzb3VyY2VzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2JpbmRfc2hhcGVfbWF0cml4Jzpcblx0XHRcdFx0XHRcdGRhdGEuYmluZFNoYXBlTWF0cml4ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlc1sgaWQgXSA9IHBhcnNlU291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdqb2ludHMnOlxuXHRcdFx0XHRcdFx0ZGF0YS5qb2ludHMgPSBwYXJzZUpvaW50cyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4X3dlaWdodHMnOlxuXHRcdFx0XHRcdFx0ZGF0YS52ZXJ0ZXhXZWlnaHRzID0gcGFyc2VWZXJ0ZXhXZWlnaHRzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VKb2ludHMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlucHV0czoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRcdFx0XHR2YXIgc2VtYW50aWMgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKTtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5pbnB1dHNbIHNlbWFudGljIF0gPSBpZDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmVydGV4V2VpZ2h0cyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aW5wdXRzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdFx0XHRcdHZhciBzZW1hbnRpYyA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NlbWFudGljJyApO1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ29mZnNldCcgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5pbnB1dHNbIHNlbWFudGljIF0gPSB7IGlkOiBpZCwgb2Zmc2V0OiBvZmZzZXQgfTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmNvdW50Jzpcblx0XHRcdFx0XHRcdGRhdGEudmNvdW50ID0gcGFyc2VJbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRcdGRhdGEudiA9IHBhcnNlSW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQ29udHJvbGxlciggZGF0YSApIHtcblxuXHRcdFx0dmFyIGJ1aWxkID0ge1xuXHRcdFx0XHRpZDogZGF0YS5pZFxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbGlicmFyeS5nZW9tZXRyaWVzWyBidWlsZC5pZCBdO1xuXG5cdFx0XHRpZiAoIGRhdGEuc2tpbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGJ1aWxkLnNraW4gPSBidWlsZFNraW4oIGRhdGEuc2tpbiApO1xuXG5cdFx0XHRcdC8vIHdlIGVuaGFuY2UgdGhlICdzb3VyY2VzJyBwcm9wZXJ0eSBvZiB0aGUgY29ycmVzcG9uZGluZyBnZW9tZXRyeSB3aXRoIG91ciBza2luIGRhdGFcblxuXHRcdFx0XHRnZW9tZXRyeS5zb3VyY2VzLnNraW5JbmRpY2VzID0gYnVpbGQuc2tpbi5pbmRpY2VzO1xuXHRcdFx0XHRnZW9tZXRyeS5zb3VyY2VzLnNraW5XZWlnaHRzID0gYnVpbGQuc2tpbi53ZWlnaHRzO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkU2tpbiggZGF0YSApIHtcblxuXHRcdFx0dmFyIEJPTkVfTElNSVQgPSA0O1xuXG5cdFx0XHR2YXIgYnVpbGQgPSB7XG5cdFx0XHRcdGpvaW50czogW10sIC8vIHRoaXMgbXVzdCBiZSBhbiBhcnJheSB0byBwcmVzZXJ2ZSB0aGUgam9pbnQgb3JkZXJcblx0XHRcdFx0aW5kaWNlczoge1xuXHRcdFx0XHRcdGFycmF5OiBbXSxcblx0XHRcdFx0XHRzdHJpZGU6IEJPTkVfTElNSVRcblx0XHRcdFx0fSxcblx0XHRcdFx0d2VpZ2h0czoge1xuXHRcdFx0XHRcdGFycmF5OiBbXSxcblx0XHRcdFx0XHRzdHJpZGU6IEJPTkVfTElNSVRcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHNvdXJjZXMgPSBkYXRhLnNvdXJjZXM7XG5cdFx0XHR2YXIgdmVydGV4V2VpZ2h0cyA9IGRhdGEudmVydGV4V2VpZ2h0cztcblxuXHRcdFx0dmFyIHZjb3VudCA9IHZlcnRleFdlaWdodHMudmNvdW50O1xuXHRcdFx0dmFyIHYgPSB2ZXJ0ZXhXZWlnaHRzLnY7XG5cdFx0XHR2YXIgam9pbnRPZmZzZXQgPSB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5KT0lOVC5vZmZzZXQ7XG5cdFx0XHR2YXIgd2VpZ2h0T2Zmc2V0ID0gdmVydGV4V2VpZ2h0cy5pbnB1dHMuV0VJR0hULm9mZnNldDtcblxuXHRcdFx0dmFyIGpvaW50U291cmNlID0gZGF0YS5zb3VyY2VzWyBkYXRhLmpvaW50cy5pbnB1dHMuSk9JTlQgXTtcblx0XHRcdHZhciBpbnZlcnNlU291cmNlID0gZGF0YS5zb3VyY2VzWyBkYXRhLmpvaW50cy5pbnB1dHMuSU5WX0JJTkRfTUFUUklYIF07XG5cblx0XHRcdHZhciB3ZWlnaHRzID0gc291cmNlc1sgdmVydGV4V2VpZ2h0cy5pbnB1dHMuV0VJR0hULmlkIF0uYXJyYXk7XG5cdFx0XHR2YXIgc3RyaWRlID0gMDtcblxuXHRcdFx0dmFyIGksIGosIGw7XG5cblx0XHRcdC8vIHByb2NjZXMgc2tpbiBkYXRhIGZvciBlYWNoIHZlcnRleFxuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBqb2ludENvdW50ID0gdmNvdW50WyBpIF07IC8vIHRoaXMgaXMgdGhlIGFtb3VudCBvZiBqb2ludHMgdGhhdCBhZmZlY3QgYSBzaW5nbGUgdmVydGV4XG5cdFx0XHRcdHZhciB2ZXJ0ZXhTa2luRGF0YSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgam9pbnRDb3VudDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBza2luSW5kZXggPSB2WyBzdHJpZGUgKyBqb2ludE9mZnNldCBdO1xuXHRcdFx0XHRcdHZhciB3ZWlnaHRJZCA9IHZbIHN0cmlkZSArIHdlaWdodE9mZnNldCBdO1xuXHRcdFx0XHRcdHZhciBza2luV2VpZ2h0ID0gd2VpZ2h0c1sgd2VpZ2h0SWQgXTtcblxuXHRcdFx0XHRcdHZlcnRleFNraW5EYXRhLnB1c2goIHsgaW5kZXg6IHNraW5JbmRleCwgd2VpZ2h0OiBza2luV2VpZ2h0IH0gKTtcblxuXHRcdFx0XHRcdHN0cmlkZSArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB3ZSBzb3J0IHRoZSBqb2ludHMgaW4gZGVzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGUgd2VpZ2h0cy5cblx0XHRcdFx0Ly8gdGhpcyBlbnN1cmVzLCB3ZSBvbmx5IHByb2NjZWQgdGhlIG1vc3QgaW1wb3J0YW50IGpvaW50cyBvZiB0aGUgdmVydGV4XG5cblx0XHRcdFx0dmVydGV4U2tpbkRhdGEuc29ydCggZGVzY2VuZGluZyApO1xuXG5cdFx0XHRcdC8vIG5vdyB3ZSBwcm92aWRlIGZvciBlYWNoIHZlcnRleCBhIHNldCBvZiBmb3VyIGluZGV4IGFuZCB3ZWlnaHQgdmFsdWVzLlxuXHRcdFx0XHQvLyB0aGUgb3JkZXIgb2YgdGhlIHNraW4gZGF0YSBtYXRjaGVzIHRoZSBvcmRlciBvZiB2ZXJ0aWNlc1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgQk9ORV9MSU1JVDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBkID0gdmVydGV4U2tpbkRhdGFbIGogXTtcblxuXHRcdFx0XHRcdGlmICggZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRidWlsZC5pbmRpY2VzLmFycmF5LnB1c2goIGQuaW5kZXggKTtcblx0XHRcdFx0XHRcdGJ1aWxkLndlaWdodHMuYXJyYXkucHVzaCggZC53ZWlnaHQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGJ1aWxkLmluZGljZXMuYXJyYXkucHVzaCggMCApO1xuXHRcdFx0XHRcdFx0YnVpbGQud2VpZ2h0cy5hcnJheS5wdXNoKCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldHVwIGJpbmQgbWF0cml4XG5cblx0XHRcdGlmICggZGF0YS5iaW5kU2hhcGVNYXRyaXggKSB7XG5cblx0XHRcdFx0YnVpbGQuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBkYXRhLmJpbmRTaGFwZU1hdHJpeCApLnRyYW5zcG9zZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJ1aWxkLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpLmlkZW50aXR5KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvY2VzcyBib25lcyBhbmQgaW52ZXJzZSBiaW5kIG1hdHJpeCBkYXRhXG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gam9pbnRTb3VyY2UuYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbmFtZSA9IGpvaW50U291cmNlLmFycmF5WyBpIF07XG5cdFx0XHRcdHZhciBib25lSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBpbnZlcnNlU291cmNlLmFycmF5LCBpICogaW52ZXJzZVNvdXJjZS5zdHJpZGUgKS50cmFuc3Bvc2UoKTtcblxuXHRcdFx0XHRidWlsZC5qb2ludHMucHVzaCggeyBuYW1lOiBuYW1lLCBib25lSW52ZXJzZTogYm9uZUludmVyc2UgfSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdFx0Ly8gYXJyYXkgc29ydCBmdW5jdGlvblxuXG5cdFx0XHRmdW5jdGlvbiBkZXNjZW5kaW5nKCBhLCBiICkge1xuXG5cdFx0XHRcdHJldHVybiBiLndlaWdodCAtIGEud2VpZ2h0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb250cm9sbGVyKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmNvbnRyb2xsZXJzWyBpZCBdLCBidWlsZENvbnRyb2xsZXIgKTtcblxuXHRcdH1cblxuXHRcdC8vIGltYWdlXG5cblx0XHRmdW5jdGlvbiBwYXJzZUltYWdlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpbml0X2Zyb206IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICdpbml0X2Zyb20nIClbIDAgXS50ZXh0Q29udGVudFxuXHRcdFx0fTtcblxuXHRcdFx0bGlicmFyeS5pbWFnZXNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkSW1hZ2UoIGRhdGEgKSB7XG5cblx0XHRcdGlmICggZGF0YS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHRcdHJldHVybiBkYXRhLmluaXRfZnJvbTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEltYWdlKCBpZCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSBsaWJyYXJ5LmltYWdlc1sgaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBkYXRhLCBidWlsZEltYWdlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBmaW5kIGltYWdlIHdpdGggSUQ6JywgaWQgKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBlZmZlY3RcblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0KCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdwcm9maWxlX0NPTU1PTic6XG5cdFx0XHRcdFx0XHRkYXRhLnByb2ZpbGUgPSBwYXJzZUVmZmVjdFByb2ZpbGVDT01NT04oIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5lZmZlY3RzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFByb2ZpbGVDT01NT04oIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHN1cmZhY2VzOiB7fSxcblx0XHRcdFx0c2FtcGxlcnM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbmV3cGFyYW0nOlxuXHRcdFx0XHRcdFx0cGFyc2VFZmZlY3ROZXdwYXJhbSggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gcGFyc2VFZmZlY3RUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdGRhdGEuZXh0cmEgPSBwYXJzZUVmZmVjdEV4dHJhKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3ROZXdwYXJhbSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHR2YXIgc2lkID0geG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3N1cmZhY2UnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zdXJmYWNlc1sgc2lkIF0gPSBwYXJzZUVmZmVjdFN1cmZhY2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NhbXBsZXIyRCc6XG5cdFx0XHRcdFx0XHRkYXRhLnNhbXBsZXJzWyBzaWQgXSA9IHBhcnNlRWZmZWN0U2FtcGxlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RTdXJmYWNlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbml0X2Zyb20nOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbml0X2Zyb20gPSBjaGlsZC50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0U2FtcGxlciggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFRlY2huaXF1ZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29uc3RhbnQnOlxuXHRcdFx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0XHRcdGNhc2UgJ2JsaW5uJzpcblx0XHRcdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRcdFx0XHRkYXRhLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGRhdGEucGFyYW1ldGVycyA9IHBhcnNlRWZmZWN0UGFyYW1ldGVycyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVycyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZW1pc3Npb24nOlxuXHRcdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyJzpcblx0XHRcdFx0XHRjYXNlICdidW1wJzpcblx0XHRcdFx0XHRjYXNlICdhbWJpZW50Jzpcblx0XHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VFZmZlY3RQYXJhbWV0ZXIoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0ge1xuXHRcdFx0XHRcdFx0XHRvcGFxdWU6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ29wYXF1ZScgKSxcblx0XHRcdFx0XHRcdFx0ZGF0YTogcGFyc2VFZmZlY3RQYXJhbWV0ZXIoIGNoaWxkIClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlciggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmbG9hdCc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0geyBpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAndGV4dHVyZScgKSwgZXh0cmE6IHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZSggY2hpbGQgKSB9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHR0ZWNobmlxdWU6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdFx0cGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlRXh0cmEoIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmVFeHRyYSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblx0XHRcdFx0XHRcdHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhVGVjaG5pcXVlKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmVFeHRyYVRlY2huaXF1ZSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncmVwZWF0VSc6XG5cdFx0XHRcdFx0Y2FzZSAncmVwZWF0Vic6XG5cdFx0XHRcdFx0Y2FzZSAnb2Zmc2V0VSc6XG5cdFx0XHRcdFx0Y2FzZSAnb2Zmc2V0Vic6XG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3dyYXBVJzpcblx0XHRcdFx0XHRjYXNlICd3cmFwVic6XG5cblx0XHRcdFx0XHRcdC8vIHNvbWUgZmlsZXMgaGF2ZSB2YWx1ZXMgZm9yIHdyYXBVL3dyYXBWIHdoaWNoIGJlY29tZSBOYU4gdmlhIHBhcnNlSW50XG5cblx0XHRcdFx0XHRcdGlmICggY2hpbGQudGV4dENvbnRlbnQudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnICkge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gMTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY2hpbGQudGV4dENvbnRlbnQudG9VcHBlckNhc2UoKSA9PT0gJ0ZBTFNFJyApIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZVsgY2hpbGQubm9kZU5hbWUgXSA9IDA7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWVbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUludCggY2hpbGQudGV4dENvbnRlbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0RXh0cmEoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IHBhcnNlRWZmZWN0RXh0cmFUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdEV4dHJhVGVjaG5pcXVlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdkb3VibGVfc2lkZWQnOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlSW50KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRFZmZlY3QoIGRhdGEgKSB7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RWZmZWN0KCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmVmZmVjdHNbIGlkIF0sIGJ1aWxkRWZmZWN0ICk7XG5cblx0XHR9XG5cblx0XHQvLyBtYXRlcmlhbFxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VNYXRlcmlhbCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnIClcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9lZmZlY3QnOlxuXHRcdFx0XHRcdFx0ZGF0YS51cmwgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5Lm1hdGVyaWFsc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUxvYWRlciggaW1hZ2UgKSB7XG5cblx0XHRcdHZhciBsb2FkZXI7XG5cblx0XHRcdHZhciBleHRlbnNpb24gPSBpbWFnZS5zbGljZSggKCBpbWFnZS5sYXN0SW5kZXhPZiggJy4nICkgLSAxID4+PiAwICkgKyAyICk7IC8vIGh0dHA6Ly93d3cuanN0aXBzLmNvL2VuL2phdmFzY3JpcHQvZ2V0LWZpbGUtZXh0ZW5zaW9uL1xuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdHN3aXRjaCAoIGV4dGVuc2lvbiApIHtcblxuXHRcdFx0XHRjYXNlICd0Z2EnOlxuXHRcdFx0XHRcdGxvYWRlciA9IHRnYUxvYWRlcjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxvYWRlcjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTWF0ZXJpYWwoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBlZmZlY3QgPSBnZXRFZmZlY3QoIGRhdGEudXJsICk7XG5cdFx0XHR2YXIgdGVjaG5pcXVlID0gZWZmZWN0LnByb2ZpbGUudGVjaG5pcXVlO1xuXHRcdFx0dmFyIGV4dHJhID0gZWZmZWN0LnByb2ZpbGUuZXh0cmE7XG5cblx0XHRcdHZhciBtYXRlcmlhbDtcblxuXHRcdFx0c3dpdGNoICggdGVjaG5pcXVlLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAncGhvbmcnOlxuXHRcdFx0XHRjYXNlICdibGlubic6XG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdsYW1iZXJ0Jzpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoTGFtYmVydE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsLm5hbWUgPSBkYXRhLm5hbWUgfHwgJyc7XG5cblx0XHRcdGZ1bmN0aW9uIGdldFRleHR1cmUoIHRleHR1cmVPYmplY3QgKSB7XG5cblx0XHRcdFx0dmFyIHNhbXBsZXIgPSBlZmZlY3QucHJvZmlsZS5zYW1wbGVyc1sgdGV4dHVyZU9iamVjdC5pZCBdO1xuXHRcdFx0XHR2YXIgaW1hZ2UgPSBudWxsO1xuXG5cdFx0XHRcdC8vIGdldCBpbWFnZVxuXG5cdFx0XHRcdGlmICggc2FtcGxlciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHN1cmZhY2UgPSBlZmZlY3QucHJvZmlsZS5zdXJmYWNlc1sgc2FtcGxlci5zb3VyY2UgXTtcblx0XHRcdFx0XHRpbWFnZSA9IGdldEltYWdlKCBzdXJmYWNlLmluaXRfZnJvbSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbmRlZmluZWQgc2FtcGxlci4gQWNjZXNzIGltYWdlIGRpcmVjdGx5IChzZWUgIzEyNTMwKS4nICk7XG5cdFx0XHRcdFx0aW1hZ2UgPSBnZXRJbWFnZSggdGV4dHVyZU9iamVjdC5pZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgdGV4dHVyZSBpZiBpbWFnZSBpcyBhdmFpYWJsZVxuXG5cdFx0XHRcdGlmICggaW1hZ2UgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgbG9hZGVyID0gZ2V0VGV4dHVyZUxvYWRlciggaW1hZ2UgKTtcblxuXHRcdFx0XHRcdGlmICggbG9hZGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGltYWdlICk7XG5cblx0XHRcdFx0XHRcdHZhciBleHRyYSA9IHRleHR1cmVPYmplY3QuZXh0cmE7XG5cblx0XHRcdFx0XHRcdGlmICggZXh0cmEgIT09IHVuZGVmaW5lZCAmJiBleHRyYS50ZWNobmlxdWUgIT09IHVuZGVmaW5lZCAmJiBpc0VtcHR5KCBleHRyYS50ZWNobmlxdWUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRlY2huaXF1ZSA9IGV4dHJhLnRlY2huaXF1ZTtcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gdGVjaG5pcXVlLndyYXBVID8gUmVwZWF0V3JhcHBpbmcgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gdGVjaG5pcXVlLndyYXBWID8gUmVwZWF0V3JhcHBpbmcgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUub2Zmc2V0LnNldCggdGVjaG5pcXVlLm9mZnNldFUgfHwgMCwgdGVjaG5pcXVlLm9mZnNldFYgfHwgMCApO1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5zZXQoIHRlY2huaXF1ZS5yZXBlYXRVIHx8IDEsIHRlY2huaXF1ZS5yZXBlYXRWIHx8IDEgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IExvYWRlciBmb3IgdGV4dHVyZSAlcyBub3QgZm91bmQuJywgaW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgY3JlYXRlIHRleHR1cmUgd2l0aCBJRDonLCB0ZXh0dXJlT2JqZWN0LmlkICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0ZWNobmlxdWUucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBrZXkgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdkaWZmdXNlJzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLmNvbG9yICkgbWF0ZXJpYWwuY29sb3IuZnJvbUFycmF5KCBwYXJhbWV0ZXIuY29sb3IgKTtcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLnRleHR1cmUgKSBtYXRlcmlhbC5tYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIuY29sb3IgJiYgbWF0ZXJpYWwuc3BlY3VsYXIgKSBtYXRlcmlhbC5zcGVjdWxhci5mcm9tQXJyYXkoIHBhcmFtZXRlci5jb2xvciApO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2J1bXAnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdhbWJpZW50Jzpcblx0XHRcdFx0XHRcdGlmICggcGFyYW1ldGVyLnRleHR1cmUgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIuZmxvYXQgJiYgbWF0ZXJpYWwuc2hpbmluZXNzICkgbWF0ZXJpYWwuc2hpbmluZXNzID0gcGFyYW1ldGVyLmZsb2F0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZW1pc3Npb24nOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIuY29sb3IgJiYgbWF0ZXJpYWwuZW1pc3NpdmUgKSBtYXRlcmlhbC5lbWlzc2l2ZS5mcm9tQXJyYXkoIHBhcmFtZXRlci5jb2xvciApO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgdHJhbnNwYXJlbnQgPSBwYXJhbWV0ZXJzWyAndHJhbnNwYXJlbnQnIF07XG5cdFx0XHR2YXIgdHJhbnNwYXJlbmN5ID0gcGFyYW1ldGVyc1sgJ3RyYW5zcGFyZW5jeScgXTtcblxuXHRcdFx0Ly8gPHRyYW5zcGFyZW5jeT4gZG9lcyBub3QgZXhpc3QgYnV0IDx0cmFuc3BhcmVudD5cblxuXHRcdFx0aWYgKCB0cmFuc3BhcmVuY3kgPT09IHVuZGVmaW5lZCAmJiB0cmFuc3BhcmVudCApIHtcblxuXHRcdFx0XHR0cmFuc3BhcmVuY3kgPSB7XG5cdFx0XHRcdFx0ZmxvYXQ6IDFcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyA8dHJhbnNwYXJlbnQ+IGRvZXMgbm90IGV4aXN0IGJ1dCA8dHJhbnNwYXJlbmN5PlxuXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW50ID09PSB1bmRlZmluZWQgJiYgdHJhbnNwYXJlbmN5ICkge1xuXG5cdFx0XHRcdHRyYW5zcGFyZW50ID0ge1xuXHRcdFx0XHRcdG9wYXF1ZTogJ0FfT05FJyxcblx0XHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0XHRjb2xvcjogWyAxLCAxLCAxLCAxIF1cblx0XHRcdFx0XHR9IH07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0cmFuc3BhcmVudCAmJiB0cmFuc3BhcmVuY3kgKSB7XG5cblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2UgaWYgYSB0ZXh0dXJlIGV4aXN0cyBidXQgbm8gY29sb3JcblxuXHRcdFx0XHRpZiAoIHRyYW5zcGFyZW50LmRhdGEudGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdC8vIHdlIGRvIG5vdCBzZXQgYW4gYWxwaGEgbWFwIChzZWUgIzEzNzkyKVxuXG5cdFx0XHRcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgY29sb3IgPSB0cmFuc3BhcmVudC5kYXRhLmNvbG9yO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggdHJhbnNwYXJlbnQub3BhcXVlICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdBX09ORSc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSBjb2xvclsgMyBdICogdHJhbnNwYXJlbmN5LmZsb2F0O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1JHQl9aRVJPJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IDEgLSAoIGNvbG9yWyAwIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdBX1pFUk8nOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gMSAtICggY29sb3JbIDMgXSAqIHRyYW5zcGFyZW5jeS5mbG9hdCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ1JHQl9PTkUnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gY29sb3JbIDAgXSAqIHRyYW5zcGFyZW5jeS5mbG9hdDtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBJbnZhbGlkIG9wYXF1ZSB0eXBlIFwiJXNcIiBvZiB0cmFuc3BhcmVudCB0YWcuJywgdHJhbnNwYXJlbnQub3BhcXVlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm9wYWNpdHkgPCAxICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHRpZiAoIGV4dHJhICE9PSB1bmRlZmluZWQgJiYgZXh0cmEudGVjaG5pcXVlICE9PSB1bmRlZmluZWQgJiYgZXh0cmEudGVjaG5pcXVlLmRvdWJsZV9zaWRlZCA9PT0gMSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5tYXRlcmlhbHNbIGlkIF0sIGJ1aWxkTWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdC8vIGNhbWVyYVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDYW1lcmEoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnb3B0aWNzJzpcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzID0gcGFyc2VDYW1lcmFPcHRpY3MoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5jYW1lcmFzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNhbWVyYU9wdGljcyggeG1sICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHBhcnNlQ2FtZXJhVGVjaG5pcXVlKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge307XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNhbWVyYVRlY2huaXF1ZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3BlcnNwZWN0aXZlJzpcblx0XHRcdFx0XHRjYXNlICdvcnRob2dyYXBoaWMnOlxuXG5cdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0ZGF0YS5wYXJhbWV0ZXJzID0gcGFyc2VDYW1lcmFQYXJhbWV0ZXJzKCBjaGlsZCApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNhbWVyYVBhcmFtZXRlcnMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd4Zm92Jzpcblx0XHRcdFx0XHRjYXNlICd5Zm92Jzpcblx0XHRcdFx0XHRjYXNlICd4bWFnJzpcblx0XHRcdFx0XHRjYXNlICd5bWFnJzpcblx0XHRcdFx0XHRjYXNlICd6bmVhcic6XG5cdFx0XHRcdFx0Y2FzZSAnemZhcic6XG5cdFx0XHRcdFx0Y2FzZSAnYXNwZWN0X3JhdGlvJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRDYW1lcmEoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBjYW1lcmE7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEub3B0aWNzLnRlY2huaXF1ZSApIHtcblxuXHRcdFx0XHRjYXNlICdwZXJzcGVjdGl2ZSc6XG5cdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy55Zm92LFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy5hc3BlY3RfcmF0aW8sXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpuZWFyLFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56ZmFyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdvcnRob2dyYXBoaWMnOlxuXHRcdFx0XHRcdHZhciB5bWFnID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy55bWFnO1xuXHRcdFx0XHRcdHZhciB4bWFnID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy54bWFnO1xuXHRcdFx0XHRcdHZhciBhc3BlY3RSYXRpbyA9IGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuYXNwZWN0X3JhdGlvO1xuXG5cdFx0XHRcdFx0eG1hZyA9ICggeG1hZyA9PT0gdW5kZWZpbmVkICkgPyAoIHltYWcgKiBhc3BlY3RSYXRpbyApIDogeG1hZztcblx0XHRcdFx0XHR5bWFnID0gKCB5bWFnID09PSB1bmRlZmluZWQgKSA/ICggeG1hZyAvIGFzcGVjdFJhdGlvICkgOiB5bWFnO1xuXG5cdFx0XHRcdFx0eG1hZyAqPSAwLjU7XG5cdFx0XHRcdFx0eW1hZyAqPSAwLjU7XG5cblx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKFxuXHRcdFx0XHRcdFx0LSB4bWFnLCB4bWFnLCB5bWFnLCAtIHltYWcsIC8vIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbVxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56bmVhcixcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuemZhclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRjYW1lcmEubmFtZSA9IGRhdGEubmFtZSB8fCAnJztcblxuXHRcdFx0cmV0dXJuIGNhbWVyYTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENhbWVyYSggaWQgKSB7XG5cblx0XHRcdHZhciBkYXRhID0gbGlicmFyeS5jYW1lcmFzWyBpZCBdO1xuXG5cdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGRhdGEsIGJ1aWxkQ2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBmaW5kIGNhbWVyYSB3aXRoIElEOicsIGlkICk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGlnaHRcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGlnaHQoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0ZGF0YSA9IHBhcnNlTGlnaHRUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5saWdodHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGlnaHRUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2RpcmVjdGlvbmFsJzpcblx0XHRcdFx0XHRjYXNlICdwb2ludCc6XG5cdFx0XHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdFx0Y2FzZSAnYW1iaWVudCc6XG5cblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRkYXRhLnBhcmFtZXRlcnMgPSBwYXJzZUxpZ2h0UGFyYW1ldGVycyggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpZ2h0UGFyYW1ldGVycyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLmNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmYWxsb2ZmX2FuZ2xlJzpcblx0XHRcdFx0XHRcdGRhdGEuZmFsbG9mZkFuZ2xlID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncXVhZHJhdGljX2F0dGVudWF0aW9uJzpcblx0XHRcdFx0XHRcdHZhciBmID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEuZGlzdGFuY2UgPSBmID8gTWF0aC5zcXJ0KCAxIC8gZiApIDogMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTGlnaHQoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBsaWdodDtcblxuXHRcdFx0c3dpdGNoICggZGF0YS50ZWNobmlxdWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnZGlyZWN0aW9uYWwnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwb2ludCc6XG5cdFx0XHRcdFx0bGlnaHQgPSBuZXcgUG9pbnRMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Nwb3QnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFNwb3RMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdGxpZ2h0ID0gbmV3IEFtYmllbnRMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5wYXJhbWV0ZXJzLmNvbG9yICkgbGlnaHQuY29sb3IuY29weSggZGF0YS5wYXJhbWV0ZXJzLmNvbG9yICk7XG5cdFx0XHRpZiAoIGRhdGEucGFyYW1ldGVycy5kaXN0YW5jZSApIGxpZ2h0LmRpc3RhbmNlID0gZGF0YS5wYXJhbWV0ZXJzLmRpc3RhbmNlO1xuXG5cdFx0XHRyZXR1cm4gbGlnaHQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRMaWdodCggaWQgKSB7XG5cblx0XHRcdHZhciBkYXRhID0gbGlicmFyeS5saWdodHNbIGlkIF07XG5cblx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBnZXRCdWlsZCggZGF0YSwgYnVpbGRMaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IENvdWxkblxcJ3QgZmluZCBsaWdodCB3aXRoIElEOicsIGlkICk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VvbWV0cnlcblxuXHRcdGZ1bmN0aW9uIHBhcnNlR2VvbWV0cnkoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApLFxuXHRcdFx0XHRzb3VyY2VzOiB7fSxcblx0XHRcdFx0dmVydGljZXM6IHt9LFxuXHRcdFx0XHRwcmltaXRpdmVzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIG1lc2ggPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnbWVzaCcgKVsgMCBdO1xuXG5cdFx0XHQvLyB0aGUgZm9sbG93aW5nIHRhZ3MgaW5zaWRlIGdlb21ldHJ5IGFyZSBub3Qgc3VwcG9ydGVkIHlldCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8xMjYwNik6IGNvbnZleF9tZXNoLCBzcGxpbmUsIGJyZXBcblx0XHRcdGlmICggbWVzaCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtZXNoLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IG1lc2guY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgaWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnNvdXJjZXNbIGlkIF0gPSBwYXJzZVNvdXJjZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndmVydGljZXMnOlxuXHRcdFx0XHRcdFx0Ly8gZGF0YS5zb3VyY2VzWyBpZCBdID0gZGF0YS5zb3VyY2VzWyBwYXJzZUlkKCBnZXRFbGVtZW50c0J5VGFnTmFtZSggY2hpbGQsICdpbnB1dCcgKVsgMCBdLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApIF07XG5cdFx0XHRcdFx0XHRkYXRhLnZlcnRpY2VzID0gcGFyc2VHZW9tZXRyeVZlcnRpY2VzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwb2x5Z29ucyc6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbnN1cHBvcnRlZCBwcmltaXRpdmUgdHlwZTogJywgY2hpbGQubm9kZU5hbWUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluZXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzdHJpcHMnOlxuXHRcdFx0XHRcdGNhc2UgJ3BvbHlsaXN0Jzpcblx0XHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxuXHRcdFx0XHRcdFx0ZGF0YS5wcmltaXRpdmVzLnB1c2goIHBhcnNlR2VvbWV0cnlQcmltaXRpdmUoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5Lmdlb21ldHJpZXNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU291cmNlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRhcnJheTogW10sXG5cdFx0XHRcdHN0cmlkZTogM1xuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZmxvYXRfYXJyYXknOlxuXHRcdFx0XHRcdFx0ZGF0YS5hcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdOYW1lX2FycmF5Jzpcblx0XHRcdFx0XHRcdGRhdGEuYXJyYXkgPSBwYXJzZVN0cmluZ3MoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0dmFyIGFjY2Vzc29yID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNoaWxkLCAnYWNjZXNzb3InIClbIDAgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBhY2Nlc3NvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEuc3RyaWRlID0gcGFyc2VJbnQoIGFjY2Vzc29yLmdldEF0dHJpYnV0ZSggJ3N0cmlkZScgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlR2VvbWV0cnlWZXJ0aWNlcyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0ZGF0YVsgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICkgXSA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VHZW9tZXRyeVByaW1pdGl2ZSggeG1sICkge1xuXG5cdFx0XHR2YXIgcHJpbWl0aXZlID0ge1xuXHRcdFx0XHR0eXBlOiB4bWwubm9kZU5hbWUsXG5cdFx0XHRcdG1hdGVyaWFsOiB4bWwuZ2V0QXR0cmlidXRlKCAnbWF0ZXJpYWwnICksXG5cdFx0XHRcdGNvdW50OiBwYXJzZUludCggeG1sLmdldEF0dHJpYnV0ZSggJ2NvdW50JyApICksXG5cdFx0XHRcdGlucHV0czoge30sXG5cdFx0XHRcdHN0cmlkZTogMCxcblx0XHRcdFx0aGFzVVY6IGZhbHNlXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0dmFyIGlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHR2YXIgc2VtYW50aWMgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKTtcblx0XHRcdFx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnb2Zmc2V0JyApICk7XG5cdFx0XHRcdFx0XHR2YXIgc2V0ID0gcGFyc2VJbnQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NldCcgKSApO1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0bmFtZSA9ICggc2V0ID4gMCA/IHNlbWFudGljICsgc2V0IDogc2VtYW50aWMgKTtcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5pbnB1dHNbIGlucHV0bmFtZSBdID0geyBpZDogaWQsIG9mZnNldDogb2Zmc2V0IH07XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUuc3RyaWRlID0gTWF0aC5tYXgoIHByaW1pdGl2ZS5zdHJpZGUsIG9mZnNldCArIDEgKTtcblx0XHRcdFx0XHRcdGlmICggc2VtYW50aWMgPT09ICdURVhDT09SRCcgKSBwcmltaXRpdmUuaGFzVVYgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Y291bnQnOlxuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLnZjb3VudCA9IHBhcnNlSW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncCc6XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUucCA9IHBhcnNlSW50cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJpbWl0aXZlO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ3JvdXBQcmltaXRpdmVzKCBwcmltaXRpdmVzICkge1xuXG5cdFx0XHR2YXIgYnVpbGQgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJ1aWxkWyBwcmltaXRpdmUudHlwZSBdID09PSB1bmRlZmluZWQgKSBidWlsZFsgcHJpbWl0aXZlLnR5cGUgXSA9IFtdO1xuXG5cdFx0XHRcdGJ1aWxkWyBwcmltaXRpdmUudHlwZSBdLnB1c2goIHByaW1pdGl2ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrVVZDb29yZGluYXRlcyggcHJpbWl0aXZlcyApIHtcblxuXHRcdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUuaGFzVVYgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRjb3VudCArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb3VudCA+IDAgJiYgY291bnQgPCBwcmltaXRpdmVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRwcmltaXRpdmVzLnV2c05lZWRzRml4ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRHZW9tZXRyeSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGJ1aWxkID0ge307XG5cblx0XHRcdHZhciBzb3VyY2VzID0gZGF0YS5zb3VyY2VzO1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gZGF0YS52ZXJ0aWNlcztcblx0XHRcdHZhciBwcmltaXRpdmVzID0gZGF0YS5wcmltaXRpdmVzO1xuXG5cdFx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuIHt9O1xuXG5cdFx0XHQvLyBvdXIgZ29hbCBpcyB0byBjcmVhdGUgb25lIGJ1ZmZlciBnZW9tZXRyeSBmb3IgYSBzaW5nbGUgdHlwZSBvZiBwcmltaXRpdmVzXG5cdFx0XHQvLyBmaXJzdCwgd2UgZ3JvdXAgYWxsIHByaW1pdGl2ZXMgYnkgdGhlaXIgdHlwZVxuXG5cdFx0XHR2YXIgZ3JvdXBlZFByaW1pdGl2ZXMgPSBncm91cFByaW1pdGl2ZXMoIHByaW1pdGl2ZXMgKTtcblxuXHRcdFx0Zm9yICggdmFyIHR5cGUgaW4gZ3JvdXBlZFByaW1pdGl2ZXMgKSB7XG5cblx0XHRcdFx0dmFyIHByaW1pdGl2ZVR5cGUgPSBncm91cGVkUHJpbWl0aXZlc1sgdHlwZSBdO1xuXG5cdFx0XHRcdC8vIHNlY29uZCwgZW5zdXJlIGNvbnNpc3RlbnQgdXYgY29vcmRpbmF0ZXMgZm9yIGVhY2ggdHlwZSBvZiBwcmltaXRpdmVzIChwb2x5bGlzdCx0cmlhbmdsZXMgb3IgbGluZXMpXG5cblx0XHRcdFx0Y2hlY2tVVkNvb3JkaW5hdGVzKCBwcmltaXRpdmVUeXBlICk7XG5cblx0XHRcdFx0Ly8gdGhpcmQsIGNyZWF0ZSBhIGJ1ZmZlciBnZW9tZXRyeSBmb3IgZWFjaCB0eXBlIG9mIHByaW1pdGl2ZXNcblxuXHRcdFx0XHRidWlsZFsgdHlwZSBdID0gYnVpbGRHZW9tZXRyeVR5cGUoIHByaW1pdGl2ZVR5cGUsIHNvdXJjZXMsIHZlcnRpY2VzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRHZW9tZXRyeVR5cGUoIHByaW1pdGl2ZXMsIHNvdXJjZXMsIHZlcnRpY2VzICkge1xuXG5cdFx0XHR2YXIgYnVpbGQgPSB7fTtcblxuXHRcdFx0dmFyIHBvc2l0aW9uID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0dmFyIG5vcm1hbCA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdHZhciB1diA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdHZhciB1djIgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cdFx0XHR2YXIgY29sb3IgPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cblx0XHRcdHZhciBza2luSW5kZXggPSB7IGFycmF5OiBbXSwgc3RyaWRlOiA0IH07XG5cdFx0XHR2YXIgc2tpbldlaWdodCA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDQgfTtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdHZhciBtYXRlcmlhbEtleXMgPSBbXTtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIHAgPSAwOyBwIDwgcHJpbWl0aXZlcy5sZW5ndGg7IHAgKysgKSB7XG5cblx0XHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIHAgXTtcblx0XHRcdFx0dmFyIGlucHV0cyA9IHByaW1pdGl2ZS5pbnB1dHM7XG5cblx0XHRcdFx0Ly8gZ3JvdXBzXG5cblx0XHRcdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdFx0XHRzd2l0Y2ggKCBwcmltaXRpdmUudHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzJzpcblx0XHRcdFx0XHRjYXNlICdsaW5lc3RyaXBzJzpcblx0XHRcdFx0XHRcdGNvdW50ID0gcHJpbWl0aXZlLmNvdW50ICogMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblx0XHRcdFx0XHRcdGNvdW50ID0gcHJpbWl0aXZlLmNvdW50ICogMztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgZyA9IDA7IGcgPCBwcmltaXRpdmUuY291bnQ7IGcgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHZjID0gcHJpbWl0aXZlLnZjb3VudFsgZyBdO1xuXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoIHZjICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAzOlxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQgKz0gMzsgLy8gc2luZ2xlIHRyaWFuZ2xlXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50ICs9IDY7IC8vIHF1YWQsIHN1YmRpdmlkZWQgaW50byB0d28gdHJpYW5nbGVzXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRjb3VudCArPSAoIHZjIC0gMiApICogMzsgLy8gcG9seWxpc3Qgd2l0aCBtb3JlIHRoYW4gZm91ciB2ZXJ0aWNlc1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVua25vdyBwcmltaXRpdmUgdHlwZTonLCBwcmltaXRpdmUudHlwZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggc3RhcnQsIGNvdW50LCBwICk7XG5cdFx0XHRcdHN0YXJ0ICs9IGNvdW50O1xuXG5cdFx0XHRcdC8vIG1hdGVyaWFsXG5cblx0XHRcdFx0aWYgKCBwcmltaXRpdmUubWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbEtleXMucHVzaCggcHJpbWl0aXZlLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdlb21ldHJ5IGRhdGFcblxuXHRcdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBpbnB1dHMgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5wdXQgPSBpbnB1dHNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG5hbWUgKVx0e1xuXG5cdFx0XHRcdFx0XHRjYXNlICdWRVJURVgnOlxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHZlcnRpY2VzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGlkID0gdmVydGljZXNbIGtleSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICgga2V5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdQT1NJVElPTic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcmV2TGVuZ3RoID0gcG9zaXRpb24uYXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIHBvc2l0aW9uLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uLnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc291cmNlcy5za2luV2VpZ2h0cyAmJiBzb3VyY2VzLnNraW5JbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlcy5za2luSW5kaWNlcywgaW5wdXQub2Zmc2V0LCBza2luSW5kZXguYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzLnNraW5XZWlnaHRzLCBpbnB1dC5vZmZzZXQsIHNraW5XZWlnaHQuYXJyYXkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc2VlICMzODAzXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBwcmltaXRpdmUuaGFzVVYgPT09IGZhbHNlICYmIHByaW1pdGl2ZXMudXZzTmVlZHNGaXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgY291bnQgPSAoIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAtIHByZXZMZW5ndGggKSAvIHBvc2l0aW9uLnN0cmlkZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxsIG1pc3NpbmcgdXYgY29vcmRpbmF0ZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dXYuYXJyYXkucHVzaCggMCwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnTk9STUFMJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaWQgXSwgaW5wdXQub2Zmc2V0LCBub3JtYWwuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsLnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnQ09MT1InOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIGNvbG9yLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yLnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIHV2LmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHV2LnN0cmlkZSA9IHNvdXJjZXNbIGlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQxJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaWQgXSwgaW5wdXQub2Zmc2V0LCB1djIuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXYuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBTZW1hbnRpYyBcIiVzXCIgbm90IGhhbmRsZWQgaW4gZ2VvbWV0cnkgYnVpbGQgcHJvY2Vzcy4nLCBrZXkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ05PUk1BTCc6XG5cdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlucHV0LmlkIF0sIGlucHV0Lm9mZnNldCwgbm9ybWFsLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbC5zdHJpZGUgPSBzb3VyY2VzWyBpbnB1dC5pZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0NPTE9SJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCBjb2xvci5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRjb2xvci5zdHJpZGUgPSBzb3VyY2VzWyBpbnB1dC5pZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1RFWENPT1JEJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCB1di5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHR1di5zdHJpZGUgPSBzb3VyY2VzWyBpbnB1dC5pZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1RFWENPT1JEMSc6XG5cdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlucHV0LmlkIF0sIGlucHV0Lm9mZnNldCwgdXYyLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdHV2Mi5zdHJpZGUgPSBzb3VyY2VzWyBpbnB1dC5pZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHRcdGlmICggcG9zaXRpb24uYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLmFycmF5LCBwb3NpdGlvbi5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCBub3JtYWwuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWwuYXJyYXksIG5vcm1hbC5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCBjb2xvci5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IuYXJyYXksIGNvbG9yLnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIHV2LmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1di5hcnJheSwgdXYuc3RyaWRlICkgKTtcblx0XHRcdGlmICggdXYyLmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1djInLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXYyLmFycmF5LCB1djIuc3RyaWRlICkgKTtcblxuXHRcdFx0aWYgKCBza2luSW5kZXguYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBza2luSW5kZXguYXJyYXksIHNraW5JbmRleC5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCBza2luV2VpZ2h0LmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdza2luV2VpZ2h0JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHNraW5XZWlnaHQuYXJyYXksIHNraW5XZWlnaHQuc3RyaWRlICkgKTtcblxuXHRcdFx0YnVpbGQuZGF0YSA9IGdlb21ldHJ5O1xuXHRcdFx0YnVpbGQudHlwZSA9IHByaW1pdGl2ZXNbIDAgXS50eXBlO1xuXHRcdFx0YnVpbGQubWF0ZXJpYWxLZXlzID0gbWF0ZXJpYWxLZXlzO1xuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2UsIG9mZnNldCwgYXJyYXkgKSB7XG5cblx0XHRcdHZhciBpbmRpY2VzID0gcHJpbWl0aXZlLnA7XG5cdFx0XHR2YXIgc3RyaWRlID0gcHJpbWl0aXZlLnN0cmlkZTtcblx0XHRcdHZhciB2Y291bnQgPSBwcmltaXRpdmUudmNvdW50O1xuXG5cdFx0XHRmdW5jdGlvbiBwdXNoVmVjdG9yKCBpICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgKyBvZmZzZXQgXSAqIHNvdXJjZVN0cmlkZTtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IGluZGV4ICsgc291cmNlU3RyaWRlO1xuXG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICsrICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggc291cmNlQXJyYXlbIGluZGV4IF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNvdXJjZUFycmF5ID0gc291cmNlLmFycmF5O1xuXHRcdFx0dmFyIHNvdXJjZVN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XG5cblx0XHRcdGlmICggcHJpbWl0aXZlLnZjb3VudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmNvdW50Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgY291bnQgPSB2Y291bnRbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggY291bnQgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0gaW5kZXggKyBzdHJpZGUgKiAwO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBpbmRleCArIHN0cmlkZSAqIDE7XG5cdFx0XHRcdFx0XHR2YXIgYyA9IGluZGV4ICsgc3RyaWRlICogMjtcblx0XHRcdFx0XHRcdHZhciBkID0gaW5kZXggKyBzdHJpZGUgKiAzO1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBhICk7IHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggZCApO1xuXHRcdFx0XHRcdFx0cHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBjICk7IHB1c2hWZWN0b3IoIGQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50ID09PSAzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYSA9IGluZGV4ICsgc3RyaWRlICogMDtcblx0XHRcdFx0XHRcdHZhciBiID0gaW5kZXggKyBzdHJpZGUgKiAxO1xuXHRcdFx0XHRcdFx0dmFyIGMgPSBpbmRleCArIHN0cmlkZSAqIDI7XG5cblx0XHRcdFx0XHRcdHB1c2hWZWN0b3IoIGEgKTsgcHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBjICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3VudCA+IDQgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBrID0gMSwga2wgPSAoIGNvdW50IC0gMiApOyBrIDw9IGtsOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBhID0gaW5kZXggKyBzdHJpZGUgKiAwO1xuXHRcdFx0XHRcdFx0XHR2YXIgYiA9IGluZGV4ICsgc3RyaWRlICogaztcblx0XHRcdFx0XHRcdFx0dmFyIGMgPSBpbmRleCArIHN0cmlkZSAqICggayArIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBhICk7IHB1c2hWZWN0b3IoIGIgKTsgcHVzaFZlY3RvciggYyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbmRleCArPSBzdHJpZGUgKiBjb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IHN0cmlkZSApIHtcblxuXHRcdFx0XHRcdHB1c2hWZWN0b3IoIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5Lmdlb21ldHJpZXNbIGlkIF0sIGJ1aWxkR2VvbWV0cnkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGtpbmVtYXRpY3NcblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc01vZGVsKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0am9pbnRzOiB7fSxcblx0XHRcdFx0bGlua3M6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHBhcnNlS2luZW1hdGljc1RlY2huaXF1ZUNvbW1vbiggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmtpbmVtYXRpY3NNb2RlbHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkS2luZW1hdGljc01vZGVsKCBkYXRhICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuYnVpbGQgIT09IHVuZGVmaW5lZCApIHJldHVybiBkYXRhLmJ1aWxkO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtpbmVtYXRpY3NNb2RlbCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5raW5lbWF0aWNzTW9kZWxzWyBpZCBdLCBidWlsZEtpbmVtYXRpY3NNb2RlbCApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzVGVjaG5pcXVlQ29tbW9uKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2pvaW50Jzpcblx0XHRcdFx0XHRcdGRhdGEuam9pbnRzWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IHBhcnNlS2luZW1hdGljc0pvaW50KCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5rJzpcblx0XHRcdFx0XHRcdGRhdGEubGlua3MucHVzaCggcGFyc2VLaW5lbWF0aWNzTGluayggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NKb2ludCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncHJpc21hdGljJzpcblx0XHRcdFx0XHRjYXNlICdyZXZvbHV0ZSc6XG5cdFx0XHRcdFx0XHRkYXRhID0gcGFyc2VLaW5lbWF0aWNzSm9pbnRQYXJhbWV0ZXIoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NKb2ludFBhcmFtZXRlciggeG1sLCBkYXRhICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0c2lkOiB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0YXhpczogbmV3IFZlY3RvcjMoKSxcblx0XHRcdFx0bGltaXRzOiB7XG5cdFx0XHRcdFx0bWluOiAwLFxuXHRcdFx0XHRcdG1heDogMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0eXBlOiB4bWwubm9kZU5hbWUsXG5cdFx0XHRcdHN0YXRpYzogZmFsc2UsXG5cdFx0XHRcdHplcm9Qb3NpdGlvbjogMCxcblx0XHRcdFx0bWlkZGxlUG9zaXRpb246IDBcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2F4aXMnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLmF4aXMuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbGltaXRzJzpcblx0XHRcdFx0XHRcdHZhciBtYXggPSBjaGlsZC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ21heCcgKVsgMCBdO1xuXHRcdFx0XHRcdFx0dmFyIG1pbiA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbWluJyApWyAwIF07XG5cblx0XHRcdFx0XHRcdGRhdGEubGltaXRzLm1heCA9IHBhcnNlRmxvYXQoIG1heC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5saW1pdHMubWluID0gcGFyc2VGbG9hdCggbWluLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgbWluIGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBtYXgsIGNvbnNpZGVyIHRoZSBqb2ludCBzdGF0aWNcblxuXHRcdFx0aWYgKCBkYXRhLmxpbWl0cy5taW4gPj0gZGF0YS5saW1pdHMubWF4ICkge1xuXG5cdFx0XHRcdGRhdGEuc3RhdGljID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbWlkZGxlIHBvc2l0aW9uXG5cblx0XHRcdGRhdGEubWlkZGxlUG9zaXRpb24gPSAoIGRhdGEubGltaXRzLm1pbiArIGRhdGEubGltaXRzLm1heCApIC8gMi4wO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0xpbmsoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHNpZDogeG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdGF0dGFjaG1lbnRzOiBbXSxcblx0XHRcdFx0dHJhbnNmb3JtczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2F0dGFjaG1lbnRfZnVsbCc6XG5cdFx0XHRcdFx0XHRkYXRhLmF0dGFjaG1lbnRzLnB1c2goIHBhcnNlS2luZW1hdGljc0F0dGFjaG1lbnQoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXMucHVzaCggcGFyc2VLaW5lbWF0aWNzVHJhbnNmb3JtKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NBdHRhY2htZW50KCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRqb2ludDogeG1sLmdldEF0dHJpYnV0ZSggJ2pvaW50JyApLnNwbGl0KCAnLycgKS5wb3AoKSxcblx0XHRcdFx0dHJhbnNmb3JtczogW10sXG5cdFx0XHRcdGxpbmtzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluayc6XG5cdFx0XHRcdFx0XHRkYXRhLmxpbmtzLnB1c2goIHBhcnNlS2luZW1hdGljc0xpbmsoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXMucHVzaCggcGFyc2VLaW5lbWF0aWNzVHJhbnNmb3JtKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NUcmFuc2Zvcm0oIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHR5cGU6IHhtbC5ub2RlTmFtZVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIHhtbC50ZXh0Q29udGVudCApO1xuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRkYXRhLm9iaiA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0XHRcdFx0ZGF0YS5vYmouZnJvbUFycmF5KCBhcnJheSApLnRyYW5zcG9zZSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0ZGF0YS5vYmogPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdGRhdGEub2JqLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdGRhdGEub2JqID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRkYXRhLm9iai5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0ZGF0YS5hbmdsZSA9IE1hdGhVdGlscy5kZWdUb1JhZCggYXJyYXlbIDMgXSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcGh5c2ljc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQaHlzaWNzTW9kZWwoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHRyaWdpZEJvZGllczoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3JpZ2lkX2JvZHknOlxuXHRcdFx0XHRcdFx0ZGF0YS5yaWdpZEJvZGllc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSBdID0ge307XG5cdFx0XHRcdFx0XHRwYXJzZVBoeXNpY3NSaWdpZEJvZHkoIGNoaWxkLCBkYXRhLnJpZ2lkQm9kaWVzWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIF0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LnBoeXNpY3NNb2RlbHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUGh5c2ljc1JpZ2lkQm9keSggeG1sLCBkYXRhICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblx0XHRcdFx0XHRcdHBhcnNlUGh5c2ljc1RlY2huaXF1ZUNvbW1vbiggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQaHlzaWNzVGVjaG5pcXVlQ29tbW9uKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luZXJ0aWEnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbmVydGlhID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hc3MnOlxuXHRcdFx0XHRcdFx0ZGF0YS5tYXNzID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50IClbIDAgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gc2NlbmVcblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc1NjZW5lKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRiaW5kSm9pbnRBeGlzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmluZF9qb2ludF9heGlzJzpcblx0XHRcdFx0XHRcdGRhdGEuYmluZEpvaW50QXhpcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NCaW5kSm9pbnRBeGlzKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS5raW5lbWF0aWNzU2NlbmVzWyBwYXJzZUlkKCB4bWwuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NCaW5kSm9pbnRBeGlzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHR0YXJnZXQ6IHhtbC5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICkuc3BsaXQoICcvJyApLnBvcCgpXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdheGlzJzpcblx0XHRcdFx0XHRcdHZhciBwYXJhbSA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAncGFyYW0nIClbIDAgXTtcblx0XHRcdFx0XHRcdGRhdGEuYXhpcyA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0dmFyIHRtcEpvaW50SW5kZXggPSBkYXRhLmF4aXMuc3BsaXQoICdpbnN0XycgKS5wb3AoKS5zcGxpdCggJ2F4aXMnIClbIDAgXTtcblx0XHRcdFx0XHRcdGRhdGEuam9pbnRJbmRleCA9IHRtcEpvaW50SW5kZXguc3Vic3RyKCAwLCB0bXBKb2ludEluZGV4Lmxlbmd0aCAtIDEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkS2luZW1hdGljc1NjZW5lKCBkYXRhICkge1xuXG5cdFx0XHRpZiAoIGRhdGEuYnVpbGQgIT09IHVuZGVmaW5lZCApIHJldHVybiBkYXRhLmJ1aWxkO1xuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtpbmVtYXRpY3NTY2VuZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5raW5lbWF0aWNzU2NlbmVzWyBpZCBdLCBidWlsZEtpbmVtYXRpY3NTY2VuZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBLaW5lbWF0aWNzKCkge1xuXG5cdFx0XHR2YXIga2luZW1hdGljc01vZGVsSWQgPSBPYmplY3Qua2V5cyggbGlicmFyeS5raW5lbWF0aWNzTW9kZWxzIClbIDAgXTtcblx0XHRcdHZhciBraW5lbWF0aWNzU2NlbmVJZCA9IE9iamVjdC5rZXlzKCBsaWJyYXJ5LmtpbmVtYXRpY3NTY2VuZXMgKVsgMCBdO1xuXHRcdFx0dmFyIHZpc3VhbFNjZW5lSWQgPSBPYmplY3Qua2V5cyggbGlicmFyeS52aXN1YWxTY2VuZXMgKVsgMCBdO1xuXG5cdFx0XHRpZiAoIGtpbmVtYXRpY3NNb2RlbElkID09PSB1bmRlZmluZWQgfHwga2luZW1hdGljc1NjZW5lSWQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdFx0dmFyIGtpbmVtYXRpY3NNb2RlbCA9IGdldEtpbmVtYXRpY3NNb2RlbCgga2luZW1hdGljc01vZGVsSWQgKTtcblx0XHRcdHZhciBraW5lbWF0aWNzU2NlbmUgPSBnZXRLaW5lbWF0aWNzU2NlbmUoIGtpbmVtYXRpY3NTY2VuZUlkICk7XG5cdFx0XHR2YXIgdmlzdWFsU2NlbmUgPSBnZXRWaXN1YWxTY2VuZSggdmlzdWFsU2NlbmVJZCApO1xuXG5cdFx0XHR2YXIgYmluZEpvaW50QXhpcyA9IGtpbmVtYXRpY3NTY2VuZS5iaW5kSm9pbnRBeGlzO1xuXHRcdFx0dmFyIGpvaW50TWFwID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGJpbmRKb2ludEF4aXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYXhpcyA9IGJpbmRKb2ludEF4aXNbIGkgXTtcblxuXHRcdFx0XHQvLyB0aGUgcmVzdWx0IG9mIHRoZSBmb2xsb3dpbmcgcXVlcnkgaXMgYW4gZWxlbWVudCBvZiB0eXBlICd0cmFuc2xhdGUnLCAncm90YXRlJywnc2NhbGUnIG9yICdtYXRyaXgnXG5cblx0XHRcdFx0dmFyIHRhcmdldEVsZW1lbnQgPSBjb2xsYWRhLnF1ZXJ5U2VsZWN0b3IoICdbc2lkPVwiJyArIGF4aXMudGFyZ2V0ICsgJ1wiXScgKTtcblxuXHRcdFx0XHRpZiAoIHRhcmdldEVsZW1lbnQgKSB7XG5cblx0XHRcdFx0XHQvLyBnZXQgdGhlIHBhcmVudCBvZiB0aGUgdHJhbnNmb3JtIGVsZW1lbnRcblxuXHRcdFx0XHRcdHZhciBwYXJlbnRWaXN1YWxFbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gY29ubmVjdCB0aGUgam9pbnQgb2YgdGhlIGtpbmVtYXRpY3MgbW9kZWwgd2l0aCB0aGUgZWxlbWVudCBpbiB0aGUgdmlzdWFsIHNjZW5lXG5cblx0XHRcdFx0XHRjb25uZWN0KCBheGlzLmpvaW50SW5kZXgsIHBhcmVudFZpc3VhbEVsZW1lbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29ubmVjdCggam9pbnRJbmRleCwgdmlzdWFsRWxlbWVudCApIHtcblxuXHRcdFx0XHR2YXIgdmlzdWFsRWxlbWVudE5hbWUgPSB2aXN1YWxFbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHRcdHZhciBqb2ludCA9IGtpbmVtYXRpY3NNb2RlbC5qb2ludHNbIGpvaW50SW5kZXggXTtcblxuXHRcdFx0XHR2aXN1YWxTY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9iamVjdC5uYW1lID09PSB2aXN1YWxFbGVtZW50TmFtZSApIHtcblxuXHRcdFx0XHRcdFx0am9pbnRNYXBbIGpvaW50SW5kZXggXSA9IHtcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybXM6IGJ1aWxkVHJhbnNmb3JtTGlzdCggdmlzdWFsRWxlbWVudCApLFxuXHRcdFx0XHRcdFx0XHRqb2ludDogam9pbnQsXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBqb2ludC56ZXJvUG9zaXRpb25cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtMCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdGtpbmVtYXRpY3MgPSB7XG5cblx0XHRcdFx0am9pbnRzOiBraW5lbWF0aWNzTW9kZWwgJiYga2luZW1hdGljc01vZGVsLmpvaW50cyxcblxuXHRcdFx0XHRnZXRKb2ludFZhbHVlOiBmdW5jdGlvbiAoIGpvaW50SW5kZXggKSB7XG5cblx0XHRcdFx0XHR2YXIgam9pbnREYXRhID0gam9pbnRNYXBbIGpvaW50SW5kZXggXTtcblxuXHRcdFx0XHRcdGlmICggam9pbnREYXRhICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gam9pbnREYXRhLnBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSm9pbnQgJyArIGpvaW50SW5kZXggKyAnIGRvZXNuXFwndCBleGlzdC4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzZXRKb2ludFZhbHVlOiBmdW5jdGlvbiAoIGpvaW50SW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRcdFx0dmFyIGpvaW50RGF0YSA9IGpvaW50TWFwWyBqb2ludEluZGV4IF07XG5cblx0XHRcdFx0XHRpZiAoIGpvaW50RGF0YSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGpvaW50ID0gam9pbnREYXRhLmpvaW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlID4gam9pbnQubGltaXRzLm1heCB8fCB2YWx1ZSA8IGpvaW50LmxpbWl0cy5taW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSm9pbnQgJyArIGpvaW50SW5kZXggKyAnIHZhbHVlICcgKyB2YWx1ZSArICcgb3V0c2lkZSBvZiBsaW1pdHMgKG1pbjogJyArIGpvaW50LmxpbWl0cy5taW4gKyAnLCBtYXg6ICcgKyBqb2ludC5saW1pdHMubWF4ICsgJykuJyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBqb2ludC5zdGF0aWMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogSm9pbnQgJyArIGpvaW50SW5kZXggKyAnIGlzIHN0YXRpYy4nICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG9iamVjdCA9IGpvaW50RGF0YS5vYmplY3Q7XG5cdFx0XHRcdFx0XHRcdHZhciBheGlzID0gam9pbnQuYXhpcztcblx0XHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybXMgPSBqb2ludERhdGEudHJhbnNmb3JtcztcblxuXHRcdFx0XHRcdFx0XHRtYXRyaXguaWRlbnRpdHkoKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBlYWNoIHVwZGF0ZSwgd2UgaGF2ZSB0byBhcHBseSBhbGwgdHJhbnNmb3JtcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiBvZiB0aGUgdHJhbnNmb3JtIG5vZGUgd2l0aCBhIGpvaW50LCBhcHBseSB0aGUgam9pbnQgdmFsdWVcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHJhbnNmb3JtLnNpZCAmJiB0cmFuc2Zvcm0uc2lkLmluZGV4T2YoIGpvaW50SW5kZXggKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBqb2ludC50eXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3Jldm9sdXRlJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0wLm1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIE1hdGhVdGlscy5kZWdUb1JhZCggdmFsdWUgKSApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAncHJpc21hdGljJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0wLm1ha2VUcmFuc2xhdGlvbiggYXhpcy54ICogdmFsdWUsIGF4aXMueSAqIHZhbHVlLCBheGlzLnogKiB2YWx1ZSApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbmtub3duIGpvaW50IHR5cGU6ICcgKyBqb2ludC50eXBlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIHRyYW5zZm9ybS50eXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCB0cmFuc2Zvcm0ub2JqICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0wLm1ha2VUcmFuc2xhdGlvbiggdHJhbnNmb3JtLm9iai54LCB0cmFuc2Zvcm0ub2JqLnksIHRyYW5zZm9ybS5vYmoueiApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5zY2FsZSggdHJhbnNmb3JtLm9iaiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMC5tYWtlUm90YXRpb25BeGlzKCB0cmFuc2Zvcm0ub2JqLCB0cmFuc2Zvcm0uYW5nbGUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5tYXRyaXguY29weSggbWF0cml4ICk7XG5cdFx0XHRcdFx0XHRcdG9iamVjdC5tYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0XHRcdFx0XHRqb2ludE1hcFsgam9pbnRJbmRleCBdLnBvc2l0aW9uID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogJyArIGpvaW50SW5kZXggKyAnIGRvZXMgbm90IGV4aXN0LicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFRyYW5zZm9ybUxpc3QoIG5vZGUgKSB7XG5cblx0XHRcdHZhciB0cmFuc2Zvcm1zID0gW107XG5cblx0XHRcdHZhciB4bWwgPSBjb2xsYWRhLnF1ZXJ5U2VsZWN0b3IoICdbaWQ9XCInICsgbm9kZS5pZCArICdcIl0nICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggYXJyYXkgKS50cmFuc3Bvc2UoKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRzaWQ6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0XHRcdFx0dHlwZTogY2hpbGQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRcdG9iajogbWF0cml4XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0c2lkOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdFx0XHRcdHR5cGU6IGNoaWxkLm5vZGVOYW1lLFxuXHRcdFx0XHRcdFx0XHRvYmo6IHZlY3RvclxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHR2YXIgYW5nbGUgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGFycmF5WyAzIF0gKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRzaWQ6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0XHRcdFx0dHlwZTogY2hpbGQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRcdG9iajogdmVjdG9yLFxuXHRcdFx0XHRcdFx0XHRhbmdsZTogYW5nbGVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtcztcblxuXHRcdH1cblxuXHRcdC8vIG5vZGVzXG5cblx0XHRmdW5jdGlvbiBwcmVwYXJlTm9kZXMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGVsZW1lbnRzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbm9kZScgKTtcblxuXHRcdFx0Ly8gZW5zdXJlIGFsbCBub2RlIGVsZW1lbnRzIGhhdmUgaWQgYXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBlbGVtZW50c1sgaSBdO1xuXG5cdFx0XHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoICdpZCcgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSggJ2lkJywgZ2VuZXJhdGVJZCgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdHR5cGU6IHhtbC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApLFxuXHRcdFx0XHRpZDogeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApLFxuXHRcdFx0XHRzaWQ6IHhtbC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdG1hdHJpeDogbmV3IE1hdHJpeDQoKSxcblx0XHRcdFx0bm9kZXM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZUNhbWVyYXM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZUNvbnRyb2xsZXJzOiBbXSxcblx0XHRcdFx0aW5zdGFuY2VMaWdodHM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZUdlb21ldHJpZXM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZU5vZGVzOiBbXSxcblx0XHRcdFx0dHJhbnNmb3Jtczoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ25vZGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS5ub2Rlcy5wdXNoKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKSApO1xuXHRcdFx0XHRcdFx0cGFyc2VOb2RlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9jYW1lcmEnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZUNhbWVyYXMucHVzaCggcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfY29udHJvbGxlcic6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlQ29udHJvbGxlcnMucHVzaCggcGFyc2VOb2RlSW5zdGFuY2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfbGlnaHQnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZUxpZ2h0cy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9nZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlR2VvbWV0cmllcy5wdXNoKCBwYXJzZU5vZGVJbnN0YW5jZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9ub2RlJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VOb2Rlcy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLm1hdHJpeC5tdWx0aXBseSggbWF0cml4LmZyb21BcnJheSggYXJyYXkgKS50cmFuc3Bvc2UoKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXgubXVsdGlwbHkoIG1hdHJpeC5tYWtlVHJhbnNsYXRpb24oIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHR2YXIgYW5nbGUgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGFycmF5WyAzIF0gKTtcblx0XHRcdFx0XHRcdGRhdGEubWF0cml4Lm11bHRpcGx5KCBtYXRyaXgubWFrZVJvdGF0aW9uQXhpcyggdmVjdG9yLmZyb21BcnJheSggYXJyYXkgKSwgYW5nbGUgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS50cmFuc2Zvcm1zWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzaWQnICkgXSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEubWF0cml4LnNjYWxlKCB2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSApICk7XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc05vZGUoIGRhdGEuaWQgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBUaGVyZSBpcyBhbHJlYWR5IGEgbm9kZSB3aXRoIElEICVzLiBFeGNsdWRlIGN1cnJlbnQgbm9kZSBmcm9tIGZ1cnRoZXIgcHJvY2Vzc2luZy4nLCBkYXRhLmlkICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGlicmFyeS5ub2Rlc1sgZGF0YS5pZCBdID0gZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZUluc3RhbmNlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpZDogcGFyc2VJZCggeG1sLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApLFxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHRza2VsZXRvbnM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2JpbmRfbWF0ZXJpYWwnOlxuXHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlcyA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaW5zdGFuY2VfbWF0ZXJpYWwnICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGluc3RhbmNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VzWyBqIF07XG5cdFx0XHRcdFx0XHRcdHZhciBzeW1ib2wgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoICdzeW1ib2wnICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0YXJnZXQgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICk7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS5tYXRlcmlhbHNbIHN5bWJvbCBdID0gcGFyc2VJZCggdGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdza2VsZXRvbic6XG5cdFx0XHRcdFx0XHRkYXRhLnNrZWxldG9ucy5wdXNoKCBwYXJzZUlkKCBjaGlsZC50ZXh0Q29udGVudCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZFNrZWxldG9uKCBza2VsZXRvbnMsIGpvaW50cyApIHtcblxuXHRcdFx0dmFyIGJvbmVEYXRhID0gW107XG5cdFx0XHR2YXIgc29ydGVkQm9uZURhdGEgPSBbXTtcblxuXHRcdFx0dmFyIGksIGosIGRhdGE7XG5cblx0XHRcdC8vIGEgc2tlbGV0b24gY2FuIGhhdmUgbXVsdGlwbGUgcm9vdCBib25lcy4gY29sbGFkYSBleHByZXNzZXMgdGhpc1xuXHRcdFx0Ly8gc2l0dXRhdGlvbiB3aXRoIG11bHRpcGxlIFwic2tlbGV0b25cIiB0YWdzIHBlciBjb250cm9sbGVyIGluc3RhbmNlXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc2tlbGV0b25zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgc2tlbGV0b24gPSBza2VsZXRvbnNbIGkgXTtcblxuXHRcdFx0XHR2YXIgcm9vdDtcblxuXHRcdFx0XHRpZiAoIGhhc05vZGUoIHNrZWxldG9uICkgKSB7XG5cblx0XHRcdFx0XHRyb290ID0gZ2V0Tm9kZSggc2tlbGV0b24gKTtcblx0XHRcdFx0XHRidWlsZEJvbmVIaWVyYXJjaHkoIHJvb3QsIGpvaW50cywgYm9uZURhdGEgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBoYXNWaXN1YWxTY2VuZSggc2tlbGV0b24gKSApIHtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBjYXNlIHdoZXJlIHRoZSBza2VsZXRvbiByZWZlcnMgdG8gdGhlIHZpc3VhbCBzY2VuZSAoIzEzMzM1KVxuXG5cdFx0XHRcdFx0dmFyIHZpc3VhbFNjZW5lID0gbGlicmFyeS52aXN1YWxTY2VuZXNbIHNrZWxldG9uIF07XG5cdFx0XHRcdFx0dmFyIGNoaWxkcmVuID0gdmlzdWFsU2NlbmUuY2hpbGRyZW47XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuWyBqIF07XG5cblx0XHRcdFx0XHRcdGlmICggY2hpbGQudHlwZSA9PT0gJ0pPSU5UJyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcm9vdCA9IGdldE5vZGUoIGNoaWxkLmlkICk7XG5cdFx0XHRcdFx0XHRcdGJ1aWxkQm9uZUhpZXJhcmNoeSggcm9vdCwgam9pbnRzLCBib25lRGF0YSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBVbmFibGUgdG8gZmluZCByb290IGJvbmUgb2Ygc2tlbGV0b24gd2l0aCBJRDonLCBza2VsZXRvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzb3J0IGJvbmUgZGF0YSAodGhlIG9yZGVyIGlzIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY29udHJvbGxlcilcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgYm9uZURhdGEubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0ZGF0YSA9IGJvbmVEYXRhWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIGRhdGEuYm9uZS5uYW1lID09PSBqb2ludHNbIGkgXS5uYW1lICkge1xuXG5cdFx0XHRcdFx0XHRzb3J0ZWRCb25lRGF0YVsgaSBdID0gZGF0YTtcblx0XHRcdFx0XHRcdGRhdGEucHJvY2Vzc2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgdW5wcm9jZXNzZWQgYm9uZSBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBib25lRGF0YS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0ZGF0YSA9IGJvbmVEYXRhWyBpIF07XG5cblx0XHRcdFx0aWYgKCBkYXRhLnByb2Nlc3NlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRzb3J0ZWRCb25lRGF0YS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdFx0ZGF0YS5wcm9jZXNzZWQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXR1cCBhcnJheXMgZm9yIHNrZWxldG9uIGNyZWF0aW9uXG5cblx0XHRcdHZhciBib25lcyA9IFtdO1xuXHRcdFx0dmFyIGJvbmVJbnZlcnNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHNvcnRlZEJvbmVEYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhID0gc29ydGVkQm9uZURhdGFbIGkgXTtcblxuXHRcdFx0XHRib25lcy5wdXNoKCBkYXRhLmJvbmUgKTtcblx0XHRcdFx0Ym9uZUludmVyc2VzLnB1c2goIGRhdGEuYm9uZUludmVyc2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFNrZWxldG9uKCBib25lcywgYm9uZUludmVyc2VzICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEJvbmVIaWVyYXJjaHkoIHJvb3QsIGpvaW50cywgYm9uZURhdGEgKSB7XG5cblx0XHRcdC8vIHNldHVwIGJvbmUgZGF0YSBmcm9tIHZpc3VhbCBzY2VuZVxuXG5cdFx0XHRyb290LnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgYm9uZUludmVyc2U7XG5cblx0XHRcdFx0XHQvLyByZXRyaWV2ZSB0aGUgYm9uZUludmVyc2UgZnJvbSB0aGUgY29udHJvbGxlciBkYXRhXG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBqb2ludHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgam9pbnQgPSBqb2ludHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBqb2ludC5uYW1lID09PSBvYmplY3QubmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRib25lSW52ZXJzZSA9IGpvaW50LmJvbmVJbnZlcnNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBib25lSW52ZXJzZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSBjYW4gYmUgam9pbnRzIGluIHRoZSB2aXN1YWwgc2NlbmUgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlXG5cdFx0XHRcdFx0XHQvLyBjb3JyZXNwb25kaW5nIGNvbnRyb2xsZXIuIEluIHRoaXMgY2FzZSwgd2UgaGF2ZSB0byBjcmVhdGUgYSBkdW1teSBib25lSW52ZXJzZSBtYXRyaXhcblx0XHRcdFx0XHRcdC8vIGZvciB0aGUgcmVzcGVjdGl2ZSBib25lLiBUaGlzIGJvbmUgd29uJ3QgYWZmZWN0IGFueSB2ZXJ0aWNlcywgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc2tpbiBpbmRpY2VzXG5cdFx0XHRcdFx0XHQvLyBhbmQgd2VpZ2h0cyBkZWZpbmVkIGZvciBpdC4gQnV0IHdlIHN0aWxsIGhhdmUgdG8gYWRkIHRoZSBib25lIHRvIHRoZSBzb3J0ZWQgYm9uZSBsaXN0IGluIG9yZGVyIHRvXG5cdFx0XHRcdFx0XHQvLyBlbnN1cmUgYSBjb3JyZWN0IGFuaW1hdGlvbiBvZiB0aGUgbW9kZWwuXG5cblx0XHRcdFx0XHRcdGJvbmVJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJvbmVEYXRhLnB1c2goIHsgYm9uZTogb2JqZWN0LCBib25lSW52ZXJzZTogYm9uZUludmVyc2UsIHByb2Nlc3NlZDogZmFsc2UgfSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGROb2RlKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0cyA9IFtdO1xuXG5cdFx0XHR2YXIgbWF0cml4ID0gZGF0YS5tYXRyaXg7XG5cdFx0XHR2YXIgbm9kZXMgPSBkYXRhLm5vZGVzO1xuXHRcdFx0dmFyIHR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0XHR2YXIgaW5zdGFuY2VDYW1lcmFzID0gZGF0YS5pbnN0YW5jZUNhbWVyYXM7XG5cdFx0XHR2YXIgaW5zdGFuY2VDb250cm9sbGVycyA9IGRhdGEuaW5zdGFuY2VDb250cm9sbGVycztcblx0XHRcdHZhciBpbnN0YW5jZUxpZ2h0cyA9IGRhdGEuaW5zdGFuY2VMaWdodHM7XG5cdFx0XHR2YXIgaW5zdGFuY2VHZW9tZXRyaWVzID0gZGF0YS5pbnN0YW5jZUdlb21ldHJpZXM7XG5cdFx0XHR2YXIgaW5zdGFuY2VOb2RlcyA9IGRhdGEuaW5zdGFuY2VOb2RlcztcblxuXHRcdFx0Ly8gbm9kZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRvYmplY3RzLnB1c2goIGdldE5vZGUoIG5vZGVzWyBpIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIGNhbWVyYXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zdGFuY2VDYW1lcmFzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluc3RhbmNlQ2FtZXJhID0gZ2V0Q2FtZXJhKCBpbnN0YW5jZUNhbWVyYXNbIGkgXSApO1xuXG5cdFx0XHRcdGlmICggaW5zdGFuY2VDYW1lcmEgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIGluc3RhbmNlQ2FtZXJhLmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2UgY29udHJvbGxlcnNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zdGFuY2VDb250cm9sbGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9IGluc3RhbmNlQ29udHJvbGxlcnNbIGkgXTtcblx0XHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBnZXRDb250cm9sbGVyKCBpbnN0YW5jZS5pZCApO1xuXHRcdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGdldEdlb21ldHJ5KCBjb250cm9sbGVyLmlkICk7XG5cdFx0XHRcdHZhciBuZXdPYmplY3RzID0gYnVpbGRPYmplY3RzKCBnZW9tZXRyaWVzLCBpbnN0YW5jZS5tYXRlcmlhbHMgKTtcblxuXHRcdFx0XHR2YXIgc2tlbGV0b25zID0gaW5zdGFuY2Uuc2tlbGV0b25zO1xuXHRcdFx0XHR2YXIgam9pbnRzID0gY29udHJvbGxlci5za2luLmpvaW50cztcblxuXHRcdFx0XHR2YXIgc2tlbGV0b24gPSBidWlsZFNrZWxldG9uKCBza2VsZXRvbnMsIGpvaW50cyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBuZXdPYmplY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IG5ld09iamVjdHNbIGogXTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdFx0XHRcdG9iamVjdC5iaW5kKCBza2VsZXRvbiwgY29udHJvbGxlci5za2luLmJpbmRNYXRyaXggKTtcblx0XHRcdFx0XHRcdG9iamVjdC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2UgbGlnaHRzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc3RhbmNlTGlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluc3RhbmNlTGlnaHQgPSBnZXRMaWdodCggaW5zdGFuY2VMaWdodHNbIGkgXSApO1xuXG5cdFx0XHRcdGlmICggaW5zdGFuY2VMaWdodCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG9iamVjdHMucHVzaCggaW5zdGFuY2VMaWdodC5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIGdlb21ldHJpZXNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zdGFuY2VHZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VHZW9tZXRyaWVzWyBpIF07XG5cblx0XHRcdFx0Ly8gYSBzaW5nbGUgZ2VvbWV0cnkgaW5zdGFuY2UgaW4gY29sbGFkYSBjYW4gbGVhZCB0byBtdWx0aXBsZSBvYmplY3QzRHMuXG5cdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBwcmltaXRpdmVzIGFyZSBjb21iaW5lZCBsaWtlIHRyaWFuZ2xlcyBhbmQgbGluZXNcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGdldEdlb21ldHJ5KCBpbnN0YW5jZS5pZCApO1xuXHRcdFx0XHR2YXIgbmV3T2JqZWN0cyA9IGJ1aWxkT2JqZWN0cyggZ2VvbWV0cmllcywgaW5zdGFuY2UubWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG5ld09iamVjdHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIG5ld09iamVjdHNbIGogXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBub2Rlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZU5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBnZXROb2RlKCBpbnN0YW5jZU5vZGVzWyBpIF0gKS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG9iamVjdDtcblxuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPT09IDAgJiYgb2JqZWN0cy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0b2JqZWN0ID0gb2JqZWN0c1sgMCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG9iamVjdCA9ICggdHlwZSA9PT0gJ0pPSU5UJyApID8gbmV3IEJvbmUoKSA6IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmFkZCggb2JqZWN0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5uYW1lID0gKCB0eXBlID09PSAnSk9JTlQnICkgPyBkYXRhLnNpZCA6IGRhdGEubmFtZTtcblx0XHRcdG9iamVjdC5tYXRyaXguY29weSggbWF0cml4ICk7XG5cdFx0XHRvYmplY3QubWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cblx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHR9XG5cblx0XHR2YXIgZmFsbGJhY2tNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZjAwZmYgfSApO1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZU1hdGVyaWFsQmluZGluZygga2V5cywgaW5zdGFuY2VNYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpZCA9IGluc3RhbmNlTWF0ZXJpYWxzWyBrZXlzWyBpIF0gXTtcblxuXHRcdFx0XHRpZiAoIGlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBNYXRlcmlhbCB3aXRoIGtleSAlcyBub3QgZm91bmQuIEFwcGx5IGZhbGxiYWNrIG1hdGVyaWFsLicsIGtleXNbIGkgXSApO1xuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBmYWxsYmFja01hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBnZXRNYXRlcmlhbCggaWQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRPYmplY3RzKCBnZW9tZXRyaWVzLCBpbnN0YW5jZU1hdGVyaWFscyApIHtcblxuXHRcdFx0dmFyIG9iamVjdHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIHR5cGUgaW4gZ2VvbWV0cmllcyApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyB0eXBlIF07XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IHJlc29sdmVNYXRlcmlhbEJpbmRpbmcoIGdlb21ldHJ5Lm1hdGVyaWFsS2V5cywgaW5zdGFuY2VNYXRlcmlhbHMgKTtcblxuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSBpZiBubyBtYXRlcmlhbHMgYXJlIGRlZmluZWRcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdsaW5lcycgfHwgdHlwZSA9PT0gJ2xpbmVzdHJpcHMnICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHMucHVzaCggbmV3IExpbmVCYXNpY01hdGVyaWFsKCkgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBuZXcgTWVzaFBob25nTWF0ZXJpYWwoKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZWdhcmQgc2tpbm5pbmdcblxuXHRcdFx0XHR2YXIgc2tpbm5pbmcgPSAoIGdlb21ldHJ5LmRhdGEuYXR0cmlidXRlcy5za2luSW5kZXggIT09IHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdGlmICggc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzWyBpIF0uc2tpbm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaG9vc2UgYmV0d2VlbiBhIHNpbmdsZSBvciBtdWx0aSBtYXRlcmlhbHMgKG1hdGVyaWFsIGFycmF5KVxuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9ICggbWF0ZXJpYWxzLmxlbmd0aCA9PT0gMSApID8gbWF0ZXJpYWxzWyAwIF0gOiBtYXRlcmlhbHM7XG5cblx0XHRcdFx0Ly8gbm93IGNyZWF0ZSBhIHNwZWNpZmljIDNEIG9iamVjdFxuXG5cdFx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzJzpcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LmRhdGEsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzdHJpcHMnOlxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmUoIGdlb21ldHJ5LmRhdGEsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RyaWFuZ2xlcyc6XG5cdFx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXHRcdFx0XHRcdFx0aWYgKCBza2lubmluZyApIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LmRhdGEsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LmRhdGEsIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iamVjdHM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYXNOb2RlKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGxpYnJhcnkubm9kZXNbIGlkIF0gIT09IHVuZGVmaW5lZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE5vZGUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkubm9kZXNbIGlkIF0sIGJ1aWxkTm9kZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdmlzdWFsIHNjZW5lc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VWaXN1YWxTY2VuZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICksXG5cdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0cHJlcGFyZU5vZGVzKCB4bWwgKTtcblxuXHRcdFx0dmFyIGVsZW1lbnRzID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ25vZGUnICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhLmNoaWxkcmVuLnB1c2goIHBhcnNlTm9kZSggZWxlbWVudHNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGlicmFyeS52aXN1YWxTY2VuZXNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkVmlzdWFsU2NlbmUoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuXHRcdFx0Z3JvdXAubmFtZSA9IGRhdGEubmFtZTtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gZGF0YS5jaGlsZHJlbjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuWyBpIF07XG5cblx0XHRcdFx0Z3JvdXAuYWRkKCBnZXROb2RlKCBjaGlsZC5pZCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdyb3VwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFzVmlzdWFsU2NlbmUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gbGlicmFyeS52aXN1YWxTY2VuZXNbIGlkIF0gIT09IHVuZGVmaW5lZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFZpc3VhbFNjZW5lKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgaWQgXSwgYnVpbGRWaXN1YWxTY2VuZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gc2NlbmVzXG5cblx0XHRmdW5jdGlvbiBwYXJzZVNjZW5lKCB4bWwgKSB7XG5cblx0XHRcdHZhciBpbnN0YW5jZSA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICdpbnN0YW5jZV92aXN1YWxfc2NlbmUnIClbIDAgXTtcblx0XHRcdHJldHVybiBnZXRWaXN1YWxTY2VuZSggcGFyc2VJZCggaW5zdGFuY2UuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldHVwQW5pbWF0aW9ucygpIHtcblxuXHRcdFx0dmFyIGNsaXBzID0gbGlicmFyeS5jbGlwcztcblxuXHRcdFx0aWYgKCBpc0VtcHR5KCBjbGlwcyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGlmICggaXNFbXB0eSggbGlicmFyeS5hbmltYXRpb25zICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIGFuaW1hdGlvbnMgYnV0IG5vIGNsaXBzLCB3ZSBjcmVhdGUgYSBkZWZhdWx0IGNsaXAgZm9yIHBsYXliYWNrXG5cblx0XHRcdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaWQgaW4gbGlicmFyeS5hbmltYXRpb25zICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uVHJhY2tzID0gZ2V0QW5pbWF0aW9uKCBpZCApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhbmltYXRpb25UcmFja3MubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR0cmFja3MucHVzaCggYW5pbWF0aW9uVHJhY2tzWyBpIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBuZXcgQW5pbWF0aW9uQ2xpcCggJ2RlZmF1bHQnLCAtIDEsIHRyYWNrcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpZCBpbiBjbGlwcyApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggZ2V0QW5pbWF0aW9uQ2xpcCggaWQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgcGFyc2VyIGVycm9yIGVsZW1lbnQgaW50byB0ZXh0IHdpdGggZWFjaCBjaGlsZCBlbGVtZW50cyB0ZXh0XG5cdFx0Ly8gc2VwYXJhdGVkIGJ5IG5ldyBsaW5lcy5cblxuXHRcdGZ1bmN0aW9uIHBhcnNlckVycm9yVG9UZXh0KCBwYXJzZXJFcnJvciApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdFx0dmFyIHN0YWNrID0gWyBwYXJzZXJFcnJvciBdO1xuXG5cdFx0XHR3aGlsZSAoIHN0YWNrLmxlbmd0aCApIHtcblxuXHRcdFx0XHR2YXIgbm9kZSA9IHN0YWNrLnNoaWZ0KCk7XG5cblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSApIHtcblxuXHRcdFx0XHRcdHJlc3VsdCArPSBub2RlLnRleHRDb250ZW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgKz0gJ1xcbic7XG5cdFx0XHRcdFx0c3RhY2sucHVzaC5hcHBseSggc3RhY2ssIG5vZGUuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnRyaW0oKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiB7IHNjZW5lOiBuZXcgU2NlbmUoKSB9O1xuXG5cdFx0fVxuXG5cdFx0dmFyIHhtbCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoIHRleHQsICdhcHBsaWNhdGlvbi94bWwnICk7XG5cblx0XHR2YXIgY29sbGFkYSA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICdDT0xMQURBJyApWyAwIF07XG5cblx0XHR2YXIgcGFyc2VyRXJyb3IgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdwYXJzZXJlcnJvcicgKVsgMCBdO1xuXHRcdGlmICggcGFyc2VyRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gQ2hyb21lIHdpbGwgcmV0dXJuIHBhcnNlciBlcnJvciB3aXRoIGEgZGl2IGluIGl0XG5cblx0XHRcdHZhciBlcnJvckVsZW1lbnQgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggcGFyc2VyRXJyb3IsICdkaXYnIClbIDAgXTtcblx0XHRcdHZhciBlcnJvclRleHQ7XG5cblx0XHRcdGlmICggZXJyb3JFbGVtZW50ICkge1xuXG5cdFx0XHRcdGVycm9yVGV4dCA9IGVycm9yRWxlbWVudC50ZXh0Q29udGVudDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRlcnJvclRleHQgPSBwYXJzZXJFcnJvclRvVGV4dCggcGFyc2VyRXJyb3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogRmFpbGVkIHRvIHBhcnNlIGNvbGxhZGEgZmlsZS5cXG4nLCBlcnJvclRleHQgKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBtZXRhZGF0YVxuXG5cdFx0dmFyIHZlcnNpb24gPSBjb2xsYWRhLmdldEF0dHJpYnV0ZSggJ3ZlcnNpb24nICk7XG5cdFx0Y29uc29sZS5sb2coICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBGaWxlIHZlcnNpb24nLCB2ZXJzaW9uICk7XG5cblx0XHR2YXIgYXNzZXQgPSBwYXJzZUFzc2V0KCBnZXRFbGVtZW50c0J5VGFnTmFtZSggY29sbGFkYSwgJ2Fzc2V0JyApWyAwIF0gKTtcblx0XHR2YXIgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHR0ZXh0dXJlTG9hZGVyLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKS5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0dmFyIHRnYUxvYWRlcjtcblxuXHRcdGlmICggVEdBTG9hZGVyICkge1xuXG5cdFx0XHR0Z2FMb2FkZXIgPSBuZXcgVEdBTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdHRnYUxvYWRlci5zZXRQYXRoKCB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcblx0XHR2YXIga2luZW1hdGljcyA9IHt9O1xuXHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHQvL1xuXG5cdFx0dmFyIGxpYnJhcnkgPSB7XG5cdFx0XHRhbmltYXRpb25zOiB7fSxcblx0XHRcdGNsaXBzOiB7fSxcblx0XHRcdGNvbnRyb2xsZXJzOiB7fSxcblx0XHRcdGltYWdlczoge30sXG5cdFx0XHRlZmZlY3RzOiB7fSxcblx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRjYW1lcmFzOiB7fSxcblx0XHRcdGxpZ2h0czoge30sXG5cdFx0XHRnZW9tZXRyaWVzOiB7fSxcblx0XHRcdG5vZGVzOiB7fSxcblx0XHRcdHZpc3VhbFNjZW5lczoge30sXG5cdFx0XHRraW5lbWF0aWNzTW9kZWxzOiB7fSxcblx0XHRcdHBoeXNpY3NNb2RlbHM6IHt9LFxuXHRcdFx0a2luZW1hdGljc1NjZW5lczoge31cblx0XHR9O1xuXG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9hbmltYXRpb25zJywgJ2FuaW1hdGlvbicsIHBhcnNlQW5pbWF0aW9uICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9hbmltYXRpb25fY2xpcHMnLCAnYW5pbWF0aW9uX2NsaXAnLCBwYXJzZUFuaW1hdGlvbkNsaXAgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2NvbnRyb2xsZXJzJywgJ2NvbnRyb2xsZXInLCBwYXJzZUNvbnRyb2xsZXIgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2ltYWdlcycsICdpbWFnZScsIHBhcnNlSW1hZ2UgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2VmZmVjdHMnLCAnZWZmZWN0JywgcGFyc2VFZmZlY3QgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X21hdGVyaWFscycsICdtYXRlcmlhbCcsIHBhcnNlTWF0ZXJpYWwgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2NhbWVyYXMnLCAnY2FtZXJhJywgcGFyc2VDYW1lcmEgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2xpZ2h0cycsICdsaWdodCcsIHBhcnNlTGlnaHQgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2dlb21ldHJpZXMnLCAnZ2VvbWV0cnknLCBwYXJzZUdlb21ldHJ5ICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9ub2RlcycsICdub2RlJywgcGFyc2VOb2RlICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV92aXN1YWxfc2NlbmVzJywgJ3Zpc3VhbF9zY2VuZScsIHBhcnNlVmlzdWFsU2NlbmUgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2tpbmVtYXRpY3NfbW9kZWxzJywgJ2tpbmVtYXRpY3NfbW9kZWwnLCBwYXJzZUtpbmVtYXRpY3NNb2RlbCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfcGh5c2ljc19tb2RlbHMnLCAncGh5c2ljc19tb2RlbCcsIHBhcnNlUGh5c2ljc01vZGVsICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnc2NlbmUnLCAnaW5zdGFuY2Vfa2luZW1hdGljc19zY2VuZScsIHBhcnNlS2luZW1hdGljc1NjZW5lICk7XG5cblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuYW5pbWF0aW9ucywgYnVpbGRBbmltYXRpb24gKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuY2xpcHMsIGJ1aWxkQW5pbWF0aW9uQ2xpcCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5jb250cm9sbGVycywgYnVpbGRDb250cm9sbGVyICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmltYWdlcywgYnVpbGRJbWFnZSApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5lZmZlY3RzLCBidWlsZEVmZmVjdCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5tYXRlcmlhbHMsIGJ1aWxkTWF0ZXJpYWwgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuY2FtZXJhcywgYnVpbGRDYW1lcmEgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkubGlnaHRzLCBidWlsZExpZ2h0ICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5Lmdlb21ldHJpZXMsIGJ1aWxkR2VvbWV0cnkgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkudmlzdWFsU2NlbmVzLCBidWlsZFZpc3VhbFNjZW5lICk7XG5cblx0XHRzZXR1cEFuaW1hdGlvbnMoKTtcblx0XHRzZXR1cEtpbmVtYXRpY3MoKTtcblxuXHRcdHZhciBzY2VuZSA9IHBhcnNlU2NlbmUoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCBjb2xsYWRhLCAnc2NlbmUnIClbIDAgXSApO1xuXHRcdHNjZW5lLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXG5cdFx0aWYgKCBhc3NldC51cEF4aXMgPT09ICdaX1VQJyApIHtcblxuXHRcdFx0c2NlbmUucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIG5ldyBFdWxlciggLSBNYXRoLlBJIC8gMiwgMCwgMCApICk7XG5cblx0XHR9XG5cblx0XHRzY2VuZS5zY2FsZS5tdWx0aXBseVNjYWxhciggYXNzZXQudW5pdCApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldCBhbmltYXRpb25zKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFBsZWFzZSBhY2Nlc3MgYW5pbWF0aW9ucyBvdmVyIHNjZW5lLmFuaW1hdGlvbnMgbm93LicgKTtcblx0XHRcdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cblx0XHRcdH0sXG5cdFx0XHRraW5lbWF0aWNzOiBraW5lbWF0aWNzLFxuXHRcdFx0bGlicmFyeTogbGlicmFyeSxcblx0XHRcdHNjZW5lOiBzY2VuZVxuXHRcdH07XG5cblx0fVxuXG59ICk7XG5cbnZhciBPQkpMb2FkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBvIG9iamVjdF9uYW1lIHwgZyBncm91cF9uYW1lXG5cdHZhciBvYmplY3RfcGF0dGVybiA9IC9eW29nXVxccyooLispPy87XG5cdC8vIG10bGxpYiBmaWxlX3JlZmVyZW5jZVxuXHR2YXIgbWF0ZXJpYWxfbGlicmFyeV9wYXR0ZXJuID0gL15tdGxsaWIgLztcblx0Ly8gdXNlbXRsIG1hdGVyaWFsX25hbWVcblx0dmFyIG1hdGVyaWFsX3VzZV9wYXR0ZXJuID0gL151c2VtdGwgLztcblx0Ly8gdXNlbWFwIG1hcF9uYW1lXG5cdHZhciBtYXBfdXNlX3BhdHRlcm4gPSAvXnVzZW1hcCAvO1xuXG5cdHZhciB2QSA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2QiA9IG5ldyBWZWN0b3IzKCk7XG5cdHZhciB2QyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0dmFyIGFiID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBQYXJzZXJTdGF0ZSgpIHtcblxuXHRcdHZhciBzdGF0ZSA9IHtcblx0XHRcdG9iamVjdHM6IFtdLFxuXHRcdFx0b2JqZWN0OiB7fSxcblxuXHRcdFx0dmVydGljZXM6IFtdLFxuXHRcdFx0bm9ybWFsczogW10sXG5cdFx0XHRjb2xvcnM6IFtdLFxuXHRcdFx0dXZzOiBbXSxcblxuXHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdG1hdGVyaWFsTGlicmFyaWVzOiBbXSxcblxuXHRcdFx0c3RhcnRPYmplY3Q6IGZ1bmN0aW9uICggbmFtZSwgZnJvbURlY2xhcmF0aW9uICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBjdXJyZW50IG9iamVjdCAoaW5pdGlhbCBmcm9tIHJlc2V0KSBpcyBub3QgZnJvbSBhIGcvbyBkZWNsYXJhdGlvbiBpbiB0aGUgcGFyc2VkXG5cdFx0XHRcdC8vIGZpbGUuIFdlIG5lZWQgdG8gdXNlIGl0IGZvciB0aGUgZmlyc3QgcGFyc2VkIGcvbyB0byBrZWVwIHRoaW5ncyBpbiBzeW5jLlxuXHRcdFx0XHRpZiAoIHRoaXMub2JqZWN0ICYmIHRoaXMub2JqZWN0LmZyb21EZWNsYXJhdGlvbiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdC5uYW1lID0gbmFtZTtcblx0XHRcdFx0XHR0aGlzLm9iamVjdC5mcm9tRGVjbGFyYXRpb24gPSAoIGZyb21EZWNsYXJhdGlvbiAhPT0gZmFsc2UgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwcmV2aW91c01hdGVyaWFsID0gKCB0aGlzLm9iamVjdCAmJiB0eXBlb2YgdGhpcy5vYmplY3QuY3VycmVudE1hdGVyaWFsID09PSAnZnVuY3Rpb24nID8gdGhpcy5vYmplY3QuY3VycmVudE1hdGVyaWFsKCkgOiB1bmRlZmluZWQgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMub2JqZWN0ICYmIHR5cGVvZiB0aGlzLm9iamVjdC5fZmluYWxpemUgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdC5fZmluYWxpemUoIHRydWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5vYmplY3QgPSB7XG5cdFx0XHRcdFx0bmFtZTogbmFtZSB8fCAnJyxcblx0XHRcdFx0XHRmcm9tRGVjbGFyYXRpb246ICggZnJvbURlY2xhcmF0aW9uICE9PSBmYWxzZSApLFxuXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IHtcblx0XHRcdFx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHRcdFx0Y29sb3JzOiBbXSxcblx0XHRcdFx0XHRcdHV2czogW10sXG5cdFx0XHRcdFx0XHRoYXNVVkluZGljZXM6IGZhbHNlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRtYXRlcmlhbHM6IFtdLFxuXHRcdFx0XHRcdHNtb290aDogdHJ1ZSxcblxuXHRcdFx0XHRcdHN0YXJ0TWF0ZXJpYWw6IGZ1bmN0aW9uICggbmFtZSwgbGlicmFyaWVzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcHJldmlvdXMgPSB0aGlzLl9maW5hbGl6ZSggZmFsc2UgKTtcblxuXHRcdFx0XHRcdFx0Ly8gTmV3IHVzZW10bCBkZWNsYXJhdGlvbiBvdmVyd3JpdGVzIGFuIGluaGVyaXRlZCBtYXRlcmlhbCwgZXhjZXB0IGlmIGZhY2VzIHdlcmUgZGVjbGFyZWRcblx0XHRcdFx0XHRcdC8vIGFmdGVyIHRoZSBtYXRlcmlhbCwgdGhlbiBpdCBtdXN0IGJlIHByZXNlcnZlZCBmb3IgcHJvcGVyIE11bHRpTWF0ZXJpYWwgY29udGludWF0aW9uLlxuXHRcdFx0XHRcdFx0aWYgKCBwcmV2aW91cyAmJiAoIHByZXZpb3VzLmluaGVyaXRlZCB8fCBwcmV2aW91cy5ncm91cENvdW50IDw9IDAgKSApIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5zcGxpY2UoIHByZXZpb3VzLmluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0ge1xuXHRcdFx0XHRcdFx0XHRpbmRleDogdGhpcy5tYXRlcmlhbHMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBuYW1lIHx8ICcnLFxuXHRcdFx0XHRcdFx0XHRtdGxsaWI6ICggQXJyYXkuaXNBcnJheSggbGlicmFyaWVzICkgJiYgbGlicmFyaWVzLmxlbmd0aCA+IDAgPyBsaWJyYXJpZXNbIGxpYnJhcmllcy5sZW5ndGggLSAxIF0gOiAnJyApLFxuXHRcdFx0XHRcdFx0XHRzbW9vdGg6ICggcHJldmlvdXMgIT09IHVuZGVmaW5lZCA/IHByZXZpb3VzLnNtb290aCA6IHRoaXMuc21vb3RoICksXG5cdFx0XHRcdFx0XHRcdGdyb3VwU3RhcnQ6ICggcHJldmlvdXMgIT09IHVuZGVmaW5lZCA/IHByZXZpb3VzLmdyb3VwRW5kIDogMCApLFxuXHRcdFx0XHRcdFx0XHRncm91cEVuZDogLSAxLFxuXHRcdFx0XHRcdFx0XHRncm91cENvdW50OiAtIDEsXG5cdFx0XHRcdFx0XHRcdGluaGVyaXRlZDogZmFsc2UsXG5cblx0XHRcdFx0XHRcdFx0Y2xvbmU6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgY2xvbmVkID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXg6ICggdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyA/IGluZGV4IDogdGhpcy5pbmRleCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0bXRsbGliOiB0aGlzLm10bGxpYixcblx0XHRcdFx0XHRcdFx0XHRcdHNtb290aDogdGhpcy5zbW9vdGgsXG5cdFx0XHRcdFx0XHRcdFx0XHRncm91cFN0YXJ0OiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0Z3JvdXBFbmQ6IC0gMSxcblx0XHRcdFx0XHRcdFx0XHRcdGdyb3VwQ291bnQ6IC0gMSxcblx0XHRcdFx0XHRcdFx0XHRcdGluaGVyaXRlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lZC5jbG9uZSA9IHRoaXMuY2xvbmUuYmluZCggY2xvbmVkICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsb25lZDtcblxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Y3VycmVudE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5tYXRlcmlhbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNbIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdF9maW5hbGl6ZTogZnVuY3Rpb24gKCBlbmQgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBsYXN0TXVsdGlNYXRlcmlhbCA9IHRoaXMuY3VycmVudE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0XHRpZiAoIGxhc3RNdWx0aU1hdGVyaWFsICYmIGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kID09PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBFbmQgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHRcdFx0XHRcdGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwQ291bnQgPSBsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCAtIGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwU3RhcnQ7XG5cdFx0XHRcdFx0XHRcdGxhc3RNdWx0aU1hdGVyaWFsLmluaGVyaXRlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIElnbm9yZSBvYmplY3RzIHRhaWwgbWF0ZXJpYWxzIGlmIG5vIGZhY2UgZGVjbGFyYXRpb25zIGZvbGxvd2VkIHRoZW0gYmVmb3JlIGEgbmV3IG8vZyBzdGFydGVkLlxuXHRcdFx0XHRcdFx0aWYgKCBlbmQgJiYgdGhpcy5tYXRlcmlhbHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgbWkgPSB0aGlzLm1hdGVyaWFscy5sZW5ndGggLSAxOyBtaSA+PSAwOyBtaSAtLSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdGhpcy5tYXRlcmlhbHNbIG1pIF0uZ3JvdXBDb3VudCA8PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5zcGxpY2UoIG1pLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEd1YXJhbnRlZSBhdCBsZWFzdCBvbmUgZW1wdHkgbWF0ZXJpYWwsIHRoaXMgbWFrZXMgdGhlIGNyZWF0aW9uIGxhdGVyIG1vcmUgc3RyYWlnaHQgZm9yd2FyZC5cblx0XHRcdFx0XHRcdGlmICggZW5kICYmIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLm1hdGVyaWFscy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogJycsXG5cdFx0XHRcdFx0XHRcdFx0c21vb3RoOiB0aGlzLnNtb290aFxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGxhc3RNdWx0aU1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIEluaGVyaXQgcHJldmlvdXMgb2JqZWN0cyBtYXRlcmlhbC5cblx0XHRcdFx0Ly8gU3BlYyB0ZWxscyB1cyB0aGF0IGEgZGVjbGFyZWQgbWF0ZXJpYWwgbXVzdCBiZSBzZXQgdG8gYWxsIG9iamVjdHMgdW50aWwgYSBuZXcgbWF0ZXJpYWwgaXMgZGVjbGFyZWQuXG5cdFx0XHRcdC8vIElmIGEgdXNlbXRsIGRlY2xhcmF0aW9uIGlzIGVuY291bnRlcmVkIHdoaWxlIHRoaXMgbmV3IG9iamVjdCBpcyBiZWluZyBwYXJzZWQsIGl0IHdpbGxcblx0XHRcdFx0Ly8gb3ZlcndyaXRlIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwuIEV4Y2VwdGlvbiBiZWluZyB0aGF0IHRoZXJlIHdhcyBhbHJlYWR5IGZhY2UgZGVjbGFyYXRpb25zXG5cdFx0XHRcdC8vIHRvIHRoZSBpbmhlcml0ZWQgbWF0ZXJpYWwsIHRoZW4gaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgZm9yIHByb3BlciBNdWx0aU1hdGVyaWFsIGNvbnRpbnVhdGlvbi5cblxuXHRcdFx0XHRpZiAoIHByZXZpb3VzTWF0ZXJpYWwgJiYgcHJldmlvdXNNYXRlcmlhbC5uYW1lICYmIHR5cGVvZiBwcmV2aW91c01hdGVyaWFsLmNsb25lID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRcdFx0dmFyIGRlY2xhcmVkID0gcHJldmlvdXNNYXRlcmlhbC5jbG9uZSggMCApO1xuXHRcdFx0XHRcdGRlY2xhcmVkLmluaGVyaXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5vYmplY3QubWF0ZXJpYWxzLnB1c2goIGRlY2xhcmVkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMub2JqZWN0cy5wdXNoKCB0aGlzLm9iamVjdCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Ll9maW5hbGl6ZSggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0cGFyc2VWZXJ0ZXhJbmRleDogZnVuY3Rpb24gKCB2YWx1ZSwgbGVuICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcblx0XHRcdFx0cmV0dXJuICggaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMyApICogMztcblxuXHRcdFx0fSxcblxuXHRcdFx0cGFyc2VOb3JtYWxJbmRleDogZnVuY3Rpb24gKCB2YWx1ZSwgbGVuICkge1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSwgMTAgKTtcblx0XHRcdFx0cmV0dXJuICggaW5kZXggPj0gMCA/IGluZGV4IC0gMSA6IGluZGV4ICsgbGVuIC8gMyApICogMztcblxuXHRcdFx0fSxcblxuXHRcdFx0cGFyc2VVVkluZGV4OiBmdW5jdGlvbiAoIHZhbHVlLCBsZW4gKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlLCAxMCApO1xuXHRcdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAyICkgKiAyO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRWZXJ0ZXg6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSwgc3JjWyBhICsgMiBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSwgc3JjWyBiICsgMiBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAwIF0sIHNyY1sgYyArIDEgXSwgc3JjWyBjICsgMiBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFZlcnRleFBvaW50OiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRWZXJ0ZXhMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGROb3JtYWw6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy5ub3JtYWxzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkubm9ybWFscztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBiICsgMCBdLCBzcmNbIGIgKyAxIF0sIHNyY1sgYiArIDIgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0sIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRGYWNlTm9ybWFsOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudmVydGljZXM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5ub3JtYWxzO1xuXG5cdFx0XHRcdHZBLmZyb21BcnJheSggc3JjLCBhICk7XG5cdFx0XHRcdHZCLmZyb21BcnJheSggc3JjLCBiICk7XG5cdFx0XHRcdHZDLmZyb21BcnJheSggc3JjLCBjICk7XG5cblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xuXHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRkc3QucHVzaCggY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRkc3QucHVzaCggY2IueCwgY2IueSwgY2IueiApO1xuXHRcdFx0XHRkc3QucHVzaCggY2IueCwgY2IueSwgY2IueiApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRDb2xvcjogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLmNvbG9ycztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmNvbG9ycztcblxuXHRcdFx0XHRpZiAoIHNyY1sgYSBdICE9PSB1bmRlZmluZWQgKSBkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0sIHNyY1sgYSArIDIgXSApO1xuXHRcdFx0XHRpZiAoIHNyY1sgYiBdICE9PSB1bmRlZmluZWQgKSBkc3QucHVzaCggc3JjWyBiICsgMCBdLCBzcmNbIGIgKyAxIF0sIHNyY1sgYiArIDIgXSApO1xuXHRcdFx0XHRpZiAoIHNyY1sgYyBdICE9PSB1bmRlZmluZWQgKSBkc3QucHVzaCggc3JjWyBjICsgMCBdLCBzcmNbIGMgKyAxIF0sIHNyY1sgYyArIDIgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRVVjogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnV2cztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnV2cztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAwIF0sIHNyY1sgYyArIDEgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGREZWZhdWx0VVY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCAwLCAwICk7XG5cdFx0XHRcdGRzdC5wdXNoKCAwLCAwICk7XG5cdFx0XHRcdGRzdC5wdXNoKCAwLCAwICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFVWTGluZTogZnVuY3Rpb24gKCBhICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnV2cztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnV2cztcblxuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBhICsgMCBdLCBzcmNbIGEgKyAxIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkRmFjZTogZnVuY3Rpb24gKCBhLCBiLCBjLCB1YSwgdWIsIHVjLCBuYSwgbmIsIG5jICkge1xuXG5cdFx0XHRcdHZhciB2TGVuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0dmFyIGlhID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBhLCB2TGVuICk7XG5cdFx0XHRcdHZhciBpYiA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggYiwgdkxlbiApO1xuXHRcdFx0XHR2YXIgaWMgPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIGMsIHZMZW4gKTtcblxuXHRcdFx0XHR0aGlzLmFkZFZlcnRleCggaWEsIGliLCBpYyApO1xuXHRcdFx0XHR0aGlzLmFkZENvbG9yKCBpYSwgaWIsIGljICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRcdGlmICggbmEgIT09IHVuZGVmaW5lZCAmJiBuYSAhPT0gJycgKSB7XG5cblx0XHRcdFx0XHR2YXIgbkxlbiA9IHRoaXMubm9ybWFscy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpYSA9IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmEsIG5MZW4gKTtcblx0XHRcdFx0XHRpYiA9IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmIsIG5MZW4gKTtcblx0XHRcdFx0XHRpYyA9IHRoaXMucGFyc2VOb3JtYWxJbmRleCggbmMsIG5MZW4gKTtcblxuXHRcdFx0XHRcdHRoaXMuYWRkTm9ybWFsKCBpYSwgaWIsIGljICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkRmFjZU5vcm1hbCggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1dnNcblxuXHRcdFx0XHRpZiAoIHVhICE9PSB1bmRlZmluZWQgJiYgdWEgIT09ICcnICkge1xuXG5cdFx0XHRcdFx0dmFyIHV2TGVuID0gdGhpcy51dnMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWEgPSB0aGlzLnBhcnNlVVZJbmRleCggdWEsIHV2TGVuICk7XG5cdFx0XHRcdFx0aWIgPSB0aGlzLnBhcnNlVVZJbmRleCggdWIsIHV2TGVuICk7XG5cdFx0XHRcdFx0aWMgPSB0aGlzLnBhcnNlVVZJbmRleCggdWMsIHV2TGVuICk7XG5cblx0XHRcdFx0XHR0aGlzLmFkZFVWKCBpYSwgaWIsIGljICk7XG5cblx0XHRcdFx0XHR0aGlzLm9iamVjdC5nZW9tZXRyeS5oYXNVVkluZGljZXMgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBhZGQgcGxhY2Vob2xkZXIgdmFsdWVzIChmb3IgaW5jb25zaXN0ZW50IGZhY2UgZGVmaW5pdGlvbnMpXG5cblx0XHRcdFx0XHR0aGlzLmFkZERlZmF1bHRVVigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkUG9pbnRHZW9tZXRyeTogZnVuY3Rpb24gKCB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5nZW9tZXRyeS50eXBlID0gJ1BvaW50cyc7XG5cblx0XHRcdFx0dmFyIHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgdmkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyB2aSA8IGw7IHZpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCB2ZXJ0aWNlc1sgdmkgXSwgdkxlbiApO1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRWZXJ0ZXhQb2ludCggaW5kZXggKTtcblx0XHRcdFx0XHR0aGlzLmFkZENvbG9yKCBpbmRleCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkTGluZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHZlcnRpY2VzLCB1dnMgKSB7XG5cblx0XHRcdFx0dGhpcy5vYmplY3QuZ2VvbWV0cnkudHlwZSA9ICdMaW5lJztcblxuXHRcdFx0XHR2YXIgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHRcdFx0XHR2YXIgdXZMZW4gPSB0aGlzLnV2cy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggdmFyIHZpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgdmkgPCBsOyB2aSArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVmVydGV4TGluZSggdGhpcy5wYXJzZVZlcnRleEluZGV4KCB2ZXJ0aWNlc1sgdmkgXSwgdkxlbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciB1dmkgPSAwLCBsID0gdXZzLmxlbmd0aDsgdXZpIDwgbDsgdXZpICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRVVkxpbmUoIHRoaXMucGFyc2VVVkluZGV4KCB1dnNbIHV2aSBdLCB1dkxlbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0c3RhdGUuc3RhcnRPYmplY3QoICcnLCBmYWxzZSApO1xuXG5cdFx0cmV0dXJuIHN0YXRlO1xuXG5cdH1cblxuXHQvL1xuXG5cdGZ1bmN0aW9uIE9CSkxvYWRlciggbWFuYWdlciApIHtcblxuXHRcdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWxzID0gbnVsbDtcblxuXHR9XG5cblx0T0JKTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogT0JKTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHZhciBzdGF0ZSA9IG5ldyBQYXJzZXJTdGF0ZSgpO1xuXG5cdFx0XHRpZiAoIHRleHQuaW5kZXhPZiggJ1xcclxcbicgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gU3RyaW5nLnNwbGl0IHdpdGggcmVnZXggdGhhdCBzcGxpdHMgb24gYm90aFxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCAvXFxyXFxuL2csICdcXG4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0ZXh0LmluZGV4T2YoICdcXFxcXFxuJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8gam9pbiBsaW5lcyBzZXBhcmF0ZWQgYnkgYSBsaW5lIGNvbnRpbnVhdGlvbiBjaGFyYWN0ZXIgKFxcKVxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCAvXFxcXFxcbi9nLCAnJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBsaW5lcyA9IHRleHQuc3BsaXQoICdcXG4nICk7XG5cdFx0XHR2YXIgbGluZSA9ICcnLCBsaW5lRmlyc3RDaGFyID0gJyc7XG5cdFx0XHR2YXIgbGluZUxlbmd0aCA9IDA7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdC8vIEZhc3RlciB0byBqdXN0IHRyaW0gbGVmdCBzaWRlIG9mIHRoZSBsaW5lLiBVc2UgaWYgYXZhaWxhYmxlLlxuXHRcdFx0dmFyIHRyaW1MZWZ0ID0gKCB0eXBlb2YgJycudHJpbUxlZnQgPT09ICdmdW5jdGlvbicgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRsaW5lID0gbGluZXNbIGkgXTtcblxuXHRcdFx0XHRsaW5lID0gdHJpbUxlZnQgPyBsaW5lLnRyaW1MZWZ0KCkgOiBsaW5lLnRyaW0oKTtcblxuXHRcdFx0XHRsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBsaW5lTGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0bGluZUZpcnN0Q2hhciA9IGxpbmUuY2hhckF0KCAwICk7XG5cblx0XHRcdFx0Ly8gQHRvZG8gaW52b2tlIHBhc3NlZCBpbiBoYW5kbGVyIGlmIGFueVxuXHRcdFx0XHRpZiAoIGxpbmVGaXJzdENoYXIgPT09ICcjJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ3YnICkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBsaW5lLnNwbGl0KCAvXFxzKy8gKTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGRhdGFbIDAgXSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnZlcnRpY2VzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMSBdICksXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMiBdICksXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMyBdIClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhLmxlbmd0aCA+PSA3ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29sb3JzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA0IF0gKSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDUgXSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgNiBdIClcblxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIG5vIGNvbG9ycyBhcmUgZGVmaW5lZCwgYWRkIHBsYWNlaG9sZGVycyBzbyBjb2xvciBhbmQgdmVydGV4IGluZGljZXMgbWF0Y2hcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmNvbG9ycy5wdXNoKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAndm4nOlxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5ub3JtYWxzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMSBdICksXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMiBdICksXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMyBdIClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd2dCc6XG5cdFx0XHRcdFx0XHRcdHN0YXRlLnV2cy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDEgXSApLFxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDIgXSApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmVGaXJzdENoYXIgPT09ICdmJyApIHtcblxuXHRcdFx0XHRcdHZhciBsaW5lRGF0YSA9IGxpbmUuc3Vic3RyKCAxICkudHJpbSgpO1xuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhEYXRhID0gbGluZURhdGEuc3BsaXQoIC9cXHMrLyApO1xuXHRcdFx0XHRcdHZhciBmYWNlVmVydGljZXMgPSBbXTtcblxuXHRcdFx0XHRcdC8vIFBhcnNlIHRoZSBmYWNlIHZlcnRleCBkYXRhIGludG8gYW4gZWFzeSB0byB3b3JrIHdpdGggZm9ybWF0XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdmVydGV4RGF0YS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRleERhdGFbIGogXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB2ZXJ0ZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdmVydGV4UGFydHMgPSB2ZXJ0ZXguc3BsaXQoICcvJyApO1xuXHRcdFx0XHRcdFx0XHRmYWNlVmVydGljZXMucHVzaCggdmVydGV4UGFydHMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRHJhdyBhbiBlZGdlIGJldHdlZW4gdGhlIGZpcnN0IHZlcnRleCBhbmQgYWxsIHN1YnNlcXVlbnQgdmVydGljZXMgdG8gZm9ybSBhbiBuLWdvblxuXG5cdFx0XHRcdFx0dmFyIHYxID0gZmFjZVZlcnRpY2VzWyAwIF07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDEsIGpsID0gZmFjZVZlcnRpY2VzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHYyID0gZmFjZVZlcnRpY2VzWyBqIF07XG5cdFx0XHRcdFx0XHR2YXIgdjMgPSBmYWNlVmVydGljZXNbIGogKyAxIF07XG5cblx0XHRcdFx0XHRcdHN0YXRlLmFkZEZhY2UoXG5cdFx0XHRcdFx0XHRcdHYxWyAwIF0sIHYyWyAwIF0sIHYzWyAwIF0sXG5cdFx0XHRcdFx0XHRcdHYxWyAxIF0sIHYyWyAxIF0sIHYzWyAxIF0sXG5cdFx0XHRcdFx0XHRcdHYxWyAyIF0sIHYyWyAyIF0sIHYzWyAyIF1cblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ2wnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpbmVQYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKCAxICkudHJpbSgpLnNwbGl0KCAnICcgKTtcblx0XHRcdFx0XHR2YXIgbGluZVZlcnRpY2VzID0gW10sIGxpbmVVVnMgPSBbXTtcblxuXHRcdFx0XHRcdGlmICggbGluZS5pbmRleE9mKCAnLycgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRsaW5lVmVydGljZXMgPSBsaW5lUGFydHM7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbGkgPSAwLCBsbGVuID0gbGluZVBhcnRzLmxlbmd0aDsgbGkgPCBsbGVuOyBsaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcGFydHMgPSBsaW5lUGFydHNbIGxpIF0uc3BsaXQoICcvJyApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggcGFydHNbIDAgXSAhPT0gJycgKSBsaW5lVmVydGljZXMucHVzaCggcGFydHNbIDAgXSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHBhcnRzWyAxIF0gIT09ICcnICkgbGluZVVWcy5wdXNoKCBwYXJ0c1sgMSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN0YXRlLmFkZExpbmVHZW9tZXRyeSggbGluZVZlcnRpY2VzLCBsaW5lVVZzICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ3AnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpbmVEYXRhID0gbGluZS5zdWJzdHIoIDEgKS50cmltKCk7XG5cdFx0XHRcdFx0dmFyIHBvaW50RGF0YSA9IGxpbmVEYXRhLnNwbGl0KCAnICcgKTtcblxuXHRcdFx0XHRcdHN0YXRlLmFkZFBvaW50R2VvbWV0cnkoIHBvaW50RGF0YSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gb2JqZWN0X3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBvIG9iamVjdF9uYW1lXG5cdFx0XHRcdFx0Ly8gb3Jcblx0XHRcdFx0XHQvLyBnIGdyb3VwX25hbWVcblxuXHRcdFx0XHRcdC8vIFdPUktBUk9VTkQ6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTI4Njlcblx0XHRcdFx0XHQvLyB2YXIgbmFtZSA9IHJlc3VsdFsgMCBdLnN1YnN0ciggMSApLnRyaW0oKTtcblx0XHRcdFx0XHR2YXIgbmFtZSA9ICggJyAnICsgcmVzdWx0WyAwIF0uc3Vic3RyKCAxICkudHJpbSgpICkuc3Vic3RyKCAxICk7XG5cblx0XHRcdFx0XHRzdGF0ZS5zdGFydE9iamVjdCggbmFtZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsX3VzZV9wYXR0ZXJuLnRlc3QoIGxpbmUgKSApIHtcblxuXHRcdFx0XHRcdC8vIG1hdGVyaWFsXG5cblx0XHRcdFx0XHRzdGF0ZS5vYmplY3Quc3RhcnRNYXRlcmlhbCggbGluZS5zdWJzdHJpbmcoIDcgKS50cmltKCksIHN0YXRlLm1hdGVyaWFsTGlicmFyaWVzICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxfbGlicmFyeV9wYXR0ZXJuLnRlc3QoIGxpbmUgKSApIHtcblxuXHRcdFx0XHRcdC8vIG10bCBmaWxlXG5cblx0XHRcdFx0XHRzdGF0ZS5tYXRlcmlhbExpYnJhcmllcy5wdXNoKCBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hcF91c2VfcGF0dGVybi50ZXN0KCBsaW5lICkgKSB7XG5cblx0XHRcdFx0XHQvLyB0aGUgbGluZSBpcyBwYXJzZWQgYnV0IGlnbm9yZWQgc2luY2UgdGhlIGxvYWRlciBhc3N1bWVzIHRleHR1cmVzIGFyZSBkZWZpbmVkIE1UTCBmaWxlc1xuXHRcdFx0XHRcdC8vIChhY2NvcmRpbmcgdG8gaHR0cHM6Ly93d3cub2tpbm8uY29tL2NvbnYvaW1wX3dhdmUuaHRtLCAndXNlbWFwJyBpcyB0aGUgb2xkLXN0eWxlIFdhdmVmcm9udCB0ZXh0dXJlIHJlZmVyZW5jZSBtZXRob2QpXG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PQkpMb2FkZXI6IFJlbmRlcmluZyBpZGVudGlmaWVyIFwidXNlbWFwXCIgbm90IHN1cHBvcnRlZC4gVGV4dHVyZXMgbXVzdCBiZSBkZWZpbmVkIGluIE1UTCBmaWxlcy4nICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ3MnICkge1xuXG5cdFx0XHRcdFx0cmVzdWx0ID0gbGluZS5zcGxpdCggJyAnICk7XG5cblx0XHRcdFx0XHQvLyBzbW9vdGggc2hhZGluZ1xuXG5cdFx0XHRcdFx0Ly8gQHRvZG8gSGFuZGxlIGZpbGVzIHRoYXQgaGF2ZSB2YXJ5aW5nIHNtb290aCB2YWx1ZXMgZm9yIGEgc2V0IG9mIGZhY2VzIGluc2lkZSBvbmUgZ2VvbWV0cnksXG5cdFx0XHRcdFx0Ly8gYnV0IGRvZXMgbm90IGRlZmluZSBhIHVzZW10bCBmb3IgZWFjaCBmYWNlIHNldC5cblx0XHRcdFx0XHQvLyBUaGlzIHNob3VsZCBiZSBkZXRlY3RlZCBhbmQgYSBkdW1teSBtYXRlcmlhbCBjcmVhdGVkIChsYXRlciBNdWx0aU1hdGVyaWFsIGFuZCBnZW9tZXRyeSBncm91cHMpLlxuXHRcdFx0XHRcdC8vIFRoaXMgcmVxdWlyZXMgc29tZSBjYXJlIHRvIG5vdCBjcmVhdGUgZXh0cmEgbWF0ZXJpYWwgb24gZWFjaCBzbW9vdGggdmFsdWUgZm9yIFwibm9ybWFsXCIgb2JqIGZpbGVzLlxuXHRcdFx0XHRcdC8vIHdoZXJlIGV4cGxpY2l0IHVzZW10bCBkZWZpbmVzIGdlb21ldHJ5IGdyb3Vwcy5cblx0XHRcdFx0XHQvLyBFeGFtcGxlIGFzc2V0OiBleGFtcGxlcy9tb2RlbHMvb2JqL2NlcmJlcnVzL0NlcmJlcnVzLm9ialxuXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHQgKiBodHRwOi8vcGF1bGJvdXJrZS5uZXQvZGF0YWZvcm1hdHMvb2JqL1xuXHRcdFx0XHRcdCAqIG9yXG5cdFx0XHRcdFx0ICogaHR0cDovL3d3dy5jcy51dGFoLmVkdS9+Ym91bG9zL2NzMzUwNS9vYmpfc3BlYy5wZGZcblx0XHRcdFx0XHQgKlxuXHRcdFx0XHRcdCAqIEZyb20gY2hhcHRlciBcIkdyb3VwaW5nXCIgU3ludGF4IGV4cGxhbmF0aW9uIFwicyBncm91cF9udW1iZXJcIjpcblx0XHRcdFx0XHQgKiBcImdyb3VwX251bWJlciBpcyB0aGUgc21vb3RoaW5nIGdyb3VwIG51bWJlci4gVG8gdHVybiBvZmYgc21vb3RoaW5nIGdyb3VwcywgdXNlIGEgdmFsdWUgb2YgMCBvciBvZmYuXG5cdFx0XHRcdFx0ICogUG9seWdvbmFsIGVsZW1lbnRzIHVzZSBncm91cCBudW1iZXJzIHRvIHB1dCBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc21vb3RoaW5nIGdyb3Vwcy4gRm9yIGZyZWUtZm9ybVxuXHRcdFx0XHRcdCAqIHN1cmZhY2VzLCBzbW9vdGhpbmcgZ3JvdXBzIGFyZSBlaXRoZXIgdHVybmVkIG9uIG9yIG9mZjsgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHZhbHVlcyBncmVhdGVyXG5cdFx0XHRcdFx0ICogdGhhbiAwLlwiXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0aWYgKCByZXN1bHQubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gcmVzdWx0WyAxIF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRzdGF0ZS5vYmplY3Quc21vb3RoID0gKCB2YWx1ZSAhPT0gJzAnICYmIHZhbHVlICE9PSAnb2ZmJyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gWkJydXNoIGNhbiBwcm9kdWNlIFwic1wiIGxpbmVzICMxMTcwN1xuXHRcdFx0XHRcdFx0c3RhdGUub2JqZWN0LnNtb290aCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBzdGF0ZS5vYmplY3QuY3VycmVudE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCApIG1hdGVyaWFsLnNtb290aCA9IHN0YXRlLm9iamVjdC5zbW9vdGg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBudWxsIHRlcm1pbmF0ZWQgZmlsZXMgd2l0aG91dCBleGNlcHRpb25cblx0XHRcdFx0XHRpZiAoIGxpbmUgPT09ICdcXDAnICkgY29udGludWU7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PQkpMb2FkZXI6IFVuZXhwZWN0ZWQgbGluZTogXCInICsgbGluZSArICdcIicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0c3RhdGUuZmluYWxpemUoKTtcblxuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5ldyBHcm91cCgpO1xuXHRcdFx0Y29udGFpbmVyLm1hdGVyaWFsTGlicmFyaWVzID0gW10uY29uY2F0KCBzdGF0ZS5tYXRlcmlhbExpYnJhcmllcyApO1xuXG5cdFx0XHR2YXIgaGFzUHJpbWl0aXZlcyA9ICEgKCBzdGF0ZS5vYmplY3RzLmxlbmd0aCA9PT0gMSAmJiBzdGF0ZS5vYmplY3RzWyAwIF0uZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID09PSAwICk7XG5cblx0XHRcdGlmICggaGFzUHJpbWl0aXZlcyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdGF0ZS5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gc3RhdGUub2JqZWN0c1sgaSBdO1xuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gb2JqZWN0Lm1hdGVyaWFscztcblx0XHRcdFx0XHR2YXIgaXNMaW5lID0gKCBnZW9tZXRyeS50eXBlID09PSAnTGluZScgKTtcblx0XHRcdFx0XHR2YXIgaXNQb2ludHMgPSAoIGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludHMnICk7XG5cdFx0XHRcdFx0dmFyIGhhc1ZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gU2tpcCBvL2cgbGluZSBkZWNsYXJhdGlvbnMgdGhhdCBkaWQgbm90IGZvbGxvdyB3aXRoIGFueSBmYWNlc1xuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID09PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLCAzICkgKTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkubm9ybWFscywgMyApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRoYXNWZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLCAzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaGFzVVZJbmRpY2VzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS51dnMsIDIgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIG1hdGVyaWFsc1xuXG5cdFx0XHRcdFx0dmFyIGNyZWF0ZWRNYXRlcmlhbHMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtaSA9IDAsIG1pTGVuID0gbWF0ZXJpYWxzLmxlbmd0aDsgbWkgPCBtaUxlbjsgbWkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBzb3VyY2VNYXRlcmlhbCA9IG1hdGVyaWFsc1sgbWkgXTtcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbEhhc2ggPSBzb3VyY2VNYXRlcmlhbC5uYW1lICsgJ18nICsgc291cmNlTWF0ZXJpYWwuc21vb3RoICsgJ18nICsgaGFzVmVydGV4Q29sb3JzO1xuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gc3RhdGUubWF0ZXJpYWxzWyBtYXRlcmlhbEhhc2ggXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFscyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzLmNyZWF0ZSggc291cmNlTWF0ZXJpYWwubmFtZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG10bCBldGMuIGxvYWRlcnMgcHJvYmFibHkgY2FuJ3QgY3JlYXRlIGxpbmUgbWF0ZXJpYWxzIGNvcnJlY3RseSwgY29weSBwcm9wZXJ0aWVzIHRvIGEgbGluZSBtYXRlcmlhbC5cblx0XHRcdFx0XHRcdFx0aWYgKCBpc0xpbmUgJiYgbWF0ZXJpYWwgJiYgISAoIG1hdGVyaWFsIGluc3RhbmNlb2YgTGluZUJhc2ljTWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbExpbmUgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBtYXRlcmlhbExpbmUsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxMaW5lLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbExpbmU7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgJiYgbWF0ZXJpYWwgJiYgISAoIG1hdGVyaWFsIGluc3RhbmNlb2YgUG9pbnRzTWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbFBvaW50cyA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBzaXplOiAxMCwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9ICk7XG5cdFx0XHRcdFx0XHRcdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggbWF0ZXJpYWxQb2ludHMsIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxQb2ludHMuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbFBvaW50cy5tYXAgPSBtYXRlcmlhbC5tYXA7XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbFBvaW50cztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaXNMaW5lICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpc1BvaW50cyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IHNpemU6IDEsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UgfSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gc291cmNlTWF0ZXJpYWwubmFtZTtcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBzb3VyY2VNYXRlcmlhbC5zbW9vdGggPyBmYWxzZSA6IHRydWU7XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGhhc1ZlcnRleENvbG9ycztcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5tYXRlcmlhbHNbIG1hdGVyaWFsSGFzaCBdID0gbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3JlYXRlZE1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIG1lc2hcblxuXHRcdFx0XHRcdHZhciBtZXNoO1xuXG5cdFx0XHRcdFx0aWYgKCBjcmVhdGVkTWF0ZXJpYWxzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBtaSA9IDAsIG1pTGVuID0gbWF0ZXJpYWxzLmxlbmd0aDsgbWkgPCBtaUxlbjsgbWkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzWyBtaSBdO1xuXHRcdFx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5hZGRHcm91cCggc291cmNlTWF0ZXJpYWwuZ3JvdXBTdGFydCwgc291cmNlTWF0ZXJpYWwuZ3JvdXBDb3VudCwgbWkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGlzTGluZSApIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVTZWdtZW50cyggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggaXNQb2ludHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBQb2ludHMoIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGlzTGluZSApIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVTZWdtZW50cyggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpc1BvaW50cyApIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IFBvaW50cyggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgTWVzaCggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXNoLm5hbWUgPSBvYmplY3QubmFtZTtcblxuXHRcdFx0XHRcdGNvbnRhaW5lci5hZGQoIG1lc2ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgb25seSB0aGUgZGVmYXVsdCBwYXJzZXIgc3RhdGUgb2JqZWN0IHdpdGggbm8gZ2VvbWV0cnkgZGF0YSwgaW50ZXJwcmV0IGRhdGEgYXMgcG9pbnQgY2xvdWRcblxuXHRcdFx0XHRpZiAoIHN0YXRlLnZlcnRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMSwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHN0YXRlLnZlcnRpY2VzLCAzICkgKTtcblxuXHRcdFx0XHRcdGlmICggc3RhdGUuY29sb3JzLmxlbmd0aCA+IDAgJiYgc3RhdGUuY29sb3JzWyAwIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc3RhdGUuY29sb3JzLCAzICkgKTtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcG9pbnRzID0gbmV3IFBvaW50cyggYnVmZmVyZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmFkZCggcG9pbnRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb250YWluZXI7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdHJldHVybiBPQkpMb2FkZXI7XG5cbn0gKSgpO1xuXG4vKipcbiAqIExvYWRzIGEgV2F2ZWZyb250IC5tdGwgZmlsZSBzcGVjaWZ5aW5nIG1hdGVyaWFsc1xuICovXG5cbnZhciBNVExMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG59O1xuXG5NVExMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogTVRMTG9hZGVyLFxuXG5cdC8qKlxuXHQgKiBMb2FkcyBhbmQgcGFyc2VzIGEgTVRMIGFzc2V0IGZyb20gYSBVUkwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgLSBVUkwgdG8gdGhlIE1UTCBmaWxlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Mb2FkXSAtIENhbGxiYWNrIGludm9rZWQgd2l0aCB0aGUgbG9hZGVkIG9iamVjdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW29uUHJvZ3Jlc3NdIC0gQ2FsbGJhY2sgZm9yIGRvd25sb2FkIHByb2dyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gLSBDYWxsYmFjayBmb3IgZG93bmxvYWQgZXJyb3JzLlxuXHQgKlxuXHQgKiBAc2VlIHNldFBhdGggc2V0UmVzb3VyY2VQYXRoXG5cdCAqXG5cdCAqIEBub3RlIEluIG9yZGVyIGZvciByZWxhdGl2ZSB0ZXh0dXJlIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZSBjb3JyZWN0bHlcblx0ICogeW91IG11c3QgY2FsbCBzZXRSZXNvdXJjZVBhdGgoKSBleHBsaWNpdGx5IHByaW9yIHRvIGxvYWQuXG5cdCAqL1xuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBwYXRoID0gKCB0aGlzLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiB0aGlzLnBhdGg7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCwgcGF0aCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldE1hdGVyaWFsT3B0aW9uczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWF0ZXJpYWxPcHRpb25zID0gdmFsdWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvKipcblx0ICogUGFyc2VzIGEgTVRMIGZpbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gQ29udGVudCBvZiBNVEwgZmlsZVxuXHQgKiBAcmV0dXJuIHtNVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yfVxuXHQgKlxuXHQgKiBAc2VlIHNldFBhdGggc2V0UmVzb3VyY2VQYXRoXG5cdCAqXG5cdCAqIEBub3RlIEluIG9yZGVyIGZvciByZWxhdGl2ZSB0ZXh0dXJlIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZSBjb3JyZWN0bHlcblx0ICogeW91IG11c3QgY2FsbCBzZXRSZXNvdXJjZVBhdGgoKSBleHBsaWNpdGx5IHByaW9yIHRvIHBhcnNlLlxuXHQgKi9cblx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCwgcGF0aCApIHtcblxuXHRcdHZhciBsaW5lcyA9IHRleHQuc3BsaXQoICdcXG4nICk7XG5cdFx0dmFyIGluZm8gPSB7fTtcblx0XHR2YXIgZGVsaW1pdGVyX3BhdHRlcm4gPSAvXFxzKy87XG5cdFx0dmFyIG1hdGVyaWFsc0luZm8gPSB7fTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1sgaSBdO1xuXHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRpZiAoIGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KCAwICkgPT09ICcjJyApIHtcblxuXHRcdFx0XHQvLyBCbGFuayBsaW5lIG9yIGNvbW1lbnQgaWdub3JlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwb3MgPSBsaW5lLmluZGV4T2YoICcgJyApO1xuXG5cdFx0XHR2YXIga2V5ID0gKCBwb3MgPj0gMCApID8gbGluZS5zdWJzdHJpbmcoIDAsIHBvcyApIDogbGluZTtcblx0XHRcdGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHR2YXIgdmFsdWUgPSAoIHBvcyA+PSAwICkgPyBsaW5lLnN1YnN0cmluZyggcG9zICsgMSApIDogJyc7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBrZXkgPT09ICduZXdtdGwnICkge1xuXG5cdFx0XHRcdC8vIE5ldyBtYXRlcmlhbFxuXG5cdFx0XHRcdGluZm8gPSB7IG5hbWU6IHZhbHVlIH07XG5cdFx0XHRcdG1hdGVyaWFsc0luZm9bIHZhbHVlIF0gPSBpbmZvO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICgga2V5ID09PSAna2EnIHx8IGtleSA9PT0gJ2tkJyB8fCBrZXkgPT09ICdrcycgfHwga2V5ID09PSAna2UnICkge1xuXG5cdFx0XHRcdFx0dmFyIHNzID0gdmFsdWUuc3BsaXQoIGRlbGltaXRlcl9wYXR0ZXJuLCAzICk7XG5cdFx0XHRcdFx0aW5mb1sga2V5IF0gPSBbIHBhcnNlRmxvYXQoIHNzWyAwIF0gKSwgcGFyc2VGbG9hdCggc3NbIDEgXSApLCBwYXJzZUZsb2F0KCBzc1sgMiBdICkgXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5mb1sga2V5IF0gPSB2YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBtYXRlcmlhbENyZWF0b3IgPSBuZXcgTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvciggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCwgdGhpcy5tYXRlcmlhbE9wdGlvbnMgKTtcblx0XHRtYXRlcmlhbENyZWF0b3Iuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRtYXRlcmlhbENyZWF0b3Iuc2V0TWFuYWdlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hdGVyaWFscyggbWF0ZXJpYWxzSW5mbyApO1xuXHRcdHJldHVybiBtYXRlcmlhbENyZWF0b3I7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IE1UTExvYWRlci5NYXRlcmlhbENyZWF0b3JcbiAqIEBwYXJhbSBiYXNlVXJsIC0gVXJsIHJlbGF0aXZlIHRvIHdoaWNoIHRleHR1cmVzIGFyZSBsb2FkZWRcbiAqIEBwYXJhbSBvcHRpb25zIC0gU2V0IG9mIG9wdGlvbnMgb24gaG93IHRvIGNvbnN0cnVjdCB0aGUgbWF0ZXJpYWxzXG4gKiAgICAgICAgICAgICAgICAgIHNpZGU6IFdoaWNoIHNpZGUgdG8gYXBwbHkgdGhlIG1hdGVyaWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIEZyb250U2lkZSAoZGVmYXVsdCksIFRIUkVFLkJhY2tTaWRlLCBUSFJFRS5Eb3VibGVTaWRlXG4gKiAgICAgICAgICAgICAgICAgIHdyYXA6IFdoYXQgdHlwZSBvZiB3cmFwcGluZyB0byBhcHBseSBmb3IgdGV4dHVyZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgUmVwZWF0V3JhcHBpbmcgKGRlZmF1bHQpLCBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLCBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG4gKiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJHQjogUkdCcyBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQgdG8gMC0xIGZyb20gMC0yNTVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZSwgYXNzdW1lZCB0byBiZSBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAqICAgICAgICAgICAgICAgICAgaWdub3JlWmVyb1JHQnM6IElnbm9yZSB2YWx1ZXMgb2YgUkdCcyAoS2EsS2QsS3MpIHRoYXQgYXJlIGFsbCAwJ3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQ6IGZhbHNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yID0gZnVuY3Rpb24gKCBiYXNlVXJsLCBvcHRpb25zICkge1xuXG5cdHRoaXMuYmFzZVVybCA9IGJhc2VVcmwgfHwgJyc7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMubWF0ZXJpYWxzSW5mbyA9IHt9O1xuXHR0aGlzLm1hdGVyaWFscyA9IHt9O1xuXHR0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XG5cdHRoaXMubmFtZUxvb2t1cCA9IHt9O1xuXG5cdHRoaXMuc2lkZSA9ICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zaWRlICkgPyB0aGlzLm9wdGlvbnMuc2lkZSA6IEZyb250U2lkZTtcblx0dGhpcy53cmFwID0gKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndyYXAgKSA/IHRoaXMub3B0aW9ucy53cmFwIDogUmVwZWF0V3JhcHBpbmc7XG5cbn07XG5cbk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBNVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yLFxuXG5cdGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldE1hbmFnZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm1hbmFnZXIgPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHNldE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHNJbmZvICkge1xuXG5cdFx0dGhpcy5tYXRlcmlhbHNJbmZvID0gdGhpcy5jb252ZXJ0KCBtYXRlcmlhbHNJbmZvICk7XG5cdFx0dGhpcy5tYXRlcmlhbHMgPSB7fTtcblx0XHR0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XG5cdFx0dGhpcy5uYW1lTG9va3VwID0ge307XG5cblx0fSxcblxuXHRjb252ZXJ0OiBmdW5jdGlvbiAoIG1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRpZiAoICEgdGhpcy5vcHRpb25zICkgcmV0dXJuIG1hdGVyaWFsc0luZm87XG5cblx0XHR2YXIgY29udmVydGVkID0ge307XG5cblx0XHRmb3IgKCB2YXIgbW4gaW4gbWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdFx0Ly8gQ29udmVydCBtYXRlcmlhbHMgaW5mbyBpbnRvIG5vcm1hbGl6ZWQgZm9ybSBiYXNlZCBvbiBvcHRpb25zXG5cblx0XHRcdHZhciBtYXQgPSBtYXRlcmlhbHNJbmZvWyBtbiBdO1xuXG5cdFx0XHR2YXIgY292bWF0ID0ge307XG5cblx0XHRcdGNvbnZlcnRlZFsgbW4gXSA9IGNvdm1hdDtcblxuXHRcdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xuXG5cdFx0XHRcdHZhciBzYXZlID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0WyBwcm9wIF07XG5cdFx0XHRcdHZhciBscHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBscHJvcCApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2tkJzpcblx0XHRcdFx0XHRjYXNlICdrYSc6XG5cdFx0XHRcdFx0Y2FzZSAna3MnOlxuXG5cdFx0XHRcdFx0XHQvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubm9ybWFsaXplUkdCICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gWyB2YWx1ZVsgMCBdIC8gMjU1LCB2YWx1ZVsgMSBdIC8gMjU1LCB2YWx1ZVsgMiBdIC8gMjU1IF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmlnbm9yZVplcm9SR0JzICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWVbIDAgXSA9PT0gMCAmJiB2YWx1ZVsgMSBdID09PSAwICYmIHZhbHVlWyAyIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBpZ25vcmVcblxuXHRcdFx0XHRcdFx0XHRcdHNhdmUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2F2ZSApIHtcblxuXHRcdFx0XHRcdGNvdm1hdFsgbHByb3AgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcblxuXHR9LFxuXG5cdHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRcdHRoaXMuY3JlYXRlKCBtbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uICggbWF0ZXJpYWxOYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubmFtZUxvb2t1cFsgbWF0ZXJpYWxOYW1lIF07XG5cblx0fSxcblxuXHRnZXRBc0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0Zm9yICggdmFyIG1uIGluIHRoaXMubWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbHNBcnJheVsgaW5kZXggXSA9IHRoaXMuY3JlYXRlKCBtbiApO1xuXHRcdFx0dGhpcy5uYW1lTG9va3VwWyBtbiBdID0gaW5kZXg7XG5cdFx0XHRpbmRleCArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc0FycmF5O1xuXG5cdH0sXG5cblx0Y3JlYXRlOiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcblxuXHRcdGlmICggdGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuY3JlYXRlTWF0ZXJpYWxfKCBtYXRlcmlhbE5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF07XG5cblx0fSxcblxuXHRjcmVhdGVNYXRlcmlhbF86IGZ1bmN0aW9uICggbWF0ZXJpYWxOYW1lICkge1xuXG5cdFx0Ly8gQ3JlYXRlIG1hdGVyaWFsXG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdHZhciBtYXQgPSB0aGlzLm1hdGVyaWFsc0luZm9bIG1hdGVyaWFsTmFtZSBdO1xuXHRcdHZhciBwYXJhbXMgPSB7XG5cblx0XHRcdG5hbWU6IG1hdGVyaWFsTmFtZSxcblx0XHRcdHNpZGU6IHRoaXMuc2lkZVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVVUkwoIGJhc2VVcmwsIHVybCApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB1cmwgPT09ICcnIClcblx0XHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0XHQvLyBBYnNvbHV0ZSBVUkxcblx0XHRcdGlmICggL15odHRwcz86XFwvXFwvL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0XHRyZXR1cm4gYmFzZVVybCArIHVybDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldE1hcEZvclR5cGUoIG1hcFR5cGUsIHZhbHVlICkge1xuXG5cdFx0XHRpZiAoIHBhcmFtc1sgbWFwVHlwZSBdICkgcmV0dXJuOyAvLyBLZWVwIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB0ZXh0dXJlXG5cblx0XHRcdHZhciB0ZXhQYXJhbXMgPSBzY29wZS5nZXRUZXh0dXJlUGFyYW1zKCB2YWx1ZSwgcGFyYW1zICk7XG5cdFx0XHR2YXIgbWFwID0gc2NvcGUubG9hZFRleHR1cmUoIHJlc29sdmVVUkwoIHNjb3BlLmJhc2VVcmwsIHRleFBhcmFtcy51cmwgKSApO1xuXG5cdFx0XHRtYXAucmVwZWF0LmNvcHkoIHRleFBhcmFtcy5zY2FsZSApO1xuXHRcdFx0bWFwLm9mZnNldC5jb3B5KCB0ZXhQYXJhbXMub2Zmc2V0ICk7XG5cblx0XHRcdG1hcC53cmFwUyA9IHNjb3BlLndyYXA7XG5cdFx0XHRtYXAud3JhcFQgPSBzY29wZS53cmFwO1xuXG5cdFx0XHRwYXJhbXNbIG1hcFR5cGUgXSA9IG1hcDtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBwcm9wIGluIG1hdCApIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gbWF0WyBwcm9wIF07XG5cdFx0XHR2YXIgbjtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gJycgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggcHJvcC50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0XHRcdC8vIE5zIGlzIG1hdGVyaWFsIHNwZWN1bGFyIGV4cG9uZW50XG5cblx0XHRcdFx0Y2FzZSAna2QnOlxuXG5cdFx0XHRcdFx0Ly8gRGlmZnVzZSBjb2xvciAoY29sb3IgdW5kZXIgd2hpdGUgbGlnaHQpIHVzaW5nIFJHQiB2YWx1ZXNcblxuXHRcdFx0XHRcdHBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2tzJzpcblxuXHRcdFx0XHRcdC8vIFNwZWN1bGFyIGNvbG9yIChjb2xvciB3aGVuIGxpZ2h0IGlzIHJlZmxlY3RlZCBmcm9tIHNoaW55IHN1cmZhY2UpIHVzaW5nIFJHQiB2YWx1ZXNcblx0XHRcdFx0XHRwYXJhbXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdrZSc6XG5cblx0XHRcdFx0XHQvLyBFbWlzc2l2ZSB1c2luZyBSR0IgdmFsdWVzXG5cdFx0XHRcdFx0cGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwX2tkJzpcblxuXHRcdFx0XHRcdC8vIERpZmZ1c2UgdGV4dHVyZSBtYXBcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdtYXAnLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwX2tzJzpcblxuXHRcdFx0XHRcdC8vIFNwZWN1bGFyIG1hcFxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ3NwZWN1bGFyTWFwJywgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9rZSc6XG5cblx0XHRcdFx0XHQvLyBFbWlzc2l2ZSBtYXBcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdlbWlzc2l2ZU1hcCcsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdub3JtJzpcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdub3JtYWxNYXAnLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwX2J1bXAnOlxuXHRcdFx0XHRjYXNlICdidW1wJzpcblxuXHRcdFx0XHRcdC8vIEJ1bXAgdGV4dHVyZSBtYXBcblxuXHRcdFx0XHRcdHNldE1hcEZvclR5cGUoICdidW1wTWFwJywgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9kJzpcblxuXHRcdFx0XHRcdC8vIEFscGhhIG1hcFxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ2FscGhhTWFwJywgdmFsdWUgKTtcblx0XHRcdFx0XHRwYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbnMnOlxuXG5cdFx0XHRcdFx0Ly8gVGhlIHNwZWN1bGFyIGV4cG9uZW50IChkZWZpbmVzIHRoZSBmb2N1cyBvZiB0aGUgc3BlY3VsYXIgaGlnaGxpZ2h0KVxuXHRcdFx0XHRcdC8vIEEgaGlnaCBleHBvbmVudCByZXN1bHRzIGluIGEgdGlnaHQsIGNvbmNlbnRyYXRlZCBoaWdobGlnaHQuIE5zIHZhbHVlcyBub3JtYWxseSByYW5nZSBmcm9tIDAgdG8gMTAwMC5cblxuXHRcdFx0XHRcdHBhcmFtcy5zaGluaW5lc3MgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0biA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRpZiAoIG4gPCAxICkge1xuXG5cdFx0XHRcdFx0XHRwYXJhbXMub3BhY2l0eSA9IG47XG5cdFx0XHRcdFx0XHRwYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndHInOlxuXHRcdFx0XHRcdG4gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmludmVydFRyUHJvcGVydHkgKSBuID0gMSAtIG47XG5cblx0XHRcdFx0XHRpZiAoIG4gPiAwICkge1xuXG5cdFx0XHRcdFx0XHRwYXJhbXMub3BhY2l0eSA9IDEgLSBuO1xuXHRcdFx0XHRcdFx0cGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF0gPSBuZXcgTWVzaFBob25nTWF0ZXJpYWwoIHBhcmFtcyApO1xuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF07XG5cblx0fSxcblxuXHRnZXRUZXh0dXJlUGFyYW1zOiBmdW5jdGlvbiAoIHZhbHVlLCBtYXRQYXJhbXMgKSB7XG5cblx0XHR2YXIgdGV4UGFyYW1zID0ge1xuXG5cdFx0XHRzY2FsZTogbmV3IFZlY3RvcjIoIDEsIDEgKSxcblx0XHRcdG9mZnNldDogbmV3IFZlY3RvcjIoIDAsIDAgKVxuXG5cdFx0IH07XG5cblx0XHR2YXIgaXRlbXMgPSB2YWx1ZS5zcGxpdCggL1xccysvICk7XG5cdFx0dmFyIHBvcztcblxuXHRcdHBvcyA9IGl0ZW1zLmluZGV4T2YoICctYm0nICk7XG5cblx0XHRpZiAoIHBvcyA+PSAwICkge1xuXG5cdFx0XHRtYXRQYXJhbXMuYnVtcFNjYWxlID0gcGFyc2VGbG9hdCggaXRlbXNbIHBvcyArIDEgXSApO1xuXHRcdFx0aXRlbXMuc3BsaWNlKCBwb3MsIDIgKTtcblxuXHRcdH1cblxuXHRcdHBvcyA9IGl0ZW1zLmluZGV4T2YoICctcycgKTtcblxuXHRcdGlmICggcG9zID49IDAgKSB7XG5cblx0XHRcdHRleFBhcmFtcy5zY2FsZS5zZXQoIHBhcnNlRmxvYXQoIGl0ZW1zWyBwb3MgKyAxIF0gKSwgcGFyc2VGbG9hdCggaXRlbXNbIHBvcyArIDIgXSApICk7XG5cdFx0XHRpdGVtcy5zcGxpY2UoIHBvcywgNCApOyAvLyB3ZSBleHBlY3QgMyBwYXJhbWV0ZXJzIGhlcmUhXG5cblx0XHR9XG5cblx0XHRwb3MgPSBpdGVtcy5pbmRleE9mKCAnLW8nICk7XG5cblx0XHRpZiAoIHBvcyA+PSAwICkge1xuXG5cdFx0XHR0ZXhQYXJhbXMub2Zmc2V0LnNldCggcGFyc2VGbG9hdCggaXRlbXNbIHBvcyArIDEgXSApLCBwYXJzZUZsb2F0KCBpdGVtc1sgcG9zICsgMiBdICkgKTtcblx0XHRcdGl0ZW1zLnNwbGljZSggcG9zLCA0ICk7IC8vIHdlIGV4cGVjdCAzIHBhcmFtZXRlcnMgaGVyZSFcblxuXHRcdH1cblxuXHRcdHRleFBhcmFtcy51cmwgPSBpdGVtcy5qb2luKCAnICcgKS50cmltKCk7XG5cdFx0cmV0dXJuIHRleFBhcmFtcztcblxuXHR9LFxuXG5cdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHRleHR1cmU7XG5cdFx0dmFyIG1hbmFnZXIgPSAoIHRoaXMubWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyB0aGlzLm1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdFx0dmFyIGxvYWRlciA9IG1hbmFnZXIuZ2V0SGFuZGxlciggdXJsICk7XG5cblx0XHRpZiAoIGxvYWRlciA9PT0gbnVsbCApIHtcblxuXHRcdFx0bG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbG9hZGVyLnNldENyb3NzT3JpZ2luICkgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0aWYgKCBtYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59O1xuXG4vKiEgY2hldnJvdGFpbiAtIHY0LjYuMCAqL1xuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJjaGV2cm90YWluXCIsW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5jaGV2cm90YWluPWUoKTp0LmNoZXZyb3RhaW49ZSgpO30oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp1bmRlZmluZWQsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9e307ZnVuY3Rpb24gbihyKXtpZihlW3JdKXJldHVybiBlW3JdLmV4cG9ydHM7dmFyIGk9ZVtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsbiksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gbi5tPXQsbi5jPWUsbi5kPWZ1bmN0aW9uKHQsZSxyKXtuLm8odCxlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxnZXQ6cn0pO30sbi5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7fSxuLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PW4odCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBpIGluIHQpbi5kKHIsaSxmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLGkpKTtyZXR1cm4gcn0sbi5uPWZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiBuLmQoZSxcImFcIixlKSxlfSxuLm89ZnVuY3Rpb24odCxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9LG4ucD1cIlwiLG4obi5zPTE4KX0oW2Z1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3JldHVybiB0JiYwPT09dC5sZW5ndGh9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gbnVsbD09dD9bXTpPYmplY3Qua2V5cyh0KX1mdW5jdGlvbiBvKHQpe2Zvcih2YXIgZT1bXSxuPU9iamVjdC5rZXlzKHQpLHI9MDtyPG4ubGVuZ3RoO3IrKyllLnB1c2godFtuW3JdXSk7cmV0dXJuIGV9ZnVuY3Rpb24gYSh0LGUpe2Zvcih2YXIgbj1bXSxyPWkodCksbz0wO288ci5sZW5ndGg7bysrKXt2YXIgYT1yW29dO24ucHVzaChlLmNhbGwobnVsbCx0W2FdLGEpKTt9cmV0dXJuIG59ZnVuY3Rpb24gcyh0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjx0Lmxlbmd0aDtyKyspbi5wdXNoKGUuY2FsbChudWxsLHRbcl0scikpO3JldHVybiBufWZ1bmN0aW9uIHUodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtBcnJheS5pc0FycmF5KHIpP2U9ZS5jb25jYXQodShyKSk6ZS5wdXNoKHIpO31yZXR1cm4gZX1mdW5jdGlvbiBjKHQpe3JldHVybiByKHQpP3ZvaWQgMDp0WzBdfWZ1bmN0aW9uIHAodCl7dmFyIGU9dCYmdC5sZW5ndGg7cmV0dXJuIGU/dFtlLTFdOnZvaWQgMH1mdW5jdGlvbiBsKHQsZSl7aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyllLmNhbGwobnVsbCx0W25dLG4pO2Vsc2Uge2lmKCFDKHQpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7dmFyIHI9aSh0KTtmb3Iobj0wO248ci5sZW5ndGg7bisrKXt2YXIgbz1yW25dLGE9dFtvXTtlLmNhbGwobnVsbCxhLG8pO319fWZ1bmN0aW9uIGgodCl7cmV0dXJuIFwic3RyaW5nXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGYodCl7cmV0dXJuIHZvaWQgMD09PXR9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZ1bmN0aW9ufWZ1bmN0aW9uIEUodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MSksdC5zbGljZShlLHQubGVuZ3RoKX1mdW5jdGlvbiBtKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTEpLHQuc2xpY2UoMCx0Lmxlbmd0aC1lKX1mdW5jdGlvbiB5KHQsZSl7dmFyIG49W107aWYoQXJyYXkuaXNBcnJheSh0KSlmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGk9dFtyXTtlLmNhbGwobnVsbCxpKSYmbi5wdXNoKGkpO31yZXR1cm4gbn1mdW5jdGlvbiBUKHQsZSl7cmV0dXJuIHkodCxmdW5jdGlvbih0KXtyZXR1cm4gIWUodCl9KX1mdW5jdGlvbiB2KHQsZSl7Zm9yKHZhciBuPU9iamVjdC5rZXlzKHQpLHI9e30saT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgbz1uW2ldLGE9dFtvXTtlKGEpJiYocltvXT1hKTt9cmV0dXJuIHJ9ZnVuY3Rpb24gZyh0LGUpe3JldHVybiAhIUModCkmJnQuaGFzT3duUHJvcGVydHkoZSl9ZnVuY3Rpb24gXyh0LGUpe3JldHVybiB2b2lkIDAhPT1OKHQsZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1lfSl9ZnVuY3Rpb24gUih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bisrKWUucHVzaCh0W25dKTtyZXR1cm4gZX1mdW5jdGlvbiBBKHQpe3ZhciBlPXt9O2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKTtyZXR1cm4gZX1mdW5jdGlvbiBOKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07aWYoZS5jYWxsKG51bGwscikpcmV0dXJuIHJ9fWZ1bmN0aW9uIE8odCxlKXtmb3IodmFyIG49W10scj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgaT10W3JdO2UuY2FsbChudWxsLGkpJiZuLnB1c2goaSk7fXJldHVybiBufWZ1bmN0aW9uIFModCxlLG4pe2Zvcih2YXIgcj1BcnJheS5pc0FycmF5KHQpLGE9cj90Om8odCkscz1yP1tdOmkodCksdT1uLGM9MDtjPGEubGVuZ3RoO2MrKyl1PWUuY2FsbChudWxsLHUsYVtjXSxyP2M6c1tjXSk7cmV0dXJuIHV9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gVCh0LGZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fSl9ZnVuY3Rpb24gTCh0LGUpe3ZvaWQgMD09PWUmJihlPWZ1bmN0aW9uKHQpe3JldHVybiB0fSk7dmFyIG49W107cmV0dXJuIFModCxmdW5jdGlvbih0LHIpe3ZhciBpPWUocik7cmV0dXJuIF8obixpKT90OihuLnB1c2goaSksdC5jb25jYXQocikpfSxbXSl9ZnVuY3Rpb24gayh0KXtmb3IodmFyIGU9W10sbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspZVtuLTFdPWFyZ3VtZW50c1tuXTt2YXIgcj1bbnVsbF0uY29uY2F0KGUpO3JldHVybiBGdW5jdGlvbi5iaW5kLmFwcGx5KHQscil9ZnVuY3Rpb24gUCh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KX1mdW5jdGlvbiB4KHQpe3JldHVybiB0IGluc3RhbmNlb2YgUmVnRXhwfWZ1bmN0aW9uIEModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBPYmplY3R9ZnVuY3Rpb24gTSh0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCFlKHRbbl0sbikpcmV0dXJuICExO3JldHVybiAhMH1mdW5jdGlvbiBGKHQsZSl7cmV0dXJuIFQodCxmdW5jdGlvbih0KXtyZXR1cm4gXyhlLHQpfSl9ZnVuY3Rpb24gYih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKGUodFtuXSkpcmV0dXJuICEwO3JldHVybiAhMX1mdW5jdGlvbiBEKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYodFtuXT09PWUpcmV0dXJuIG47cmV0dXJuIC0xfWZ1bmN0aW9uIHcodCxlKXt2YXIgbj1SKHQpO3JldHVybiBuLnNvcnQoZnVuY3Rpb24odCxuKXtyZXR1cm4gZSh0KS1lKG4pfSksbn1mdW5jdGlvbiBVKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBFcnJvcihcImNhbid0IHppcE9iamVjdCB3aXRoIGRpZmZlcmVudCBudW1iZXIgb2Yga2V5cyBhbmQgdmFsdWVzIVwiKTtmb3IodmFyIG49e30scj0wO3I8dC5sZW5ndGg7cisrKW5bdFtyXV09ZVtyXTtyZXR1cm4gbn1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKWZvcih2YXIgbz1lW3JdLGE9aShvKSxzPTA7czxhLmxlbmd0aDtzKyspe3ZhciB1PWFbc107dFt1XT1vW3VdO31yZXR1cm4gdH1mdW5jdGlvbiBCKHQpe2Zvcih2YXIgZT1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbz1lW3JdO2lmKCFmKG8pKWZvcih2YXIgYT1pKG8pLHM9MDtzPGEubGVuZ3RoO3MrKyl7dmFyIHU9YVtzXTtnKHQsdSl8fCh0W3VdPW9bdV0pO319cmV0dXJuIHR9ZnVuY3Rpb24gSygpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gQi5hcHBseShudWxsLFt7fV0uY29uY2F0KHQpKX1mdW5jdGlvbiBXKHQsZSl7dmFyIG49e307cmV0dXJuIGwodCxmdW5jdGlvbih0KXt2YXIgcj1lKHQpLGk9bltyXTtpP2kucHVzaCh0KTpuW3JdPVt0XTt9KSxufWZ1bmN0aW9uIGoodCxlKXtmb3IodmFyIG49QSh0KSxyPWkoZSksbz0wO288ci5sZW5ndGg7bysrKXt2YXIgYT1yW29dLHM9ZVthXTtuW2FdPXM7fXJldHVybiBufWZ1bmN0aW9uIFYoKXt9ZnVuY3Rpb24gWSh0KXtyZXR1cm4gdH1mdW5jdGlvbiBIKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ZS5wdXNoKHZvaWQgMCE9PXI/cjp2b2lkIDApO31yZXR1cm4gZX1mdW5jdGlvbiBYKHQpe2NvbnNvbGUmJmNvbnNvbGUuZXJyb3ImJmNvbnNvbGUuZXJyb3IoXCJFcnJvcjogXCIrdCk7fWZ1bmN0aW9uIHoodCl7Y29uc29sZSYmY29uc29sZS53YXJuJiZjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBcIit0KTt9ZnVuY3Rpb24gcSgpe3JldHVybiBcImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXB9ZnVuY3Rpb24gJCh0LGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbj1lLnByb3RvdHlwZTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHIpe2lmKFwiY29uc3RydWN0b3JcIiE9PXIpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobixyKTtpJiYoaS5nZXR8fGkuc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUscixpKTp0LnByb3RvdHlwZVtyXT1lLnByb3RvdHlwZVtyXTt9fSk7fSk7fWZ1bmN0aW9uIFoodCl7ZnVuY3Rpb24gZSgpe31lLnByb3RvdHlwZT10O3ZhciBuPW5ldyBlO2Z1bmN0aW9uIHIoKXtyZXR1cm4gdHlwZW9mIG4uYmFyfXJldHVybiByKCkscigpLHR9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc0VtcHR5PXIsZS5rZXlzPWksZS52YWx1ZXM9byxlLm1hcFZhbHVlcz1hLGUubWFwPXMsZS5mbGF0dGVuPXUsZS5maXJzdD1jLGUubGFzdD1wLGUuZm9yRWFjaD1sLGUuaXNTdHJpbmc9aCxlLmlzVW5kZWZpbmVkPWYsZS5pc0Z1bmN0aW9uPWQsZS5kcm9wPUUsZS5kcm9wUmlnaHQ9bSxlLmZpbHRlcj15LGUucmVqZWN0PVQsZS5waWNrPXYsZS5oYXM9ZyxlLmNvbnRhaW5zPV8sZS5jbG9uZUFycj1SLGUuY2xvbmVPYmo9QSxlLmZpbmQ9TixlLmZpbmRBbGw9TyxlLnJlZHVjZT1TLGUuY29tcGFjdD1JLGUudW5pcT1MLGUucGFydGlhbD1rLGUuaXNBcnJheT1QLGUuaXNSZWdFeHA9eCxlLmlzT2JqZWN0PUMsZS5ldmVyeT1NLGUuZGlmZmVyZW5jZT1GLGUuc29tZT1iLGUuaW5kZXhPZj1ELGUuc29ydEJ5PXcsZS56aXBPYmplY3Q9VSxlLmFzc2lnbj1HLGUuYXNzaWduTm9PdmVyd3JpdGU9QixlLmRlZmF1bHRzPUssZS5ncm91cEJ5PVcsZS5tZXJnZT1qLGUuTk9PUD1WLGUuSURFTlRJVFk9WSxlLnBhY2tBcnJheT1ILGUuUFJJTlRfRVJST1I9WCxlLlBSSU5UX1dBUk5JTkc9eixlLmlzRVMyMDE1TWFwU3VwcG9ydGVkPXEsZS5hcHBseU1peGlucz0kLGUudG9GYXN0UHJvcGVydGllcz1aO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigwKSxhPW4oMikscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kZWZpbml0aW9uPXQ7fXJldHVybiB0LnByb3RvdHlwZS5hY2NlcHQ9ZnVuY3Rpb24odCl7dC52aXNpdCh0aGlzKSxvLmZvckVhY2godGhpcy5kZWZpbml0aW9uLGZ1bmN0aW9uKGUpe2UuYWNjZXB0KHQpO30pO30sdH0oKTtlLkFic3RyYWN0UHJvZHVjdGlvbj1zO3ZhciB1PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsW10pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImRlZmluaXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMucmVmZXJlbmNlZFJ1bGU/dGhpcy5yZWZlcmVuY2VkUnVsZS5kZWZpbml0aW9uOltdfSxzZXQ6ZnVuY3Rpb24odCl7fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmFjY2VwdD1mdW5jdGlvbih0KXt0LnZpc2l0KHRoaXMpO30sZX0ocyk7ZS5Ob25UZXJtaW5hbD11O3ZhciBjPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5vcmdUZXh0PVwiXCIsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5SdWxlPWM7dmFyIHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLkZsYXQ9cDt2YXIgbD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5PcHRpb249bDt2YXIgaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5SZXBldGl0aW9uTWFuZGF0b3J5PWg7dmFyIGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9Zjt2YXIgZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5SZXBldGl0aW9uPWQ7dmFyIEU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLmlkeD0xLG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9RTt2YXIgbT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5BbHRlcm5hdGlvbj1tO3ZhciB5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmlkeD0xLG8uYXNzaWduKHRoaXMsby5waWNrKHQsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSk7fXJldHVybiB0LnByb3RvdHlwZS5hY2NlcHQ9ZnVuY3Rpb24odCl7dC52aXNpdCh0aGlzKTt9LHR9KCk7ZnVuY3Rpb24gVCh0KXtmdW5jdGlvbiBlKHQpe3JldHVybiBvLm1hcCh0LFQpfWlmKHQgaW5zdGFuY2VvZiB1KXJldHVybiB7dHlwZTpcIk5vblRlcm1pbmFsXCIsbmFtZTp0Lm5vblRlcm1pbmFsTmFtZSxpZHg6dC5pZHh9O2lmKHQgaW5zdGFuY2VvZiBwKXJldHVybiB7dHlwZTpcIkZsYXRcIixkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIGwpcmV0dXJuIHt0eXBlOlwiT3B0aW9uXCIsaWR4OnQuaWR4LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgaClyZXR1cm4ge3R5cGU6XCJSZXBldGl0aW9uTWFuZGF0b3J5XCIsbmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgZilyZXR1cm4ge3R5cGU6XCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiLG5hbWU6dC5uYW1lLGlkeDp0LmlkeCxzZXBhcmF0b3I6VChuZXcgeSh7dGVybWluYWxUeXBlOnQuc2VwYXJhdG9yfSkpLGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgRSlyZXR1cm4ge3R5cGU6XCJSZXBldGl0aW9uV2l0aFNlcGFyYXRvclwiLG5hbWU6dC5uYW1lLGlkeDp0LmlkeCxzZXBhcmF0b3I6VChuZXcgeSh7dGVybWluYWxUeXBlOnQuc2VwYXJhdG9yfSkpLGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgZClyZXR1cm4ge3R5cGU6XCJSZXBldGl0aW9uXCIsbmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgbSlyZXR1cm4ge3R5cGU6XCJBbHRlcm5hdGlvblwiLG5hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07aWYodCBpbnN0YW5jZW9mIHkpe3ZhciBuPXt0eXBlOlwiVGVybWluYWxcIixuYW1lOmEudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKSxsYWJlbDphLnRva2VuTGFiZWwodC50ZXJtaW5hbFR5cGUpLGlkeDp0LmlkeH0scj10LnRlcm1pbmFsVHlwZS5QQVRURVJOO3JldHVybiB0LnRlcm1pbmFsVHlwZS5QQVRURVJOJiYobi5wYXR0ZXJuPW8uaXNSZWdFeHAocik/ci5zb3VyY2U6ciksbn1pZih0IGluc3RhbmNlb2YgYylyZXR1cm4ge3R5cGU6XCJSdWxlXCIsbmFtZTp0Lm5hbWUsb3JnVGV4dDp0Lm9yZ1RleHQsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZS5UZXJtaW5hbD15LGUuc2VyaWFsaXplR3JhbW1hcj1mdW5jdGlvbih0KXtyZXR1cm4gby5tYXAodCxUKX0sZS5zZXJpYWxpemVQcm9kdWN0aW9uPVQ7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oNCksbz1uKDE1KSxhPW4oNyk7ZnVuY3Rpb24gcyh0KXtyZXR1cm4gci5pc1N0cmluZyh0LkxBQkVMKSYmXCJcIiE9PXQuTEFCRUx9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gci5pc09iamVjdCh0KSYmdC5oYXNPd25Qcm9wZXJ0eShcInRva2VuTmFtZVwiKSYmci5pc1N0cmluZyh0LnRva2VuTmFtZSk/dC50b2tlbk5hbWU6aS5mdW5jdGlvbk5hbWUodCl9ZS50b2tlbkxhYmVsPWZ1bmN0aW9uKHQpe3JldHVybiBzKHQpP3QuTEFCRUw6dSh0KX0sZS5oYXNUb2tlbkxhYmVsPXMsZS50b2tlbk5hbWU9dTt2YXIgYz1cInBhcmVudFwiLHA9XCJjYXRlZ29yaWVzXCIsbD1cImxhYmVsXCIsaD1cImdyb3VwXCIsZj1cInB1c2hfbW9kZVwiLGQ9XCJwb3BfbW9kZVwiLEU9XCJsb25nZXJfYWx0XCIsbT1cImxpbmVfYnJlYWtzXCIseT1cInN0YXJ0X2NoYXJzX2hpbnRcIjtmdW5jdGlvbiBUKHQpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj10LnBhdHRlcm4sbz17fTtpLmRlZmluZU5hbWVQcm9wKG8sZSl8fChvLnRva2VuTmFtZT1lKTtyLmlzVW5kZWZpbmVkKG4pfHwoby5QQVRURVJOPW4pO2lmKHIuaGFzKHQsYykpdGhyb3cgXCJUaGUgcGFyZW50IHByb3BlcnR5IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXFxuU2VlOiBodHRwczovL2dpdGh1Yi5jb20vU0FQL2NoZXZyb3RhaW4vaXNzdWVzLzU2NCNpc3N1ZWNvbW1lbnQtMzQ5MDYyMzQ2IGZvciBkZXRhaWxzLlwiO3IuaGFzKHQscCkmJihvLkNBVEVHT1JJRVM9dFtwXSk7YS5hdWdtZW50VG9rZW5UeXBlcyhbb10pLHIuaGFzKHQsbCkmJihvLkxBQkVMPXRbbF0pO3IuaGFzKHQsaCkmJihvLkdST1VQPXRbaF0pO3IuaGFzKHQsZCkmJihvLlBPUF9NT0RFPXRbZF0pO3IuaGFzKHQsZikmJihvLlBVU0hfTU9ERT10W2ZdKTtyLmhhcyh0LEUpJiYoby5MT05HRVJfQUxUPXRbRV0pO3IuaGFzKHQsbSkmJihvLkxJTkVfQlJFQUtTPXRbbV0pO3IuaGFzKHQseSkmJihvLlNUQVJUX0NIQVJTX0hJTlQ9dFt5XSk7cmV0dXJuIG99KHQpfWUuY3JlYXRlVG9rZW49VCxlLkVPRj1UKHtuYW1lOlwiRU9GXCIscGF0dGVybjpvLkxleGVyLk5BfSksYS5hdWdtZW50VG9rZW5UeXBlcyhbZS5FT0ZdKSxlLmNyZWF0ZVRva2VuSW5zdGFuY2U9ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzKXtyZXR1cm4ge2ltYWdlOmUsc3RhcnRPZmZzZXQ6bixlbmRPZmZzZXQ6cixzdGFydExpbmU6aSxlbmRMaW5lOm8sc3RhcnRDb2x1bW46YSxlbmRDb2x1bW46cyx0b2tlblR5cGVJZHg6dC50b2tlblR5cGVJZHgsdG9rZW5UeXBlOnR9fSxlLnRva2VuTWF0Y2hlcj1mdW5jdGlvbih0LGUpe3JldHVybiBhLnRva2VuU3RydWN0dXJlZE1hdGNoZXIodCxlKX07fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDQpLGE9bigwKSxzPW4oMjYpLHU9bigyKSxjPW4oMjMpLHA9bigxNiksbD1uKDEwKSxoPW4oMjQpLGY9bigyNSksZD1uKDMxKSxFPW4oMzIpLG09bigzNCkseT1uKDM1KSxUPW4oMzYpLHY9bigzNyksZz1uKDM4KTtlLkVORF9PRl9GSUxFPXUuY3JlYXRlVG9rZW5JbnN0YW5jZSh1LkVPRixcIlwiLE5hTixOYU4sTmFOLE5hTixOYU4sTmFOKSxPYmplY3QuZnJlZXplKGUuRU5EX09GX0ZJTEUpLGUuREVGQVVMVF9QQVJTRVJfQ09ORklHPU9iamVjdC5mcmVlemUoe3JlY292ZXJ5RW5hYmxlZDohMSxtYXhMb29rYWhlYWQ6NCxpZ25vcmVkSXNzdWVzOnt9LGR5bmFtaWNUb2tlbnNFbmFibGVkOiExLG91dHB1dENzdDohMCxlcnJvck1lc3NhZ2VQcm92aWRlcjpsLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLHNlcmlhbGl6ZWRHcmFtbWFyOm51bGx9KSxlLkRFRkFVTFRfUlVMRV9DT05GSUc9T2JqZWN0LmZyZWV6ZSh7cmVjb3ZlcnlWYWx1ZUZ1bmM6ZnVuY3Rpb24oKXt9LHJlc3luY0VuYWJsZWQ6ITB9KSxmdW5jdGlvbih0KXt0W3QuSU5WQUxJRF9SVUxFX05BTUU9MF09XCJJTlZBTElEX1JVTEVfTkFNRVwiLHRbdC5EVVBMSUNBVEVfUlVMRV9OQU1FPTFdPVwiRFVQTElDQVRFX1JVTEVfTkFNRVwiLHRbdC5JTlZBTElEX1JVTEVfT1ZFUlJJREU9Ml09XCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIix0W3QuRFVQTElDQVRFX1BST0RVQ1RJT05TPTNdPVwiRFVQTElDQVRFX1BST0RVQ1RJT05TXCIsdFt0LlVOUkVTT0xWRURfU1VCUlVMRV9SRUY9NF09XCJVTlJFU09MVkVEX1NVQlJVTEVfUkVGXCIsdFt0LkxFRlRfUkVDVVJTSU9OPTVdPVwiTEVGVF9SRUNVUlNJT05cIix0W3QuTk9ORV9MQVNUX0VNUFRZX0FMVD02XT1cIk5PTkVfTEFTVF9FTVBUWV9BTFRcIix0W3QuQU1CSUdVT1VTX0FMVFM9N109XCJBTUJJR1VPVVNfQUxUU1wiLHRbdC5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFPThdPVwiQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRVwiLHRbdC5JTlZBTElEX1RPS0VOX05BTUU9OV09XCJJTlZBTElEX1RPS0VOX05BTUVcIix0W3QuSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FPTEwXT1cIklOVkFMSURfTkVTVEVEX1JVTEVfTkFNRVwiLHRbdC5EVVBMSUNBVEVfTkVTVEVEX05BTUU9MTFdPVwiRFVQTElDQVRFX05FU1RFRF9OQU1FXCIsdFt0Lk5PX05PTl9FTVBUWV9MT09LQUhFQUQ9MTJdPVwiTk9fTk9OX0VNUFRZX0xPT0tBSEVBRFwiLHRbdC5BTUJJR1VPVVNfUFJFRklYX0FMVFM9MTNdPVwiQU1CSUdVT1VTX1BSRUZJWF9BTFRTXCIsdFt0LlRPT19NQU5ZX0FMVFM9MTRdPVwiVE9PX01BTllfQUxUU1wiO30oZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlfHwoZS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlPXt9KSksZS5FTVBUWV9BTFQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PXZvaWQgMCksZnVuY3Rpb24oKXtyZXR1cm4gdH19O3ZhciBfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4pe3ZvaWQgMD09PW4mJihuPWUuREVGQVVMVF9QQVJTRVJfQ09ORklHKSx0aGlzLmlnbm9yZWRJc3N1ZXM9ZS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuaWdub3JlZElzc3Vlcyx0aGlzLmRlZmluaXRpb25FcnJvcnM9W10sdGhpcy5zZWxmQW5hbHlzaXNEb25lPSExO3RoaXMuaW5pdEVycm9ySGFuZGxlcihuKSx0aGlzLmluaXRMZXhlckFkYXB0ZXIoKSx0aGlzLmluaXRMb29rc0FoZWFkKG4pLHRoaXMuaW5pdFJlY29nbml6ZXJFbmdpbmUodCxuKSx0aGlzLmluaXRSZWNvdmVyYWJsZShuKSx0aGlzLmluaXRUcmVlQnVpbGRlcihuKSx0aGlzLmluaXRDb250ZW50QXNzaXN0KCksdGhpcy5pZ25vcmVkSXNzdWVzPWEuaGFzKG4sXCJpZ25vcmVkSXNzdWVzXCIpP24uaWdub3JlZElzc3VlczplLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5pZ25vcmVkSXNzdWVzLGEudG9GYXN0UHJvcGVydGllcyh0aGlzKTt9cmV0dXJuIHQucGVyZm9ybVNlbGZBbmFseXNpcz1mdW5jdGlvbih0KXt0LnBlcmZvcm1TZWxmQW5hbHlzaXMoKTt9LHQucHJvdG90eXBlLnBlcmZvcm1TZWxmQW5hbHlzaXM9ZnVuY3Rpb24oKXt2YXIgZSxuPXRoaXM7dGhpcy5zZWxmQW5hbHlzaXNEb25lPSEwO3ZhciByPW8uY2xhc3NOYW1lRnJvbUluc3RhbmNlKHRoaXMpLGk9dGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZTtpZih0aGlzLnNlcmlhbGl6ZWRHcmFtbWFyKXt2YXIgdT1jLmRlc2VyaWFsaXplR3JhbW1hcih0aGlzLnNlcmlhbGl6ZWRHcmFtbWFyLHRoaXMudG9rZW5zTWFwKTthLmZvckVhY2godSxmdW5jdGlvbih0KXtuLmdhc3RQcm9kdWN0aW9uc0NhY2hlLnB1dCh0Lm5hbWUsdCk7fSk7fXZhciBmPWgucmVzb2x2ZUdyYW1tYXIoe3J1bGVzOmkudmFsdWVzKCl9KTtpZih0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseSh0aGlzLmRlZmluaXRpb25FcnJvcnMsZiksYS5pc0VtcHR5KGYpKXt2YXIgZD1oLnZhbGlkYXRlR3JhbW1hcih7cnVsZXM6aS52YWx1ZXMoKSxtYXhMb29rYWhlYWQ6dGhpcy5tYXhMb29rYWhlYWQsdG9rZW5UeXBlczphLnZhbHVlcyh0aGlzLnRva2Vuc01hcCksaWdub3JlZElzc3Vlczp0aGlzLmlnbm9yZWRJc3N1ZXMsZXJyTXNnUHJvdmlkZXI6bC5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsZ3JhbW1hck5hbWU6cn0pO3RoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoLmFwcGx5KHRoaXMuZGVmaW5pdGlvbkVycm9ycyxkKTt9aWYoYS5pc0VtcHR5KHRoaXMuZGVmaW5pdGlvbkVycm9ycykpe3ZhciBFPXMuY29tcHV0ZUFsbFByb2RzRm9sbG93cyhpLnZhbHVlcygpKTt0aGlzLnJlc3luY0ZvbGxvd3M9RTt9dmFyIG09cC5hbmFseXplQ3N0KGkudmFsdWVzKCksdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0KTtpZih0aGlzLmFsbFJ1bGVOYW1lcz1tLmFsbFJ1bGVOYW1lcywhdC5ERUZFUl9ERUZJTklUSU9OX0VSUk9SU19IQU5ETElORyYmIWEuaXNFbXB0eSh0aGlzLmRlZmluaXRpb25FcnJvcnMpKXRocm93IGU9YS5tYXAodGhpcy5kZWZpbml0aW9uRXJyb3JzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1lc3NhZ2V9KSxuZXcgRXJyb3IoXCJQYXJzZXIgRGVmaW5pdGlvbiBFcnJvcnMgZGV0ZWN0ZWQ6XFxuIFwiK2Uuam9pbihcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIikpfSx0LkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HPSExLHR9KCk7ZS5QYXJzZXI9XyxhLmFwcGx5TWl4aW5zKF8sW2YuUmVjb3ZlcmFibGUsZC5Mb29rc0FoZWFkLEUuVHJlZUJ1aWxkZXIsbS5MZXhlckFkYXB0ZXIsVC5SZWNvZ25pemVyRW5naW5lLHkuUmVjb2duaXplckFwaSx2LkVycm9ySGFuZGxlcixnLkNvbnRlbnRBc3Npc3RdKTt2YXIgUj1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4scil7dm9pZCAwPT09ciYmKHI9ZS5ERUZBVUxUX1BBUlNFUl9DT05GSUcpO3ZhciBpPWEuY2xvbmVPYmoocik7cmV0dXJuIGkub3V0cHV0Q3N0PSEwLHQuY2FsbCh0aGlzLG4saSl8fHRoaXN9cmV0dXJuIGkobix0KSxufShfKTtlLkNzdFBhcnNlcj1SO3ZhciBBPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4obixyKXt2b2lkIDA9PT1yJiYocj1lLkRFRkFVTFRfUEFSU0VSX0NPTkZJRyk7dmFyIGk9YS5jbG9uZU9iaihyKTtyZXR1cm4gaS5vdXRwdXRDc3Q9ITEsdC5jYWxsKHRoaXMsbixpKXx8dGhpc31yZXR1cm4gaShuLHQpLG59KF8pO2UuRW1iZWRkZWRBY3Rpb25zUGFyc2VyPUE7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKTtlLmNsYXNzTmFtZUZyb21JbnN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gYSh0LmNvbnN0cnVjdG9yKX07dmFyIGk9L15cXHMqZnVuY3Rpb25cXHMqKFxcUyopXFxzKlxcKC8sbz1cIm5hbWVcIjtmdW5jdGlvbiBhKHQpe3ZhciBlPXQubmFtZTtyZXR1cm4gZXx8dC50b1N0cmluZygpLm1hdGNoKGkpWzFdfWUuZnVuY3Rpb25OYW1lPWEsZS5kZWZpbmVOYW1lUHJvcD1mdW5jdGlvbih0LGUpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxvKTtyZXR1cm4gISghci5pc1VuZGVmaW5lZChuKSYmIW4uY29uZmlndXJhYmxlfHwoT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbyx7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITEsdmFsdWU6ZX0pLDApKX07dmFyIHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5fc3RhdGU9e307fXJldHVybiB0LnByb3RvdHlwZS5rZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHIua2V5cyh0aGlzLl9zdGF0ZSl9LHQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3JldHVybiByLnZhbHVlcyh0aGlzLl9zdGF0ZSl9LHQucHJvdG90eXBlLnB1dD1mdW5jdGlvbih0LGUpe3RoaXMuX3N0YXRlW3RdPWU7fSx0LnByb3RvdHlwZS5wdXRBbGw9ZnVuY3Rpb24odCl7dGhpcy5fc3RhdGU9ci5hc3NpZ24odGhpcy5fc3RhdGUsdC5fc3RhdGUpO30sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9zdGF0ZVt0XX0sdC5wcm90b3R5cGUuY29udGFpbnNLZXk9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaGFzKHRoaXMuX3N0YXRlLHQpfSx0LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX3N0YXRlPXt9O30sdH0oKTtlLkhhc2hUYWJsZT1zO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMSksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLnZpc2l0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiByLk5vblRlcm1pbmFsKXJldHVybiB0aGlzLnZpc2l0Tm9uVGVybWluYWwodCk7aWYodCBpbnN0YW5jZW9mIHIuRmxhdClyZXR1cm4gdGhpcy52aXNpdEZsYXQodCk7aWYodCBpbnN0YW5jZW9mIHIuT3B0aW9uKXJldHVybiB0aGlzLnZpc2l0T3B0aW9uKHQpO2lmKHQgaW5zdGFuY2VvZiByLlJlcGV0aXRpb25NYW5kYXRvcnkpcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KHQpO2lmKHQgaW5zdGFuY2VvZiByLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IodCk7aWYodCBpbnN0YW5jZW9mIHIuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcih0KTtpZih0IGluc3RhbmNlb2Ygci5SZXBldGl0aW9uKXJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbih0KTtpZih0IGluc3RhbmNlb2Ygci5BbHRlcm5hdGlvbilyZXR1cm4gdGhpcy52aXNpdEFsdGVybmF0aW9uKHQpO2lmKHQgaW5zdGFuY2VvZiByLlRlcm1pbmFsKXJldHVybiB0aGlzLnZpc2l0VGVybWluYWwodCk7aWYodCBpbnN0YW5jZW9mIHIuUnVsZSlyZXR1cm4gdGhpcy52aXNpdFJ1bGUodCk7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX0sdC5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0RmxhdD1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRUZXJtaW5hbD1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0UnVsZT1mdW5jdGlvbih0KXt9LHR9KCk7ZS5HQXN0VmlzaXRvcj1pO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1cIk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvblwiLG89XCJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiLGE9XCJFYXJseUV4aXRFeGNlcHRpb25cIixzPVwiTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb25cIix1PVtpLG8sYSxzXTtmdW5jdGlvbiBjKHQsZSxuKXt0aGlzLm5hbWU9aSx0aGlzLm1lc3NhZ2U9dCx0aGlzLnRva2VuPWUsdGhpcy5wcmV2aW91c1Rva2VuPW4sdGhpcy5yZXN5bmNlZFRva2Vucz1bXTt9ZnVuY3Rpb24gcCh0LGUsbil7dGhpcy5uYW1lPW8sdGhpcy5tZXNzYWdlPXQsdGhpcy50b2tlbj1lLHRoaXMucHJldmlvdXNUb2tlbj1uLHRoaXMucmVzeW5jZWRUb2tlbnM9W107fWZ1bmN0aW9uIGwodCxlKXt0aGlzLm5hbWU9cyx0aGlzLm1lc3NhZ2U9dCx0aGlzLnRva2VuPWUsdGhpcy5yZXN5bmNlZFRva2Vucz1bXTt9ZnVuY3Rpb24gaCh0LGUsbil7dGhpcy5uYW1lPWEsdGhpcy5tZXNzYWdlPXQsdGhpcy50b2tlbj1lLHRoaXMucHJldmlvdXNUb2tlbj1uLHRoaXMucmVzeW5jZWRUb2tlbnM9W107fU9iamVjdC5mcmVlemUodSksZS5pc1JlY29nbml0aW9uRXhjZXB0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiByLmNvbnRhaW5zKHUsdC5uYW1lKX0sZS5NaXNtYXRjaGVkVG9rZW5FeGNlcHRpb249YyxjLnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGUsZS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbj1wLHAucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZSxlLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uPWwsbC5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlLGUuRWFybHlFeGl0RXhjZXB0aW9uPWgsaC5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDQpLG89bigyKTtmdW5jdGlvbiBhKHQpe2Zvcih2YXIgZT1yLmNsb25lQXJyKHQpLG49dCxpPSEwO2k7KXtuPXIuY29tcGFjdChyLmZsYXR0ZW4oci5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4gdC5DQVRFR09SSUVTfSkpKTt2YXIgbz1yLmRpZmZlcmVuY2UobixlKTtlPWUuY29uY2F0KG8pLHIuaXNFbXB0eShvKT9pPSExOm49bzt9cmV0dXJuIGV9ZnVuY3Rpb24gcyh0KXtyLmZvckVhY2godCxmdW5jdGlvbih0KXtsKHQpfHwoZS50b2tlbklkeFRvQ2xhc3MucHV0KGUudG9rZW5TaG9ydE5hbWVJZHgsdCksdC50b2tlblR5cGVJZHg9ZS50b2tlblNob3J0TmFtZUlkeCsrKSxoKHQpJiYhci5pc0FycmF5KHQuQ0FURUdPUklFUykmJih0LkNBVEVHT1JJRVM9W3QuQ0FURUdPUklFU10pLGgodCl8fCh0LkNBVEVHT1JJRVM9W10pLGYodCl8fCh0LmNhdGVnb3J5TWF0Y2hlcz1bXSksZCh0KXx8KHQuY2F0ZWdvcnlNYXRjaGVzTWFwPXt9KSxFKHQpfHwodC50b2tlbk5hbWU9by50b2tlbk5hbWUodCkpO30pO31mdW5jdGlvbiB1KHQpe3IuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3QuY2F0ZWdvcnlNYXRjaGVzPVtdLHIuZm9yRWFjaCh0LmNhdGVnb3J5TWF0Y2hlc01hcCxmdW5jdGlvbihuLHIpe3QuY2F0ZWdvcnlNYXRjaGVzLnB1c2goZS50b2tlbklkeFRvQ2xhc3MuZ2V0KHIpLnRva2VuVHlwZUlkeCk7fSk7fSk7fWZ1bmN0aW9uIGModCl7ci5mb3JFYWNoKHQsZnVuY3Rpb24odCl7cChbXSx0KTt9KTt9ZnVuY3Rpb24gcCh0LGUpe3IuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe2UuY2F0ZWdvcnlNYXRjaGVzTWFwW3QudG9rZW5UeXBlSWR4XT0hMDt9KSxyLmZvckVhY2goZS5DQVRFR09SSUVTLGZ1bmN0aW9uKG4pe3ZhciBpPXQuY29uY2F0KGUpO3IuY29udGFpbnMoaSxuKXx8cChpLG4pO30pO31mdW5jdGlvbiBsKHQpe3JldHVybiByLmhhcyh0LFwidG9rZW5UeXBlSWR4XCIpfWZ1bmN0aW9uIGgodCl7cmV0dXJuIHIuaGFzKHQsXCJDQVRFR09SSUVTXCIpfWZ1bmN0aW9uIGYodCl7cmV0dXJuIHIuaGFzKHQsXCJjYXRlZ29yeU1hdGNoZXNcIil9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gci5oYXModCxcImNhdGVnb3J5TWF0Y2hlc01hcFwiKX1mdW5jdGlvbiBFKHQpe3JldHVybiByLmhhcyh0LFwidG9rZW5OYW1lXCIpfWUudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcj1mdW5jdGlvbih0LGUpe3ZhciBuPXQudG9rZW5UeXBlSWR4O3JldHVybiBuPT09ZS50b2tlblR5cGVJZHh8fCEwPT09ZS5pc1BhcmVudCYmITA9PT1lLmNhdGVnb3J5TWF0Y2hlc01hcFtuXX0sZS50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQudG9rZW5UeXBlSWR4PT09ZS50b2tlblR5cGVJZHh9LGUudG9rZW5TaG9ydE5hbWVJZHg9MSxlLnRva2VuSWR4VG9DbGFzcz1uZXcgaS5IYXNoVGFibGUsZS5hdWdtZW50VG9rZW5UeXBlcz1mdW5jdGlvbih0KXt2YXIgZT1hKHQpO3MoZSksYyhlKSx1KGUpLHIuZm9yRWFjaChlLGZ1bmN0aW9uKHQpe3QuaXNQYXJlbnQ9dC5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoPjA7fSk7fSxlLmV4cGFuZENhdGVnb3JpZXM9YSxlLmFzc2lnblRva2VuRGVmYXVsdFByb3BzPXMsZS5hc3NpZ25DYXRlZ29yaWVzVG9rZW5zUHJvcD11LGUuYXNzaWduQ2F0ZWdvcmllc01hcFByb3A9YyxlLnNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwPXAsZS5oYXNTaG9ydEtleVByb3BlcnR5PWwsZS5oYXNDYXRlZ29yaWVzUHJvcGVydHk9aCxlLmhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHk9ZixlLmhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHk9ZCxlLmhhc1Rva2VuTmFtZVByb3BlcnR5PUUsZS5pc1Rva2VuVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gci5oYXModCxcInRva2VuVHlwZUlkeFwiKX07fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDApLGE9bigxKSxzPW4oNSksdT1uKDIpO2UuaXNTZXF1ZW5jZVByb2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBhLkZsYXR8fHQgaW5zdGFuY2VvZiBhLk9wdGlvbnx8dCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbnx8dCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbk1hbmRhdG9yeXx8dCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3J8fHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yfHx0IGluc3RhbmNlb2YgYS5UZXJtaW5hbHx8dCBpbnN0YW5jZW9mIGEuUnVsZX0sZS5pc09wdGlvbmFsUHJvZD1mdW5jdGlvbiB0KGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPVtdKSwhIShlIGluc3RhbmNlb2YgYS5PcHRpb258fGUgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb258fGUgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXx8KGUgaW5zdGFuY2VvZiBhLkFsdGVybmF0aW9uP28uc29tZShlLmRlZmluaXRpb24sZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSxuKX0pOiEoZSBpbnN0YW5jZW9mIGEuTm9uVGVybWluYWwmJm8uY29udGFpbnMobixlKSkmJmUgaW5zdGFuY2VvZiBhLkFic3RyYWN0UHJvZHVjdGlvbiYmKGUgaW5zdGFuY2VvZiBhLk5vblRlcm1pbmFsJiZuLnB1c2goZSksby5ldmVyeShlLmRlZmluaXRpb24sZnVuY3Rpb24oZSl7cmV0dXJuIHQoZSxuKX0pKSl9LGUuaXNCcmFuY2hpbmdQcm9kPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgYS5BbHRlcm5hdGlvbn0sZS5nZXRQcm9kdWN0aW9uRHNsTmFtZT1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgYS5Ob25UZXJtaW5hbClyZXR1cm4gXCJTVUJSVUxFXCI7aWYodCBpbnN0YW5jZW9mIGEuT3B0aW9uKXJldHVybiBcIk9QVElPTlwiO2lmKHQgaW5zdGFuY2VvZiBhLkFsdGVybmF0aW9uKXJldHVybiBcIk9SXCI7aWYodCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gXCJBVF9MRUFTVF9PTkVcIjtpZih0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcilyZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7aWYodCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpcmV0dXJuIFwiTUFOWV9TRVBcIjtpZih0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uKXJldHVybiBcIk1BTllcIjtpZih0IGluc3RhbmNlb2YgYS5UZXJtaW5hbClyZXR1cm4gXCJDT05TVU1FXCI7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX07dmFyIGM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5zZXBhcmF0b3I9XCItXCIsZS5kc2xNZXRob2RzPXtvcHRpb246W10sYWx0ZXJuYXRpb246W10scmVwZXRpdGlvbjpbXSxyZXBldGl0aW9uV2l0aFNlcGFyYXRvcjpbXSxyZXBldGl0aW9uTWFuZGF0b3J5OltdLHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOltdfSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRUZXJtaW5hbD1mdW5jdGlvbih0KXt2YXIgZT11LnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSkrdGhpcy5zZXBhcmF0b3IrXCJUZXJtaW5hbFwiO28uaGFzKHRoaXMuZHNsTWV0aG9kcyxlKXx8KHRoaXMuZHNsTWV0aG9kc1tlXT1bXSksdGhpcy5kc2xNZXRob2RzW2VdLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHQpe3ZhciBlPXQubm9uVGVybWluYWxOYW1lK3RoaXMuc2VwYXJhdG9yK1wiVGVybWluYWxcIjtvLmhhcyh0aGlzLmRzbE1ldGhvZHMsZSl8fCh0aGlzLmRzbE1ldGhvZHNbZV09W10pLHRoaXMuZHNsTWV0aG9kc1tlXS5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24odCl7dGhpcy5kc2xNZXRob2RzLm9wdGlvbi5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbldpdGhTZXBhcmF0b3IucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbk1hbmRhdG9yeS5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbi5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMuYWx0ZXJuYXRpb24ucHVzaCh0KTt9LGV9KHMuR0FzdFZpc2l0b3IpO2UuRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3I9Yzt9LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQsZSxuKXtyZXR1cm4gbnxlfHR9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5CSVRTX0ZPUl9NRVRIT0RfSURYPTQsZS5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWD00LGUuQklUU19GT1JfUlVMRV9JRFg9MjQsZS5CSVRTX0ZPUl9BTFRfSURYPTgsZS5PUl9JRFg9MTw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuT1BUSU9OX0lEWD0yPDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5NQU5ZX0lEWD0zPDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5BVF9MRUFTVF9PTkVfSURYPTQ8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLk1BTllfU0VQX0lEWD01PDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5BVF9MRUFTVF9PTkVfU0VQX0lEWD02PDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQ9cjt2YXIgaT0zMi1lLkJJVFNfRk9SX0FMVF9JRFg7ZS5nZXRLZXlGb3JBbHRJbmRleD1mdW5jdGlvbih0LGUsbixvKXt2YXIgYT1vKzE8PGk7cmV0dXJuIHIodCxlLG4pfGF9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMiksaT1uKDApLG89bigwKSxhPW4oMSkscz1uKDgpLHU9bigxMSksYz1uKDE3KSxwPW4oMyk7ZS5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcj17YnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZTpmdW5jdGlvbih0KXt2YXIgZT10LmV4cGVjdGVkLG49dC5hY3R1YWw7dC5wcmV2aW91cyx0LnJ1bGVOYW1lO3JldHVybiBcIkV4cGVjdGluZyBcIisoci5oYXNUb2tlbkxhYmVsKGUpP1wiLS1cXHgzZSBcIityLnRva2VuTGFiZWwoZSkrXCIgPC0tXCI6XCJ0b2tlbiBvZiB0eXBlIC0tXFx4M2UgXCIrci50b2tlbk5hbWUoZSkrXCIgPC0tXCIpK1wiIGJ1dCBmb3VuZCAtLVxceDNlICdcIituLmltYWdlK1wiJyA8LS1cIn0sYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dC5maXJzdFJlZHVuZGFudDt0LnJ1bGVOYW1lO3JldHVybiBcIlJlZHVuZGFudCBpbnB1dCwgZXhwZWN0aW5nIEVPRiBidXQgZm91bmQ6IFwiK2UuaW1hZ2V9LGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZXhwZWN0ZWRQYXRoc1BlckFsdCxuPXQuYWN0dWFsLGk9KHQucHJldmlvdXMsdC5jdXN0b21Vc2VyRGVzY3JpcHRpb24pLGE9KHQucnVsZU5hbWUsXCJcXG5idXQgZm91bmQ6ICdcIitvLmZpcnN0KG4pLmltYWdlK1wiJ1wiKTtpZihpKXJldHVybiBcIkV4cGVjdGluZzogXCIraSthO3ZhciBzPW8ucmVkdWNlKGUsZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb25jYXQoZSl9LFtdKSx1PW8ubWFwKHMsZnVuY3Rpb24odCl7cmV0dXJuIFwiW1wiK28ubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHIudG9rZW5MYWJlbCh0KX0pLmpvaW4oXCIsIFwiKStcIl1cIn0pO3JldHVybiBcIkV4cGVjdGluZzogXCIrKFwib25lIG9mIHRoZXNlIHBvc3NpYmxlIFRva2VuIHNlcXVlbmNlczpcXG5cIitvLm1hcCh1LGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFwiICBcIisoZSsxKStcIi4gXCIrdH0pLmpvaW4oXCJcXG5cIikpK2F9LGJ1aWxkRWFybHlFeGl0TWVzc2FnZTpmdW5jdGlvbih0KXt2YXIgZT10LmV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsbj10LmFjdHVhbCxpPXQuY3VzdG9tVXNlckRlc2NyaXB0aW9uLGE9KHQucnVsZU5hbWUsXCJcXG5idXQgZm91bmQ6ICdcIitvLmZpcnN0KG4pLmltYWdlK1wiJ1wiKTtyZXR1cm4gaT9cIkV4cGVjdGluZzogXCIraSthOlwiRXhwZWN0aW5nOiBcIisoXCJleHBlY3RpbmcgYXQgbGVhc3Qgb25lIGl0ZXJhdGlvbiB3aGljaCBzdGFydHMgd2l0aCBvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOjpcXG4gIDxcIitvLm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiBcIltcIitvLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiByLnRva2VuTGFiZWwodCl9KS5qb2luKFwiLFwiKStcIl1cIn0pLmpvaW4oXCIgLFwiKStcIj5cIikrYX19LE9iamVjdC5mcmVlemUoZS5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciksZS5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlcj17YnVpbGRSdWxlTm90Rm91bmRFcnJvcjpmdW5jdGlvbih0LGUpe3JldHVybiBcIkludmFsaWQgZ3JhbW1hciwgcmVmZXJlbmNlIHRvIGEgcnVsZSB3aGljaCBpcyBub3QgZGVmaW5lZDogLT5cIitlLm5vblRlcm1pbmFsTmFtZStcIjwtXFxuaW5zaWRlIHRvcCBsZXZlbCBydWxlOiAtPlwiK3QubmFtZStcIjwtXCJ9fSxlLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcj17YnVpbGREdXBsaWNhdGVGb3VuZEVycm9yOmZ1bmN0aW9uKHQsZSl7dmFyIG4saT10Lm5hbWUsdT1vLmZpcnN0KGUpLGM9dS5pZHgscD1zLmdldFByb2R1Y3Rpb25Ec2xOYW1lKHUpLGw9KG49dSlpbnN0YW5jZW9mIGEuVGVybWluYWw/ci50b2tlbk5hbWUobi50ZXJtaW5hbFR5cGUpOm4gaW5zdGFuY2VvZiBhLk5vblRlcm1pbmFsP24ubm9uVGVybWluYWxOYW1lOlwiXCIsaD1cIi0+XCIrcCtcIjwtIHdpdGggbnVtZXJpY2FsIHN1ZmZpeDogLT5cIitjK1wiPC1cXG4gICAgICAgICAgICAgICAgICBcIisobD9cImFuZCBhcmd1bWVudDogLT5cIitsK1wiPC1cIjpcIlwiKStcIlxcbiAgICAgICAgICAgICAgICAgIGFwcGVhcnMgbW9yZSB0aGFuIG9uY2UgKFwiK2UubGVuZ3RoK1wiIHRpbWVzKSBpbiB0aGUgdG9wIGxldmVsIHJ1bGU6IC0+XCIraStcIjwtLlxcbiAgICAgICAgICAgICAgICAgIFwiKygwPT09Yz9cIkFsc28gbm90ZSB0aGF0IG51bWVyaWNhbCBzdWZmaXggMCBtZWFucyBcIitwK1wiIHdpdGhvdXQgYW55IHN1ZmZpeC5cIjpcIlwiKStcIlxcbiAgICAgICAgICAgICAgICAgIFRvIGZpeCB0aGlzIG1ha2Ugc3VyZSBlYWNoIHVzYWdlIG9mIFwiK3ArXCIgXCIrKGw/XCJ3aXRoIHRoZSBhcmd1bWVudDogLT5cIitsK1wiPC1cIjpcIlwiKStcIlxcbiAgICAgICAgICAgICAgICAgIGluIHRoZSBydWxlIC0+XCIraStcIjwtIGhhcyBhIGRpZmZlcmVudCBvY2N1cnJlbmNlIGluZGV4ICgwLTUpLCBhcyB0aGF0IGNvbWJpbmF0aW9uIGFjdHMgYXMgYSB1bmlxdWVcXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBrZXkgaW4gdGhlIGdyYW1tYXIsIHdoaWNoIGlzIG5lZWRlZCBieSB0aGUgcGFyc2luZyBlbmdpbmUuXFxuICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgRm9yIGZ1cnRoZXIgZGV0YWlscyBzZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvRkFRLmh0bWwjTlVNRVJJQ0FMX1NVRkZJWEVTIFxcbiAgICAgICAgICAgICAgICAgIFwiO3JldHVybiBoPShoPWgucmVwbGFjZSgvWyBcXHRdKy9nLFwiIFwiKSkucmVwbGFjZSgvXFxzXFxzKy9nLFwiXFxuXCIpfSxidWlsZEludmFsaWROZXN0ZWRSdWxlTmFtZUVycm9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFwiSW52YWxpZCBuZXN0ZWQgcnVsZSBuYW1lOiAtPlwiK2UubmFtZStcIjwtIGluc2lkZSBydWxlOiAtPlwiK3QubmFtZStcIjwtXFxuaXQgbXVzdCBtYXRjaCB0aGUgcGF0dGVybjogLT5cIit1LnZhbGlkTmVzdGVkUnVsZU5hbWUudG9TdHJpbmcoKStcIjwtLlxcbk5vdGUgdGhhdCB0aGlzIG1lYW5zIGEgbmVzdGVkIHJ1bGUgbmFtZSBtdXN0IHN0YXJ0IHdpdGggdGhlICckJyhkb2xsYXIpIHNpZ24uXCJ9LGJ1aWxkRHVwbGljYXRlTmVzdGVkUnVsZU5hbWVFcnJvcjpmdW5jdGlvbih0LGUpe3JldHVybiBcIkR1cGxpY2F0ZSBuZXN0ZWQgcnVsZSBuYW1lOiAtPlwiK28uZmlyc3QoZSkubmFtZStcIjwtIGluc2lkZSBydWxlOiAtPlwiK3QubmFtZStcIjwtXFxuQSBuZXN0ZWQgbmFtZSBtdXN0IGJlIHVuaXF1ZSBpbiB0aGUgc2NvcGUgb2YgYSB0b3AgbGV2ZWwgZ3JhbW1hciBydWxlLlwifSxidWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiTmFtZXNwYWNlIGNvbmZsaWN0IGZvdW5kIGluIGdyYW1tYXIuXFxuVGhlIGdyYW1tYXIgaGFzIGJvdGggYSBUZXJtaW5hbChUb2tlbikgYW5kIGEgTm9uLVRlcm1pbmFsKFJ1bGUpIG5hbWVkOiA8XCIrdC5uYW1lK1wiPi5cXG5UbyByZXNvbHZlIHRoaXMgbWFrZSBzdXJlIGVhY2ggVGVybWluYWwgYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBhcmUgdW5pcXVlXFxuVGhpcyBpcyBlYXN5IHRvIGFjY29tcGxpc2ggYnkgdXNpbmcgdGhlIGNvbnZlbnRpb24gdGhhdCBUZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGFuIHVwcGVyY2FzZSBsZXR0ZXJcXG5hbmQgTm9uLVRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYSBsb3dlciBjYXNlIGxldHRlci5cIn0sYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPW8ubWFwKHQucHJlZml4UGF0aCxmdW5jdGlvbih0KXtyZXR1cm4gci50b2tlbkxhYmVsKHQpfSkuam9pbihcIiwgXCIpLG49MD09PXQuYWx0ZXJuYXRpb24uaWR4P1wiXCI6dC5hbHRlcm5hdGlvbi5pZHg7cmV0dXJuIFwiQW1iaWd1b3VzIGFsdGVybmF0aXZlczogPFwiK3QuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIikrXCI+IGR1ZSB0byBjb21tb24gbG9va2FoZWFkIHByZWZpeFxcbmluIDxPUlwiK24rXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIj4gUnVsZSxcXG48XCIrZStcIj4gbWF5IGFwcGVhcnMgYXMgYSBwcmVmaXggcGF0aCBpbiBhbGwgdGhlc2UgYWx0ZXJuYXRpdmVzLlxcbmh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQ09NTU9OX1BSRUZJWFxcbkZvciBGdXJ0aGVyIGRldGFpbHMuXCJ9LGJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcjpmdW5jdGlvbih0KXt2YXIgZT1vLm1hcCh0LnByZWZpeFBhdGgsZnVuY3Rpb24odCl7cmV0dXJuIHIudG9rZW5MYWJlbCh0KX0pLmpvaW4oXCIsIFwiKSxuPTA9PT10LmFsdGVybmF0aW9uLmlkeD9cIlwiOnQuYWx0ZXJuYXRpb24uaWR4LGk9XCJBbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzOiA8XCIrdC5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKStcIj4gaW4gPE9SXCIrbitcIj4gaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPiBSdWxlLFxcbjxcIitlK1wiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuXCIsYT1jLlZFUlNJT04ucmVwbGFjZSgvXFwuL2csXCJfXCIpO3JldHVybiBpPWkrXCJUbyBSZXNvbHZlIHRoaXMsIHRyeSBvbmUgb2Ygb2YgdGhlIGZvbGxvd2luZzogXFxuMS4gUmVmYWN0b3IgeW91ciBncmFtbWFyIHRvIGJlIExMKEspIGZvciB0aGUgY3VycmVudCB2YWx1ZSBvZiBrIChieSBkZWZhdWx0IGs9XCIrcC5ERUZBVUxUX1BBUlNFUl9DT05GSUcubWF4TG9va2FoZWFkK1wifSlcXG4yLiBJbmNyZWFzZSB0aGUgdmFsdWUgb2YgSyBmb3IgeW91ciBncmFtbWFyIGJ5IHByb3ZpZGluZyBhIGxhcmdlciAnbWF4TG9va2FoZWFkJyB2YWx1ZSBpbiB0aGUgcGFyc2VyJ3MgY29uZmlnXFxuMy4gVGhpcyBpc3N1ZSBjYW4gYmUgaWdub3JlZCAoaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLi4uKSwgc2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3VtZW50YXRpb24vXCIrYStcIi9pbnRlcmZhY2VzL2lwYXJzZXJjb25maWcuaHRtbCNpZ25vcmVkaXNzdWVzIGZvciBtb3JlIGRldGFpbHNcXG5cIn0sYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcjpmdW5jdGlvbih0KXt2YXIgZT1zLmdldFByb2R1Y3Rpb25Ec2xOYW1lKHQucmVwZXRpdGlvbik7cmV0dXJuIDAhPT10LnJlcGV0aXRpb24uaWR4JiYoZSs9dC5yZXBldGl0aW9uLmlkeCksXCJUaGUgcmVwZXRpdGlvbiA8XCIrZStcIj4gd2l0aGluIFJ1bGUgPFwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI+IGNhbiBuZXZlciBjb25zdW1lIGFueSB0b2tlbnMuXFxuVGhpcyBjb3VsZCBsZWFkIHRvIGFuIGluZmluaXRlIGxvb3AuXCJ9LGJ1aWxkVG9rZW5OYW1lRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiSW52YWxpZCBHcmFtbWFyIFRva2VuIG5hbWU6IC0+XCIrci50b2tlbk5hbWUodC50b2tlblR5cGUpK1wiPC0gaXQgbXVzdCBtYXRjaCB0aGUgcGF0dGVybjogLT5cIit0LmV4cGVjdGVkUGF0dGVybi50b1N0cmluZygpK1wiPC1cIn0sYnVpbGRFbXB0eUFsdGVybmF0aW9uRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8XCIrKHQuZW1wdHlDaG9pY2VJZHgrMSkrXCI+IGluIDxPUlwiK3QuYWx0ZXJuYXRpb24uaWR4K1wiPiBpbnNpZGUgPFwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI+IFJ1bGUuXFxuT25seSB0aGUgbGFzdCBhbHRlcm5hdGl2ZSBtYXkgYmUgYW4gZW1wdHkgYWx0ZXJuYXRpdmUuXCJ9LGJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIkFuIEFsdGVybmF0aW9uIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiAyNTYgYWx0ZXJuYXRpdmVzOlxcbjxPUlwiK3QuYWx0ZXJuYXRpb24uaWR4K1wiPiBpbnNpZGUgPFwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI+IFJ1bGUuXFxuIGhhcyBcIisodC5hbHRlcm5hdGlvbi5kZWZpbml0aW9uLmxlbmd0aCsxKStcIiBhbHRlcm5hdGl2ZXMuXCJ9LGJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPXQudG9wTGV2ZWxSdWxlLm5hbWU7cmV0dXJuIFwiTGVmdCBSZWN1cnNpb24gZm91bmQgaW4gZ3JhbW1hci5cXG5ydWxlOiA8XCIrZStcIj4gY2FuIGJlIGludm9rZWQgZnJvbSBpdHNlbGYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpXFxud2l0aG91dCBjb25zdW1pbmcgYW55IFRva2Vucy4gVGhlIGdyYW1tYXIgcGF0aCB0aGF0IGNhdXNlcyB0aGlzIGlzOiBcXG4gXCIrKGUrXCIgLS1cXHgzZSBcIitpLm1hcCh0LmxlZnRSZWN1cnNpb25QYXRoLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KS5jb25jYXQoW2VdKS5qb2luKFwiIC0tXFx4M2UgXCIpKStcIlxcbiBUbyBmaXggdGhpcyByZWZhY3RvciB5b3VyIGdyYW1tYXIgdG8gcmVtb3ZlIHRoZSBsZWZ0IHJlY3Vyc2lvbi5cXG5zZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xMX3BhcnNlciNMZWZ0X0ZhY3RvcmluZy5cIn0sYnVpbGRJbnZhbGlkUnVsZU5hbWVFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJJbnZhbGlkIGdyYW1tYXIgcnVsZSBuYW1lOiAtPlwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI8LSBpdCBtdXN0IG1hdGNoIHRoZSBwYXR0ZXJuOiAtPlwiK3QuZXhwZWN0ZWRQYXR0ZXJuLnRvU3RyaW5nKCkrXCI8LVwifSxidWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiRHVwbGljYXRlIGRlZmluaXRpb24sIHJ1bGU6IC0+XCIrKHQudG9wTGV2ZWxSdWxlIGluc3RhbmNlb2YgYS5SdWxlP3QudG9wTGV2ZWxSdWxlLm5hbWU6dC50b3BMZXZlbFJ1bGUpK1wiPC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPlwiK3QuZ3JhbW1hck5hbWUrXCI8LVwifX07fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDApLGE9bigwKSxzPW4oMyksdT1uKDgpLGM9bigyKSxwPW4oMTIpLGw9bigxNiksaD1uKDEzKSxmPW4oMSksZD1uKDUpO2Z1bmN0aW9uIEUodCl7cmV0dXJuIHUuZ2V0UHJvZHVjdGlvbkRzbE5hbWUodCkrXCJfI19cIit0LmlkeCtcIl8jX1wiK20odCl9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGYuVGVybWluYWw/Yy50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpOnQgaW5zdGFuY2VvZiBmLk5vblRlcm1pbmFsP3Qubm9uVGVybWluYWxOYW1lOlwiXCJ9ZS52YWxpZGF0ZUdyYW1tYXI9ZnVuY3Rpb24odCxlLG4scixpLHApe3ZhciBoPW8ubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IHk7dC5hY2NlcHQobik7dmFyIHI9bi5hbGxQcm9kdWN0aW9ucyxpPW8uZ3JvdXBCeShyLEUpLGE9by5waWNrKGksZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPjF9KTtyZXR1cm4gby5tYXAoby52YWx1ZXMoYSksZnVuY3Rpb24obil7dmFyIHI9by5maXJzdChuKSxpPWUuYnVpbGREdXBsaWNhdGVGb3VuZEVycm9yKHQsbiksYT11LmdldFByb2R1Y3Rpb25Ec2xOYW1lKHIpLGM9e21lc3NhZ2U6aSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUFJPRFVDVElPTlMscnVsZU5hbWU6dC5uYW1lLGRzbE5hbWU6YSxvY2N1cnJlbmNlOnIuaWR4fSxwPW0ocik7cmV0dXJuIHAmJihjLnBhcmFtZXRlcj1wKSxjfSl9KHQsaSl9KSxmPW8ubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIFIodCx0LGkpfSksZD1bXSxBPVtdLE49W107YS5ldmVyeShmLGEuaXNFbXB0eSkmJihkPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIE8odCxpKX0pLEE9YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gUyh0LGUscixpKX0pLE49ayh0LGUsaSkpO3ZhciBJPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bXSxpPWEubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIGMudG9rZW5OYW1lKHQpfSk7cmV0dXJuIGEuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZTtpZihhLmNvbnRhaW5zKGksZSkpe3ZhciBvPW4uYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKHQpO3IucHVzaCh7bWVzc2FnZTpvLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0UscnVsZU5hbWU6ZX0pO319KSxyfSh0LG4saSksUD1vLm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiBnKHQsaSl9KSx4PWZ1bmN0aW9uKHQsZSl7dmFyIG49W107cmV0dXJuIGEuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciByPW5ldyBsLk5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoXCJcIik7dC5hY2NlcHQocik7dmFyIGk9YS5tYXAoci5yZXN1bHQsZnVuY3Rpb24odCl7cmV0dXJuIHQub3JnUHJvZH0pO24ucHVzaChhLm1hcChpLGZ1bmN0aW9uKG4pe3JldHVybiB2KHQsbixlKX0pKTt9KSxhLmZsYXR0ZW4obil9KHQsaSksQz1mdW5jdGlvbih0LGUpe3ZhciBuPVtdO3JldHVybiBhLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgcj1uZXcgbC5OYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKFwiXCIpO3QuYWNjZXB0KHIpO3ZhciBpPWEuZ3JvdXBCeShyLnJlc3VsdCxmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSksbz1hLnBpY2soaSxmdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg+MX0pO2EuZm9yRWFjaChhLnZhbHVlcyhvKSxmdW5jdGlvbihyKXt2YXIgaT1hLm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9yZ1Byb2R9KSxvPWUuYnVpbGREdXBsaWNhdGVOZXN0ZWRSdWxlTmFtZUVycm9yKHQsaSk7bi5wdXNoKHttZXNzYWdlOm8sdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX05FU1RFRF9OQU1FLHJ1bGVOYW1lOnQubmFtZX0pO30pO30pLG59KHQsaSksTT1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBMKHQsaSl9KSxGPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIFQodCxpKX0pLGI9YS5tYXAodCxmdW5jdGlvbihlKXtyZXR1cm4gXyhlLHQscCxpKX0pO3JldHVybiBvLmZsYXR0ZW4oaC5jb25jYXQoUCx4LEMsTixmLGQsQSxJLE0sRixiKSl9LGUuaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcz1FO3ZhciB5PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuYWxsUHJvZHVjdGlvbnM9W10sZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWw9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGV9KGQuR0FzdFZpc2l0b3IpO2Z1bmN0aW9uIFQodCxuKXt2YXIgcj1bXSxpPXQubmFtZTtyZXR1cm4gaS5tYXRjaChlLnZhbGlkVGVybXNQYXR0ZXJuKXx8ci5wdXNoKHttZXNzYWdlOm4uYnVpbGRJbnZhbGlkUnVsZU5hbWVFcnJvcih7dG9wTGV2ZWxSdWxlOnQsZXhwZWN0ZWRQYXR0ZXJuOmUudmFsaWRUZXJtc1BhdHRlcm59KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1JVTEVfTkFNRSxydWxlTmFtZTppfSkscn1mdW5jdGlvbiB2KHQsbixyKXt2YXIgaSxvPVtdO3JldHVybiBuLm5hbWUubWF0Y2goZS52YWxpZE5lc3RlZFJ1bGVOYW1lKXx8KGk9ci5idWlsZEludmFsaWROZXN0ZWRSdWxlTmFtZUVycm9yKHQsbiksby5wdXNoKHttZXNzYWdlOmksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FLHJ1bGVOYW1lOnQubmFtZX0pKSxvfWZ1bmN0aW9uIGcodCxuKXt2YXIgcj1bXTtyZXR1cm4gYy50b2tlbk5hbWUodCkubWF0Y2goZS52YWxpZFRlcm1zUGF0dGVybil8fHIucHVzaCh7bWVzc2FnZTpuLmJ1aWxkVG9rZW5OYW1lRXJyb3Ioe3Rva2VuVHlwZTp0LGV4cGVjdGVkUGF0dGVybjplLnZhbGlkVGVybXNQYXR0ZXJufSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9UT0tFTl9OQU1FfSkscn1mdW5jdGlvbiBfKHQsZSxuLHIpe3ZhciBpPVtdO2lmKGEucmVkdWNlKGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4gbi5uYW1lPT09dC5uYW1lP2UrMTplfSwwKT4xKXt2YXIgbz1yLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7dG9wTGV2ZWxSdWxlOnQsZ3JhbW1hck5hbWU6bn0pO2kucHVzaCh7bWVzc2FnZTpvLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9SVUxFX05BTUUscnVsZU5hbWU6dC5uYW1lfSk7fXJldHVybiBpfWZ1bmN0aW9uIFIodCxlLG4scil7dm9pZCAwPT09ciYmKHI9W10pO3ZhciBpPVtdLGE9QShlLmRlZmluaXRpb24pO2lmKG8uaXNFbXB0eShhKSlyZXR1cm4gW107dmFyIHU9dC5uYW1lO28uY29udGFpbnMoYSx0KSYmaS5wdXNoKHttZXNzYWdlOm4uYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3Ioe3RvcExldmVsUnVsZTp0LGxlZnRSZWN1cnNpb25QYXRoOnJ9KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5MRUZUX1JFQ1VSU0lPTixydWxlTmFtZTp1fSk7dmFyIGM9by5kaWZmZXJlbmNlKGEsci5jb25jYXQoW3RdKSkscD1vLm1hcChjLGZ1bmN0aW9uKGUpe3ZhciBpPW8uY2xvbmVBcnIocik7cmV0dXJuIGkucHVzaChlKSxSKHQsZSxuLGkpfSk7cmV0dXJuIGkuY29uY2F0KG8uZmxhdHRlbihwKSl9ZnVuY3Rpb24gQSh0KXt2YXIgZT1bXTtpZihvLmlzRW1wdHkodCkpcmV0dXJuIGU7dmFyIG49by5maXJzdCh0KTtpZihuIGluc3RhbmNlb2YgZi5Ob25UZXJtaW5hbCllLnB1c2gobi5yZWZlcmVuY2VkUnVsZSk7ZWxzZSBpZihuIGluc3RhbmNlb2YgZi5GbGF0fHxuIGluc3RhbmNlb2YgZi5PcHRpb258fG4gaW5zdGFuY2VvZiBmLlJlcGV0aXRpb25NYW5kYXRvcnl8fG4gaW5zdGFuY2VvZiBmLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yfHxuIGluc3RhbmNlb2YgZi5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcnx8biBpbnN0YW5jZW9mIGYuUmVwZXRpdGlvbillPWUuY29uY2F0KEEobi5kZWZpbml0aW9uKSk7ZWxzZSBpZihuIGluc3RhbmNlb2YgZi5BbHRlcm5hdGlvbillPW8uZmxhdHRlbihvLm1hcChuLmRlZmluaXRpb24sZnVuY3Rpb24odCl7cmV0dXJuIEEodC5kZWZpbml0aW9uKX0pKTtlbHNlIGlmKCEobiBpbnN0YW5jZW9mIGYuVGVybWluYWwpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7dmFyIHI9dS5pc09wdGlvbmFsUHJvZChuKSxpPXQubGVuZ3RoPjE7aWYociYmaSl7dmFyIGE9by5kcm9wKHQpO3JldHVybiBlLmNvbmNhdChBKGEpKX1yZXR1cm4gZX1lLk9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yPXksZS52YWxpZFRlcm1zUGF0dGVybj0vXlthLXpBLVpfXVxcdyokLyxlLnZhbGlkTmVzdGVkUnVsZU5hbWU9bmV3IFJlZ0V4cChlLnZhbGlkVGVybXNQYXR0ZXJuLnNvdXJjZS5yZXBsYWNlKFwiXlwiLFwiXlxcXFwkXCIpKSxlLnZhbGlkYXRlUnVsZU5hbWU9VCxlLnZhbGlkYXRlTmVzdGVkUnVsZU5hbWU9dixlLnZhbGlkYXRlVG9rZW5OYW1lPWcsZS52YWxpZGF0ZVJ1bGVEb2VzTm90QWxyZWFkeUV4aXN0PV8sZS52YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW49ZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9W107cmV0dXJuIG8uY29udGFpbnMoZSx0KXx8KHI9XCJJbnZhbGlkIHJ1bGUgb3ZlcnJpZGUsIHJ1bGU6IC0+XCIrdCtcIjwtIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHRoZSBncmFtbWFyOiAtPlwiK24rXCI8LWFzIGl0IGlzIG5vdCBkZWZpbmVkIGluIGFueSBvZiB0aGUgc3VwZXIgZ3JhbW1hcnMgXCIsaS5wdXNoKHttZXNzYWdlOnIsdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX09WRVJSSURFLHJ1bGVOYW1lOnR9KSksaX0sZS52YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbj1SLGUuZ2V0Rmlyc3ROb25lVGVybWluYWw9QTt2YXIgTj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLmFsdGVybmF0aW9ucz1bXSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGlvbj1mdW5jdGlvbih0KXt0aGlzLmFsdGVybmF0aW9ucy5wdXNoKHQpO30sZX0oZC5HQXN0VmlzaXRvcik7ZnVuY3Rpb24gTyh0LGUpe3ZhciBuPW5ldyBOO3QuYWNjZXB0KG4pO3ZhciByPW4uYWx0ZXJuYXRpb25zO3JldHVybiBvLnJlZHVjZShyLGZ1bmN0aW9uKG4scil7dmFyIGk9by5kcm9wUmlnaHQoci5kZWZpbml0aW9uKSxhPW8ubWFwKGksZnVuY3Rpb24obixpKXt2YXIgYT1oLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtuXSxbXSxudWxsLDEpO3JldHVybiBvLmlzRW1wdHkoYSk/e21lc3NhZ2U6ZS5idWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcih7dG9wTGV2ZWxSdWxlOnQsYWx0ZXJuYXRpb246cixlbXB0eUNob2ljZUlkeDppfSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9ORV9MQVNUX0VNUFRZX0FMVCxydWxlTmFtZTp0Lm5hbWUsb2NjdXJyZW5jZTpyLmlkeCxhbHRlcm5hdGl2ZTppKzF9Om51bGx9KTtyZXR1cm4gbi5jb25jYXQoby5jb21wYWN0KGEpKX0sW10pfWZ1bmN0aW9uIFModCxlLG4scil7dmFyIGk9bmV3IE47dC5hY2NlcHQoaSk7dmFyIGM9aS5hbHRlcm5hdGlvbnMsbD1uW3QubmFtZV07cmV0dXJuIGwmJihjPWEucmVqZWN0KGMsZnVuY3Rpb24odCl7cmV0dXJuIGxbdS5nZXRQcm9kdWN0aW9uRHNsTmFtZSh0KSsoMD09PXQuaWR4P1wiXCI6dC5pZHgpXX0pKSxvLnJlZHVjZShjLGZ1bmN0aW9uKG4saSl7dmFyIHU9aS5pZHgsYz1wLmdldExvb2thaGVhZFBhdGhzRm9yT3IodSx0LGUpLGw9ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9W10sdT1hLnJlZHVjZSh0LGZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gYS5mb3JFYWNoKG4sZnVuY3Rpb24obil7dmFyIG89W3JdO2EuZm9yRWFjaCh0LGZ1bmN0aW9uKHQsZSl7ciE9PWUmJnAuY29udGFpbnNQYXRoKHQsbikmJm8ucHVzaChlKTt9KSxvLmxlbmd0aD4xJiYhcC5jb250YWluc1BhdGgoaSxuKSYmKGkucHVzaChuKSxlLnB1c2goe2FsdHM6byxwYXRoOm59KSk7fSksZX0sW10pO3JldHVybiBvLm1hcCh1LGZ1bmN0aW9uKHQpe3ZhciBpPWEubWFwKHQuYWx0cyxmdW5jdGlvbih0KXtyZXR1cm4gdCsxfSksbz1yLmJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcih7dG9wTGV2ZWxSdWxlOm4sYWx0ZXJuYXRpb246ZSxhbWJpZ3VpdHlJbmRpY2VzOmkscHJlZml4UGF0aDp0LnBhdGh9KTtyZXR1cm4ge21lc3NhZ2U6byx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfQUxUUyxydWxlTmFtZTpuLm5hbWUsb2NjdXJyZW5jZTplLmlkeCxhbHRlcm5hdGl2ZXM6W3QuYWx0c119fSl9KGMsaSx0LHIpLGg9UChjLGksdCxyKTtyZXR1cm4gbi5jb25jYXQobCxoKX0sW10pfWUudmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmU9TyxlLnZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXM9Uzt2YXIgST1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLmFsbFByb2R1Y3Rpb25zPVtdLGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlfShkLkdBc3RWaXNpdG9yKTtmdW5jdGlvbiBMKHQsZSl7dmFyIG49bmV3IE47dC5hY2NlcHQobik7dmFyIHI9bi5hbHRlcm5hdGlvbnM7cmV0dXJuIG8ucmVkdWNlKHIsZnVuY3Rpb24obixyKXtyZXR1cm4gci5kZWZpbml0aW9uLmxlbmd0aD4yNTUmJm4ucHVzaCh7bWVzc2FnZTplLmJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yKHt0b3BMZXZlbFJ1bGU6dCxhbHRlcm5hdGlvbjpyfSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuVE9PX01BTllfQUxUUyxydWxlTmFtZTp0Lm5hbWUsb2NjdXJyZW5jZTpyLmlkeH0pLG59LFtdKX1mdW5jdGlvbiBrKHQsZSxuKXt2YXIgcj1bXTtyZXR1cm4gYS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIGk9bmV3IEk7dC5hY2NlcHQoaSk7dmFyIG89aS5hbGxQcm9kdWN0aW9uczthLmZvckVhY2gobyxmdW5jdGlvbihpKXt2YXIgbz1wLmdldFByb2RUeXBlKGkpLHU9aS5pZHgsYz1wLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKHUsdCxvLGUpWzBdO2lmKGEuaXNFbXB0eShhLmZsYXR0ZW4oYykpKXt2YXIgbD1uLmJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3Ioe3RvcExldmVsUnVsZTp0LHJlcGV0aXRpb246aX0pO3IucHVzaCh7bWVzc2FnZTpsLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PX05PTl9FTVBUWV9MT09LQUhFQUQscnVsZU5hbWU6dC5uYW1lfSk7fX0pO30pLHJ9ZnVuY3Rpb24gUCh0LGUsbixyKXt2YXIgaT1bXSxvPWEucmVkdWNlKHQsZnVuY3Rpb24odCxlLG4pe3ZhciByPWEubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHtpZHg6bixwYXRoOnR9fSk7cmV0dXJuIHQuY29uY2F0KHIpfSxbXSk7cmV0dXJuIGEuZm9yRWFjaChvLGZ1bmN0aW9uKHQpe3ZhciB1PXQuaWR4LGM9dC5wYXRoLGw9YS5maW5kQWxsKG8sZnVuY3Rpb24odCl7cmV0dXJuIHQuaWR4PHUmJnAuaXNTdHJpY3RQcmVmaXhPZlBhdGgodC5wYXRoLGMpfSksaD1hLm1hcChsLGZ1bmN0aW9uKHQpe3ZhciBpPVt0LmlkeCsxLHUrMV0sbz0wPT09ZS5pZHg/XCJcIjplLmlkeDtyZXR1cm4ge21lc3NhZ2U6ci5idWlsZEFsdGVybmF0aW9uUHJlZml4QW1iaWd1aXR5RXJyb3Ioe3RvcExldmVsUnVsZTpuLGFsdGVybmF0aW9uOmUsYW1iaWd1aXR5SW5kaWNlczppLHByZWZpeFBhdGg6dC5wYXRofSksdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQU1CSUdVT1VTX1BSRUZJWF9BTFRTLHJ1bGVOYW1lOm4ubmFtZSxvY2N1cnJlbmNlOm8sYWx0ZXJuYXRpdmVzOml9fSk7aT1pLmNvbmNhdChoKTt9KSxpfWUuUmVwZXRpb25Db2xsZWN0b3I9SSxlLnZhbGlkYXRlVG9vTWFueUFsdHM9TCxlLnZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aD1rLGUuY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcz1QO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG8sYT1uKDApLHM9bigxMyksdT1uKDE0KSxjPW4oNykscD1uKDEpLGw9big1KTshZnVuY3Rpb24odCl7dFt0Lk9QVElPTj0wXT1cIk9QVElPTlwiLHRbdC5SRVBFVElUSU9OPTFdPVwiUkVQRVRJVElPTlwiLHRbdC5SRVBFVElUSU9OX01BTkRBVE9SWT0yXT1cIlJFUEVUSVRJT05fTUFOREFUT1JZXCIsdFt0LlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SPTNdPVwiUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1JcIix0W3QuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUj00XT1cIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIix0W3QuQUxURVJOQVRJT049NV09XCJBTFRFUk5BVElPTlwiO30obz1lLlBST0RfVFlQRXx8KGUuUFJPRF9UWVBFPXt9KSksZS5nZXRQcm9kVHlwZT1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgcC5PcHRpb24pcmV0dXJuIG8uT1BUSU9OO2lmKHQgaW5zdGFuY2VvZiBwLlJlcGV0aXRpb24pcmV0dXJuIG8uUkVQRVRJVElPTjtpZih0IGluc3RhbmNlb2YgcC5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVybiBvLlJFUEVUSVRJT05fTUFOREFUT1JZO2lmKHQgaW5zdGFuY2VvZiBwLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXJldHVybiBvLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SO2lmKHQgaW5zdGFuY2VvZiBwLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXJldHVybiBvLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7aWYodCBpbnN0YW5jZW9mIHAuQWx0ZXJuYXRpb24pcmV0dXJuIG8uQUxURVJOQVRJT047dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX0sZS5idWlsZExvb2thaGVhZEZ1bmNGb3JPcj1mdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9RSh0LGUsbik7cmV0dXJuIG8oYSxyLFQoYSk/Yy50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzOmMudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcixpKX0sZS5idWlsZExvb2thaGVhZEZ1bmNGb3JPcHRpb25hbFByb2Q9ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPW0odCxlLGksbikscz1UKGEpP2MudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpjLnRva2VuU3RydWN0dXJlZE1hdGNoZXI7cmV0dXJuIG8oYVswXSxzLHIpfSxlLmJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYz1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT10Lmxlbmd0aCxvPWEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiAxPT09dC5sZW5ndGh9KX0pO2lmKGUpcmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj1hLm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB0LkdBVEV9KSxvPTA7bzxpO28rKyl7dmFyIHM9dFtvXSx1PXMubGVuZ3RoLGM9cltvXTtpZih2b2lkIDA9PT1jfHwhMSE9PWMuY2FsbCh0aGlzKSl0OmZvcih2YXIgcD0wO3A8dTtwKyspe2Zvcih2YXIgbD1zW3BdLGg9bC5sZW5ndGgsZj0wO2Y8aDtmKyspe3ZhciBkPXRoaXMuTEEoZisxKTtpZighMT09PW4oZCxsW2ZdKSljb250aW51ZSB0fXJldHVybiBvfX19O2lmKG8mJiFyKXt2YXIgcz1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmZsYXR0ZW4odCl9KSx1PWEucmVkdWNlKHMsZnVuY3Rpb24odCxlLG4pe3JldHVybiBhLmZvckVhY2goZSxmdW5jdGlvbihlKXthLmhhcyh0LGUudG9rZW5UeXBlSWR4KXx8KHRbZS50b2tlblR5cGVJZHhdPW4pLGEuZm9yRWFjaChlLmNhdGVnb3J5TWF0Y2hlcyxmdW5jdGlvbihlKXthLmhhcyh0LGUpfHwodFtlXT1uKTt9KTt9KSx0fSxbXSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5MQSgxKTtyZXR1cm4gdVt0LnRva2VuVHlwZUlkeF19fXJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8aTtlKyspe3ZhciByPXRbZV0sbz1yLmxlbmd0aDt0OmZvcih2YXIgYT0wO2E8bzthKyspe2Zvcih2YXIgcz1yW2FdLHU9cy5sZW5ndGgsYz0wO2M8dTtjKyspe3ZhciBwPXRoaXMuTEEoYysxKTtpZighMT09PW4ocCxzW2NdKSljb250aW51ZSB0fXJldHVybiBlfX19fSxlLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbj1mdW5jdGlvbih0LGUsbil7dmFyIHI9YS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiAxPT09dC5sZW5ndGh9KSxpPXQubGVuZ3RoO2lmKHImJiFuKXt2YXIgbz1hLmZsYXR0ZW4odCk7aWYoMT09PW8ubGVuZ3RoJiZhLmlzRW1wdHkob1swXS5jYXRlZ29yeU1hdGNoZXMpKXt2YXIgcz1vWzBdLnRva2VuVHlwZUlkeDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5MQSgxKS50b2tlblR5cGVJZHg9PT1zfX12YXIgdT1hLnJlZHVjZShvLGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdFtlLnRva2VuVHlwZUlkeF09ITAsYS5mb3JFYWNoKGUuY2F0ZWdvcnlNYXRjaGVzLGZ1bmN0aW9uKGUpe3RbZV09ITA7fSksdH0sW10pO3JldHVybiBmdW5jdGlvbigpe3ZhciB0PXRoaXMuTEEoMSk7cmV0dXJuICEwPT09dVt0LnRva2VuVHlwZUlkeF19fXJldHVybiBmdW5jdGlvbigpe3Q6Zm9yKHZhciBuPTA7bjxpO24rKyl7Zm9yKHZhciByPXRbbl0sbz1yLmxlbmd0aCxhPTA7YTxvO2ErKyl7dmFyIHM9dGhpcy5MQShhKzEpO2lmKCExPT09ZShzLHJbYV0pKWNvbnRpbnVlIHR9cmV0dXJuICEwfXJldHVybiAhMX19O3ZhciBoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuLHIpe3ZhciBpPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gaS50b3BQcm9kPWUsaS50YXJnZXRPY2N1cnJlbmNlPW4saS50YXJnZXRQcm9kVHlwZT1yLGl9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YWxrKHRoaXMudG9wUHJvZCksdGhpcy5yZXN0RGVmfSxlLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0PWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0LmlkeD09PXRoaXMudGFyZ2V0T2NjdXJyZW5jZSYmdGhpcy50YXJnZXRQcm9kVHlwZT09PWUmJih0aGlzLnJlc3REZWY9bi5jb25jYXQociksITApfSxlLnByb3RvdHlwZS53YWxrT3B0aW9uPWZ1bmN0aW9uKGUsbixyKXt0aGlzLmNoZWNrSXNUYXJnZXQoZSxvLk9QVElPTixuLHIpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxlLG4scik7fSxlLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZT1mdW5jdGlvbihlLG4scil7dGhpcy5jaGVja0lzVGFyZ2V0KGUsby5SRVBFVElUSU9OX01BTkRBVE9SWSxuLHIpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxlLG4scik7fSxlLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcD1mdW5jdGlvbihlLG4scil7dGhpcy5jaGVja0lzVGFyZ2V0KGUsby5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUixuLHIpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxlLG4scik7fSxlLnByb3RvdHlwZS53YWxrTWFueT1mdW5jdGlvbihlLG4scil7dGhpcy5jaGVja0lzVGFyZ2V0KGUsby5SRVBFVElUSU9OLG4scil8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLGUsbixyKTt9LGUucHJvdG90eXBlLndhbGtNYW55U2VwPWZ1bmN0aW9uKGUsbixyKXt0aGlzLmNoZWNrSXNUYXJnZXQoZSxvLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsbixyKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsZSxuLHIpO30sZX0odS5SZXN0V2Fsa2VyKSxmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIudGFyZ2V0T2NjdXJyZW5jZT1lLHIudGFyZ2V0UHJvZFR5cGU9bixyLnJlc3VsdD1bXSxyfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuY2hlY2tJc1RhcmdldD1mdW5jdGlvbih0LGUpe3QuaWR4PT09dGhpcy50YXJnZXRPY2N1cnJlbmNlJiZ0aGlzLnRhcmdldFByb2RUeXBlPT09ZSYmKHRoaXMucmVzdWx0PXQuZGVmaW5pdGlvbik7fSxlLnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLk9QVElPTik7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5SRVBFVElUSU9OKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLlJFUEVUSVRJT05fTUFOREFUT1JZKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUik7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUik7fSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uQUxURVJOQVRJT04pO30sZX0obC5HQXN0VmlzaXRvcik7ZnVuY3Rpb24gZCh0LGUpe2Z1bmN0aW9uIG4odCxlKXtyZXR1cm4gYS5yZWR1Y2UodCxmdW5jdGlvbih0LG4scil7aWYociE9PWUpe3ZhciBpPWEubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIHQucGFydGlhbFBhdGh9KTtyZXR1cm4gdC5jb25jYXQoaSl9cmV0dXJuIHR9LFtdKX1mdW5jdGlvbiByKHQsZSl7cmV0dXJuIHZvaWQgMD09PWEuZmluZCh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmV2ZXJ5KGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4gcj1lLGk9dFtuXSxyPT09aXx8ciYmaSYmKHIuY2F0ZWdvcnlNYXRjaGVzTWFwW2kudG9rZW5UeXBlSWR4XXx8aS5jYXRlZ29yeU1hdGNoZXNNYXBbci50b2tlblR5cGVJZHhdKTt2YXIgcixpO30pfSl9ZnVuY3Rpb24gaSh0KXtmb3IodmFyIGU9W10sbj0wO248dDtuKyspZS5wdXNoKFtdKTtyZXR1cm4gZX1mb3IodmFyIG89YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gcy5wb3NzaWJsZVBhdGhzRnJvbShbdF0sMSl9KSx1PWkoby5sZW5ndGgpLGM9byxwPTE7cDw9ZTtwKyspe3ZhciBsPWM7Yz1pKGwubGVuZ3RoKTtmb3IodmFyIGg9MDtoPGwubGVuZ3RoO2grKylmb3IodmFyIGY9bFtoXSxkPW4obCxoKSxFPTA7RTxmLmxlbmd0aDtFKyspe3ZhciBtPWZbRV0ucGFydGlhbFBhdGgsVD1mW0VdLnN1ZmZpeERlZjtpZihyKGQsbSl8fGEuaXNFbXB0eShUKXx8bS5sZW5ndGg9PT1lKXt2YXIgdj11W2hdO3kodixtKXx8di5wdXNoKG0pO31lbHNlIHt2YXIgZz1zLnBvc3NpYmxlUGF0aHNGcm9tKFQscCsxLG0pO2NbaF09Y1toXS5jb25jYXQoZyk7fX19cmV0dXJuIHV9ZnVuY3Rpb24gRSh0LGUsbil7dmFyIHI9bmV3IGYodCxvLkFMVEVSTkFUSU9OKTtyZXR1cm4gZS5hY2NlcHQociksZChyLnJlc3VsdCxuKX1mdW5jdGlvbiBtKHQsZSxuLHIpe3ZhciBpPW5ldyBmKHQsbik7ZS5hY2NlcHQoaSk7dmFyIG89aS5yZXN1bHQsYT1uZXcgaChlLHQsbikuc3RhcnRXYWxraW5nKCk7cmV0dXJuIGQoW25ldyBwLkZsYXQoe2RlZmluaXRpb246b30pLG5ldyBwLkZsYXQoe2RlZmluaXRpb246YX0pXSxyKX1mdW5jdGlvbiB5KHQsZSl7cmV0dXJuIHZvaWQgMCE9PWEuZmluZCh0LGZ1bmN0aW9uKHQpe3JldHVybiBlLmxlbmd0aD09PXQubGVuZ3RoJiZhLmV2ZXJ5KGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4gZT09PXRbbl18fHRbbl0uY2F0ZWdvcnlNYXRjaGVzTWFwW2UudG9rZW5UeXBlSWR4XX0pfSl9ZnVuY3Rpb24gVCh0KXtyZXR1cm4gYS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5pc0VtcHR5KHQuY2F0ZWdvcnlNYXRjaGVzKX0pfSl9KX1lLmxvb2tBaGVhZFNlcXVlbmNlRnJvbUFsdGVybmF0aXZlcz1kLGUuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcj1FLGUuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Q9bSxlLmNvbnRhaW5zUGF0aD15LGUuaXNTdHJpY3RQcmVmaXhPZlBhdGg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5sZW5ndGg8ZS5sZW5ndGgmJmEuZXZlcnkodCxmdW5jdGlvbih0LG4pe3ZhciByPWVbbl07cmV0dXJuIHQ9PT1yfHxyLmNhdGVnb3J5TWF0Y2hlc01hcFt0LnRva2VuVHlwZUlkeF19KX0sZS5hcmVUb2tlbkNhdGVnb3JpZXNOb3RVc2VkPVQ7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDE0KSxhPW4oMCkscz1uKDIpLHU9bigyMSksYz1uKDEpLHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci50b3BQcm9kPWUsci5wYXRoPW4sci5wb3NzaWJsZVRva1R5cGVzPVtdLHIubmV4dFByb2R1Y3Rpb25OYW1lPVwiXCIsci5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2U9MCxyLmZvdW5kPSExLHIuaXNBdEVuZE9mUGF0aD0hMSxyfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuc3RhcnRXYWxraW5nPWZ1bmN0aW9uKCl7aWYodGhpcy5mb3VuZD0hMSx0aGlzLnBhdGgucnVsZVN0YWNrWzBdIT09dGhpcy50b3BQcm9kLm5hbWUpdGhyb3cgRXJyb3IoXCJUaGUgcGF0aCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSB3YWxrZXIncyB0b3AgUnVsZSFcIik7cmV0dXJuIHRoaXMucnVsZVN0YWNrPWEuY2xvbmVBcnIodGhpcy5wYXRoLnJ1bGVTdGFjaykucmV2ZXJzZSgpLHRoaXMub2NjdXJyZW5jZVN0YWNrPWEuY2xvbmVBcnIodGhpcy5wYXRoLm9jY3VycmVuY2VTdGFjaykucmV2ZXJzZSgpLHRoaXMucnVsZVN0YWNrLnBvcCgpLHRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpLHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCksdGhpcy53YWxrKHRoaXMudG9wUHJvZCksdGhpcy5wb3NzaWJsZVRva1R5cGVzfSxlLnByb3RvdHlwZS53YWxrPWZ1bmN0aW9uKGUsbil7dm9pZCAwPT09biYmKG49W10pLHRoaXMuZm91bmR8fHQucHJvdG90eXBlLndhbGsuY2FsbCh0aGlzLGUsbik7fSxlLnByb3RvdHlwZS53YWxrUHJvZFJlZj1mdW5jdGlvbih0LGUsbil7aWYodC5yZWZlcmVuY2VkUnVsZS5uYW1lPT09dGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUmJnQuaWR4PT09dGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2Upe3ZhciByPWUuY29uY2F0KG4pO3RoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCksdGhpcy53YWxrKHQucmVmZXJlbmNlZFJ1bGUscik7fX0sZS5wcm90b3R5cGUudXBkYXRlRXhwZWN0ZWROZXh0PWZ1bmN0aW9uKCl7YS5pc0VtcHR5KHRoaXMucnVsZVN0YWNrKT8odGhpcy5uZXh0UHJvZHVjdGlvbk5hbWU9XCJcIix0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZT0wLHRoaXMuaXNBdEVuZE9mUGF0aD0hMCk6KHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lPXRoaXMucnVsZVN0YWNrLnBvcCgpLHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlPXRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpKTt9LGV9KG8uUmVzdFdhbGtlcik7ZS5BYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlcj1wO3ZhciBsPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuKXt2YXIgcj10LmNhbGwodGhpcyxlLG4pfHx0aGlzO3JldHVybiByLnBhdGg9bixyLm5leHRUZXJtaW5hbE5hbWU9XCJcIixyLm5leHRUZXJtaW5hbE9jY3VycmVuY2U9MCxyLm5leHRUZXJtaW5hbE5hbWU9cy50b2tlbk5hbWUoci5wYXRoLmxhc3RUb2spLHIubmV4dFRlcm1pbmFsT2NjdXJyZW5jZT1yLnBhdGgubGFzdFRva09jY3VycmVuY2Uscn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLndhbGtUZXJtaW5hbD1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5pc0F0RW5kT2ZQYXRoJiZzLnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSk9PT10aGlzLm5leHRUZXJtaW5hbE5hbWUmJnQuaWR4PT09dGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlJiYhdGhpcy5mb3VuZCl7dmFyIHI9ZS5jb25jYXQobiksaT1uZXcgYy5GbGF0KHtkZWZpbml0aW9uOnJ9KTt0aGlzLnBvc3NpYmxlVG9rVHlwZXM9dS5maXJzdChpKSx0aGlzLmZvdW5kPSEwO319LGV9KHApO2UuTmV4dEFmdGVyVG9rZW5XYWxrZXI9bDt2YXIgaD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbil7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLnRvcFJ1bGU9ZSxyLm9jY3VycmVuY2U9bixyLnJlc3VsdD17dG9rZW46dm9pZCAwLG9jY3VycmVuY2U6dm9pZCAwLGlzRW5kT2ZSdWxlOnZvaWQgMH0scn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnN0YXJ0V2Fsa2luZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhbGsodGhpcy50b3BSdWxlKSx0aGlzLnJlc3VsdH0sZX0oby5SZXN0V2Fsa2VyKTtlLkFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyPWg7dmFyIGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS53YWxrTWFueT1mdW5jdGlvbihlLG4scil7aWYoZS5pZHg9PT10aGlzLm9jY3VycmVuY2Upe3ZhciBpPWEuZmlyc3Qobi5jb25jYXQocikpO3RoaXMucmVzdWx0LmlzRW5kT2ZSdWxlPXZvaWQgMD09PWksaSBpbnN0YW5jZW9mIGMuVGVybWluYWwmJih0aGlzLnJlc3VsdC50b2tlbj1pLnRlcm1pbmFsVHlwZSx0aGlzLnJlc3VsdC5vY2N1cnJlbmNlPWkuaWR4KTt9ZWxzZSB0LnByb3RvdHlwZS53YWxrTWFueS5jYWxsKHRoaXMsZSxuLHIpO30sZX0oaCk7ZS5OZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXI9Zjt2YXIgZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLndhbGtNYW55U2VwPWZ1bmN0aW9uKGUsbixyKXtpZihlLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGk9YS5maXJzdChuLmNvbmNhdChyKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9dm9pZCAwPT09aSxpIGluc3RhbmNlb2YgYy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWkudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9aS5pZHgpO31lbHNlIHQucHJvdG90eXBlLndhbGtNYW55U2VwLmNhbGwodGhpcyxlLG4scik7fSxlfShoKTtlLk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcj1kO3ZhciBFPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmU9ZnVuY3Rpb24oZSxuLHIpe2lmKGUuaWR4PT09dGhpcy5vY2N1cnJlbmNlKXt2YXIgaT1hLmZpcnN0KG4uY29uY2F0KHIpKTt0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZT12b2lkIDA9PT1pLGkgaW5zdGFuY2VvZiBjLlRlcm1pbmFsJiYodGhpcy5yZXN1bHQudG9rZW49aS50ZXJtaW5hbFR5cGUsdGhpcy5yZXN1bHQub2NjdXJyZW5jZT1pLmlkeCk7fWVsc2UgdC5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmUuY2FsbCh0aGlzLGUsbixyKTt9LGV9KGgpO2UuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyPUU7dmFyIG09ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcD1mdW5jdGlvbihlLG4scil7aWYoZS5pZHg9PT10aGlzLm9jY3VycmVuY2Upe3ZhciBpPWEuZmlyc3Qobi5jb25jYXQocikpO3RoaXMucmVzdWx0LmlzRW5kT2ZSdWxlPXZvaWQgMD09PWksaSBpbnN0YW5jZW9mIGMuVGVybWluYWwmJih0aGlzLnJlc3VsdC50b2tlbj1pLnRlcm1pbmFsVHlwZSx0aGlzLnJlc3VsdC5vY2N1cnJlbmNlPWkuaWR4KTt9ZWxzZSB0LnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZVNlcC5jYWxsKHRoaXMsZSxuLHIpO30sZX0oaCk7ZnVuY3Rpb24geSh0LGUsbixyKXt2YXIgaT1hLmNsb25lQXJyKG4pO2kucHVzaCh0Lm5hbWUpO3ZhciBvPWEuY2xvbmVBcnIocik7cmV0dXJuIG8ucHVzaCgxKSx7aWR4OmUsZGVmOnQuZGVmaW5pdGlvbixydWxlU3RhY2s6aSxvY2N1cnJlbmNlU3RhY2s6b319ZS5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXI9bSxlLnBvc3NpYmxlUGF0aHNGcm9tPWZ1bmN0aW9uIHQoZSxuLHIpe3ZvaWQgMD09PXImJihyPVtdKSxyPWEuY2xvbmVBcnIocik7dmFyIGk9W10sbz0wO2Z1bmN0aW9uIHMocyl7dmFyIHU9dChzLmNvbmNhdChhLmRyb3AoZSxvKzEpKSxuLHIpO3JldHVybiBpLmNvbmNhdCh1KX1mb3IoO3IubGVuZ3RoPG4mJm88ZS5sZW5ndGg7KXt2YXIgdT1lW29dO2lmKHUgaW5zdGFuY2VvZiBjLkZsYXQpcmV0dXJuIHModS5kZWZpbml0aW9uKTtpZih1IGluc3RhbmNlb2YgYy5Ob25UZXJtaW5hbClyZXR1cm4gcyh1LmRlZmluaXRpb24pO2lmKHUgaW5zdGFuY2VvZiBjLk9wdGlvbilpPXModS5kZWZpbml0aW9uKTtlbHNlIHtpZih1IGluc3RhbmNlb2YgYy5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVybiBzKHA9dS5kZWZpbml0aW9uLmNvbmNhdChbbmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjp1LmRlZmluaXRpb259KV0pKTtpZih1IGluc3RhbmNlb2YgYy5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcilyZXR1cm4gcyhwPVtuZXcgYy5GbGF0KHtkZWZpbml0aW9uOnUuZGVmaW5pdGlvbn0pLG5ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246W25ldyBjLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6dS5zZXBhcmF0b3J9KV0uY29uY2F0KHUuZGVmaW5pdGlvbil9KV0pO2lmKHUgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXt2YXIgcD11LmRlZmluaXRpb24uY29uY2F0KFtuZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltuZXcgYy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOnUuc2VwYXJhdG9yfSldLmNvbmNhdCh1LmRlZmluaXRpb24pfSldKTtpPXMocCk7fWVsc2UgaWYodSBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbilwPXUuZGVmaW5pdGlvbi5jb25jYXQoW25ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246dS5kZWZpbml0aW9ufSldKSxpPXMocCk7ZWxzZSB7aWYodSBpbnN0YW5jZW9mIGMuQWx0ZXJuYXRpb24pcmV0dXJuIGEuZm9yRWFjaCh1LmRlZmluaXRpb24sZnVuY3Rpb24odCl7aT1zKHQuZGVmaW5pdGlvbik7fSksaTtpZighKHUgaW5zdGFuY2VvZiBjLlRlcm1pbmFsKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO3IucHVzaCh1LnRlcm1pbmFsVHlwZSk7fX1vKys7fXJldHVybiBpLnB1c2goe3BhcnRpYWxQYXRoOnIsc3VmZml4RGVmOmEuZHJvcChlLG8pfSksaX0sZS5uZXh0UG9zc2libGVUb2tlbnNBZnRlcj1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1bXCJFWElUX05PTkVfVEVSTUlOQUxcIl0sbz0hMSxzPWUubGVuZ3RoLHU9cy1yLTEscD1bXSxsPVtdO2ZvcihsLnB1c2goe2lkeDotMSxkZWY6dCxydWxlU3RhY2s6W10sb2NjdXJyZW5jZVN0YWNrOltdfSk7IWEuaXNFbXB0eShsKTspe3ZhciBoPWwucG9wKCk7aWYoXCJFWElUX0FMVEVSTkFUSVZFXCIhPT1oKXt2YXIgZj1oLmRlZixkPWguaWR4LEU9aC5ydWxlU3RhY2ssbT1oLm9jY3VycmVuY2VTdGFjaztpZighYS5pc0VtcHR5KGYpKXt2YXIgVD1mWzBdO2lmKFwiRVhJVF9OT05FX1RFUk1JTkFMXCI9PT1UKXt2YXIgdj17aWR4OmQsZGVmOmEuZHJvcChmKSxydWxlU3RhY2s6YS5kcm9wUmlnaHQoRSksb2NjdXJyZW5jZVN0YWNrOmEuZHJvcFJpZ2h0KG0pfTtsLnB1c2godik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuVGVybWluYWwpaWYoZDxzLTEpe3ZhciBnPWQrMTtuKGVbZ10sVC50ZXJtaW5hbFR5cGUpJiYodj17aWR4OmcsZGVmOmEuZHJvcChmKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKHYpKTt9ZWxzZSB7aWYoZCE9PXMtMSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO3AucHVzaCh7bmV4dFRva2VuVHlwZTpULnRlcm1pbmFsVHlwZSxuZXh0VG9rZW5PY2N1cnJlbmNlOlQuaWR4LHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSksbz0hMDt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5Ob25UZXJtaW5hbCl7dmFyIF89YS5jbG9uZUFycihFKTtfLnB1c2goVC5ub25UZXJtaW5hbE5hbWUpO3ZhciBSPWEuY2xvbmVBcnIobSk7Ui5wdXNoKFQuaWR4KSx2PXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChpLGEuZHJvcChmKSkscnVsZVN0YWNrOl8sb2NjdXJyZW5jZVN0YWNrOlJ9LGwucHVzaCh2KTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5PcHRpb24pe3ZhciBBPXtpZHg6ZCxkZWY6YS5kcm9wKGYpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfTtsLnB1c2goQSksbC5wdXNoKFwiRVhJVF9BTFRFUk5BVElWRVwiKTt2YXIgTj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX07bC5wdXNoKE4pO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25NYW5kYXRvcnkpe3ZhciBPPW5ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246VC5kZWZpbml0aW9uLGlkeDpULmlkeH0pO3Y9e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KFtPXSxhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2godik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Ipe3ZhciBTPW5ldyBjLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6VC5zZXBhcmF0b3J9KTtPPW5ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246W1NdLmNvbmNhdChULmRlZmluaXRpb24pLGlkeDpULmlkeH0pLHY9e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KFtPXSxhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2godik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Ipe0E9e2lkeDpkLGRlZjphLmRyb3AoZikscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaChBKSxsLnB1c2goXCJFWElUX0FMVEVSTkFUSVZFXCIpLFM9bmV3IGMuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTpULnNlcGFyYXRvcn0pO3ZhciBJPW5ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246W1NdLmNvbmNhdChULmRlZmluaXRpb24pLGlkeDpULmlkeH0pO049e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KFtJXSxhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2goTik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbilBPXtpZHg6ZCxkZWY6YS5kcm9wKGYpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2goQSksbC5wdXNoKFwiRVhJVF9BTFRFUk5BVElWRVwiKSxJPW5ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246VC5kZWZpbml0aW9uLGlkeDpULmlkeH0pLE49e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KFtJXSxhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2goTik7ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5BbHRlcm5hdGlvbilmb3IodmFyIEw9VC5kZWZpbml0aW9uLmxlbmd0aC0xO0w+PTA7TC0tKXt2YXIgaz17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbltMXS5kZWZpbml0aW9uLmNvbmNhdChhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfTtsLnB1c2goayksbC5wdXNoKFwiRVhJVF9BTFRFUk5BVElWRVwiKTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5GbGF0KWwucHVzaCh7aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoYS5kcm9wKGYpKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0pO2Vsc2Uge2lmKCEoVCBpbnN0YW5jZW9mIGMuUnVsZSkpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtsLnB1c2goeShULGQsRSxtKSk7fX19ZWxzZSBvJiZhLmxhc3QobCkuaWR4PD11JiZsLnBvcCgpO31yZXR1cm4gcH07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oMSksbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLndhbGs9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3ZvaWQgMD09PWUmJihlPVtdKSxyLmZvckVhY2godC5kZWZpbml0aW9uLGZ1bmN0aW9uKG8sYSl7dmFyIHM9ci5kcm9wKHQuZGVmaW5pdGlvbixhKzEpO2lmKG8gaW5zdGFuY2VvZiBpLk5vblRlcm1pbmFsKW4ud2Fsa1Byb2RSZWYobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuVGVybWluYWwpbi53YWxrVGVybWluYWwobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuRmxhdCluLndhbGtGbGF0KG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLk9wdGlvbiluLndhbGtPcHRpb24obyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuUmVwZXRpdGlvbk1hbmRhdG9yeSluLndhbGtBdExlYXN0T25lKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKW4ud2Fsa0F0TGVhc3RPbmVTZXAobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Ipbi53YWxrTWFueVNlcChvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5SZXBldGl0aW9uKW4ud2Fsa01hbnkobyxzLGUpO2Vsc2Uge2lmKCEobyBpbnN0YW5jZW9mIGkuQWx0ZXJuYXRpb24pKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7bi53YWxrT3IobyxzLGUpO319KTt9LHQucHJvdG90eXBlLndhbGtUZXJtaW5hbD1mdW5jdGlvbih0LGUsbil7fSx0LnByb3RvdHlwZS53YWxrUHJvZFJlZj1mdW5jdGlvbih0LGUsbil7fSx0LnByb3RvdHlwZS53YWxrRmxhdD1mdW5jdGlvbih0LGUsbil7dmFyIHI9ZS5jb25jYXQobik7dGhpcy53YWxrKHQscik7fSx0LnByb3RvdHlwZS53YWxrT3B0aW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1lLmNvbmNhdChuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bbmV3IGkuT3B0aW9uKHtkZWZpbml0aW9uOnQuZGVmaW5pdGlvbn0pXS5jb25jYXQoZSxuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hKHQsZSxuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bbmV3IGkuT3B0aW9uKHtkZWZpbml0aW9uOnQuZGVmaW5pdGlvbn0pXS5jb25jYXQoZSxuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtNYW55U2VwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hKHQsZSxuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtPcj1mdW5jdGlvbih0LGUsbil7dmFyIG89dGhpcyxhPWUuY29uY2F0KG4pO3IuZm9yRWFjaCh0LmRlZmluaXRpb24sZnVuY3Rpb24odCl7dmFyIGU9bmV3IGkuRmxhdCh7ZGVmaW5pdGlvbjpbdF19KTtvLndhbGsoZSxhKTt9KTt9LHR9KCk7ZnVuY3Rpb24gYSh0LGUsbil7cmV0dXJuIFtuZXcgaS5PcHRpb24oe2RlZmluaXRpb246W25ldyBpLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6dC5zZXBhcmF0b3J9KV0uY29uY2F0KHQuZGVmaW5pdGlvbil9KV0uY29uY2F0KGUsbil9ZS5SZXN0V2Fsa2VyPW87fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigyNyksaT1uKDApLG89big3KSxhPW4oMjApOyFmdW5jdGlvbih0KXt0W3QuTUlTU0lOR19QQVRURVJOPTBdPVwiTUlTU0lOR19QQVRURVJOXCIsdFt0LklOVkFMSURfUEFUVEVSTj0xXT1cIklOVkFMSURfUEFUVEVSTlwiLHRbdC5FT0lfQU5DSE9SX0ZPVU5EPTJdPVwiRU9JX0FOQ0hPUl9GT1VORFwiLHRbdC5VTlNVUFBPUlRFRF9GTEFHU19GT1VORD0zXT1cIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCIsdFt0LkRVUExJQ0FURV9QQVRURVJOU19GT1VORD00XT1cIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiLHRbdC5JTlZBTElEX0dST1VQX1RZUEVfRk9VTkQ9NV09XCJJTlZBTElEX0dST1VQX1RZUEVfRk9VTkRcIix0W3QuUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUPTZdPVwiUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUXCIsdFt0Lk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREU9N109XCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXCIsdFt0Lk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWT04XT1cIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVwiLHRbdC5NVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVD05XT1cIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCIsdFt0LkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEPTEwXT1cIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsdFt0LlNPSV9BTkNIT1JfRk9VTkQ9MTFdPVwiU09JX0FOQ0hPUl9GT1VORFwiLHRbdC5FTVBUWV9NQVRDSF9QQVRURVJOPTEyXT1cIkVNUFRZX01BVENIX1BBVFRFUk5cIix0W3QuTk9fTElORV9CUkVBS1NfRkxBR1M9MTNdPVwiTk9fTElORV9CUkVBS1NfRkxBR1NcIix0W3QuVU5SRUFDSEFCTEVfUEFUVEVSTj0xNF09XCJVTlJFQUNIQUJMRV9QQVRURVJOXCIsdFt0LklERU5USUZZX1RFUk1JTkFUT1I9MTVdPVwiSURFTlRJRllfVEVSTUlOQVRPUlwiLHRbdC5DVVNUT01fTElORV9CUkVBSz0xNl09XCJDVVNUT01fTElORV9CUkVBS1wiO30oZS5MZXhlckRlZmluaXRpb25FcnJvclR5cGV8fChlLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZT17fSkpO3ZhciBzPXtkZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZzohMSxwb3NpdGlvblRyYWNraW5nOlwiZnVsbFwiLGxpbmVUZXJtaW5hdG9yc1BhdHRlcm46L1xcbnxcXHJcXG4/L2csbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOltcIlxcblwiLFwiXFxyXCJdLGVuc3VyZU9wdGltaXphdGlvbnM6ITEsc2FmZU1vZGU6ITEsZXJyb3JNZXNzYWdlUHJvdmlkZXI6YS5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyfTtPYmplY3QuZnJlZXplKHMpO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPXRoaXM7aWYodm9pZCAwPT09ZSYmKGU9cyksdGhpcy5sZXhlckRlZmluaXRpb249dCx0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycz1bXSx0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmc9W10sdGhpcy5wYXR0ZXJuSWR4VG9Db25maWc9e30sdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnPXt9LHRoaXMubW9kZXM9W10sdGhpcy5lbXB0eUdyb3Vwcz17fSx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy50cmFja1N0YXJ0TGluZXM9ITAsdGhpcy50cmFja0VuZExpbmVzPSEwLHRoaXMuaGFzQ3VzdG9tPSExLHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkPXt9LFwiYm9vbGVhblwiPT10eXBlb2YgZSl0aHJvdyBFcnJvcihcIlRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExleGVyIGNvbnN0cnVjdG9yIGlzIG5vdyBhbiBJTGV4ZXJDb25maWcgT2JqZWN0LlxcbmEgYm9vbGVhbiAybmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTtpZih0aGlzLmNvbmZpZz1pLm1lcmdlKHMsZSksdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybj09PXMubGluZVRlcm1pbmF0b3JzUGF0dGVybil0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuPXIuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI7ZWxzZSBpZih0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnM9PT1zLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyl0aHJvdyBFcnJvcihcIkVycm9yOiBNaXNzaW5nIDxsaW5lVGVybWluYXRvckNoYXJhY3RlcnM+IHByb3BlcnR5IG9uIHRoZSBMZXhlciBjb25maWcuXFxuXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNNSVNTSU5HX0xJTkVfVEVSTV9DSEFSU1wiKTtpZihlLnNhZmVNb2RlJiZlLmVuc3VyZU9wdGltaXphdGlvbnMpdGhyb3cgRXJyb3IoJ1wic2FmZU1vZGVcIiBhbmQgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTt0aGlzLnRyYWNrU3RhcnRMaW5lcz0vZnVsbHxvbmx5U3RhcnQvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpLHRoaXMudHJhY2tFbmRMaW5lcz0vZnVsbC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7dmFyIGEsdT0hMDtpLmlzQXJyYXkodCk/KChhPXttb2Rlczp7fX0pLm1vZGVzW3IuREVGQVVMVF9NT0RFXT1pLmNsb25lQXJyKHQpLGFbci5ERUZBVUxUX01PREVdPXIuREVGQVVMVF9NT0RFKToodT0hMSxhPWkuY2xvbmVPYmoodCkpLHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzPXRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChyLnBlcmZvcm1SdW50aW1lQ2hlY2tzKGEsdGhpcy50cmFja1N0YXJ0TGluZXMsdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSksdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nPXRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZy5jb25jYXQoci5wZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MoYSx0aGlzLnRyYWNrU3RhcnRMaW5lcyx0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKSxhLm1vZGVzPWEubW9kZXM/YS5tb2Rlczp7fSxpLmZvckVhY2goYS5tb2RlcyxmdW5jdGlvbih0LGUpe2EubW9kZXNbZV09aS5yZWplY3QodCxmdW5jdGlvbih0KXtyZXR1cm4gaS5pc1VuZGVmaW5lZCh0KX0pO30pO3ZhciBjPWkua2V5cyhhLm1vZGVzKTtpZihpLmZvckVhY2goYS5tb2RlcyxmdW5jdGlvbih0LGEpe2lmKG4ubW9kZXMucHVzaChhKSxuLmxleGVyRGVmaW5pdGlvbkVycm9ycz1uLmxleGVyRGVmaW5pdGlvbkVycm9ycy5jb25jYXQoci52YWxpZGF0ZVBhdHRlcm5zKHQsYykpLGkuaXNFbXB0eShuLmxleGVyRGVmaW5pdGlvbkVycm9ycykpe28uYXVnbWVudFRva2VuVHlwZXModCk7dmFyIHM9ci5hbmFseXplVG9rZW5UeXBlcyh0LHtsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6bi5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzLHBvc2l0aW9uVHJhY2tpbmc6ZS5wb3NpdGlvblRyYWNraW5nLGVuc3VyZU9wdGltaXphdGlvbnM6ZS5lbnN1cmVPcHRpbWl6YXRpb25zLHNhZmVNb2RlOmUuc2FmZU1vZGV9KTtuLnBhdHRlcm5JZHhUb0NvbmZpZ1thXT1zLnBhdHRlcm5JZHhUb0NvbmZpZyxuLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbYV09cy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnLG4uZW1wdHlHcm91cHM9aS5tZXJnZShuLmVtcHR5R3JvdXBzLHMuZW1wdHlHcm91cHMpLG4uaGFzQ3VzdG9tPXMuaGFzQ3VzdG9tfHxuLmhhc0N1c3RvbSxuLmNhbk1vZGVCZU9wdGltaXplZFthXT1zLmNhbkJlT3B0aW1pemVkO319KSx0aGlzLmRlZmF1bHRNb2RlPWEuZGVmYXVsdE1vZGUsIWkuaXNFbXB0eSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykmJiF0aGlzLmNvbmZpZy5kZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZyl7dmFyIHA9aS5tYXAodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcnMgZGV0ZWN0ZWQgaW4gZGVmaW5pdGlvbiBvZiBMZXhlcjpcXG5cIitwKX1pZihpLmZvckVhY2godGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLGZ1bmN0aW9uKHQpe2kuUFJJTlRfV0FSTklORyh0Lm1lc3NhZ2UpO30pLHIuU1VQUE9SVF9TVElDS1k/KHRoaXMuY2hvcElucHV0PWkuSURFTlRJVFksdGhpcy5tYXRjaD10aGlzLm1hdGNoV2l0aFRlc3QpOih0aGlzLnVwZGF0ZUxhc3RJbmRleD1pLk5PT1AsdGhpcy5tYXRjaD10aGlzLm1hdGNoV2l0aEV4ZWMpLHUmJih0aGlzLmhhbmRsZU1vZGVzPWkuTk9PUCksITE9PT10aGlzLnRyYWNrU3RhcnRMaW5lcyYmKHRoaXMuY29tcHV0ZU5ld0NvbHVtbj1pLklERU5USVRZKSwhMT09PXRoaXMudHJhY2tFbmRMaW5lcyYmKHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb249aS5OT09QKSwvZnVsbC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlPXRoaXMuY3JlYXRlRnVsbFRva2VuO2Vsc2UgaWYoL29ubHlTdGFydC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlPXRoaXMuY3JlYXRlU3RhcnRPbmx5VG9rZW47ZWxzZSB7aWYoIS9vbmx5T2Zmc2V0L2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSl0aHJvdyBFcnJvcignSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXCInK3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcrJ1wiJyk7dGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlPXRoaXMuY3JlYXRlT2Zmc2V0T25seVRva2VuO310aGlzLmhhc0N1c3RvbT90aGlzLmFkZFRva2VuPXRoaXMuYWRkVG9rZW5Vc2luZ1B1c2g6dGhpcy5hZGRUb2tlbj10aGlzLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3M7dmFyIGw9aS5yZWR1Y2UodGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWQsZnVuY3Rpb24odCxlLG4pe3JldHVybiAhMT09PWUmJnQucHVzaChuKSx0fSxbXSk7aWYoZS5lbnN1cmVPcHRpbWl6YXRpb25zJiYhaS5pc0VtcHR5KGwpKXRocm93IEVycm9yKFwiTGV4ZXIgTW9kZXM6IDwgXCIrbC5qb2luKFwiLCBcIikrJyA+IGNhbm5vdCBiZSBvcHRpbWl6ZWQuXFxuXFx0IERpc2FibGUgdGhlIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGxleGVyIGNvbmZpZyBmbGFnIHRvIHNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBydW4gdGhlIGxleGVyIGluIGFuIHVuLW9wdGltaXplZCBtb2RlLlxcblxcdCBPciBpbnNwZWN0IHRoZSBjb25zb2xlIGxvZyBmb3IgZGV0YWlscyBvbiBob3cgdG8gcmVzb2x2ZSB0aGVzZSBpc3N1ZXMuJyl9cmV0dXJuIHQucHJvdG90eXBlLnRva2VuaXplPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9dGhpcy5kZWZhdWx0TW9kZSksIWkuaXNFbXB0eSh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycykpe3ZhciBuPWkubWFwKHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1lc3NhZ2V9KS5qb2luKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIik7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIFRva2VuaXplIGJlY2F1c2UgRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIrbil9cmV0dXJuIHRoaXMudG9rZW5pemVJbnRlcm5hbCh0LGUpfSx0LnByb3RvdHlwZS50b2tlbml6ZUludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG4sbyxhLHMsdSxjLHAsbCxoLGYsZCxFLG09dGhpcyx5PXQsVD15Lmxlbmd0aCx2PTAsZz0wLF89dGhpcy5oYXNDdXN0b20/MDpNYXRoLmZsb29yKHQubGVuZ3RoLzEwKSxSPW5ldyBBcnJheShfKSxBPVtdLE49dGhpcy50cmFja1N0YXJ0TGluZXM/MTp2b2lkIDAsTz10aGlzLnRyYWNrU3RhcnRMaW5lcz8xOnZvaWQgMCxTPXIuY2xvbmVFbXB0eUdyb3Vwcyh0aGlzLmVtcHR5R3JvdXBzKSxJPXRoaXMudHJhY2tTdGFydExpbmVzLEw9dGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybixrPTAsUD1bXSx4PVtdLEM9W10sTT1bXTtPYmplY3QuZnJlZXplKE0pO3ZhciBGLGI9dm9pZCAwLEQ9ZnVuY3Rpb24odCl7aWYoMT09PUMubGVuZ3RoJiZ2b2lkIDA9PT10LnRva2VuVHlwZS5QVVNIX01PREUpe3ZhciBlPW0uY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlKHQpO0EucHVzaCh7b2Zmc2V0OnQuc3RhcnRPZmZzZXQsbGluZTp2b2lkIDAhPT10LnN0YXJ0TGluZT90LnN0YXJ0TGluZTp2b2lkIDAsY29sdW1uOnZvaWQgMCE9PXQuc3RhcnRDb2x1bW4/dC5zdGFydENvbHVtbjp2b2lkIDAsbGVuZ3RoOnQuaW1hZ2UubGVuZ3RoLG1lc3NhZ2U6ZX0pO31lbHNlIHtDLnBvcCgpO3ZhciBuPWkubGFzdChDKTtQPW0ucGF0dGVybklkeFRvQ29uZmlnW25dLHg9bS5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25dLGs9UC5sZW5ndGg7dmFyIHI9bS5jYW5Nb2RlQmVPcHRpbWl6ZWRbbl0mJiExPT09bS5jb25maWcuc2FmZU1vZGU7Yj14JiZyP2Z1bmN0aW9uKHQpe3ZhciBlPXhbdF07cmV0dXJuIHZvaWQgMD09PWU/TTplfTpmdW5jdGlvbigpe3JldHVybiBQfTt9fTtmdW5jdGlvbiB3KHQpe0MucHVzaCh0KSx4PXRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1t0XSxQPXRoaXMucGF0dGVybklkeFRvQ29uZmlnW3RdLGs9UC5sZW5ndGgsaz1QLmxlbmd0aDt2YXIgZT10aGlzLmNhbk1vZGVCZU9wdGltaXplZFt0XSYmITE9PT10aGlzLmNvbmZpZy5zYWZlTW9kZTtiPXgmJmU/ZnVuY3Rpb24odCl7dmFyIGU9eFt0XTtyZXR1cm4gdm9pZCAwPT09ZT9NOmV9OmZ1bmN0aW9uKCl7cmV0dXJuIFB9O31mb3Iody5jYWxsKHRoaXMsZSk7djxUOyl7dT1udWxsO3ZhciBVPXkuY2hhckNvZGVBdCh2KSxHPWIoVSksQj1HLmxlbmd0aDtmb3Iobj0wO248QjtuKyspe3ZhciBLPShGPUdbbl0pLnBhdHRlcm47aWYoITEhPT0oWj1GLnNob3J0KT9VPT09WiYmKHU9Syk6ITA9PT1GLmlzQ3VzdG9tP3U9bnVsbCE9PShFPUsuZXhlYyh5LHYsUixTKSk/RVswXTpFOih0aGlzLnVwZGF0ZUxhc3RJbmRleChLLHYpLHU9dGhpcy5tYXRjaChLLHQsdikpLG51bGwhPT11KXtpZih2b2lkIDAhPT0ocz1GLmxvbmdlckFsdCkpe3ZhciBXPVBbc10saj1XLnBhdHRlcm47ITA9PT1XLmlzQ3VzdG9tP2E9bnVsbCE9PShFPWouZXhlYyh5LHYsUixTKSk/RVswXTpFOih0aGlzLnVwZGF0ZUxhc3RJbmRleChqLHYpLGE9dGhpcy5tYXRjaChqLHQsdikpLGEmJmEubGVuZ3RoPnUubGVuZ3RoJiYodT1hLEY9Vyk7fWJyZWFrfX1pZihudWxsIT09dSl7aWYoYz11Lmxlbmd0aCx2b2lkIDAhPT0ocD1GLmdyb3VwKSYmKGw9Ri50b2tlblR5cGVJZHgsaD10aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UodSx2LGwsRi50b2tlblR5cGUsTixPLGMpLCExPT09cD9nPXRoaXMuYWRkVG9rZW4oUixnLGgpOlNbcF0ucHVzaChoKSksdD10aGlzLmNob3BJbnB1dCh0LGMpLHYrPWMsTz10aGlzLmNvbXB1dGVOZXdDb2x1bW4oTyxjKSwhMD09PUkmJiEwPT09Ri5jYW5MaW5lVGVybWluYXRvcil7dmFyIFY9MCxZPXZvaWQgMCxIPXZvaWQgMDtMLmxhc3RJbmRleD0wO2RveyEwPT09KFk9TC50ZXN0KHUpKSYmKEg9TC5sYXN0SW5kZXgtMSxWKyspO313aGlsZShZKTswIT09ViYmKE4rPVYsTz1jLUgsdGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbihoLHAsSCxWLE4sTyxjKSk7fXRoaXMuaGFuZGxlTW9kZXMoRixELHcsaCk7fWVsc2Uge2Zvcih2YXIgWD12LHo9TixxPU8sJD0hMTshJCYmdjxUOylmb3IoeS5jaGFyQ29kZUF0KHYpLHQ9dGhpcy5jaG9wSW5wdXQodCwxKSx2Kyssbz0wO288aztvKyspe3ZhciBaLFE9UFtvXTtLPVEucGF0dGVybjtpZighMSE9PShaPVEuc2hvcnQpP3kuY2hhckNvZGVBdCh2KT09PVomJigkPSEwKTohMD09PVEuaXNDdXN0b20/JD1udWxsIT09Sy5leGVjKHksdixSLFMpOih0aGlzLnVwZGF0ZUxhc3RJbmRleChLLHYpLCQ9bnVsbCE9PUsuZXhlYyh0KSksITA9PT0kKWJyZWFrfWY9di1YLGQ9dGhpcy5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2UoeSxYLGYseixxKSxBLnB1c2goe29mZnNldDpYLGxpbmU6eixjb2x1bW46cSxsZW5ndGg6ZixtZXNzYWdlOmR9KTt9fXJldHVybiB0aGlzLmhhc0N1c3RvbXx8KFIubGVuZ3RoPWcpLHt0b2tlbnM6Uixncm91cHM6UyxlcnJvcnM6QX19LHQucHJvdG90eXBlLmhhbmRsZU1vZGVzPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKCEwPT09dC5wb3Ape3ZhciBpPXQucHVzaDtlKHIpLHZvaWQgMCE9PWkmJm4uY2FsbCh0aGlzLGkpO31lbHNlIHZvaWQgMCE9PXQucHVzaCYmbi5jYWxsKHRoaXMsdC5wdXNoKTt9LHQucHJvdG90eXBlLmNob3BJbnB1dD1mdW5jdGlvbih0LGUpe3JldHVybiB0LnN1YnN0cmluZyhlKX0sdC5wcm90b3R5cGUudXBkYXRlTGFzdEluZGV4PWZ1bmN0aW9uKHQsZSl7dC5sYXN0SW5kZXg9ZTt9LHQucHJvdG90eXBlLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uPWZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzLHU7dm9pZCAwIT09ZSYmKHU9KHM9bj09PWEtMSk/LTE6MCwxPT09ciYmITA9PT1zfHwodC5lbmRMaW5lPWkrdSx0LmVuZENvbHVtbj1vLTEtdSkpO30sdC5wcm90b3R5cGUuY29tcHV0ZU5ld0NvbHVtbj1mdW5jdGlvbih0LGUpe3JldHVybiB0K2V9LHQucHJvdG90eXBlLmNyZWF0ZVRva2VuSW5zdGFuY2U9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspdFtlXT1hcmd1bWVudHNbZV07cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLmNyZWF0ZU9mZnNldE9ubHlUb2tlbj1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4ge2ltYWdlOnQsc3RhcnRPZmZzZXQ6ZSx0b2tlblR5cGVJZHg6bix0b2tlblR5cGU6cn19LHQucHJvdG90eXBlLmNyZWF0ZVN0YXJ0T25seVRva2VuPWZ1bmN0aW9uKHQsZSxuLHIsaSxvKXtyZXR1cm4ge2ltYWdlOnQsc3RhcnRPZmZzZXQ6ZSxzdGFydExpbmU6aSxzdGFydENvbHVtbjpvLHRva2VuVHlwZUlkeDpuLHRva2VuVHlwZTpyfX0sdC5wcm90b3R5cGUuY3JlYXRlRnVsbFRva2VuPWZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3JldHVybiB7aW1hZ2U6dCxzdGFydE9mZnNldDplLGVuZE9mZnNldDplK2EtMSxzdGFydExpbmU6aSxlbmRMaW5lOmksc3RhcnRDb2x1bW46byxlbmRDb2x1bW46bythLTEsdG9rZW5UeXBlSWR4Om4sdG9rZW5UeXBlOnJ9fSx0LnByb3RvdHlwZS5hZGRUb2tlbj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIDY2Nn0sdC5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ1B1c2g9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0LnB1c2gobiksZX0sdC5wcm90b3R5cGUuYWRkVG9rZW5Vc2luZ01lbWJlckFjY2Vzcz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRbZV09biwrK2V9LHQucHJvdG90eXBlLm1hdGNoPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbnVsbH0sdC5wcm90b3R5cGUubWF0Y2hXaXRoVGVzdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuICEwPT09dC50ZXN0KGUpP2Uuc3Vic3RyaW5nKG4sdC5sYXN0SW5kZXgpOm51bGx9LHQucHJvdG90eXBlLm1hdGNoV2l0aEV4ZWM9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmV4ZWMoZSk7cmV0dXJuIG51bGwhPT1uP25bMF06bn0sdC5TS0lQUEVEPVwiVGhpcyBtYXJrcyBhIHNraXBwZWQgVG9rZW4gcGF0dGVybiwgdGhpcyBtZWFucyBlYWNoIHRva2VuIGlkZW50aWZpZWQgYnkgaXQgd2lsbGJlIGNvbnN1bWVkIGFuZCB0aGVuIHRocm93biBpbnRvIG9ibGl2aW9uLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGZvciBleGFtcGxlIHRvIGNvbXBsZXRlbHkgaWdub3JlIHdoaXRlc3BhY2UuXCIsdC5OQT0vTk9UX0FQUExJQ0FCTEUvLHR9KCk7ZS5MZXhlcj11O30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigwKSxhPW4oNCkscz1uKDkpLHU9bigxKSxjPW4oNSk7ZS5hZGRUZXJtaW5hbFRvQ3N0PWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT10LmNoaWxkcmVuW25dP3QuY2hpbGRyZW5bbl09W2VdOnQuY2hpbGRyZW5bbl0ucHVzaChlKTt9LGUuYWRkTm9uZVRlcm1pbmFsVG9Dc3Q9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PXQuY2hpbGRyZW5bZV0/dC5jaGlsZHJlbltlXT1bbl06dC5jaGlsZHJlbltlXS5wdXNoKG4pO307dmFyIHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ucmVzdWx0PVtdLG4ucnVsZUlkeD1lLG59cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5jb2xsZWN0TmFtZWREU0xNZXRob2Q9ZnVuY3Rpb24odCxlLG4pe2lmKCFvLmlzVW5kZWZpbmVkKHQubmFtZSkpe3ZhciByPXZvaWQgMDtpZih0IGluc3RhbmNlb2YgdS5PcHRpb258fHQgaW5zdGFuY2VvZiB1LlJlcGV0aXRpb258fHQgaW5zdGFuY2VvZiB1LlJlcGV0aXRpb25NYW5kYXRvcnl8fHQgaW5zdGFuY2VvZiB1LkFsdGVybmF0aW9uKXI9bmV3IGUoe2RlZmluaXRpb246dC5kZWZpbml0aW9uLGlkeDp0LmlkeH0pO2Vsc2Uge2lmKCEodCBpbnN0YW5jZW9mIHUuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3J8fHQgaW5zdGFuY2VvZiB1LlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO3I9bmV3IGUoe2RlZmluaXRpb246dC5kZWZpbml0aW9uLGlkeDp0LmlkeCxzZXBhcmF0b3I6dC5zZXBhcmF0b3J9KTt9dmFyIGk9W3JdLGE9cy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQodGhpcy5ydWxlSWR4LG4sdC5pZHgpO3RoaXMucmVzdWx0LnB1c2goe2RlZjppLGtleTphLG5hbWU6dC5uYW1lLG9yZ1Byb2Q6dH0pO319LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5PcHRpb24scy5PUFRJT05fSURYKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuUmVwZXRpdGlvbixzLk1BTllfSURYKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuUmVwZXRpdGlvbk1hbmRhdG9yeSxzLkFUX0xFQVNUX09ORV9JRFgpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iscy5BVF9MRUFTVF9PTkVfU0VQX0lEWCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcixzLk1BTllfU0VQX0lEWCk7fSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1LkFsdGVybmF0aW9uLHMuT1JfSURYKTt2YXIgbj10LmRlZmluaXRpb24ubGVuZ3RoPjE7by5mb3JFYWNoKHQuZGVmaW5pdGlvbixmdW5jdGlvbihyLGkpe2lmKCFvLmlzVW5kZWZpbmVkKHIubmFtZSkpe3ZhciBhPXIuZGVmaW5pdGlvbjthPW4/W25ldyB1Lk9wdGlvbih7ZGVmaW5pdGlvbjpyLmRlZmluaXRpb259KV06ci5kZWZpbml0aW9uO3ZhciBjPXMuZ2V0S2V5Rm9yQWx0SW5kZXgoZS5ydWxlSWR4LHMuT1JfSURYLHQuaWR4LGkpO2UucmVzdWx0LnB1c2goe2RlZjphLGtleTpjLG5hbWU6ci5uYW1lLG9yZ1Byb2Q6cn0pO319KTt9LGV9KGMuR0FzdFZpc2l0b3IpO2UuTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcj1wLGUuYW5hbHl6ZUNzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXtkaWN0RGVmOm5ldyBhLkhhc2hUYWJsZSxhbGxSdWxlTmFtZXM6W119O3JldHVybiBvLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgcj1lLmdldCh0Lm5hbWUpO24uYWxsUnVsZU5hbWVzLnB1c2godC5uYW1lKTt2YXIgaT1uZXcgcChyKTt0LmFjY2VwdChpKSxvLmZvckVhY2goaS5yZXN1bHQsZnVuY3Rpb24oZSl7ZS5kZWYsZS5rZXk7dmFyIHI9ZS5uYW1lO24uYWxsUnVsZU5hbWVzLnB1c2godC5uYW1lK3IpO30pO30pLG59O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVkVSU0lPTj1cIjQuNi4wXCI7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigzKSxpPW4oMTUpLG89bigyKSxhPW4oNikscz1uKDE3KSx1PW4oMTApLGM9bigzOSkscD1uKDUpLGw9bigxKSxoPW4oMjQpLGY9big0MCksZD1uKDIwKSxFPXt9O0UuVkVSU0lPTj1zLlZFUlNJT04sRS5QYXJzZXI9ci5QYXJzZXIsRS5Dc3RQYXJzZXI9ci5Dc3RQYXJzZXIsRS5FbWJlZGRlZEFjdGlvbnNQYXJzZXI9ci5FbWJlZGRlZEFjdGlvbnNQYXJzZXI7RS5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlPXIuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSxFLkxleGVyPWkuTGV4ZXIsRS5MZXhlckRlZmluaXRpb25FcnJvclR5cGU9aS5MZXhlckRlZmluaXRpb25FcnJvclR5cGUsRS5FT0Y9by5FT0YsRS50b2tlbk5hbWU9by50b2tlbk5hbWUsRS50b2tlbkxhYmVsPW8udG9rZW5MYWJlbCxFLnRva2VuTWF0Y2hlcj1vLnRva2VuTWF0Y2hlcixFLmNyZWF0ZVRva2VuPW8uY3JlYXRlVG9rZW4sRS5jcmVhdGVUb2tlbkluc3RhbmNlPW8uY3JlYXRlVG9rZW5JbnN0YW5jZSxFLkVNUFRZX0FMVD1yLkVNUFRZX0FMVCxFLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyPXUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIsRS5pc1JlY29nbml0aW9uRXhjZXB0aW9uPWEuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbixFLkVhcmx5RXhpdEV4Y2VwdGlvbj1hLkVhcmx5RXhpdEV4Y2VwdGlvbixFLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbj1hLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbixFLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uPWEuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24sRS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbj1hLk5vVmlhYmxlQWx0RXhjZXB0aW9uLEUuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcj1kLmRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIsRS5GbGF0PWwuRmxhdCxFLlJlcGV0aXRpb249bC5SZXBldGl0aW9uLEUuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9bC5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcixFLlJlcGV0aXRpb25NYW5kYXRvcnk9bC5SZXBldGl0aW9uTWFuZGF0b3J5LEUuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9bC5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcixFLk9wdGlvbj1sLk9wdGlvbixFLkFsdGVybmF0aW9uPWwuQWx0ZXJuYXRpb24sRS5Ob25UZXJtaW5hbD1sLk5vblRlcm1pbmFsLEUuVGVybWluYWw9bC5UZXJtaW5hbCxFLlJ1bGU9bC5SdWxlLEUuR0FzdFZpc2l0b3I9cC5HQXN0VmlzaXRvcixFLnNlcmlhbGl6ZUdyYW1tYXI9bC5zZXJpYWxpemVHcmFtbWFyLEUuc2VyaWFsaXplUHJvZHVjdGlvbj1sLnNlcmlhbGl6ZVByb2R1Y3Rpb24sRS5yZXNvbHZlR3JhbW1hcj1oLnJlc29sdmVHcmFtbWFyLEUuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXI9dS5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlcixFLnZhbGlkYXRlR3JhbW1hcj1oLnZhbGlkYXRlR3JhbW1hcixFLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcj11LmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixFLmFzc2lnbk9jY3VycmVuY2VJbmRpY2VzPWguYXNzaWduT2NjdXJyZW5jZUluZGljZXMsRS5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiVGhlIGNsZWFyQ2FjaGUgZnVuY3Rpb24gd2FzICdzb2Z0JyByZW1vdmVkIGZyb20gdGhlIENoZXZyb3RhaW4gQVBJLlxcblxcdCBJdCBwZXJmb3JtcyBubyBhY3Rpb24gb3RoZXIgdGhhbiBwcmludGluZyB0aGlzIG1lc3NhZ2UuXFxuXFx0IFBsZWFzZSBhdm9pZCB1c2luZyBpdCBhcyBpdCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXCIpO30sRS5jcmVhdGVTeW50YXhEaWFncmFtc0NvZGU9Yy5jcmVhdGVTeW50YXhEaWFncmFtc0NvZGUsRS5nZW5lcmF0ZVBhcnNlckZhY3Rvcnk9Zi5nZW5lcmF0ZVBhcnNlckZhY3RvcnksRS5nZW5lcmF0ZVBhcnNlck1vZHVsZT1mLmdlbmVyYXRlUGFyc2VyTW9kdWxlLHQuZXhwb3J0cz1FO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGksbztpPVtdLHZvaWQgMD09PShvPVwiZnVuY3Rpb25cIj09dHlwZW9mKHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXQucHJvdG90eXBlLnNhdmVTdGF0ZT1mdW5jdGlvbigpe3JldHVybiB7aWR4OnRoaXMuaWR4LGlucHV0OnRoaXMuaW5wdXQsZ3JvdXBJZHg6dGhpcy5ncm91cElkeH19LHQucHJvdG90eXBlLnJlc3RvcmVTdGF0ZT1mdW5jdGlvbih0KXt0aGlzLmlkeD10LmlkeCx0aGlzLmlucHV0PXQuaW5wdXQsdGhpcy5ncm91cElkeD10Lmdyb3VwSWR4O30sdC5wcm90b3R5cGUucGF0dGVybj1mdW5jdGlvbih0KXt0aGlzLmlkeD0wLHRoaXMuaW5wdXQ9dCx0aGlzLmdyb3VwSWR4PTAsdGhpcy5jb25zdW1lQ2hhcihcIi9cIik7dmFyIGU9dGhpcy5kaXNqdW5jdGlvbigpO3RoaXMuY29uc3VtZUNoYXIoXCIvXCIpO2Zvcih2YXIgbj17dHlwZTpcIkZsYWdzXCIsZ2xvYmFsOiExLGlnbm9yZUNhc2U6ITEsbXVsdGlMaW5lOiExLHVuaWNvZGU6ITEsc3RpY2t5OiExfTt0aGlzLmlzUmVnRXhwRmxhZygpOylzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcImdcIjpzKG4sXCJnbG9iYWxcIik7YnJlYWs7Y2FzZVwiaVwiOnMobixcImlnbm9yZUNhc2VcIik7YnJlYWs7Y2FzZVwibVwiOnMobixcIm11bHRpTGluZVwiKTticmVhaztjYXNlXCJ1XCI6cyhuLFwidW5pY29kZVwiKTticmVhaztjYXNlXCJ5XCI6cyhuLFwic3RpY2t5XCIpO31pZih0aGlzLmlkeCE9PXRoaXMuaW5wdXQubGVuZ3RoKXRocm93IEVycm9yKFwiUmVkdW5kYW50IGlucHV0OiBcIit0aGlzLmlucHV0LnN1YnN0cmluZyh0aGlzLmlkeCkpO3JldHVybiB7dHlwZTpcIlBhdHRlcm5cIixmbGFnczpuLHZhbHVlOmV9fSx0LnByb3RvdHlwZS5kaXNqdW5jdGlvbj1mdW5jdGlvbigpe3ZhciB0PVtdO2Zvcih0LnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKTtcInxcIj09PXRoaXMucGVla0NoYXIoKTspdGhpcy5jb25zdW1lQ2hhcihcInxcIiksdC5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSk7cmV0dXJuIHt0eXBlOlwiRGlzanVuY3Rpb25cIix2YWx1ZTp0fX0sdC5wcm90b3R5cGUuYWx0ZXJuYXRpdmU9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W107dGhpcy5pc1Rlcm0oKTspdC5wdXNoKHRoaXMudGVybSgpKTtyZXR1cm4ge3R5cGU6XCJBbHRlcm5hdGl2ZVwiLHZhbHVlOnR9fSx0LnByb3RvdHlwZS50ZXJtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNBc3NlcnRpb24oKT90aGlzLmFzc2VydGlvbigpOnRoaXMuYXRvbSgpfSx0LnByb3RvdHlwZS5hc3NlcnRpb249ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIl5cIjpyZXR1cm4ge3R5cGU6XCJTdGFydEFuY2hvclwifTtjYXNlXCIkXCI6cmV0dXJuIHt0eXBlOlwiRW5kQW5jaG9yXCJ9O2Nhc2VcIlxcXFxcIjpzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcImJcIjpyZXR1cm4ge3R5cGU6XCJXb3JkQm91bmRhcnlcIn07Y2FzZVwiQlwiOnJldHVybiB7dHlwZTpcIk5vbldvcmRCb3VuZGFyeVwifX10aHJvdyBFcnJvcihcIkludmFsaWQgQXNzZXJ0aW9uIEVzY2FwZVwiKTtjYXNlXCIoXCI6dmFyIHQ7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpLHRoaXMucG9wQ2hhcigpKXtjYXNlXCI9XCI6dD1cIkxvb2thaGVhZFwiO2JyZWFrO2Nhc2VcIiFcIjp0PVwiTmVnYXRpdmVMb29rYWhlYWRcIjt9dSh0KTt2YXIgZT10aGlzLmRpc2p1bmN0aW9uKCk7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCIpXCIpLHt0eXBlOnQsdmFsdWU6ZX19IWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIil9KCk7fSx0LnByb3RvdHlwZS5xdWFudGlmaWVyPWZ1bmN0aW9uKHQpe3ZhciBlO3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiKlwiOmU9e2F0TGVhc3Q6MCxhdE1vc3Q6MS8wfTticmVhaztjYXNlXCIrXCI6ZT17YXRMZWFzdDoxLGF0TW9zdDoxLzB9O2JyZWFrO2Nhc2VcIj9cIjplPXthdExlYXN0OjAsYXRNb3N0OjF9O2JyZWFrO2Nhc2VcIntcIjp2YXIgbj10aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKCk7c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJ9XCI6ZT17YXRMZWFzdDpuLGF0TW9zdDpufTticmVhaztjYXNlXCIsXCI6dmFyIHI7dGhpcy5pc0RpZ2l0KCk/KHI9dGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpLGU9e2F0TGVhc3Q6bixhdE1vc3Q6cn0pOmU9e2F0TGVhc3Q6bixhdE1vc3Q6MS8wfSx0aGlzLmNvbnN1bWVDaGFyKFwifVwiKTt9aWYoITA9PT10JiZ2b2lkIDA9PT1lKXJldHVybjt1KGUpO31pZighMCE9PXR8fHZvaWQgMCE9PWUpcmV0dXJuIHUoZSksXCI/XCI9PT10aGlzLnBlZWtDaGFyKDApPyh0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKSxlLmdyZWVkeT0hMSk6ZS5ncmVlZHk9ITAsZS50eXBlPVwiUXVhbnRpZmllclwiLGV9LHQucHJvdG90eXBlLmF0b209ZnVuY3Rpb24oKXt2YXIgdDtzd2l0Y2godGhpcy5wZWVrQ2hhcigpKXtjYXNlXCIuXCI6dD10aGlzLmRvdEFsbCgpO2JyZWFrO2Nhc2VcIlxcXFxcIjp0PXRoaXMuYXRvbUVzY2FwZSgpO2JyZWFrO2Nhc2VcIltcIjp0PXRoaXMuY2hhcmFjdGVyQ2xhc3MoKTticmVhaztjYXNlXCIoXCI6dD10aGlzLmdyb3VwKCk7fXJldHVybiB2b2lkIDA9PT10JiZ0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpJiYodD10aGlzLnBhdHRlcm5DaGFyYWN0ZXIoKSksdSh0KSx0aGlzLmlzUXVhbnRpZmllcigpJiYodC5xdWFudGlmaWVyPXRoaXMucXVhbnRpZmllcigpKSx0fSx0LnByb3RvdHlwZS5kb3RBbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIi5cIikse3R5cGU6XCJTZXRcIixjb21wbGVtZW50OiEwLHZhbHVlOltvKFwiXFxuXCIpLG8oXCJcXHJcIiksbyhcIlxcdTIwMjhcIiksbyhcIlxcdTIwMjlcIildfX0sdC5wcm90b3R5cGUuYXRvbUVzY2FwZT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKSx0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIjFcIjpjYXNlXCIyXCI6Y2FzZVwiM1wiOmNhc2VcIjRcIjpjYXNlXCI1XCI6Y2FzZVwiNlwiOmNhc2VcIjdcIjpjYXNlXCI4XCI6Y2FzZVwiOVwiOnJldHVybiB0aGlzLmRlY2ltYWxFc2NhcGVBdG9tKCk7Y2FzZVwiZFwiOmNhc2VcIkRcIjpjYXNlXCJzXCI6Y2FzZVwiU1wiOmNhc2VcIndcIjpjYXNlXCJXXCI6cmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKTtjYXNlXCJmXCI6Y2FzZVwiblwiOmNhc2VcInJcIjpjYXNlXCJ0XCI6Y2FzZVwidlwiOnJldHVybiB0aGlzLmNvbnRyb2xFc2NhcGVBdG9tKCk7Y2FzZVwiY1wiOnJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKCk7Y2FzZVwiMFwiOnJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKTtjYXNlXCJ4XCI6cmV0dXJuIHRoaXMuaGV4RXNjYXBlU2VxdWVuY2VBdG9tKCk7Y2FzZVwidVwiOnJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKTtkZWZhdWx0OnJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpfX0sdC5wcm90b3R5cGUuZGVjaW1hbEVzY2FwZUF0b209ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvc2l0aXZlSW50ZWdlcigpO3JldHVybiB7dHlwZTpcIkdyb3VwQmFja1JlZmVyZW5jZVwiLHZhbHVlOnR9fSx0LnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzc0VzY2FwZT1mdW5jdGlvbigpe3ZhciB0LGU9ITE7c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJkXCI6dD1jO2JyZWFrO2Nhc2VcIkRcIjp0PWMsZT0hMDticmVhaztjYXNlXCJzXCI6dD1sO2JyZWFrO2Nhc2VcIlNcIjp0PWwsZT0hMDticmVhaztjYXNlXCJ3XCI6dD1wO2JyZWFrO2Nhc2VcIldcIjp0PXAsZT0hMDt9cmV0dXJuIHUodCkse3R5cGU6XCJTZXRcIix2YWx1ZTp0LGNvbXBsZW1lbnQ6ZX19LHQucHJvdG90eXBlLmNvbnRyb2xFc2NhcGVBdG9tPWZ1bmN0aW9uKCl7dmFyIHQ7c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCJmXCI6dD1vKFwiXFxmXCIpO2JyZWFrO2Nhc2VcIm5cIjp0PW8oXCJcXG5cIik7YnJlYWs7Y2FzZVwiclwiOnQ9byhcIlxcclwiKTticmVhaztjYXNlXCJ0XCI6dD1vKFwiXFx0XCIpO2JyZWFrO2Nhc2VcInZcIjp0PW8oXCJcXHZcIik7fXJldHVybiB1KHQpLHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6dH19LHQucHJvdG90eXBlLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tPWZ1bmN0aW9uKCl7dGhpcy5jb25zdW1lQ2hhcihcImNcIik7dmFyIHQ9dGhpcy5wb3BDaGFyKCk7aWYoITE9PT0vW2EtekEtWl0vLnRlc3QodCkpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFwiKTt2YXIgZT10LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKS02NDtyZXR1cm4ge3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTplfX0sdC5wcm90b3R5cGUubnVsQ2hhcmFjdGVyQXRvbT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiMFwiKSx7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm8oXCJcXDBcIil9fSx0LnByb3RvdHlwZS5oZXhFc2NhcGVTZXF1ZW5jZUF0b209ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcInhcIiksdGhpcy5wYXJzZUhleERpZ2l0cygyKX0sdC5wcm90b3R5cGUucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwidVwiKSx0aGlzLnBhcnNlSGV4RGlnaXRzKDQpfSx0LnByb3RvdHlwZS5pZGVudGl0eUVzY2FwZUF0b209ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvcENoYXIoKTtyZXR1cm4ge3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvKHQpfX0sdC5wcm90b3R5cGUuY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIlxcblwiOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6Y2FzZVwiXFxcXFwiOmNhc2VcIl1cIjp0aHJvdyBFcnJvcihcIlRCRFwiKTtkZWZhdWx0OnZhciB0PXRoaXMucG9wQ2hhcigpO3JldHVybiB7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm8odCl9fX0sdC5wcm90b3R5cGUuY2hhcmFjdGVyQ2xhc3M9ZnVuY3Rpb24oKXt2YXIgdD1bXSxlPSExO2Zvcih0aGlzLmNvbnN1bWVDaGFyKFwiW1wiKSxcIl5cIj09PXRoaXMucGVla0NoYXIoMCkmJih0aGlzLmNvbnN1bWVDaGFyKFwiXlwiKSxlPSEwKTt0aGlzLmlzQ2xhc3NBdG9tKCk7KXt2YXIgbj10aGlzLmNsYXNzQXRvbSgpLHI9XCJDaGFyYWN0ZXJcIj09PW4udHlwZTtpZihyJiZ0aGlzLmlzUmFuZ2VEYXNoKCkpe3RoaXMuY29uc3VtZUNoYXIoXCItXCIpO3ZhciBpPXRoaXMuY2xhc3NBdG9tKCkscz1cIkNoYXJhY3RlclwiPT09aS50eXBlO2lmKHMpe2lmKGkudmFsdWU8bi52YWx1ZSl0aHJvdyBFcnJvcihcIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3NcIik7dC5wdXNoKHtmcm9tOm4udmFsdWUsdG86aS52YWx1ZX0pO31lbHNlIGEobi52YWx1ZSx0KSx0LnB1c2gobyhcIi1cIikpLGEoaS52YWx1ZSx0KTt9ZWxzZSBhKG4udmFsdWUsdCk7fXJldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiXVwiKSx7dHlwZTpcIlNldFwiLGNvbXBsZW1lbnQ6ZSx2YWx1ZTp0fX0sdC5wcm90b3R5cGUuY2xhc3NBdG9tPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiXVwiOmNhc2VcIlxcblwiOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6dGhyb3cgRXJyb3IoXCJUQkRcIik7Y2FzZVwiXFxcXFwiOnJldHVybiB0aGlzLmNsYXNzRXNjYXBlKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5jbGFzc1BhdHRlcm5DaGFyYWN0ZXJBdG9tKCl9fSx0LnByb3RvdHlwZS5jbGFzc0VzY2FwZT1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKSx0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcImJcIjpyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcImJcIikse3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvKFwiXFxiXCIpfTtjYXNlXCJkXCI6Y2FzZVwiRFwiOmNhc2VcInNcIjpjYXNlXCJTXCI6Y2FzZVwid1wiOmNhc2VcIldcIjpyZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpO2Nhc2VcImZcIjpjYXNlXCJuXCI6Y2FzZVwiclwiOmNhc2VcInRcIjpjYXNlXCJ2XCI6cmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKTtjYXNlXCJjXCI6cmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKTtjYXNlXCIwXCI6cmV0dXJuIHRoaXMubnVsQ2hhcmFjdGVyQXRvbSgpO2Nhc2VcInhcIjpyZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKTtjYXNlXCJ1XCI6cmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuaWRlbnRpdHlFc2NhcGVBdG9tKCl9fSx0LnByb3RvdHlwZS5ncm91cD1mdW5jdGlvbigpe3ZhciB0PSEwO3N3aXRjaCh0aGlzLmNvbnN1bWVDaGFyKFwiKFwiKSx0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCI/XCI6dGhpcy5jb25zdW1lQ2hhcihcIj9cIiksdGhpcy5jb25zdW1lQ2hhcihcIjpcIiksdD0hMTticmVhaztkZWZhdWx0OnRoaXMuZ3JvdXBJZHgrKzt9dmFyIGU9dGhpcy5kaXNqdW5jdGlvbigpO3RoaXMuY29uc3VtZUNoYXIoXCIpXCIpO3ZhciBuPXt0eXBlOlwiR3JvdXBcIixjYXB0dXJpbmc6dCx2YWx1ZTplfTtyZXR1cm4gdCYmKG4uaWR4PXRoaXMuZ3JvdXBJZHgpLG59LHQucHJvdG90eXBlLnBvc2l0aXZlSW50ZWdlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMucG9wQ2hhcigpO2lmKCExPT09aS50ZXN0KHQpKXRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtmb3IoO3IudGVzdCh0aGlzLnBlZWtDaGFyKDApKTspdCs9dGhpcy5wb3BDaGFyKCk7cmV0dXJuIHBhcnNlSW50KHQsMTApfSx0LnByb3RvdHlwZS5pbnRlZ2VySW5jbHVkaW5nWmVybz1mdW5jdGlvbigpe3ZhciB0PXRoaXMucG9wQ2hhcigpO2lmKCExPT09ci50ZXN0KHQpKXRocm93IEVycm9yKFwiRXhwZWN0aW5nIGFuIGludGVnZXJcIik7Zm9yKDtyLnRlc3QodGhpcy5wZWVrQ2hhcigwKSk7KXQrPXRoaXMucG9wQ2hhcigpO3JldHVybiBwYXJzZUludCh0LDEwKX0sdC5wcm90b3R5cGUucGF0dGVybkNoYXJhY3Rlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMucG9wQ2hhcigpO3N3aXRjaCh0KXtjYXNlXCJcXG5cIjpjYXNlXCJcXHJcIjpjYXNlXCJcXHUyMDI4XCI6Y2FzZVwiXFx1MjAyOVwiOmNhc2VcIl5cIjpjYXNlXCIkXCI6Y2FzZVwiXFxcXFwiOmNhc2VcIi5cIjpjYXNlXCIqXCI6Y2FzZVwiK1wiOmNhc2VcIj9cIjpjYXNlXCIoXCI6Y2FzZVwiKVwiOmNhc2VcIltcIjpjYXNlXCJ8XCI6dGhyb3cgRXJyb3IoXCJUQkRcIik7ZGVmYXVsdDpyZXR1cm4ge3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvKHQpfX19LHQucHJvdG90eXBlLmlzUmVnRXhwRmxhZz1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCJnXCI6Y2FzZVwiaVwiOmNhc2VcIm1cIjpjYXNlXCJ1XCI6Y2FzZVwieVwiOnJldHVybiAhMDtkZWZhdWx0OnJldHVybiAhMX19LHQucHJvdG90eXBlLmlzUmFuZ2VEYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIFwiLVwiPT09dGhpcy5wZWVrQ2hhcigpJiZ0aGlzLmlzQ2xhc3NBdG9tKDEpfSx0LnByb3RvdHlwZS5pc0RpZ2l0PWZ1bmN0aW9uKCl7cmV0dXJuIHIudGVzdCh0aGlzLnBlZWtDaGFyKDApKX0sdC5wcm90b3R5cGUuaXNDbGFzc0F0b209ZnVuY3Rpb24odCl7c3dpdGNoKHZvaWQgMD09PXQmJih0PTApLHRoaXMucGVla0NoYXIodCkpe2Nhc2VcIl1cIjpjYXNlXCJcXG5cIjpjYXNlXCJcXHJcIjpjYXNlXCJcXHUyMDI4XCI6Y2FzZVwiXFx1MjAyOVwiOnJldHVybiAhMTtkZWZhdWx0OnJldHVybiAhMH19LHQucHJvdG90eXBlLmlzVGVybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQXRvbSgpfHx0aGlzLmlzQXNzZXJ0aW9uKCl9LHQucHJvdG90eXBlLmlzQXRvbT1mdW5jdGlvbigpe2lmKHRoaXMuaXNQYXR0ZXJuQ2hhcmFjdGVyKCkpcmV0dXJuICEwO3N3aXRjaCh0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCIuXCI6Y2FzZVwiXFxcXFwiOmNhc2VcIltcIjpjYXNlXCIoXCI6cmV0dXJuICEwO2RlZmF1bHQ6cmV0dXJuICExfX0sdC5wcm90b3R5cGUuaXNBc3NlcnRpb249ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigwKSl7Y2FzZVwiXlwiOmNhc2VcIiRcIjpyZXR1cm4gITA7Y2FzZVwiXFxcXFwiOnN3aXRjaCh0aGlzLnBlZWtDaGFyKDEpKXtjYXNlXCJiXCI6Y2FzZVwiQlwiOnJldHVybiAhMDtkZWZhdWx0OnJldHVybiAhMX1jYXNlXCIoXCI6cmV0dXJuIFwiP1wiPT09dGhpcy5wZWVrQ2hhcigxKSYmKFwiPVwiPT09dGhpcy5wZWVrQ2hhcigyKXx8XCIhXCI9PT10aGlzLnBlZWtDaGFyKDIpKTtkZWZhdWx0OnJldHVybiAhMX19LHQucHJvdG90eXBlLmlzUXVhbnRpZmllcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuc2F2ZVN0YXRlKCk7dHJ5e3JldHVybiB2b2lkIDAhPT10aGlzLnF1YW50aWZpZXIoITApfWNhdGNoKHQpe3JldHVybiAhMX1maW5hbGx5e3RoaXMucmVzdG9yZVN0YXRlKHQpO319LHQucHJvdG90eXBlLmlzUGF0dGVybkNoYXJhY3Rlcj1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIl5cIjpjYXNlXCIkXCI6Y2FzZVwiXFxcXFwiOmNhc2VcIi5cIjpjYXNlXCIqXCI6Y2FzZVwiK1wiOmNhc2VcIj9cIjpjYXNlXCIoXCI6Y2FzZVwiKVwiOmNhc2VcIltcIjpjYXNlXCJ8XCI6Y2FzZVwiL1wiOmNhc2VcIlxcblwiOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6cmV0dXJuICExO2RlZmF1bHQ6cmV0dXJuICEwfX0sdC5wcm90b3R5cGUucGFyc2VIZXhEaWdpdHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIscj0wO3I8dDtyKyspe3ZhciBpPXRoaXMucG9wQ2hhcigpO2lmKCExPT09bi50ZXN0KGkpKXRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgSGV4RGVjaW1hbCBkaWdpdHNcIik7ZSs9aTt9dmFyIG89cGFyc2VJbnQoZSwxNik7cmV0dXJuIHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6b319LHQucHJvdG90eXBlLnBlZWtDaGFyPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx0aGlzLmlucHV0W3RoaXMuaWR4K3RdfSx0LnByb3RvdHlwZS5wb3BDaGFyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wZWVrQ2hhcigwKTtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcigpLHR9LHQucHJvdG90eXBlLmNvbnN1bWVDaGFyPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQmJnRoaXMuaW5wdXRbdGhpcy5pZHhdIT09dCl0aHJvdyBFcnJvcihcIkV4cGVjdGVkOiAnXCIrdCtcIicgYnV0IGZvdW5kOiAnXCIrdGhpcy5pbnB1dFt0aGlzLmlkeF0rXCInIGF0IG9mZnNldDogXCIrdGhpcy5pZHgpO2lmKHRoaXMuaWR4Pj10aGlzLmlucHV0Lmxlbmd0aCl0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO3RoaXMuaWR4Kys7fTt2YXIgZSxuPS9bMC05YS1mQS1GXS8scj0vWzAtOV0vLGk9L1sxLTldLztmdW5jdGlvbiBvKHQpe3JldHVybiB0LmNoYXJDb2RlQXQoMCl9ZnVuY3Rpb24gYSh0LGUpe3ZvaWQgMCE9PXQubGVuZ3RoP3QuZm9yRWFjaChmdW5jdGlvbih0KXtlLnB1c2godCk7fSk6ZS5wdXNoKHQpO31mdW5jdGlvbiBzKHQsZSl7aWYoITA9PT10W2VdKXRocm93IFwiZHVwbGljYXRlIGZsYWcgXCIrZTt0W2VdPSEwO31mdW5jdGlvbiB1KHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIil9dmFyIGM9W107Zm9yKGU9byhcIjBcIik7ZTw9byhcIjlcIik7ZSsrKWMucHVzaChlKTt2YXIgcD1bbyhcIl9cIildLmNvbmNhdChjKTtmb3IoZT1vKFwiYVwiKTtlPD1vKFwielwiKTtlKyspcC5wdXNoKGUpO2ZvcihlPW8oXCJBXCIpO2U8PW8oXCJaXCIpO2UrKylwLnB1c2goZSk7dmFyIGw9W28oXCIgXCIpLG8oXCJcXGZcIiksbyhcIlxcblwiKSxvKFwiXFxyXCIpLG8oXCJcXHRcIiksbyhcIlxcdlwiKSxvKFwiXFx0XCIpLG8oXCLCoFwiKSxvKFwi4ZqAXCIpLG8oXCLigIBcIiksbyhcIuKAgVwiKSxvKFwi4oCCXCIpLG8oXCLigINcIiksbyhcIuKAhFwiKSxvKFwi4oCFXCIpLG8oXCLigIZcIiksbyhcIuKAh1wiKSxvKFwi4oCIXCIpLG8oXCLigIlcIiksbyhcIuKAilwiKSxvKFwiXFx1MjAyOFwiKSxvKFwiXFx1MjAyOVwiKSxvKFwi4oCvXCIpLG8oXCLigZ9cIiksbyhcIuOAgFwiKSxvKFwiXFx1ZmVmZlwiKV07ZnVuY3Rpb24gaCgpe31yZXR1cm4gaC5wcm90b3R5cGUudmlzaXRDaGlsZHJlbj1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdCl7dmFyIG49dFtlXTt0Lmhhc093blByb3BlcnR5KGUpJiYodm9pZCAwIT09bi50eXBlP3RoaXMudmlzaXQobik6QXJyYXkuaXNBcnJheShuKSYmbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe3RoaXMudmlzaXQodCk7fSx0aGlzKSk7fX0saC5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24odCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiUGF0dGVyblwiOnRoaXMudmlzaXRQYXR0ZXJuKHQpO2JyZWFrO2Nhc2VcIkZsYWdzXCI6dGhpcy52aXNpdEZsYWdzKHQpO2JyZWFrO2Nhc2VcIkRpc2p1bmN0aW9uXCI6dGhpcy52aXNpdERpc2p1bmN0aW9uKHQpO2JyZWFrO2Nhc2VcIkFsdGVybmF0aXZlXCI6dGhpcy52aXNpdEFsdGVybmF0aXZlKHQpO2JyZWFrO2Nhc2VcIlN0YXJ0QW5jaG9yXCI6dGhpcy52aXNpdFN0YXJ0QW5jaG9yKHQpO2JyZWFrO2Nhc2VcIkVuZEFuY2hvclwiOnRoaXMudmlzaXRFbmRBbmNob3IodCk7YnJlYWs7Y2FzZVwiV29yZEJvdW5kYXJ5XCI6dGhpcy52aXNpdFdvcmRCb3VuZGFyeSh0KTticmVhaztjYXNlXCJOb25Xb3JkQm91bmRhcnlcIjp0aGlzLnZpc2l0Tm9uV29yZEJvdW5kYXJ5KHQpO2JyZWFrO2Nhc2VcIkxvb2thaGVhZFwiOnRoaXMudmlzaXRMb29rYWhlYWQodCk7YnJlYWs7Y2FzZVwiTmVnYXRpdmVMb29rYWhlYWRcIjp0aGlzLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQodCk7YnJlYWs7Y2FzZVwiQ2hhcmFjdGVyXCI6dGhpcy52aXNpdENoYXJhY3Rlcih0KTticmVhaztjYXNlXCJTZXRcIjp0aGlzLnZpc2l0U2V0KHQpO2JyZWFrO2Nhc2VcIkdyb3VwXCI6dGhpcy52aXNpdEdyb3VwKHQpO2JyZWFrO2Nhc2VcIkdyb3VwQmFja1JlZmVyZW5jZVwiOnRoaXMudmlzaXRHcm91cEJhY2tSZWZlcmVuY2UodCk7YnJlYWs7Y2FzZVwiUXVhbnRpZmllclwiOnRoaXMudmlzaXRRdWFudGlmaWVyKHQpO310aGlzLnZpc2l0Q2hpbGRyZW4odCk7fSxoLnByb3RvdHlwZS52aXNpdFBhdHRlcm49ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdEZsYWdzPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXREaXNqdW5jdGlvbj1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpdmU9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdFN0YXJ0QW5jaG9yPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRFbmRBbmNob3I9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdFdvcmRCb3VuZGFyeT1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0Tm9uV29yZEJvdW5kYXJ5PWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRMb29rYWhlYWQ9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdE5lZ2F0aXZlTG9va2FoZWFkPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRDaGFyYWN0ZXI9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdFNldD1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0R3JvdXA9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdEdyb3VwQmFja1JlZmVyZW5jZT1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0UXVhbnRpZmllcj1mdW5jdGlvbih0KXt9LHtSZWdFeHBQYXJzZXI6dCxCYXNlUmVnRXhwVmlzaXRvcjpoLFZFUlNJT046XCIwLjQuMFwifX0pP3IuYXBwbHkoZSxpKTpyKXx8KHQuZXhwb3J0cz1vKTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXI9e2J1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlOmZ1bmN0aW9uKHQpe3JldHVybiBcIlVuYWJsZSB0byBwb3AgTGV4ZXIgTW9kZSBhZnRlciBlbmNvdW50ZXJpbmcgVG9rZW4gLT5cIit0LmltYWdlK1wiPC0gVGhlIE1vZGUgU3RhY2sgaXMgZW1wdHlcIn0sYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2U6ZnVuY3Rpb24odCxlLG4scixpKXtyZXR1cm4gXCJ1bmV4cGVjdGVkIGNoYXJhY3RlcjogLT5cIit0LmNoYXJBdChlKStcIjwtIGF0IG9mZnNldDogXCIrZStcIiwgc2tpcHBlZCBcIituK1wiIGNoYXJhY3RlcnMuXCJ9fTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9bigxKSxvPW4oOCk7ZnVuY3Rpb24gYSh0KXtpZih0IGluc3RhbmNlb2YgaS5Ob25UZXJtaW5hbClyZXR1cm4gYSh0LnJlZmVyZW5jZWRSdWxlKTtpZih0IGluc3RhbmNlb2YgaS5UZXJtaW5hbClyZXR1cm4gYyh0KTtpZihvLmlzU2VxdWVuY2VQcm9kKHQpKXJldHVybiBzKHQpO2lmKG8uaXNCcmFuY2hpbmdQcm9kKHQpKXJldHVybiB1KHQpO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZnVuY3Rpb24gcyh0KXtmb3IodmFyIGUsbj1bXSxpPXQuZGVmaW5pdGlvbixzPTAsdT1pLmxlbmd0aD5zLGM9ITA7dSYmYzspZT1pW3NdLGM9by5pc09wdGlvbmFsUHJvZChlKSxuPW4uY29uY2F0KGEoZSkpLHMrPTEsdT1pLmxlbmd0aD5zO3JldHVybiByLnVuaXEobil9ZnVuY3Rpb24gdSh0KXt2YXIgZT1yLm1hcCh0LmRlZmluaXRpb24sZnVuY3Rpb24odCl7cmV0dXJuIGEodCl9KTtyZXR1cm4gci51bmlxKHIuZmxhdHRlbihlKSl9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gW3QudGVybWluYWxUeXBlXX1lLmZpcnN0PWEsZS5maXJzdEZvclNlcXVlbmNlPXMsZS5maXJzdEZvckJyYW5jaGluZz11LGUuZmlyc3RGb3JUZXJtaW5hbD1jO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuSU49XCJffklOfl9cIjt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcixpPW4oMjkpLG89bigwKSxhPW4oMSk7IWZ1bmN0aW9uKHQpe3RbdC5PUFRJT049MF09XCJPUFRJT05cIix0W3QuT1I9MV09XCJPUlwiLHRbdC5NQU5ZPTJdPVwiTUFOWVwiLHRbdC5NQU5ZX1NFUD0zXT1cIk1BTllfU0VQXCIsdFt0LkFUX0xFQVNUX09ORT00XT1cIkFUX0xFQVNUX09ORVwiLHRbdC5BVF9MRUFTVF9PTkVfU0VQPTVdPVwiQVRfTEVBU1RfT05FX1NFUFwiLHRbdC5SRUY9Nl09XCJSRUZcIix0W3QuVEVSTUlOQUw9N109XCJURVJNSU5BTFwiLHRbdC5GTEFUPThdPVwiRkxBVFwiO30ocj1lLlByb2RUeXBlfHwoZS5Qcm9kVHlwZT17fSkpO3ZhciBzPS8oPzpcXHMqe1xccypOQU1FXFxzKjpcXHMqW1wiJ2BdKFtcXHckXSopW1wiJ2BdKT8vLHU9bmV3IFJlZ0V4cChzLnNvdXJjZS5yZXBsYWNlKFwie1wiLFwiXCIpLnJlcGxhY2UoXCIpP1wiLFwiXFxcXHMqLCk/XCIpKSxjPS9cXC5cXHMqQ09OU1VNRShcXGQrKT9cXHMqXFwoXFxzKig/OlthLXpBLVpfJF1cXHcqXFxzKlxcLlxccyopKihbYS16QS1aXyRdXFx3KikvLHA9bmV3IFJlZ0V4cChjLnNvdXJjZSxcImdcIiksbD0vXFwuXFxzKlNVQlJVTEUoXFxkKyk/XFxzKlxcKFxccyooPzpbYS16QS1aXyRdXFx3KlxccypcXC5cXHMqKSooW2EtekEtWl8kXVxcdyopLyxoPW5ldyBSZWdFeHAobC5zb3VyY2UsXCJnXCIpLGY9L1xcLlxccypPUFRJT04oXFxkKyk/XFxzKlxcKC8sZD1uZXcgUmVnRXhwKGYuc291cmNlK3Muc291cmNlKSxFPW5ldyBSZWdFeHAoZi5zb3VyY2UsXCJnXCIpLG09L1xcLlxccypNQU5ZKFxcZCspP1xccypcXCgvLHk9bmV3IFJlZ0V4cChtLnNvdXJjZStzLnNvdXJjZSksVD1uZXcgUmVnRXhwKG0uc291cmNlLFwiZ1wiKSx2PS9cXHMqU0VQXFxzKjpcXHMqKD86W2EtekEtWl8kXVxcdypcXHMqXFwuXFxzKikqKFthLXpBLVpfJF1cXHcqKS8sZz1uZXcgUmVnRXhwKC9cXC5cXHMqTUFOWV9TRVAoXFxkKyk/XFxzKlxcKFxccyp7Ly5zb3VyY2UrdS5zb3VyY2Urdi5zb3VyY2UpLF89bmV3IFJlZ0V4cChnLnNvdXJjZSxcImdcIiksUj1uZXcgUmVnRXhwKC9cXC5cXHMqQVRfTEVBU1RfT05FX1NFUChcXGQrKT9cXHMqXFwoXFxzKnsvLnNvdXJjZSt1LnNvdXJjZSt2LnNvdXJjZSksQT1uZXcgUmVnRXhwKFIuc291cmNlLFwiZ1wiKSxOPS9cXC5cXHMqQVRfTEVBU1RfT05FKFxcZCspP1xccypcXCgvLE89bmV3IFJlZ0V4cChOLnNvdXJjZStzLnNvdXJjZSksUz1uZXcgUmVnRXhwKE4uc291cmNlLFwiZ1wiKSxJPS9cXC5cXHMqT1IoXFxkKyk/XFxzKlxcKC8sTD1uZXcgUmVnRXhwKEkuc291cmNlK3Muc291cmNlKSxrPW5ldyBSZWdFeHAoSS5zb3VyY2UsXCJnXCIpLFA9bmV3IFJlZ0V4cCh1LnNvdXJjZSsvXFxzKihBTFQpXFxzKjovLnNvdXJjZSkseD1uZXcgUmVnRXhwKFAuc291cmNlLFwiZ1wiKTtmdW5jdGlvbiBDKHQsbixpKXtzd2l0Y2godC50eXBlKXtjYXNlIHIuQVRfTEVBU1RfT05FOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIE0oTyxuZXcgYS5SZXBldGl0aW9uTWFuZGF0b3J5KHtkZWZpbml0aW9uOltdfSksdCxlLG4pfSh0LG4saSk7Y2FzZSByLkFUX0xFQVNUX09ORV9TRVA6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gRih0LGUsYS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcixSLG4pfSh0LG4saSk7Y2FzZSByLk1BTllfU0VQOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIEYodCxlLGEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsZyxuKX0odCxuLGkpO2Nhc2Ugci5NQU5ZOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIE0oeSxuZXcgYS5SZXBldGl0aW9uKHtkZWZpbml0aW9uOltdfSksdCxlLG4pfSh0LG4saSk7Y2FzZSByLk9QVElPTjpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBNKGQsbmV3IGEuT3B0aW9uKHtkZWZpbml0aW9uOltdfSksdCxlLG4pfSh0LG4saSk7Y2FzZSByLk9SOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIE0oTCxuZXcgYS5BbHRlcm5hdGlvbih7ZGVmaW5pdGlvbjpbXX0pLHQsZSxuKX0odCxuLGkpO2Nhc2Ugci5GTEFUOnJldHVybiBmdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGEuRmxhdCh7ZGVmaW5pdGlvbjpbXX0pLGk9UC5leGVjKHQudGV4dClbMV07by5pc1VuZGVmaW5lZChpKXx8KHIubmFtZT1pKTtyZXR1cm4gYihyLHQucmFuZ2UsZSxuKX0odCxuLGkpO2Nhc2Ugci5SRUY6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPWwuZXhlYyh0LnRleHQpLG49dm9pZCAwPT09ZVsxXT8wOnBhcnNlSW50KGVbMV0sMTApLHI9ZVsyXTtyZXR1cm4gbmV3IGEuTm9uVGVybWluYWwoe25vblRlcm1pbmFsTmFtZTpyLGlkeDpufSl9KHQpO2Nhc2Ugci5URVJNSU5BTDpyZXR1cm4gZnVuY3Rpb24odCxuKXt2YXIgcj1jLmV4ZWModC50ZXh0KSxpPXZvaWQgMD09PXJbMV0/MDpwYXJzZUludChyWzFdLDEwKSxvPXJbMl0scz1lLnRlcm1pbmFsTmFtZVRvQ29uc3RydWN0b3Jbb107aWYoIXMpdGhyb3cgRXJyb3IoXCJUZXJtaW5hbCBUb2tlbiBuYW1lOiA8XCIrbytcIj4gbm90IGZvdW5kIGluIHJ1bGU6IDxcIituK1wiPiAgXFxuXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI1RFUk1JTkFMX05BTUVfTk9UX0ZPVU5EXFxuXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7cmV0dXJuIG5ldyBhLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6cyxpZHg6aX0pfSh0LGkpO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX19ZnVuY3Rpb24gTSh0LGUsbixyLGkpe3ZhciBhPXQuZXhlYyhuLnRleHQpLHM9dm9pZCAwPT09YVsxXTtlLmlkeD1zPzA6cGFyc2VJbnQoYVsxXSwxMCk7dmFyIHU9YVsyXTtyZXR1cm4gby5pc1VuZGVmaW5lZCh1KXx8KGUubmFtZT11KSxiKGUsbi5yYW5nZSxyLGkpfWZ1bmN0aW9uIEYodCxuLHIsaSxhKXt2YXIgcz1pLmV4ZWModC50ZXh0KSx1PXZvaWQgMD09PXNbMV0/MDpwYXJzZUludChzWzFdLDEwKSxjPXNbM10scD1lLnRlcm1pbmFsTmFtZVRvQ29uc3RydWN0b3JbY107aWYoIXApdGhyb3cgRXJyb3IoXCJTZXBhcmF0b3IgVGVybWluYWwgVG9rZW4gbmFtZTogXCIrYytcIiBub3QgZm91bmRcIik7dmFyIGw9bmV3IHIoe2RlZmluaXRpb246W10sc2VwYXJhdG9yOnAsaWR4OnV9KSxoPXNbMl07cmV0dXJuIG8uaXNVbmRlZmluZWQoaCl8fChsLm5hbWU9aCksYihsLHQucmFuZ2UsbixhKX1mdW5jdGlvbiBiKHQsZSxuLHIpe3ZhciBpPUQoZSxuKSxhPW8uc29ydEJ5KGksZnVuY3Rpb24odCl7cmV0dXJuIHQucmFuZ2Uuc3RhcnR9KSxzPVtdO3JldHVybiBvLmZvckVhY2goYSxmdW5jdGlvbih0KXtzLnB1c2goQyh0LG4scikpO30pLHQuZGVmaW5pdGlvbj1zLHR9ZnVuY3Rpb24gRCh0LGUpe3JldHVybiBvLmZpbHRlcihlLGZ1bmN0aW9uKG4pe3ZhciByPXQuc3RyaWN0bHlDb250YWluc1JhbmdlKG4ucmFuZ2UpLGk9by5ldmVyeShlLGZ1bmN0aW9uKGUpe3ZhciByPWUucmFuZ2Uuc3RyaWN0bHlDb250YWluc1JhbmdlKG4ucmFuZ2UpLGk9ZS5yYW5nZS5pc1N0cmljdGx5Q29udGFpbmVkSW5SYW5nZSh0KTtyZXR1cm4gIShyJiZpKX0pO3JldHVybiByJiZpfSl9ZS50ZXJtaW5hbE5hbWVUb0NvbnN0cnVjdG9yPXt9LGUuYnVpbGRUb3BQcm9kdWN0aW9uPWZ1bmN0aW9uKHQsbixyKXtlLnRlcm1pbmFsTmFtZVRvQ29uc3RydWN0b3I9cjt2YXIgbz1WKGooSyhcIiAgXCIrdCkpKTtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGIobmV3IGEuUnVsZSh7bmFtZTp0LGRlZmluaXRpb246W10sb3JnVGV4dDpyfSksZSxuLHQpfShuLG5ldyBpLlJhbmdlKDAsdC5sZW5ndGgrMiksbyx0KX0sZS5idWlsZFByb2RHYXN0PUMsZS5nZXREaXJlY3RseUNvbnRhaW5lZFJhbmdlcz1EO3ZhciB3PS9cXC9cXC8uKi9nLFU9L1xcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKlxcL118W1xcclxcbl0pKSkqXFwqK1xcLy9nLEc9LyhOQU1FXFxzKjpcXHMqKT9cIihbXlxcXFxcIl18XFxcXChbYmZucnR2XCJcXFxcXFwvXXx1WzAtOWEtZkEtRl17NH0pKSpcIi9nLEI9LyhOQU1FXFxzKjpcXHMqKT8nKFteXFxcXCddfFxcXFwoW2JmbnJ0didcXFxcXFwvXXx1WzAtOWEtZkEtRl17NH0pKSonL2c7ZnVuY3Rpb24gSyh0KXtyZXR1cm4gdC5yZXBsYWNlKHcsXCJcIikucmVwbGFjZShVLFwiXCIpfWZ1bmN0aW9uIFcodCxlKXtyZXR1cm4gdm9pZCAwIT09ZT90OlwiXCJ9ZnVuY3Rpb24gaih0KXtyZXR1cm4gdC5yZXBsYWNlKEcsVykucmVwbGFjZShCLFcpfWZ1bmN0aW9uIFYodCl7dmFyIGU9WSh0KSxuPUgodCkscj1YKHQpLGk9eih0KSxvPXEodCksYT0kKHQpLHM9Wih0KSx1PVEodCk7cmV0dXJuIFtdLmNvbmNhdChlLG4scixpLG8sYSxzLHUpfWZ1bmN0aW9uIFkodCl7cmV0dXJuIG50KHQsci5URVJNSU5BTCxwKX1mdW5jdGlvbiBIKHQpe3JldHVybiBudCh0LHIuUkVGLGgpfWZ1bmN0aW9uIFgodCl7cmV0dXJuIHJ0KHQsci5BVF9MRUFTVF9PTkUsUyl9ZnVuY3Rpb24geih0KXtyZXR1cm4gcnQodCxyLkFUX0xFQVNUX09ORV9TRVAsQSl9ZnVuY3Rpb24gcSh0KXtyZXR1cm4gcnQodCxyLk1BTlksVCl9ZnVuY3Rpb24gJCh0KXtyZXR1cm4gcnQodCxyLk1BTllfU0VQLF8pfWZ1bmN0aW9uIFoodCl7cmV0dXJuIHJ0KHQsci5PUFRJT04sRSl9ZnVuY3Rpb24gUSh0KXt2YXIgZT1ydCh0LHIuT1Isayksbj1ldChlKTtyZXR1cm4gZS5jb25jYXQobil9ZS5yZW1vdmVDb21tZW50cz1LLGUucmVtb3ZlU3RyaW5nTGl0ZXJhbHM9aixlLmNyZWF0ZVJhbmdlcz1WLGUuY3JlYXRlVGVybWluYWxSYW5nZXM9WSxlLmNyZWF0ZVJlZnNSYW5nZXM9SCxlLmNyZWF0ZUF0TGVhc3RPbmVSYW5nZXM9WCxlLmNyZWF0ZUF0TGVhc3RPbmVTZXBSYW5nZXM9eixlLmNyZWF0ZU1hbnlSYW5nZXM9cSxlLmNyZWF0ZU1hbnlTZXBSYW5nZXM9JCxlLmNyZWF0ZU9wdGlvblJhbmdlcz1aLGUuY3JlYXRlT3JSYW5nZXM9UTt2YXIgSj1vLnBhcnRpYWwob3QsXCJ7XCIsXCJ9XCIpLHR0PW8ucGFydGlhbChvdCxcIihcIixcIilcIik7ZnVuY3Rpb24gZXQodCl7dmFyIGU9W107cmV0dXJuIG8uZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciBuPWl0KHQudGV4dCxyLkZMQVQseCxKKSxpPXQucmFuZ2Uuc3RhcnQ7by5mb3JFYWNoKG4sZnVuY3Rpb24odCl7dC5yYW5nZS5zdGFydCs9aSx0LnJhbmdlLmVuZCs9aTt9KSxlPWUuY29uY2F0KG4pO30pLG8udW5pcShlLGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGUrXCJ+XCIrdC5yYW5nZS5zdGFydCtcIn5cIit0LnJhbmdlLmVuZCtcIn5cIit0LnRleHR9KX1mdW5jdGlvbiBudCh0LGUsbil7Zm9yKHZhciByLG89W107cj1uLmV4ZWModCk7KXt2YXIgYT1yLmluZGV4LHM9bi5sYXN0SW5kZXgsdT1uZXcgaS5SYW5nZShhLHMpLGM9clswXTtvLnB1c2goe3JhbmdlOnUsdGV4dDpjLHR5cGU6ZX0pO31yZXR1cm4gb31mdW5jdGlvbiBydCh0LGUsbil7cmV0dXJuIGl0KHQsZSxuLHR0KX1mdW5jdGlvbiBpdCh0LGUsbixyKXtmb3IodmFyIG8sYT1bXTtvPW4uZXhlYyh0KTspe3ZhciBzPW8uaW5kZXgsdT1yKHMrb1swXS5sZW5ndGgsdCksYz1uZXcgaS5SYW5nZShzLHUpLHA9dC5zdWJzdHIocyx1LXMrMSk7YS5wdXNoKHtyYW5nZTpjLHRleHQ6cCx0eXBlOmV9KTt9cmV0dXJuIGF9ZnVuY3Rpb24gb3QodCxlLG4scil7Zm9yKHZhciBpPVsxXSxhPS0xOyFvLmlzRW1wdHkoaSkmJmErbjxyLmxlbmd0aDspe2ErKzt2YXIgcz1yLmNoYXJBdChuK2EpO3M9PT10P2kucHVzaCgxKTpzPT09ZSYmaS5wb3AoKTt9aWYoby5pc0VtcHR5KGkpKXJldHVybiBhK247dGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRCBJTlBVVCBURVhULCBVTlRFUk1JTkFURUQgUEFSRU5USEVTSVNcIil9ZnVuY3Rpb24gYXQodCxlKXtyZXR1cm4gby5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gc3QodCxlKX0pfWZ1bmN0aW9uIHN0KHQsZSl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiTm9uVGVybWluYWxcIjpyZXR1cm4gbmV3IGEuTm9uVGVybWluYWwoe25vblRlcm1pbmFsTmFtZTp0Lm5hbWUsaWR4OnQuaWR4fSk7Y2FzZVwiRmxhdFwiOnJldHVybiBuZXcgYS5GbGF0KHtuYW1lOnQubmFtZSxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIk9wdGlvblwiOnJldHVybiBuZXcgYS5PcHRpb24oe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIlJlcGV0aXRpb25NYW5kYXRvcnlcIjpyZXR1cm4gbmV3IGEuUmVwZXRpdGlvbk1hbmRhdG9yeSh7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3JcIjpyZXR1cm4gbmV3IGEuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Ioe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxzZXBhcmF0b3I6ZVt0LnNlcGFyYXRvci5uYW1lXSxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yXCI6cmV0dXJuIG5ldyBhLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsc2VwYXJhdG9yOmVbdC5zZXBhcmF0b3IubmFtZV0sZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJSZXBldGl0aW9uXCI6cmV0dXJuIG5ldyBhLlJlcGV0aXRpb24oe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIkFsdGVybmF0aW9uXCI6cmV0dXJuIG5ldyBhLkFsdGVybmF0aW9uKHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJUZXJtaW5hbFwiOnJldHVybiBuZXcgYS5UZXJtaW5hbCh7dGVybWluYWxUeXBlOmVbdC5uYW1lXSxpZHg6dC5pZHh9KTtjYXNlXCJSdWxlXCI6cmV0dXJuIG5ldyBhLlJ1bGUoe25hbWU6dC5uYW1lLG9yZ1RleHQ6dC5vcmdUZXh0LGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7fX1lLmNyZWF0ZU9yUGFydFJhbmdlcz1ldCxlLmZpbmRDbG9zaW5nT2Zmc2V0PW90LGUuZGVzZXJpYWxpemVHcmFtbWFyPWF0LGUuZGVzZXJpYWxpemVQcm9kdWN0aW9uPXN0O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDQpLG89bigzMCksYT1uKDExKSxzPW4oMTApLHU9big4KTtlLnJlc29sdmVHcmFtbWFyPWZ1bmN0aW9uKHQpe3Q9ci5kZWZhdWx0cyh0LHtlcnJNc2dQcm92aWRlcjpzLmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyfSk7dmFyIGU9bmV3IGkuSGFzaFRhYmxlO3JldHVybiByLmZvckVhY2godC5ydWxlcyxmdW5jdGlvbih0KXtlLnB1dCh0Lm5hbWUsdCk7fSksby5yZXNvbHZlR3JhbW1hcihlLHQuZXJyTXNnUHJvdmlkZXIpfSxlLnZhbGlkYXRlR3JhbW1hcj1mdW5jdGlvbih0KXtyZXR1cm4gdD1yLmRlZmF1bHRzKHQse2Vyck1zZ1Byb3ZpZGVyOnMuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLGlnbm9yZWRJc3N1ZXM6e319KSxhLnZhbGlkYXRlR3JhbW1hcih0LnJ1bGVzLHQubWF4TG9va2FoZWFkLHQudG9rZW5UeXBlcyx0Lmlnbm9yZWRJc3N1ZXMsdC5lcnJNc2dQcm92aWRlcix0LmdyYW1tYXJOYW1lKX0sZS5hc3NpZ25PY2N1cnJlbmNlSW5kaWNlcz1mdW5jdGlvbih0KXtyLmZvckVhY2godC5ydWxlcyxmdW5jdGlvbih0KXt2YXIgZT1uZXcgdS5Ec2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcjt0LmFjY2VwdChlKSxyLmZvckVhY2goZS5kc2xNZXRob2RzLGZ1bmN0aW9uKHQpe3IuZm9yRWFjaCh0LGZ1bmN0aW9uKHQsZSl7dC5pZHg9ZSsxO30pO30pO30pO307fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigyKSxpPW4oMCksbz1uKDYpLGE9bigyMikscz1uKDQpLHU9bigzKTtmdW5jdGlvbiBjKHQpe3RoaXMubmFtZT1lLklOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OLHRoaXMubWVzc2FnZT10O31lLkVPRl9GT0xMT1dfS0VZPXt9LGUuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT049XCJJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvblwiLGUuSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb249YyxjLnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGU7dmFyIHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0UmVjb3ZlcmFibGU9ZnVuY3Rpb24odCl7dGhpcy5maXJzdEFmdGVyUmVwTWFwPW5ldyBzLkhhc2hUYWJsZSx0aGlzLnJlc3luY0ZvbGxvd3M9bmV3IHMuSGFzaFRhYmxlLHRoaXMucmVjb3ZlcnlFbmFibGVkPWkuaGFzKHQsXCJyZWNvdmVyeUVuYWJsZWRcIik/dC5yZWNvdmVyeUVuYWJsZWQ6dS5ERUZBVUxUX1BBUlNFUl9DT05GSUcucmVjb3ZlcnlFbmFibGVkLHRoaXMucmVjb3ZlcnlFbmFibGVkJiYodGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3Zlcnk9bCk7fSx0LnByb3RvdHlwZS5nZXRUb2tlblRvSW5zZXJ0PWZ1bmN0aW9uKHQpe3ZhciBlPXIuY3JlYXRlVG9rZW5JbnN0YW5jZSh0LFwiXCIsTmFOLE5hTixOYU4sTmFOLE5hTixOYU4pO3JldHVybiBlLmlzSW5zZXJ0ZWRJblJlY292ZXJ5PSEwLGV9LHQucHJvdG90eXBlLmNhblRva2VuVHlwZUJlSW5zZXJ0ZWRJblJlY292ZXJ5PWZ1bmN0aW9uKHQpe3JldHVybiAhMH0sdC5wcm90b3R5cGUudHJ5SW5SZXBldGl0aW9uUmVjb3Zlcnk9ZnVuY3Rpb24odCxlLG4scil7Zm9yKHZhciBhPXRoaXMscz10aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKSx1PXRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLGM9W10scD0hMSxsPXRoaXMuTEEoMSksaD10aGlzLkxBKDEpLGY9ZnVuY3Rpb24oKXt2YXIgdD1hLkxBKDApLGU9YS5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtleHBlY3RlZDpyLGFjdHVhbDpsLHByZXZpb3VzOnQscnVsZU5hbWU6YS5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KSxuPW5ldyBvLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihlLGwsYS5MQSgwKSk7bi5yZXN5bmNlZFRva2Vucz1pLmRyb3BSaWdodChjKSxhLlNBVkVfRVJST1Iobik7fTshcDspe2lmKHRoaXMudG9rZW5NYXRjaGVyKGgscikpcmV0dXJuIHZvaWQgZigpO2lmKG4uY2FsbCh0aGlzKSlyZXR1cm4gZigpLHZvaWQgdC5hcHBseSh0aGlzLGUpO3RoaXMudG9rZW5NYXRjaGVyKGgscyk/cD0hMDooaD10aGlzLlNLSVBfVE9LRU4oKSx0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKGgsYykpO310aGlzLmltcG9ydExleGVyU3RhdGUodSk7fSx0LnByb3RvdHlwZS5zaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwIT09dCYmdm9pZCAwIT09ZSYmKCF0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLHQpJiYoIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSYmIXRoaXMuY2FuUGVyZm9ybUluUnVsZVJlY292ZXJ5KHQsdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkodCxlKSkpKX0sdC5wcm90b3R5cGUuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRDdXJyZW50R3JhbW1hclBhdGgodCxlKTtyZXR1cm4gdGhpcy5nZXROZXh0UG9zc2libGVUb2tlblR5cGVzKG4pfSx0LnByb3RvdHlwZS50cnlJblJ1bGVSZWNvdmVyeT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkluc2VydGlvbih0LGUpKXJldHVybiB0aGlzLmdldFRva2VuVG9JbnNlcnQodCk7aWYodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24odCkpe3ZhciBuPXRoaXMuU0tJUF9UT0tFTigpO3JldHVybiB0aGlzLmNvbnN1bWVUb2tlbigpLG59dGhyb3cgbmV3IGMoXCJzYWQgc2FkIHBhbmRhXCIpfSx0LnByb3RvdHlwZS5jYW5QZXJmb3JtSW5SdWxlUmVjb3Zlcnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKHQsZSl8fHRoaXMuY2FuUmVjb3ZlcldpdGhTaW5nbGVUb2tlbkRlbGV0aW9uKHQpfSx0LnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztpZighdGhpcy5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeSh0KSlyZXR1cm4gITE7aWYoaS5pc0VtcHR5KGUpKXJldHVybiAhMTt2YXIgcj10aGlzLkxBKDEpO3JldHVybiB2b2lkIDAhPT1pLmZpbmQoZSxmdW5jdGlvbih0KXtyZXR1cm4gbi50b2tlbk1hdGNoZXIocix0KX0pfSx0LnByb3RvdHlwZS5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMiksdCl9LHQucHJvdG90eXBlLmlzSW5DdXJyZW50UnVsZVJlU3luY1NldD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEN1cnJGb2xsb3dLZXkoKSxuPXRoaXMuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleShlKTtyZXR1cm4gaS5jb250YWlucyhuLHQpfSx0LnByb3RvdHlwZS5maW5kUmVTeW5jVG9rZW5UeXBlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZmxhdHRlbkZvbGxvd1NldCgpLGU9dGhpcy5MQSgxKSxuPTI7Oyl7dmFyIHI9ZS50b2tlblR5cGU7aWYoaS5jb250YWlucyh0LHIpKXJldHVybiByO2U9dGhpcy5MQShuKSxuKys7fX0sdC5wcm90b3R5cGUuZ2V0Q3VyckZvbGxvd0tleT1mdW5jdGlvbigpe2lmKDE9PT10aGlzLlJVTEVfU1RBQ0subGVuZ3RoKXJldHVybiBlLkVPRl9GT0xMT1dfS0VZO3ZhciB0PXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpLG49dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4KCkscj10aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lKCk7cmV0dXJuIHtydWxlTmFtZTp0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHQpLGlkeEluQ2FsbGluZ1J1bGU6bixpblJ1bGU6dGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShyKX19LHQucHJvdG90eXBlLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPXRoaXMuUlVMRV9TVEFDSyxyPXRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO3JldHVybiBpLmlzRW1wdHkodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0spfHwobj1pLm1hcCh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyxmdW5jdGlvbihlKXtyZXR1cm4gdC5SVUxFX1NUQUNLW2VdfSkscj1pLm1hcCh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyxmdW5jdGlvbihlKXtyZXR1cm4gdC5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0tbZV19KSksaS5tYXAobixmdW5jdGlvbihpLG8pe3JldHVybiAwPT09bz9lLkVPRl9GT0xMT1dfS0VZOntydWxlTmFtZTp0LnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGkpLGlkeEluQ2FsbGluZ1J1bGU6cltvXSxpblJ1bGU6dC5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShuW28tMV0pfX0pfSx0LnByb3RvdHlwZS5mbGF0dGVuRm9sbG93U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPWkubWFwKHRoaXMuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSxmdW5jdGlvbihlKXtyZXR1cm4gdC5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGUpfSk7cmV0dXJuIGkuZmxhdHRlbihlKX0sdC5wcm90b3R5cGUuZ2V0Rm9sbG93U2V0RnJvbUZvbGxvd0tleT1mdW5jdGlvbih0KXtpZih0PT09ZS5FT0ZfRk9MTE9XX0tFWSlyZXR1cm4gW3IuRU9GXTt2YXIgbj10LnJ1bGVOYW1lK3QuaWR4SW5DYWxsaW5nUnVsZSthLklOK3QuaW5SdWxlO3JldHVybiB0aGlzLnJlc3luY0ZvbGxvd3MuZ2V0KG4pfSx0LnByb3RvdHlwZS5hZGRUb1Jlc3luY1Rva2Vucz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRva2VuTWF0Y2hlcih0LHIuRU9GKXx8ZS5wdXNoKHQpLGV9LHQucHJvdG90eXBlLnJlU3luY1RvPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPXRoaXMuTEEoMSk7ITE9PT10aGlzLnRva2VuTWF0Y2hlcihuLHQpOyluPXRoaXMuU0tJUF9UT0tFTigpLHRoaXMuYWRkVG9SZXN5bmNUb2tlbnMobixlKTtyZXR1cm4gaS5kcm9wUmlnaHQoZSl9LHQucHJvdG90eXBlLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeT1mdW5jdGlvbih0LGUsbixyLGksbyl7fSx0LnByb3RvdHlwZS5nZXRDdXJyZW50R3JhbW1hclBhdGg9ZnVuY3Rpb24odCxlKXtyZXR1cm4ge3J1bGVTdGFjazp0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxvY2N1cnJlbmNlU3RhY2s6aS5jbG9uZUFycih0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyksbGFzdFRvazp0LGxhc3RUb2tPY2N1cnJlbmNlOmV9fSx0LnByb3RvdHlwZS5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gaS5pc0VtcHR5KHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLKT9pLm1hcCh0aGlzLlJVTEVfU1RBQ0ssZnVuY3Rpb24oZSl7cmV0dXJuIHQuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoZSl9KTppLm1hcCh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyxmdW5jdGlvbihlKXtyZXR1cm4gdC5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZSh0LlJVTEVfU1RBQ0tbZV0pfSl9LHR9KCk7ZnVuY3Rpb24gbCh0LGUsbixpLG8sYSl7dmFyIHM9dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaSxvKSx1PXRoaXMuZmlyc3RBZnRlclJlcE1hcC5nZXQocyk7aWYodm9pZCAwPT09dSl7dmFyIGM9dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7dT1uZXcgYSh0aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChjKSxvKS5zdGFydFdhbGtpbmcoKSx0aGlzLmZpcnN0QWZ0ZXJSZXBNYXAucHV0KHMsdSk7fXZhciBwPXUudG9rZW4sbD11Lm9jY3VycmVuY2UsaD11LmlzRW5kT2ZSdWxlOzE9PT10aGlzLlJVTEVfU1RBQ0subGVuZ3RoJiZoJiZ2b2lkIDA9PT1wJiYocD1yLkVPRixsPTEpLHRoaXMuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkKHAsbCkmJnRoaXMudHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkodCxlLG4scCk7fWUuUmVjb3ZlcmFibGU9cCxlLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeT1sO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxNCksYT1uKDQpLHM9bigyMSksdT1uKDApLGM9bigyMikscD1uKDIpLGw9bigxKSxoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnRvcFByb2Q9ZSxuLmZvbGxvd3M9bmV3IGEuSGFzaFRhYmxlLG59cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53YWxrKHRoaXMudG9wUHJvZCksdGhpcy5mb2xsb3dzfSxlLnByb3RvdHlwZS53YWxrVGVybWluYWw9ZnVuY3Rpb24odCxlLG4pe30sZS5wcm90b3R5cGUud2Fsa1Byb2RSZWY9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWYodC5yZWZlcmVuY2VkUnVsZSx0LmlkeCkrdGhpcy50b3BQcm9kLm5hbWUsaT1lLmNvbmNhdChuKSxvPW5ldyBsLkZsYXQoe2RlZmluaXRpb246aX0pLGE9cy5maXJzdChvKTt0aGlzLmZvbGxvd3MucHV0KHIsYSk7fSxlfShvLlJlc3RXYWxrZXIpO2Z1bmN0aW9uIGYodCxlKXtyZXR1cm4gdC5uYW1lK2UrYy5JTn1lLlJlc3luY0ZvbGxvd3NXYWxrZXI9aCxlLmNvbXB1dGVBbGxQcm9kc0ZvbGxvd3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGEuSGFzaFRhYmxlO3JldHVybiB1LmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgbj1uZXcgaCh0KS5zdGFydFdhbGtpbmcoKTtlLnB1dEFsbChuKTt9KSxlfSxlLmJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4PWYsZS5idWlsZEluUHJvZEZvbGxvd1ByZWZpeD1mdW5jdGlvbih0KXtyZXR1cm4gcC50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpK3QuaWR4K2MuSU59O30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxOSksYT1uKDIpLHM9bigxNSksdT1uKDApLGM9bigyOCkscD1uZXcgby5SZWdFeHBQYXJzZXIsbD1cIlBBVFRFUk5cIjtmdW5jdGlvbiBoKHQpe3ZhciBlPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7cmV0dXJuICF1Lmhhcyh0LGwpfSk7cmV0dXJuIHtlcnJvcnM6dS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gbWlzc2luZyBzdGF0aWMgJ1BBVFRFUk4nIHByb3BlcnR5XCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NSVNTSU5HX1BBVFRFUk4sdG9rZW5UeXBlczpbdF19fSksdmFsaWQ6dS5kaWZmZXJlbmNlKHQsZSl9fWZ1bmN0aW9uIGYodCl7dmFyIGU9dS5maWx0ZXIodCxmdW5jdGlvbih0KXt2YXIgZT10W2xdO3JldHVybiAhKHUuaXNSZWdFeHAoZSl8fHUuaXNGdW5jdGlvbihlKXx8dS5oYXMoZSxcImV4ZWNcIil8fHUuaXNTdHJpbmcoZSkpfSk7cmV0dXJuIHtlcnJvcnM6dS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQQVRURVJOJyBjYW4gb25seSBiZSBhIFJlZ0V4cCwgYSBGdW5jdGlvbiBtYXRjaGluZyB0aGUge0N1c3RvbVBhdHRlcm5NYXRjaGVyRnVuY30gdHlwZSBvciBhbiBPYmplY3QgbWF0Y2hpbmcgdGhlIHtJQ3VzdG9tUGF0dGVybn0gaW50ZXJmYWNlLlwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9QQVRURVJOLHRva2VuVHlwZXM6W3RdfX0pLHZhbGlkOnUuZGlmZmVyZW5jZSh0LGUpfX1lLkRFRkFVTFRfTU9ERT1cImRlZmF1bHRNb2RlXCIsZS5NT0RFUz1cIm1vZGVzXCIsZS5TVVBQT1JUX1NUSUNLWT1cImJvb2xlYW5cIj09dHlwZW9mIG5ldyBSZWdFeHAoXCIoPzopXCIpLnN0aWNreSxlLmRpc2FibGVTdGlja3k9ZnVuY3Rpb24oKXtlLlNVUFBPUlRfU1RJQ0tZPSExO30sZS5lbmFibGVTdGlja3k9ZnVuY3Rpb24oKXtlLlNVUFBPUlRfU1RJQ0tZPSEwO30sZS5hbmFseXplVG9rZW5UeXBlcz1mdW5jdGlvbih0LG4pe249dS5kZWZhdWx0cyhuLHt1c2VTdGlja3k6ZS5TVVBQT1JUX1NUSUNLWSxkZWJ1ZzohMSxzYWZlTW9kZTohMSxwb3NpdGlvblRyYWNraW5nOlwiZnVsbFwiLGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczpbXCJcXHJcIixcIlxcblwiXX0pO3ZhciByPXUucmVqZWN0KHQsZnVuY3Rpb24odCl7cmV0dXJuIHRbbF09PT1zLkxleGVyLk5BfSksaT0hMSxvPXUubWFwKHIsZnVuY3Rpb24odCl7dmFyIGU9dFtsXTtpZih1LmlzUmVnRXhwKGUpKXt2YXIgcj1lLnNvdXJjZTtyZXR1cm4gMT09PXIubGVuZ3RoJiZcIl5cIiE9PXImJlwiJFwiIT09ciYmXCIuXCIhPT1yP3I6MiE9PXIubGVuZ3RofHxcIlxcXFxcIiE9PXJbMF18fHUuY29udGFpbnMoW1wiZFwiLFwiRFwiLFwic1wiLFwiU1wiLFwidFwiLFwiclwiLFwiblwiLFwidFwiLFwiMFwiLFwiY1wiLFwiYlwiLFwiQlwiLFwiZlwiLFwidlwiLFwid1wiLFwiV1wiXSxyWzFdKT9uLnVzZVN0aWNreT9PKGUpOk4oZSk6clsxXX1pZih1LmlzRnVuY3Rpb24oZSkpcmV0dXJuIGk9ITAse2V4ZWM6ZX07aWYodS5oYXMoZSxcImV4ZWNcIikpcmV0dXJuIGk9ITAsZTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoMT09PWUubGVuZ3RoKXJldHVybiBlO3ZhciBvPWUucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXCJcXFxcJCZcIiksYT1uZXcgUmVnRXhwKG8pO3JldHVybiBuLnVzZVN0aWNreT9PKGEpOk4oYSl9dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX0pLHA9dS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gdC50b2tlblR5cGVJZHh9KSxoPXUubWFwKHIsZnVuY3Rpb24odCl7dmFyIGU9dC5HUk9VUDtpZihlIT09cy5MZXhlci5TS0lQUEVEKXtpZih1LmlzU3RyaW5nKGUpKXJldHVybiBlO2lmKHUuaXNVbmRlZmluZWQoZSkpcmV0dXJuICExO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9fSksZj11Lm1hcChyLGZ1bmN0aW9uKHQpe3ZhciBlPXQuTE9OR0VSX0FMVDtpZihlKXJldHVybiB1LmluZGV4T2YocixlKX0pLGQ9dS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gdC5QVVNIX01PREV9KSxFPXUubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuIHUuaGFzKHQsXCJQT1BfTU9ERVwiKX0pLG09UChuLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykseT11Lm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiAhMX0pO1wib25seU9mZnNldFwiIT09bi5wb3NpdGlvblRyYWNraW5nJiYoeT11Lm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiB1Lmhhcyh0LFwiTElORV9CUkVBS1NcIik/dC5MSU5FX0JSRUFLUzohMT09PUwodCxtKT9jLmNhbk1hdGNoQ2hhckNvZGUobSx0LlBBVFRFUk4pOnZvaWQgMH0pKTt2YXIgVD11Lm1hcChyLFMpLHY9dS5tYXAobyxJKSxnPXUucmVkdWNlKHIsZnVuY3Rpb24odCxlKXt2YXIgbj1lLkdST1VQO3JldHVybiB1LmlzU3RyaW5nKG4pJiZuIT09cy5MZXhlci5TS0lQUEVEJiYodFtuXT1bXSksdH0se30pLF89dS5tYXAobyxmdW5jdGlvbih0LGUpe3JldHVybiB7cGF0dGVybjpvW2VdLGxvbmdlckFsdDpmW2VdLGNhbkxpbmVUZXJtaW5hdG9yOnlbZV0saXNDdXN0b206VFtlXSxzaG9ydDp2W2VdLGdyb3VwOmhbZV0scHVzaDpkW2VdLHBvcDpFW2VdLHRva2VuVHlwZUlkeDpwW2VdLHRva2VuVHlwZTpyW2VdfX0pO2Z1bmN0aW9uIFIodCxlLG4pe3ZvaWQgMD09PXRbZV0mJih0W2VdPVtdKSx0W2VdLnB1c2gobik7fXZhciBBPSEwLGs9W107cmV0dXJuIG4uc2FmZU1vZGV8fChrPXUucmVkdWNlKHIsZnVuY3Rpb24odCxlLHIpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlLlBBVFRFUk4pe3ZhciBpPWUuUEFUVEVSTi5jaGFyQ29kZUF0KDApO1IodCxpLF9bcl0pO31lbHNlIGlmKHUuaXNBcnJheShlLlNUQVJUX0NIQVJTX0hJTlQpKXUuZm9yRWFjaChlLlNUQVJUX0NIQVJTX0hJTlQsZnVuY3Rpb24oZSl7dmFyIG49XCJzdHJpbmdcIj09dHlwZW9mIGU/ZS5jaGFyQ29kZUF0KDApOmU7Uih0LG4sX1tyXSk7fSk7ZWxzZSBpZih1LmlzUmVnRXhwKGUuUEFUVEVSTikpaWYoZS5QQVRURVJOLnVuaWNvZGUpQT0hMSxuLmVuc3VyZU9wdGltaXphdGlvbnMmJnUuUFJJTlRfRVJST1IoYy5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crXCJcXHRVbmFibGUgdG8gYW5hbHl6ZSA8IFwiK2UuUEFUVEVSTi50b1N0cmluZygpK1wiID4gcGF0dGVybi5cXG5cXHRUaGUgcmVnZXhwIHVuaWNvZGUgZmxhZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5LlxcblxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1VOSUNPREVfT1BUSU1JWkVcIik7ZWxzZSB7dmFyIG89Yy5nZXRTdGFydENvZGVzKGUuUEFUVEVSTixuLmVuc3VyZU9wdGltaXphdGlvbnMpO3UuaXNFbXB0eShvKSYmKEE9ITEpLHUuZm9yRWFjaChvLGZ1bmN0aW9uKGUpe1IodCxlLF9bcl0pO30pO31lbHNlIG4uZW5zdXJlT3B0aW1pemF0aW9ucyYmdS5QUklOVF9FUlJPUihjLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZytcIlxcdFRva2VuVHlwZTogPFwiK2EudG9rZW5OYW1lKGUpK1wiPiBpcyB1c2luZyBhIGN1c3RvbSB0b2tlbiBwYXR0ZXJuIHdpdGhvdXQgcHJvdmlkaW5nIDxzdGFydF9jaGFyc19oaW50PiBwYXJhbWV0ZXIuXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ1VTVE9NX09QVElNSVpFXCIpLEE9ITE7cmV0dXJuIHR9LFtdKSksQSYmay5sZW5ndGg8NjU1MzYmJihrPXUucGFja0FycmF5KGspKSx7ZW1wdHlHcm91cHM6ZyxwYXR0ZXJuSWR4VG9Db25maWc6XyxjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnOmssaGFzQ3VzdG9tOmksY2FuQmVPcHRpbWl6ZWQ6QX19LGUudmFsaWRhdGVQYXR0ZXJucz1mdW5jdGlvbih0LGUpe3ZhciBuPVtdLHI9aCh0KTtuPW4uY29uY2F0KHIuZXJyb3JzKTt2YXIgaT1mKHIudmFsaWQpLG89aS52YWxpZDtyZXR1cm4gbj0obj0obj0obj0obj1uLmNvbmNhdChpLmVycm9ycykpLmNvbmNhdChmdW5jdGlvbih0KXt2YXIgZT1bXSxuPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7cmV0dXJuIHUuaXNSZWdFeHAodFtsXSl9KTtyZXR1cm4gZT0oZT0oZT0oZT0oZT1lLmNvbmNhdChFKG4pKSkuY29uY2F0KFQobikpKS5jb25jYXQodihuKSkpLmNvbmNhdChnKG4pKSkuY29uY2F0KG0obikpfShvKSkpLmNvbmNhdChfKG8pKSkuY29uY2F0KFIobyxlKSkpLmNvbmNhdChBKG8pKX0sZS5maW5kTWlzc2luZ1BhdHRlcm5zPWgsZS5maW5kSW52YWxpZFBhdHRlcm5zPWY7dmFyIGQ9L1teXFxcXF1bXFwkXS87ZnVuY3Rpb24gRSh0KXt2YXIgZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLmZvdW5kPSExLGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdEVuZEFuY2hvcj1mdW5jdGlvbih0KXt0aGlzLmZvdW5kPSEwO30sZX0oby5CYXNlUmVnRXhwVmlzaXRvciksbj11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3ZhciBuPXRbbF07dHJ5e3ZhciByPXAucGF0dGVybihuLnRvU3RyaW5nKCkpLGk9bmV3IGU7cmV0dXJuIGkudmlzaXQociksaS5mb3VuZH1jYXRjaCh0KXtyZXR1cm4gZC50ZXN0KG4uc291cmNlKX19KTtyZXR1cm4gdS5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXFx0VG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUEFUVEVSTicgY2Fubm90IGNvbnRhaW4gZW5kIG9mIGlucHV0IGFuY2hvciAnJCdcXG5cXHRTZWUgc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcXHRmb3IgZGV0YWlscy5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVPSV9BTkNIT1JfRk9VTkQsdG9rZW5UeXBlczpbdF19fSl9ZnVuY3Rpb24gbSh0KXt2YXIgZT11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3JldHVybiB0W2xdLnRlc3QoXCJcIil9KTtyZXR1cm4gdS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQQVRURVJOJyBtdXN0IG5vdCBtYXRjaCBhbiBlbXB0eSBzdHJpbmdcIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVNUFRZX01BVENIX1BBVFRFUk4sdG9rZW5UeXBlczpbdF19fSl9ZS5maW5kRW5kT2ZJbnB1dEFuY2hvcj1FLGUuZmluZEVtcHR5TWF0Y2hSZWdFeHBzPW07dmFyIHk9L1teXFxcXFtdW1xcXl18XlxcXi87ZnVuY3Rpb24gVCh0KXt2YXIgZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLmZvdW5kPSExLGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdFN0YXJ0QW5jaG9yPWZ1bmN0aW9uKHQpe3RoaXMuZm91bmQ9ITA7fSxlfShvLkJhc2VSZWdFeHBWaXNpdG9yKSxuPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7dmFyIG49dFtsXTt0cnl7dmFyIHI9cC5wYXR0ZXJuKG4udG9TdHJpbmcoKSksaT1uZXcgZTtyZXR1cm4gaS52aXNpdChyKSxpLmZvdW5kfWNhdGNoKHQpe3JldHVybiB5LnRlc3Qobi5zb3VyY2UpfX0pO3JldHVybiB1Lm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlVuZXhwZWN0ZWQgUmVnRXhwIEFuY2hvciBFcnJvcjpcXG5cXHRUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBzdGFydCBvZiBpbnB1dCBhbmNob3IgJ14nXFxuXFx0U2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcXHRmb3IgZGV0YWlscy5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlNPSV9BTkNIT1JfRk9VTkQsdG9rZW5UeXBlczpbdF19fSl9ZnVuY3Rpb24gdih0KXt2YXIgZT11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3ZhciBlPXRbbF07cmV0dXJuIGUgaW5zdGFuY2VvZiBSZWdFeHAmJihlLm11bHRpbGluZXx8ZS5nbG9iYWwpfSk7cmV0dXJuIHUubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUEFUVEVSTicgbWF5IE5PVCBjb250YWluIGdsb2JhbCgnZycpIG9yIG11bHRpbGluZSgnbScpXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlNVUFBPUlRFRF9GTEFHU19GT1VORCx0b2tlblR5cGVzOlt0XX19KX1mdW5jdGlvbiBnKHQpe3ZhciBlPVtdLG49dS5tYXAodCxmdW5jdGlvbihuKXtyZXR1cm4gdS5yZWR1Y2UodCxmdW5jdGlvbih0LHIpe3JldHVybiBuLlBBVFRFUk4uc291cmNlIT09ci5QQVRURVJOLnNvdXJjZXx8dS5jb250YWlucyhlLHIpfHxyLlBBVFRFUk49PT1zLkxleGVyLk5BP3Q6KGUucHVzaChyKSx0LnB1c2gociksdCl9LFtdKX0pO249dS5jb21wYWN0KG4pO3ZhciByPXUuZmlsdGVyKG4sZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPjF9KTtyZXR1cm4gdS5tYXAocixmdW5jdGlvbih0KXt2YXIgZT11Lm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLnRva2VuTmFtZSh0KX0pO3JldHVybiB7bWVzc2FnZTpcIlRoZSBzYW1lIFJlZ0V4cCBwYXR0ZXJuIC0+XCIrdS5maXJzdCh0KS5QQVRURVJOK1wiPC1oYXMgYmVlbiB1c2VkIGluIGFsbCBvZiB0aGUgZm9sbG93aW5nIFRva2VuIFR5cGVzOiBcIitlLmpvaW4oXCIsIFwiKStcIiA8LVwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5ELHRva2VuVHlwZXM6dH19KX1mdW5jdGlvbiBfKHQpe3ZhciBlPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7aWYoIXUuaGFzKHQsXCJHUk9VUFwiKSlyZXR1cm4gITE7dmFyIGU9dC5HUk9VUDtyZXR1cm4gZSE9PXMuTGV4ZXIuU0tJUFBFRCYmZSE9PXMuTGV4ZXIuTkEmJiF1LmlzU3RyaW5nKGUpfSk7cmV0dXJuIHUubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnR1JPVVAnIGNhbiBvbmx5IGJlIExleGVyLlNLSVBQRUQvTGV4ZXIuTkEvQSBTdHJpbmdcIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfR1JPVVBfVFlQRV9GT1VORCx0b2tlblR5cGVzOlt0XX19KX1mdW5jdGlvbiBSKHQsZSl7dmFyIG49dS5maWx0ZXIodCxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dC5QVVNIX01PREUmJiF1LmNvbnRhaW5zKGUsdC5QVVNIX01PREUpfSk7cmV0dXJuIHUubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVG9rZW4gVHlwZTogLT5cIithLnRva2VuTmFtZSh0KStcIjwtIHN0YXRpYyAnUFVTSF9NT0RFJyB2YWx1ZSBjYW5ub3QgcmVmZXIgdG8gYSBMZXhlciBNb2RlIC0+XCIrdC5QVVNIX01PREUrXCI8LXdoaWNoIGRvZXMgbm90IGV4aXN0XCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5QVVNIX01PREVfRE9FU19OT1RfRVhJU1QsdG9rZW5UeXBlczpbdF19fSl9ZnVuY3Rpb24gQSh0KXt2YXIgZT1bXSxuPXUucmVkdWNlKHQsZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9ZS5QQVRURVJOO3JldHVybiBpPT09cy5MZXhlci5OQT90Oih1LmlzU3RyaW5nKGkpP3QucHVzaCh7c3RyOmksaWR4Om4sdG9rZW5UeXBlOmV9KTp1LmlzUmVnRXhwKGkpJiYocj1pLHZvaWQgMD09PXUuZmluZChbXCIuXCIsXCJcXFxcXCIsXCJbXCIsXCJdXCIsXCJ8XCIsXCJeXCIsXCIkXCIsXCIoXCIsXCIpXCIsXCI/XCIsXCIqXCIsXCIrXCIsXCJ7XCJdLGZ1bmN0aW9uKHQpe3JldHVybiAtMSE9PXIuc291cmNlLmluZGV4T2YodCl9KSkmJnQucHVzaCh7c3RyOmkuc291cmNlLGlkeDpuLHRva2VuVHlwZTplfSksdCl9LFtdKTtyZXR1cm4gdS5mb3JFYWNoKHQsZnVuY3Rpb24odCxyKXt1LmZvckVhY2gobixmdW5jdGlvbihuKXt2YXIgaT1uLnN0cixvPW4uaWR4LGM9bi50b2tlblR5cGU7aWYocjxvJiZmdW5jdGlvbih0LGUpe2lmKHUuaXNSZWdFeHAoZSkpe3ZhciBuPWUuZXhlYyh0KTtyZXR1cm4gbnVsbCE9PW4mJjA9PT1uLmluZGV4fWlmKHUuaXNGdW5jdGlvbihlKSlyZXR1cm4gZSh0LDAsW10se30pO2lmKHUuaGFzKGUsXCJleGVjXCIpKXJldHVybiBlLmV4ZWModCwwLFtdLHt9KTtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gZT09PXQ7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX0oaSx0LlBBVFRFUk4pKXt2YXIgcD1cIlRva2VuOiAtPlwiK2EudG9rZW5OYW1lKGMpK1wiPC0gY2FuIG5ldmVyIGJlIG1hdGNoZWQuXFxuQmVjYXVzZSBpdCBhcHBlYXJzIEFGVEVSIHRoZSBUb2tlbiBUeXBlIC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LWluIHRoZSBsZXhlcidzIGRlZmluaXRpb24uXFxuU2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1VOUkVBQ0hBQkxFXCI7ZS5wdXNoKHttZXNzYWdlOnAsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFQUNIQUJMRV9QQVRURVJOLHRva2VuVHlwZXM6W3QsY119KTt9fSk7fSksZX1mdW5jdGlvbiBOKHQpe3ZhciBlPXQuaWdub3JlQ2FzZT9cImlcIjpcIlwiO3JldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiK3Quc291cmNlK1wiKVwiLGUpfWZ1bmN0aW9uIE8odCl7dmFyIGU9dC5pZ25vcmVDYXNlP1wiaXlcIjpcInlcIjtyZXR1cm4gbmV3IFJlZ0V4cChcIlwiK3Quc291cmNlLGUpfWZ1bmN0aW9uIFModCl7dmFyIGU9dC5QQVRURVJOO2lmKHUuaXNSZWdFeHAoZSkpcmV0dXJuICExO2lmKHUuaXNGdW5jdGlvbihlKSlyZXR1cm4gITA7aWYodS5oYXMoZSxcImV4ZWNcIikpcmV0dXJuICEwO2lmKHUuaXNTdHJpbmcoZSkpcmV0dXJuICExO3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gISghdS5pc1N0cmluZyh0KXx8MSE9PXQubGVuZ3RoKSYmdC5jaGFyQ29kZUF0KDApfWZ1bmN0aW9uIEwodCxlKXtpZih1Lmhhcyh0LFwiTElORV9CUkVBS1NcIikpcmV0dXJuICExO2lmKHUuaXNSZWdFeHAodC5QQVRURVJOKSl7dHJ5e2MuY2FuTWF0Y2hDaGFyQ29kZShlLHQuUEFUVEVSTik7fWNhdGNoKHQpe3JldHVybiB7aXNzdWU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUixlcnJNc2c6dC5tZXNzYWdlfX1yZXR1cm4gITF9aWYodS5pc1N0cmluZyh0LlBBVFRFUk4pKXJldHVybiAhMTtpZihTKHQpKXJldHVybiB7aXNzdWU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUt9O3Rocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIil9ZnVuY3Rpb24gayh0LGUpe2lmKGUuaXNzdWU9PT1zLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SKXJldHVybiBcIldhcm5pbmc6IHVuYWJsZSB0byBpZGVudGlmeSBsaW5lIHRlcm1pbmF0b3IgdXNhZ2UgaW4gcGF0dGVybi5cXG5cXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiK3QubmFtZStcIj4gVG9rZW4gVHlwZVxcblxcdCBSb290IGNhdXNlOiBcIitlLmVyck1zZytcIi5cXG5cXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0lERU5USUZZX1RFUk1JTkFUT1JcIjtpZihlLmlzc3VlPT09cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUspcmV0dXJuIFwiV2FybmluZzogQSBDdXN0b20gVG9rZW4gUGF0dGVybiBzaG91bGQgc3BlY2lmeSB0aGUgPGxpbmVfYnJlYWtzPiBvcHRpb24uXFxuXFx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDxcIit0Lm5hbWUrXCI+IFRva2VuIFR5cGVcXG5cXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9MSU5FX0JSRUFLXCI7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1mdW5jdGlvbiBQKHQpe3JldHVybiB1Lm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB1LmlzU3RyaW5nKHQpJiZ0Lmxlbmd0aD4wP3QuY2hhckNvZGVBdCgwKTp0fSl9ZS5maW5kU3RhcnRPZklucHV0QW5jaG9yPVQsZS5maW5kVW5zdXBwb3J0ZWRGbGFncz12LGUuZmluZER1cGxpY2F0ZVBhdHRlcm5zPWcsZS5maW5kSW52YWxpZEdyb3VwVHlwZT1fLGUuZmluZE1vZGVzVGhhdERvTm90RXhpc3Q9UixlLmZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zPUEsZS5hZGRTdGFydE9mSW5wdXQ9TixlLmFkZFN0aWNreUZsYWc9TyxlLnBlcmZvcm1SdW50aW1lQ2hlY2tzPWZ1bmN0aW9uKHQsbixyKXt2YXIgaT1bXTtyZXR1cm4gdS5oYXModCxlLkRFRkFVTFRfTU9ERSl8fGkucHVzaCh7bWVzc2FnZTpcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRob3V0IGEgPFwiK2UuREVGQVVMVF9NT0RFK1wiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERX0pLHUuaGFzKHQsZS5NT0RFUyl8fGkucHVzaCh7bWVzc2FnZTpcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRob3V0IGEgPFwiK2UuTU9ERVMrXCI+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXFxuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFl9KSx1Lmhhcyh0LGUuTU9ERVMpJiZ1Lmhhcyh0LGUuREVGQVVMVF9NT0RFKSYmIXUuaGFzKHQubW9kZXMsdC5kZWZhdWx0TW9kZSkmJmkucHVzaCh7bWVzc2FnZTpcIkEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgXCIrZS5ERUZBVUxUX01PREUrXCI6IDxcIit0LmRlZmF1bHRNb2RlK1wiPndoaWNoIGRvZXMgbm90IGV4aXN0XFxuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVH0pLHUuaGFzKHQsZS5NT0RFUykmJnUuZm9yRWFjaCh0Lm1vZGVzLGZ1bmN0aW9uKHQsZSl7dS5mb3JFYWNoKHQsZnVuY3Rpb24odCxuKXt1LmlzVW5kZWZpbmVkKHQpJiZpLnB1c2goe21lc3NhZ2U6XCJBIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB1c2luZyBhbiB1bmRlZmluZWQgVG9rZW4gVHlwZS4gTW9kZTo8XCIrZStcIj4gYXQgaW5kZXg6IDxcIituK1wiPlxcblwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORUR9KTt9KTt9KSxpfSxlLnBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcz1mdW5jdGlvbih0LGUsbil7dmFyIHI9W10saT0hMSxvPXUuY29tcGFjdCh1LmZsYXR0ZW4odS5tYXBWYWx1ZXModC5tb2RlcyxmdW5jdGlvbih0KXtyZXR1cm4gdH0pKSksYT11LnJlamVjdChvLGZ1bmN0aW9uKHQpe3JldHVybiB0W2xdPT09cy5MZXhlci5OQX0pLHA9UChuKTtyZXR1cm4gZSYmdS5mb3JFYWNoKGEsZnVuY3Rpb24odCl7dmFyIGU9TCh0LHApO2lmKCExIT09ZSl7dmFyIG49e21lc3NhZ2U6ayh0LGUpLHR5cGU6ZS5pc3N1ZSx0b2tlblR5cGU6dH07ci5wdXNoKG4pO31lbHNlIHUuaGFzKHQsXCJMSU5FX0JSRUFLU1wiKT8hMD09PXQuTElORV9CUkVBS1MmJihpPSEwKTpjLmNhbk1hdGNoQ2hhckNvZGUocCx0LlBBVFRFUk4pJiYoaT0hMCk7fSksZSYmIWkmJnIucHVzaCh7bWVzc2FnZTpcIldhcm5pbmc6IE5vIExJTkVfQlJFQUtTIEZvdW5kLlxcblxcdFRoaXMgTGV4ZXIgaGFzIGJlZW4gZGVmaW5lZCB0byB0cmFjayBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24sXFxuXFx0QnV0IG5vbmUgb2YgdGhlIFRva2VuIFR5cGVzIGNhbiBiZSBpZGVudGlmaWVkIGFzIG1hdGNoaW5nIGEgbGluZSB0ZXJtaW5hdG9yLlxcblxcdFNlZSBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNMSU5FX0JSRUFLUyBcXG5cXHRmb3IgZGV0YWlscy5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PX0xJTkVfQlJFQUtTX0ZMQUdTfSkscn0sZS5jbG9uZUVtcHR5R3JvdXBzPWZ1bmN0aW9uKHQpe3ZhciBlPXt9LG49dS5rZXlzKHQpO3JldHVybiB1LmZvckVhY2gobixmdW5jdGlvbihuKXt2YXIgcj10W25dO2lmKCF1LmlzQXJyYXkocikpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtlW25dPVtdO30pLGV9LGUuaXNDdXN0b21QYXR0ZXJuPVMsZS5pc1Nob3J0UGF0dGVybj1JLGUuTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXI9e3Rlc3Q6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49dGhpcy5sYXN0SW5kZXg7bjxlO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pO2lmKDEwPT09cilyZXR1cm4gdGhpcy5sYXN0SW5kZXg9bisxLCEwO2lmKDEzPT09cilyZXR1cm4gMTA9PT10LmNoYXJDb2RlQXQobisxKT90aGlzLmxhc3RJbmRleD1uKzI6dGhpcy5sYXN0SW5kZXg9bisxLCEwfXJldHVybiAhMX0sbGFzdEluZGV4OjB9LGUuYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2U9azt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMTkpLGE9bigwKSxzPW5ldyBvLlJlZ0V4cFBhcnNlcix1PVwiQ29tcGxlbWVudCBTZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBmaXJzdCBjaGFyIG9wdGltaXphdGlvblwiO2Z1bmN0aW9uIGModCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiRGlzanVuY3Rpb25cIjpyZXR1cm4gYS5mbGF0dGVuKGEubWFwKHQudmFsdWUsYykpO2Nhc2VcIkFsdGVybmF0aXZlXCI6Zm9yKHZhciBlPVtdLG49dC52YWx1ZSxyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl07aWYoIWEuY29udGFpbnMoW1wiR3JvdXBCYWNrUmVmZXJlbmNlXCIsXCJMb29rYWhlYWRcIixcIk5lZ2F0aXZlTG9va2FoZWFkXCIsXCJTdGFydEFuY2hvclwiLFwiRW5kQW5jaG9yXCIsXCJXb3JkQm91bmRhcnlcIixcIk5vbldvcmRCb3VuZGFyeVwiXSxpLnR5cGUpKXt2YXIgbz1pO3N3aXRjaChvLnR5cGUpe2Nhc2VcIkNoYXJhY3RlclwiOmUucHVzaChvLnZhbHVlKTticmVhaztjYXNlXCJTZXRcIjppZighMD09PW8uY29tcGxlbWVudCl0aHJvdyBFcnJvcih1KTthLmZvckVhY2goby52YWx1ZSxmdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdCllLnB1c2godCk7ZWxzZSBmb3IodmFyIG49dCxyPW4uZnJvbTtyPD1uLnRvO3IrKyllLnB1c2gocik7fSk7YnJlYWs7Y2FzZVwiR3JvdXBcIjp2YXIgcz1jKG8udmFsdWUpO2EuZm9yRWFjaChzLGZ1bmN0aW9uKHQpe3JldHVybiBlLnB1c2godCl9KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiTm9uIEV4aGF1c3RpdmUgTWF0Y2hcIil9dmFyIHA9dm9pZCAwIT09by5xdWFudGlmaWVyJiYwPT09by5xdWFudGlmaWVyLmF0TGVhc3Q7aWYoXCJHcm91cFwiPT09by50eXBlJiYhMT09PWgobyl8fFwiR3JvdXBcIiE9PW8udHlwZSYmITE9PT1wKWJyZWFrfX1yZXR1cm4gZTtkZWZhdWx0OnRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2ghXCIpfX1mdW5jdGlvbiBwKHQpe3ZhciBlPVtdO3JldHVybiBhLmZvckVhY2godCxmdW5jdGlvbih0KXtlLnB1c2godCk7dmFyIG49U3RyaW5nLmZyb21DaGFyQ29kZSh0KTtuLnRvVXBwZXJDYXNlKCkhPT1uP2UucHVzaChuLnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKSk6bi50b0xvd2VyQ2FzZSgpIT09biYmZS5wdXNoKG4udG9Mb3dlckNhc2UoKS5jaGFyQ29kZUF0KDApKTt9KSxlfWZ1bmN0aW9uIGwodCxlKXtyZXR1cm4gYS5maW5kKHQudmFsdWUsZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIGEuY29udGFpbnMoZSx0KTt2YXIgbj10O3JldHVybiB2b2lkIDAhPT1hLmZpbmQoZSxmdW5jdGlvbih0KXtyZXR1cm4gbi5mcm9tPD10JiZ0PD1uLnRvfSl9KX1mdW5jdGlvbiBoKHQpe3JldHVybiAhKCF0LnF1YW50aWZpZXJ8fDAhPT10LnF1YW50aWZpZXIuYXRMZWFzdCl8fCEhdC52YWx1ZSYmKGEuaXNBcnJheSh0LnZhbHVlKT9hLmV2ZXJ5KHQudmFsdWUsaCk6aCh0LnZhbHVlKSl9ZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2c9J1VuYWJsZSB0byB1c2UgXCJmaXJzdCBjaGFyXCIgbGV4ZXIgb3B0aW1pemF0aW9uczpcXG4nLGUuZ2V0U3RhcnRDb2Rlcz1mdW5jdGlvbih0LG4pe3ZvaWQgMD09PW4mJihuPSExKTt0cnl7dmFyIHI9cy5wYXR0ZXJuKHQudG9TdHJpbmcoKSksaT1jKHIudmFsdWUpO3JldHVybiByLmZsYWdzLmlnbm9yZUNhc2UmJihpPXAoaSkpLGl9Y2F0Y2gocil7aWYoci5tZXNzYWdlPT09dSluJiZhLlBSSU5UX1dBUk5JTkcoZS5mYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2crXCJcXHRVbmFibGUgdG8gb3B0aW1pemU6IDwgXCIrdC50b1N0cmluZygpK1wiID5cXG5cXHRDb21wbGVtZW50IFNldHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkLlxcblxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NPTVBMRU1FTlQgZm9yIGRldGFpbHMuXCIpO2Vsc2Uge3ZhciBsPVwiXCI7biYmKGw9XCJcXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNSRUdFWFBfUEFSU0lORyBmb3IgZGV0YWlscy5cIiksYS5QUklOVF9FUlJPUihlLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZytcIlxcblxcdEZhaWxlZCBwYXJzaW5nOiA8IFwiK3QudG9TdHJpbmcoKStcIiA+XFxuXFx0VXNpbmcgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeSB2ZXJzaW9uOiBcIitvLlZFUlNJT04rXCJcXG5cXHRQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdDogaHR0cHM6Ly9naXRodWIuY29tL2JkODIvcmVnZXhwLXRvLWFzdC9pc3N1ZXNcIitsKTt9fXJldHVybiBbXX0sZS5maXJzdENoYXI9YyxlLmFwcGx5SWdub3JlQ2FzZT1wO3ZhciBmPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnRhcmdldENoYXJDb2Rlcz1lLG4uZm91bmQ9ITEsbn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW49ZnVuY3Rpb24oZSl7c3dpdGNoKGUudHlwZSl7Y2FzZVwiTG9va2FoZWFkXCI6cmV0dXJuIHZvaWQgdGhpcy52aXNpdExvb2thaGVhZChlKTtjYXNlXCJOZWdhdGl2ZUxvb2thaGVhZFwiOnJldHVybiB2b2lkIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChlKX10LnByb3RvdHlwZS52aXNpdENoaWxkcmVuLmNhbGwodGhpcyxlKTt9LGUucHJvdG90eXBlLnZpc2l0Q2hhcmFjdGVyPWZ1bmN0aW9uKHQpe2EuY29udGFpbnModGhpcy50YXJnZXRDaGFyQ29kZXMsdC52YWx1ZSkmJih0aGlzLmZvdW5kPSEwKTt9LGUucHJvdG90eXBlLnZpc2l0U2V0PWZ1bmN0aW9uKHQpe3QuY29tcGxlbWVudD92b2lkIDA9PT1sKHQsdGhpcy50YXJnZXRDaGFyQ29kZXMpJiYodGhpcy5mb3VuZD0hMCk6dm9pZCAwIT09bCh0LHRoaXMudGFyZ2V0Q2hhckNvZGVzKSYmKHRoaXMuZm91bmQ9ITApO30sZX0oby5CYXNlUmVnRXhwVmlzaXRvcik7ZS5jYW5NYXRjaENoYXJDb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIFJlZ0V4cCl7dmFyIG49cy5wYXR0ZXJuKGUudG9TdHJpbmcoKSkscj1uZXcgZih0KTtyZXR1cm4gci52aXNpdChuKSxyLmZvdW5kfXJldHVybiB2b2lkIDAhPT1hLmZpbmQoZSxmdW5jdGlvbihlKXtyZXR1cm4gYS5jb250YWlucyh0LGUuY2hhckNvZGVBdCgwKSl9KX07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7aWYodGhpcy5zdGFydD10LHRoaXMuZW5kPWUsIWkodCxlKSl0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEIFJBTkdFXCIpfXJldHVybiB0LnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydDw9dCYmdGhpcy5lbmQ+PXR9LHQucHJvdG90eXBlLmNvbnRhaW5zUmFuZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnQ8PXQuc3RhcnQmJnRoaXMuZW5kPj10LmVuZH0sdC5wcm90b3R5cGUuaXNDb250YWluZWRJblJhbmdlPWZ1bmN0aW9uKHQpe3JldHVybiB0LmNvbnRhaW5zUmFuZ2UodGhpcyl9LHQucHJvdG90eXBlLnN0cmljdGx5Q29udGFpbnNSYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydDx0LnN0YXJ0JiZ0aGlzLmVuZD50LmVuZH0sdC5wcm90b3R5cGUuaXNTdHJpY3RseUNvbnRhaW5lZEluUmFuZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc3RyaWN0bHlDb250YWluc1JhbmdlKHRoaXMpfSx0fSgpO2Z1bmN0aW9uIGkodCxlKXtyZXR1cm4gISh0PDB8fGU8dCl9ZS5SYW5nZT1yLGUuaXNWYWxpZFJhbmdlPWk7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDMpLGE9bigwKSxzPW4oNSk7ZS5yZXNvbHZlR3JhbW1hcj1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyB1KHQsZSk7cmV0dXJuIG4ucmVzb2x2ZVJlZnMoKSxuLmVycm9yc307dmFyIHU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci5uYW1lVG9Ub3BSdWxlPWUsci5lcnJNc2dQcm92aWRlcj1uLHIuZXJyb3JzPVtdLHJ9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5yZXNvbHZlUmVmcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7YS5mb3JFYWNoKHRoaXMubmFtZVRvVG9wUnVsZS52YWx1ZXMoKSxmdW5jdGlvbihlKXt0LmN1cnJUb3BMZXZlbD1lLGUuYWNjZXB0KHQpO30pO30sZS5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm5hbWVUb1RvcFJ1bGUuZ2V0KHQubm9uVGVybWluYWxOYW1lKTtpZihlKXQucmVmZXJlbmNlZFJ1bGU9ZTtlbHNlIHt2YXIgbj10aGlzLmVyck1zZ1Byb3ZpZGVyLmJ1aWxkUnVsZU5vdEZvdW5kRXJyb3IodGhpcy5jdXJyVG9wTGV2ZWwsdCk7dGhpcy5lcnJvcnMucHVzaCh7bWVzc2FnZTpuLHR5cGU6by5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOUkVTT0xWRURfU1VCUlVMRV9SRUYscnVsZU5hbWU6dGhpcy5jdXJyVG9wTGV2ZWwubmFtZSx1bnJlc29sdmVkUmVmTmFtZTp0Lm5vblRlcm1pbmFsTmFtZX0pO319LGV9KHMuR0FzdFZpc2l0b3IpO2UuR2FzdFJlZlJlc29sdmVyVmlzaXRvcj11O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMTIpLGk9bigwKSxvPW4oMyksYT1uKDkpLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0TG9va3NBaGVhZD1mdW5jdGlvbih0KXt0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkPWkuaGFzKHQsXCJkeW5hbWljVG9rZW5zRW5hYmxlZFwiKT90LmR5bmFtaWNUb2tlbnNFbmFibGVkOm8uREVGQVVMVF9QQVJTRVJfQ09ORklHLmR5bmFtaWNUb2tlbnNFbmFibGVkLHRoaXMubWF4TG9va2FoZWFkPWkuaGFzKHQsXCJtYXhMb29rYWhlYWRcIik/dC5tYXhMb29rYWhlYWQ6by5ERUZBVUxUX1BBUlNFUl9DT05GSUcubWF4TG9va2FoZWFkLHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZT1pLmlzRVMyMDE1TWFwU3VwcG9ydGVkKCk/bmV3IE1hcDpbXSxpLmlzRVMyMDE1TWFwU3VwcG9ydGVkKCk/KHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlPXRoaXMuZ2V0TGFGdW5jRnJvbU1hcCx0aGlzLnNldExhRnVuY0NhY2hlPXRoaXMuc2V0TGFGdW5jQ2FjaGVVc2luZ01hcCk6KHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlPXRoaXMuZ2V0TGFGdW5jRnJvbU9iaix0aGlzLnNldExhRnVuY0NhY2hlPXRoaXMuc2V0TGFGdW5jVXNpbmdPYmopO30sdC5wcm90b3R5cGUubG9va0FoZWFkQnVpbGRlckZvck9wdGlvbmFsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gci5idWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24odCxlLG4pfSx0LnByb3RvdHlwZS5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzPWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiByLmJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyh0LGUsbixpKX0sdC5wcm90b3R5cGUuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7cmV0dXJuIGEuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKG4sdCxlKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0Zvck9yPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoYS5PUl9JRFgsdCksbz10aGlzLmdldExhRnVuY0Zyb21DYWNoZShuKTtpZih2b2lkIDA9PT1vKXt2YXIgcz10aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSx1PXRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KHMpLGM9aS5zb21lKGUsZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNGdW5jdGlvbih0LkdBVEUpfSk7cmV0dXJuIG89ci5idWlsZExvb2thaGVhZEZ1bmNGb3JPcih0LHUsdGhpcy5tYXhMb29rYWhlYWQsYyx0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLHRoaXMubG9va0FoZWFkQnVpbGRlckZvckFsdGVybmF0aXZlcyksdGhpcy5zZXRMYUZ1bmNDYWNoZShuLG8pLG99cmV0dXJuIG99LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JPcHRpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yKHQsZSx0aGlzLm1heExvb2thaGVhZCxyLlBST0RfVFlQRS5PUFRJT04pfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yTWFueT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmdldExvb2thaGVhZEZ1bmNGb3IodCxlLHRoaXMubWF4TG9va2FoZWFkLHIuUFJPRF9UWVBFLlJFUEVUSVRJT04pfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yTWFueVNlcD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmdldExvb2thaGVhZEZ1bmNGb3IodCxlLHRoaXMubWF4TG9va2FoZWFkLHIuUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IpfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yQXRMZWFzdE9uZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmdldExvb2thaGVhZEZ1bmNGb3IodCxlLHRoaXMubWF4TG9va2FoZWFkLHIuUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0ZvckF0TGVhc3RPbmVTZXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yKHQsZSx0aGlzLm1heExvb2thaGVhZCxyLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUil9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3I9ZnVuY3Rpb24odCxlLG4saSl7dmFyIG89dGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUodCk7aWYodm9pZCAwPT09byl7dmFyIGE9dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCkscz10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChhKTtyZXR1cm4gbz1yLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZChlLHMsbix0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLGksdGhpcy5sb29rQWhlYWRCdWlsZGVyRm9yT3B0aW9uYWwpLHRoaXMuc2V0TGFGdW5jQ2FjaGUodCxvKSxvfXJldHVybiBvfSx0LnByb3RvdHlwZS5nZXRMYUZ1bmNGcm9tQ2FjaGU9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS5nZXRMYUZ1bmNGcm9tTWFwPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRMYUZ1bmNGcm9tT2JqPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGVbdF19LHQucHJvdG90eXBlLnNldExhRnVuY0NhY2hlPWZ1bmN0aW9uKHQsZSl7fSx0LnByb3RvdHlwZS5zZXRMYUZ1bmNDYWNoZVVzaW5nTWFwPWZ1bmN0aW9uKHQsZSl7dGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlLnNldCh0LGUpO30sdC5wcm90b3R5cGUuc2V0TGFGdW5jVXNpbmdPYmo9ZnVuY3Rpb24odCxlKXt0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGVbdF09ZTt9LHR9KCk7ZS5Mb29rc0FoZWFkPXM7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigxNiksaT1uKDApLG89bigzMyksYT1uKDkpLHM9bigzKSx1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdFRyZWVCdWlsZGVyPWZ1bmN0aW9uKHQpe3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLPVtdLHRoaXMuQ1NUX1NUQUNLPVtdLHRoaXMub3V0cHV0Q3N0PWkuaGFzKHQsXCJvdXRwdXRDc3RcIik/dC5vdXRwdXRDc3Q6cy5ERUZBVUxUX1BBUlNFUl9DT05GSUcub3V0cHV0Q3N0LHRoaXMub3V0cHV0Q3N0fHwodGhpcy5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGU9aS5OT09QLHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlPWkuTk9PUCx0aGlzLmNzdFBvc3RUZXJtaW5hbD1pLk5PT1AsdGhpcy5jc3RQb3N0Tm9uVGVybWluYWw9aS5OT09QLHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZT10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdCx0aGlzLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lPXRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdCx0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXg9dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4Tm9Dc3QsdGhpcy5tYW55SW50ZXJuYWw9dGhpcy5tYW55SW50ZXJuYWxOb0NzdCx0aGlzLm9ySW50ZXJuYWw9dGhpcy5vckludGVybmFsTm9Dc3QsdGhpcy5vcHRpb25JbnRlcm5hbD10aGlzLm9wdGlvbkludGVybmFsTm9Dc3QsdGhpcy5hdExlYXN0T25lSW50ZXJuYWw9dGhpcy5hdExlYXN0T25lSW50ZXJuYWxOb0NzdCx0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsPXRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxOb0NzdCx0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsPXRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxOb0NzdCk7fSx0LnByb3RvdHlwZS5jc3ROZXN0ZWRJbnZvY2F0aW9uU3RhdGVVcGRhdGU9ZnVuY3Rpb24odCxlKXt0aGlzLkNTVF9TVEFDSy5wdXNoKHtuYW1lOnQsZnVsbE5hbWU6dGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsLmdldCh0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKSkrdCxjaGlsZHJlbjp7fX0pO30sdC5wcm90b3R5cGUuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlPWZ1bmN0aW9uKHQsZSl7dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0sucHVzaCh0aGlzLlJVTEVfU1RBQ0subGVuZ3RoLTEpLHRoaXMuQ1NUX1NUQUNLLnB1c2goe25hbWU6dCxjaGlsZHJlbjp7fX0pO30sdC5wcm90b3R5cGUuY3N0RmluYWxseVN0YXRlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0sucG9wKCksdGhpcy5DU1RfU1RBQ0sucG9wKCk7fSx0LnByb3RvdHlwZS5jc3ROZXN0ZWRGaW5hbGx5U3RhdGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLkNTVF9TVEFDSy5wb3AoKTt9LHQucHJvdG90eXBlLmNzdFBvc3RUZXJtaW5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXTtyLmFkZFRlcm1pbmFsVG9Dc3QobixlLHQpO30sdC5wcm90b3R5cGUuY3N0UG9zdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHQsZSl7ci5hZGROb25lVGVybWluYWxUb0NzdCh0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGgtMV0sZSx0KTt9LHQucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I9ZnVuY3Rpb24oKXtpZihpLmlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3Rvcikpe3ZhciB0PW8uY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yKHRoaXMuY2xhc3NOYW1lLHRoaXMuYWxsUnVsZU5hbWVzKTtyZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yPXQsdH1yZXR1cm4gdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yfSx0LnByb3RvdHlwZS5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzPWZ1bmN0aW9uKCl7aWYoaS5pc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKXt2YXIgdD1vLmNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHModGhpcy5jbGFzc05hbWUsdGhpcy5hbGxSdWxlTmFtZXMsdGhpcy5nZXRCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKCkpO3JldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3I9dCx0fXJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3J9LHQucHJvdG90eXBlLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2U9ZnVuY3Rpb24odCxlKXt2YXIgbjtyZXR1cm4gdm9pZCAwIT09dC5OQU1FPyhuPXQuTkFNRSx0aGlzLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUobixlKSxuKTp2b2lkIDB9LHQucHJvdG90eXBlLm5lc3RlZEFsdEJlZm9yZUNsYXVzZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgaSxvPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpLHM9YS5nZXRLZXlGb3JBbHRJbmRleChvLG4sZSxyKTtyZXR1cm4gdm9pZCAwIT09dC5OQU1FPyhpPXQuTkFNRSx0aGlzLm5lc3RlZFJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUoaSxzKSx7c2hvcnROYW1lOnMsbmVzdGVkTmFtZTppfSk6dm9pZCAwfSx0LnByb3RvdHlwZS5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuQ1NUX1NUQUNLLGk9bltuLmxlbmd0aC0xXTt0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTt2YXIgbz1uW24ubGVuZ3RoLTFdO3IuYWRkTm9uZVRlcm1pbmFsVG9Dc3QobyxlLGkpO30sdC5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLW3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5SVUxFX1NUQUNLW3RdfSx0LnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3Q9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLlJVTEVfU1RBQ0s7cmV0dXJuIHRbdC5sZW5ndGgtMV19LHQucHJvdG90eXBlLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoLTJdO3JldHVybiB0aGlzLlJVTEVfU1RBQ0tbdF19LHQucHJvdG90eXBlLmdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lTm9Dc3Q9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLlJVTEVfU1RBQ0s7cmV0dXJuIHRbdC5sZW5ndGgtMl19LHQucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS1t0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLW3RdfSx0LnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4Tm9Dc3Q9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztyZXR1cm4gdFt0Lmxlbmd0aC0xXX0sdC5wcm90b3R5cGUubmVzdGVkUnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbih0LGUpe3RoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnB1c2goMSksdGhpcy5SVUxFX1NUQUNLLnB1c2goZSksdGhpcy5jc3ROZXN0ZWRJbnZvY2F0aW9uU3RhdGVVcGRhdGUodCxlKTt9LHQucHJvdG90eXBlLm5lc3RlZFJ1bGVGaW5hbGx5U3RhdGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLlJVTEVfU1RBQ0sucG9wKCksdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucG9wKCksdGhpcy5jc3ROZXN0ZWRGaW5hbGx5U3RhdGVVcGRhdGUoKTt9LHR9KCk7ZS5UcmVlQnVpbGRlcj11O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByLGk9bigwKSxvPW4oNCksYT1uKDExKTtmdW5jdGlvbiBzKHQsZSl7Zm9yKHZhciBuPWkua2V5cyh0KSxyPW4ubGVuZ3RoLG89MDtvPHI7bysrKWZvcih2YXIgYT10W25bb11dLHM9YS5sZW5ndGgsdT0wO3U8czt1Kyspe3ZhciBjPWFbdV07dm9pZCAwPT09Yy50b2tlblR5cGVJZHgmJih2b2lkIDAhPT1jLmZ1bGxOYW1lP3RoaXNbYy5mdWxsTmFtZV0oYy5jaGlsZHJlbixlKTp0aGlzW2MubmFtZV0oYy5jaGlsZHJlbixlKSk7fX1mdW5jdGlvbiB1KHQsZSl7dmFyIG49Yyh0LGUpLHI9bCh0LGUpO3JldHVybiBuLmNvbmNhdChyKX1mdW5jdGlvbiBjKHQsZSl7dmFyIG49aS5tYXAoZSxmdW5jdGlvbihlKXtpZighaS5pc0Z1bmN0aW9uKHRbZV0pKXJldHVybiB7bXNnOlwiTWlzc2luZyB2aXNpdG9yIG1ldGhvZDogPFwiK2UrXCI+IG9uIFwiK28uZnVuY3Rpb25OYW1lKHQuY29uc3RydWN0b3IpK1wiIENTVCBWaXNpdG9yLlwiLHR5cGU6ci5NSVNTSU5HX01FVEhPRCxtZXRob2ROYW1lOmV9fSk7cmV0dXJuIGkuY29tcGFjdChuKX1lLmRlZmF1bHRWaXNpdD1zLGUuY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZnVuY3Rpb24oKXt9O3JldHVybiBvLmRlZmluZU5hbWVQcm9wKG4sdCtcIkJhc2VTZW1hbnRpY3NcIiksKG4ucHJvdG90eXBlPXt2aXNpdDpmdW5jdGlvbih0LGUpe2lmKGkuaXNBcnJheSh0KSYmKHQ9dFswXSksIWkuaXNVbmRlZmluZWQodCkpcmV0dXJuIHZvaWQgMCE9PXQuZnVsbE5hbWU/dGhpc1t0LmZ1bGxOYW1lXSh0LmNoaWxkcmVuLGUpOnRoaXNbdC5uYW1lXSh0LmNoaWxkcmVuLGUpfSx2YWxpZGF0ZVZpc2l0b3I6ZnVuY3Rpb24oKXt2YXIgdD11KHRoaXMsZSk7aWYoIWkuaXNFbXB0eSh0KSl7dmFyIG49aS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gdC5tc2d9KTt0aHJvdyBFcnJvcihcIkVycm9ycyBEZXRlY3RlZCBpbiBDU1QgVmlzaXRvciA8XCIrby5mdW5jdGlvbk5hbWUodGhpcy5jb25zdHJ1Y3RvcikrXCI+OlxcblxcdFwiK24uam9pbihcIlxcblxcblwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcblxcdFwiKSl9fX0pLmNvbnN0cnVjdG9yPW4sbi5fUlVMRV9OQU1FUz1lLG59LGUuY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cz1mdW5jdGlvbih0LGUsbil7dmFyIHI9ZnVuY3Rpb24oKXt9O28uZGVmaW5lTmFtZVByb3Aocix0K1wiQmFzZVNlbWFudGljc1dpdGhEZWZhdWx0c1wiKTt2YXIgYT1PYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKTtyZXR1cm4gaS5mb3JFYWNoKGUsZnVuY3Rpb24odCl7YVt0XT1zO30pLChyLnByb3RvdHlwZT1hKS5jb25zdHJ1Y3Rvcj1yLHJ9LGZ1bmN0aW9uKHQpe3RbdC5SRURVTkRBTlRfTUVUSE9EPTBdPVwiUkVEVU5EQU5UX01FVEhPRFwiLHRbdC5NSVNTSU5HX01FVEhPRD0xXT1cIk1JU1NJTkdfTUVUSE9EXCI7fShyPWUuQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcnx8KGUuQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcj17fSkpLGUudmFsaWRhdGVWaXNpdG9yPXUsZS52YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzPWM7dmFyIHA9W1wiY29uc3RydWN0b3JcIixcInZpc2l0XCIsXCJ2YWxpZGF0ZVZpc2l0b3JcIl07ZnVuY3Rpb24gbCh0LGUpe3ZhciBuPVtdO2Zvcih2YXIgcyBpbiB0KWEudmFsaWRUZXJtc1BhdHRlcm4udGVzdChzKSYmaS5pc0Z1bmN0aW9uKHRbc10pJiYhaS5jb250YWlucyhwLHMpJiYhaS5jb250YWlucyhlLHMpJiZuLnB1c2goe21zZzpcIlJlZHVuZGFudCB2aXNpdG9yIG1ldGhvZDogPFwiK3MrXCI+IG9uIFwiK28uZnVuY3Rpb25OYW1lKHQuY29uc3RydWN0b3IpK1wiIENTVCBWaXNpdG9yXFxuVGhlcmUgaXMgbm8gR3JhbW1hciBSdWxlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRob2QncyBuYW1lLlxcbkZvciB1dGlsaXR5IG1ldGhvZHMgb24gdmlzaXRvciBjbGFzc2VzIHVzZSBtZXRob2RzIG5hbWVzIHRoYXQgZG8gbm90IG1hdGNoIC9cIithLnZhbGlkVGVybXNQYXR0ZXJuLnNvdXJjZStcIi8uXCIsdHlwZTpyLlJFRFVOREFOVF9NRVRIT0QsbWV0aG9kTmFtZTpzfSk7cmV0dXJuIG59ZS52YWxpZGF0ZVJlZHVuZGFudE1ldGhvZHM9bDt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDMpLGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0TGV4ZXJBZGFwdGVyPWZ1bmN0aW9uKCl7dGhpcy50b2tWZWN0b3I9W10sdGhpcy50b2tWZWN0b3JMZW5ndGg9MCx0aGlzLmN1cnJJZHg9LTE7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJpbnB1dFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2tWZWN0b3J9LHNldDpmdW5jdGlvbih0KXt0aGlzLnJlc2V0KCksdGhpcy50b2tWZWN0b3I9dCx0aGlzLnRva1ZlY3Rvckxlbmd0aD10Lmxlbmd0aDt9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuU0tJUF9UT0tFTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJJZHg8PXRoaXMudG9rVmVjdG9yLmxlbmd0aC0yPyh0aGlzLmNvbnN1bWVUb2tlbigpLHRoaXMuTEEoMSkpOnIuRU5EX09GX0ZJTEV9LHQucHJvdG90eXBlLkxBPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmN1cnJJZHgrdDwwfHx0aGlzLnRva1ZlY3Rvckxlbmd0aDw9dGhpcy5jdXJySWR4K3Q/ci5FTkRfT0ZfRklMRTp0aGlzLnRva1ZlY3Rvclt0aGlzLmN1cnJJZHgrdF19LHQucHJvdG90eXBlLmNvbnN1bWVUb2tlbj1mdW5jdGlvbigpe3RoaXMuY3VycklkeCsrO30sdC5wcm90b3R5cGUuZXhwb3J0TGV4ZXJTdGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJJZHh9LHQucHJvdG90eXBlLmltcG9ydExleGVyU3RhdGU9ZnVuY3Rpb24odCl7dGhpcy5jdXJySWR4PXQ7fSx0LnByb3RvdHlwZS5yZXNldExleGVyU3RhdGU9ZnVuY3Rpb24oKXt0aGlzLmN1cnJJZHg9LTE7fSx0LnByb3RvdHlwZS5tb3ZlVG9UZXJtaW5hdGVkU3RhdGU9ZnVuY3Rpb24oKXt0aGlzLmN1cnJJZHg9dGhpcy50b2tWZWN0b3IubGVuZ3RoLTE7fSx0LnByb3RvdHlwZS5nZXRMZXhlclBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpfSx0fSgpO2UuTGV4ZXJBZGFwdGVyPWk7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oNiksbz1uKDMpLGE9bigxMCkscz1uKDIzKSx1PW4oMTEpLGM9bigxKSxwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuQ09OU1VNRT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDAsZSl9LHQucHJvdG90eXBlLkNPTlNVTUUxPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsMSxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCwyLGUpfSx0LnByb3RvdHlwZS5DT05TVU1FMz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDMsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsNCxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw1LGUpfSx0LnByb3RvdHlwZS5DT05TVU1FNj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDYsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU3PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsNyxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw4LGUpfSx0LnByb3RvdHlwZS5DT05TVU1FOT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDksZSl9LHQucHJvdG90eXBlLlNVQlJVTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCwwLGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFMT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDEsZSl9LHQucHJvdG90eXBlLlNVQlJVTEUyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsMixlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCwzLGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFND1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDQsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsNSxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw2LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFNz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDcsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsOCxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw5LGUpfSx0LnByb3RvdHlwZS5PUFRJT049ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCwwKX0sdC5wcm90b3R5cGUuT1BUSU9OMT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDEpfSx0LnByb3RvdHlwZS5PUFRJT04yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsMil9LHQucHJvdG90eXBlLk9QVElPTjM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCwzKX0sdC5wcm90b3R5cGUuT1BUSU9OND1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDQpfSx0LnByb3RvdHlwZS5PUFRJT041PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsNSl9LHQucHJvdG90eXBlLk9QVElPTjY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw2KX0sdC5wcm90b3R5cGUuT1BUSU9ONz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDcpfSx0LnByb3RvdHlwZS5PUFRJT044PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsOCl9LHQucHJvdG90eXBlLk9QVElPTjk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw5KX0sdC5wcm90b3R5cGUuT1I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDApfSx0LnByb3RvdHlwZS5PUjE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDEpfSx0LnByb3RvdHlwZS5PUjI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDIpfSx0LnByb3RvdHlwZS5PUjM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDMpfSx0LnByb3RvdHlwZS5PUjQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDQpfSx0LnByb3RvdHlwZS5PUjU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDUpfSx0LnByb3RvdHlwZS5PUjY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDYpfSx0LnByb3RvdHlwZS5PUjc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDcpfSx0LnByb3RvdHlwZS5PUjg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDgpfSx0LnByb3RvdHlwZS5PUjk9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3JJbnRlcm5hbCh0LDkpfSx0LnByb3RvdHlwZS5NQU5ZPWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDAsdCk7fSx0LnByb3RvdHlwZS5NQU5ZMT1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCgxLHQpO30sdC5wcm90b3R5cGUuTUFOWTI9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoMix0KTt9LHQucHJvdG90eXBlLk1BTlkzPWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDMsdCk7fSx0LnByb3RvdHlwZS5NQU5ZND1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg0LHQpO30sdC5wcm90b3R5cGUuTUFOWTU9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoNSx0KTt9LHQucHJvdG90eXBlLk1BTlk2PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDYsdCk7fSx0LnByb3RvdHlwZS5NQU5ZNz1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg3LHQpO30sdC5wcm90b3R5cGUuTUFOWTg9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoOCx0KTt9LHQucHJvdG90eXBlLk1BTlk5PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDksdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUD1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDAsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDE9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgxLHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVAyPWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMix0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQMz1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDMsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDQ9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg0LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA1PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNSx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQNj1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDYsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDc9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg3LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA4PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoOCx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQOT1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDksdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkU9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDEsdCl9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTI9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMix0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTM9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMyx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTQ9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTU9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNSx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTY9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNix0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTc9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNyx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTg9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOCx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORTk9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOSx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORV9TRVA9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgwLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDE9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgxLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDI9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgyLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDM9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgzLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDQ9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg0LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDU9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg1LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDY9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg2LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDc9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg3LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDg9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg4LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUDk9ZnVuY3Rpb24odCl7dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg5LHQpO30sdC5wcm90b3R5cGUuUlVMRT1mdW5jdGlvbih0LGUsbil7aWYodm9pZCAwPT09biYmKG49by5ERUZBVUxUX1JVTEVfQ09ORklHKSxyLmNvbnRhaW5zKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsdCkpe3ZhciBpPXttZXNzYWdlOmEuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7dG9wTGV2ZWxSdWxlOnQsZ3JhbW1hck5hbWU6dGhpcy5jbGFzc05hbWV9KSx0eXBlOm8uUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLHJ1bGVOYW1lOnR9O3RoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoKGkpO31pZih0aGlzLmRlZmluZWRSdWxlc05hbWVzLnB1c2godCksIXRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUuY29udGFpbnNLZXkodCkmJiF0aGlzLnNlcmlhbGl6ZWRHcmFtbWFyKXt2YXIgdT1zLmJ1aWxkVG9wUHJvZHVjdGlvbihlLnRvU3RyaW5nKCksdCx0aGlzLnRva2Vuc01hcCk7dGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZS5wdXQodCx1KTt9dmFyIGM9dGhpcy5kZWZpbmVSdWxlKHQsZSxuKTtyZXR1cm4gdGhpc1t0XT1jLGN9LHQucHJvdG90eXBlLk9WRVJSSURFX1JVTEU9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW8uREVGQVVMVF9SVUxFX0NPTkZJRyk7dmFyIHI9W107aWYocj1yLmNvbmNhdCh1LnZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbih0LHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsdGhpcy5jbGFzc05hbWUpKSx0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaC5hcHBseSh0aGlzLmRlZmluaXRpb25FcnJvcnMsciksIXRoaXMuc2VyaWFsaXplZEdyYW1tYXIpe3ZhciBpPXMuYnVpbGRUb3BQcm9kdWN0aW9uKGUudG9TdHJpbmcoKSx0LHRoaXMudG9rZW5zTWFwKTt0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlLnB1dCh0LGkpO312YXIgYT10aGlzLmRlZmluZVJ1bGUodCxlLG4pO3JldHVybiB0aGlzW3RdPWEsYX0sdC5wcm90b3R5cGUuQkFDS1RSQUNLPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnB1c2goMSk7dmFyIG49dGhpcy5zYXZlUmVjb2dTdGF0ZSgpO3RyeXtyZXR1cm4gdC5hcHBseSh0aGlzLGUpLCEwfWNhdGNoKHQpe2lmKGkuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbih0KSlyZXR1cm4gITE7dGhyb3cgdH1maW5hbGx5e3RoaXMucmVsb2FkUmVjb2dTdGF0ZShuKSx0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucG9wKCk7fX19LHQucHJvdG90eXBlLmdldEdBc3RQcm9kdWN0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlfSx0LnByb3RvdHlwZS5nZXRTZXJpYWxpemVkR2FzdFByb2R1Y3Rpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIGMuc2VyaWFsaXplR3JhbW1hcih0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlLnZhbHVlcygpKX0sdH0oKTtlLlJlY29nbml6ZXJBcGk9cDt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9big5KSxvPW4oNiksYT1uKDEyKSxzPW4oMTMpLHU9bigzKSxjPW4oMjUpLHA9bigyKSxsPW4oNyksaD1uKDQpLGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0UmVjb2duaXplckVuZ2luZT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuY2xhc3NOYW1lPWguY2xhc3NOYW1lRnJvbUluc3RhbmNlKHRoaXMpLHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbD1uZXcgaC5IYXNoVGFibGUsdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0PW5ldyBoLkhhc2hUYWJsZSx0aGlzLnJ1bGVTaG9ydE5hbWVJZHg9MjU2LHRoaXMudG9rZW5NYXRjaGVyPWwudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcyx0aGlzLmRlZmluZWRSdWxlc05hbWVzPVtdLHRoaXMudG9rZW5zTWFwPXt9LHRoaXMuYWxsUnVsZU5hbWVzPVtdLHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjaz1bXSx0aGlzLlJVTEVfU1RBQ0s9W10sdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s9W10sdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZT1uZXcgaC5IYXNoVGFibGUsdGhpcy5zZXJpYWxpemVkR3JhbW1hcj1yLmhhcyhlLFwic2VyaWFsaXplZEdyYW1tYXJcIik/ZS5zZXJpYWxpemVkR3JhbW1hcjp1LkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5zZXJpYWxpemVkR3JhbW1hcixyLmlzQXJyYXkodCkpe2lmKHIuaXNFbXB0eSh0KSl0aHJvdyBFcnJvcihcIkEgVG9rZW4gVm9jYWJ1bGFyeSBjYW5ub3QgYmUgZW1wdHkuXFxuXFx0Tm90ZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBmb3IgdGhlIHBhcnNlciBjb25zdHJ1Y3RvclxcblxcdGlzIG5vIGxvbmdlciBhIFRva2VuIHZlY3RvciAoc2luY2UgdjQuMCkuXCIpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0WzBdLnN0YXJ0T2Zmc2V0KXRocm93IEVycm9yKFwiVGhlIFBhcnNlciBjb25zdHJ1Y3RvciBubyBsb25nZXIgYWNjZXB0cyBhIHRva2VuIHZlY3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXFx0U2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2NoYW5nZXMvQlJFQUtJTkdfQ0hBTkdFUy5odG1sI180LTAtMFxcblxcdEZvciBGdXJ0aGVyIGRldGFpbHMuXCIpfWlmKHIuaXNBcnJheSh0KSl0aGlzLnRva2Vuc01hcD1yLnJlZHVjZSh0LGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbcC50b2tlbk5hbWUoZSldPWUsdH0se30pO2Vsc2UgaWYoci5oYXModCxcIm1vZGVzXCIpJiZyLmV2ZXJ5KHIuZmxhdHRlbihyLnZhbHVlcyh0Lm1vZGVzKSksbC5pc1Rva2VuVHlwZSkpe3ZhciBuPXIuZmxhdHRlbihyLnZhbHVlcyh0Lm1vZGVzKSksaT1yLnVuaXEobik7dGhpcy50b2tlbnNNYXA9ci5yZWR1Y2UoaSxmdW5jdGlvbih0LGUpe3JldHVybiB0W3AudG9rZW5OYW1lKGUpXT1lLHR9LHt9KTt9ZWxzZSB7aWYoIXIuaXNPYmplY3QodCkpdGhyb3cgbmV3IEVycm9yKFwiPHRva2Vuc0RpY3Rpb25hcnk+IGFyZ3VtZW50IG11c3QgYmUgQW4gQXJyYXkgb2YgVG9rZW4gY29uc3RydWN0b3JzLCBBIGRpY3Rpb25hcnkgb2YgVG9rZW4gY29uc3RydWN0b3JzIG9yIGFuIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb25cIik7dGhpcy50b2tlbnNNYXA9ci5jbG9uZU9iaih0KTt9dGhpcy50b2tlbnNNYXAuRU9GPXAuRU9GO3ZhciBvPXIuZXZlcnkoci52YWx1ZXModCksZnVuY3Rpb24odCl7cmV0dXJuIHIuaXNFbXB0eSh0LmNhdGVnb3J5TWF0Y2hlcyl9KTt0aGlzLnRva2VuTWF0Y2hlcj1vP2wudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllczpsLnRva2VuU3RydWN0dXJlZE1hdGNoZXIsbC5hdWdtZW50VG9rZW5UeXBlcyhyLnZhbHVlcyh0aGlzLnRva2Vuc01hcCkpO30sdC5wcm90b3R5cGUuZGVmaW5lUnVsZT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zZWxmQW5hbHlzaXNEb25lKXRocm93IEVycm9yKFwiR3JhbW1hciBydWxlIDxcIit0K1wiPiBtYXkgbm90IGJlIGRlZmluZWQgYWZ0ZXIgdGhlICdwZXJmb3JtU2VsZkFuYWx5c2lzJyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkJ1xcbk1ha2Ugc3VyZSB0aGF0IGFsbCBncmFtbWFyIHJ1bGUgZGVmaW5pdGlvbnMgYXJlIGRvbmUgYmVmb3JlICdwZXJmb3JtU2VsZkFuYWx5c2lzJyBpcyBjYWxsZWQuXCIpO3ZhciBhLHM9ci5oYXMobixcInJlc3luY0VuYWJsZWRcIik/bi5yZXN5bmNFbmFibGVkOnUuREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkLGM9ci5oYXMobixcInJlY292ZXJ5VmFsdWVGdW5jXCIpP24ucmVjb3ZlcnlWYWx1ZUZ1bmM6dS5ERUZBVUxUX1JVTEVfQ09ORklHLnJlY292ZXJ5VmFsdWVGdW5jLHA9dGhpcy5ydWxlU2hvcnROYW1lSWR4PDxpLkJJVFNfRk9SX01FVEhPRF9JRFgraS5CSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWDt0aGlzLnJ1bGVTaG9ydE5hbWVJZHgrKyx0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwucHV0KHAsdCksdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0LnB1dCh0LHApO3JldHVybiAoYT1mdW5jdGlvbihuLHIpe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSx0aGlzLnJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUocCx0LG4pLGZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gITA9PT10aGlzLm91dHB1dENzdD8oZS5hcHBseSh0aGlzLHQpLHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXSk6ZS5hcHBseSh0aGlzLHQpfWNhdGNoKHQpe3ZhciBuPTE9PT10aGlzLlJVTEVfU1RBQ0subGVuZ3RoLHI9cyYmIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSYmdGhpcy5yZWNvdmVyeUVuYWJsZWQ7aWYoby5pc1JlY29nbml0aW9uRXhjZXB0aW9uKHQpKXtpZihyKXt2YXIgaSxhPXRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpO2lmKHRoaXMuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0KGEpKXJldHVybiB0LnJlc3luY2VkVG9rZW5zPXRoaXMucmVTeW5jVG8oYSksdGhpcy5vdXRwdXRDc3Q/KChpPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXSkucmVjb3ZlcmVkTm9kZT0hMCxpKTpjKCk7dGhyb3cgdGhpcy5vdXRwdXRDc3QmJigoaT10aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGgtMV0pLnJlY292ZXJlZE5vZGU9ITAsdC5wYXJ0aWFsQ3N0UmVzdWx0PWkpLHR9aWYobilyZXR1cm4gdGhpcy5tb3ZlVG9UZXJtaW5hdGVkU3RhdGUoKSxjKCk7dGhyb3cgdH10aHJvdyB0fWZpbmFsbHl7dGhpcy5ydWxlRmluYWxseVN0YXRlVXBkYXRlKCk7fX0uY2FsbCh0aGlzLHIpfSkucnVsZU5hbWU9dCxhfSx0LnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuT1BUSU9OX0lEWCxlKSxyPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZSh0LG4pO3RyeXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKHQsZSxuKX1maW5hbGx5e3ZvaWQgMCE9PXImJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixyKTt9fSx0LnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5PUFRJT05fSURYLGUpO3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsTG9naWModCxlLG4pfSx0LnByb3RvdHlwZS5vcHRpb25JbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpLG89dGhpcyxhPXRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvck9wdGlvbihuLGUpO2lmKHZvaWQgMCE9PXQuREVGKXtpZihyPXQuREVGLHZvaWQgMCE9PShpPXQuR0FURSkpe3ZhciBzPWE7YT1mdW5jdGlvbigpe3JldHVybiBpLmNhbGwobykmJnMuY2FsbChvKX07fX1lbHNlIHI9dDtpZighMD09PWEuY2FsbCh0aGlzKSlyZXR1cm4gci5jYWxsKHRoaXMpfSx0LnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLkFUX0xFQVNUX09ORV9JRFgsdCkscj10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoZSxuKTt0cnl7cmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsTG9naWModCxlLG4pfWZpbmFsbHl7dm9pZCAwIT09ciYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLHIpO319LHQucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5BVF9MRUFTVF9PTkVfSURYLHQpO3RoaXMuYXRMZWFzdE9uZUludGVybmFsTG9naWModCxlLG4pO30sdC5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsTG9naWM9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG8sdT10aGlzLGM9dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yQXRMZWFzdE9uZShuLHQpO2lmKHZvaWQgMCE9PWUuREVGKXtpZihyPWUuREVGLHZvaWQgMCE9PShvPWUuR0FURSkpe3ZhciBwPWM7Yz1mdW5jdGlvbigpe3JldHVybiBvLmNhbGwodSkmJnAuY2FsbCh1KX07fX1lbHNlIHI9ZTtpZighMCE9PWMuY2FsbCh0aGlzKSl0aHJvdyB0aGlzLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKHQsYS5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksZS5FUlJfTVNHKTtmb3IodmFyIGw9dGhpcy5kb1NpbmdsZVJlcGV0aXRpb24ocik7ITA9PT1jLmNhbGwodGhpcykmJiEwPT09bDspbD10aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihyKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCxbdCxlXSxjLGkuQVRfTEVBU1RfT05FX0lEWCx0LHMuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKTt9LHQucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5BVF9MRUFTVF9PTkVfU0VQX0lEWCx0KSxyPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShlLG4pO3RyeXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWModCxlLG4pO31maW5hbGx5e3ZvaWQgMCE9PXImJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixyKTt9fSx0LnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbE5vQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5BVF9MRUFTVF9PTkVfU0VQX0lEWCx0KTt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWModCxlLG4pO30sdC5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcyxvPWUuREVGLHU9ZS5TRVA7aWYoITAhPT10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JBdExlYXN0T25lU2VwKG4sdCkuY2FsbCh0aGlzKSl0aHJvdyB0aGlzLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKHQsYS5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsZS5FUlJfTVNHKTtvLmNhbGwodGhpcyk7Zm9yKHZhciBjPWZ1bmN0aW9uKCl7cmV0dXJuIHIudG9rZW5NYXRjaGVyKHIuTEEoMSksdSl9OyEwPT09dGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSx1KTspdGhpcy5DT05TVU1FKHUpLG8uY2FsbCh0aGlzKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCxbdCx1LGMsbyxzLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcl0sYyxpLkFUX0xFQVNUX09ORV9TRVBfSURYLHQscy5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpO30sdC5wcm90b3R5cGUubWFueUludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5NQU5ZX0lEWCx0KSxyPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShlLG4pO3RyeXtyZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyh0LGUsbil9ZmluYWxseXt2b2lkIDAhPT1yJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4scik7fX0sdC5wcm90b3R5cGUubWFueUludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk1BTllfSURYLHQpO3JldHVybiB0aGlzLm1hbnlJbnRlcm5hbExvZ2ljKHQsZSxuKX0sdC5wcm90b3R5cGUubWFueUludGVybmFsTG9naWM9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG8sYT10aGlzLHU9dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yTWFueShuLHQpO2lmKHZvaWQgMCE9PWUuREVGKXtpZihyPWUuREVGLHZvaWQgMCE9PShvPWUuR0FURSkpe3ZhciBjPXU7dT1mdW5jdGlvbigpe3JldHVybiBvLmNhbGwoYSkmJmMuY2FsbChhKX07fX1lbHNlIHI9ZTtmb3IodmFyIHA9ITA7ITA9PT11LmNhbGwodGhpcykmJiEwPT09cDspcD10aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihyKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLm1hbnlJbnRlcm5hbCxbdCxlXSx1LGkuTUFOWV9JRFgsdCxzLk5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcik7fSx0LnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuTUFOWV9TRVBfSURYLHQpLHI9dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGUsbik7dHJ5e3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyh0LGUsbik7fWZpbmFsbHl7dm9pZCAwIT09ciYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLHIpO319LHQucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk1BTllfU0VQX0lEWCx0KTt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsTG9naWModCxlLG4pO30sdC5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYz1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcyxvPWUuREVGLGE9ZS5TRVA7aWYoITA9PT10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JNYW55U2VwKG4sdCkuY2FsbCh0aGlzKSl7by5jYWxsKHRoaXMpO2Zvcih2YXIgdT1mdW5jdGlvbigpe3JldHVybiByLnRva2VuTWF0Y2hlcihyLkxBKDEpLGEpfTshMD09PXRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksYSk7KXRoaXMuQ09OU1VNRShhKSxvLmNhbGwodGhpcyk7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsW3QsYSx1LG8scy5OZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXJdLHUsaS5NQU5ZX1NFUF9JRFgsdCxzLk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7fX0sdC5wcm90b3R5cGUucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsPWZ1bmN0aW9uKHQsZSxuLHIsbyl7Zm9yKDtuKCk7KXRoaXMuQ09OU1VNRShlKSxyLmNhbGwodGhpcyk7dGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsW3QsZSxuLHIsb10sbixpLkFUX0xFQVNUX09ORV9TRVBfSURYLHQsbyk7fSx0LnByb3RvdHlwZS5kb1NpbmdsZVJlcGV0aXRpb249ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7cmV0dXJuIHQuY2FsbCh0aGlzKSx0aGlzLmdldExleGVyUG9zaXRpb24oKT5lfSx0LnByb3RvdHlwZS5vckludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj1yLmlzQXJyYXkodCk/dDp0LkRFRixpPXRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvck9yKGUsbikuY2FsbCh0aGlzLG4pO2lmKHZvaWQgMCE9PWkpcmV0dXJuIG5baV0uQUxULmNhbGwodGhpcyk7dGhpcy5yYWlzZU5vQWx0RXhjZXB0aW9uKGUsdC5FUlJfTVNHKTt9LHQucHJvdG90eXBlLm9ySW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk9SX0lEWCxlKSxvPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZSh0LG4pO3RyeXt2YXIgYT1yLmlzQXJyYXkodCk/dDp0LkRFRixzPXRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvck9yKGUsYSkuY2FsbCh0aGlzLGEpO2lmKHZvaWQgMCE9PXMpe3ZhciB1PWFbc10sYz10aGlzLm5lc3RlZEFsdEJlZm9yZUNsYXVzZSh1LGUsaS5PUl9JRFgscyk7dHJ5e3JldHVybiB1LkFMVC5jYWxsKHRoaXMpfWZpbmFsbHl7dm9pZCAwIT09YyYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShjLnNob3J0TmFtZSxjLm5lc3RlZE5hbWUpO319dGhpcy5yYWlzZU5vQWx0RXhjZXB0aW9uKGUsdC5FUlJfTVNHKTt9ZmluYWxseXt2b2lkIDAhPT1vJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4sbyk7fX0sdC5wcm90b3R5cGUucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZT1mdW5jdGlvbigpe2lmKHRoaXMuUlVMRV9TVEFDSy5wb3AoKSx0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKSx0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSgpLDA9PT10aGlzLlJVTEVfU1RBQ0subGVuZ3RoJiYhdGhpcy5pc0F0RW5kT2ZJbnB1dCgpKXt2YXIgdD10aGlzLkxBKDEpLGU9dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7Zmlyc3RSZWR1bmRhbnQ6dCxydWxlTmFtZTp0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKX0pO3RoaXMuU0FWRV9FUlJPUihuZXcgby5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbihlLHQpKTt9fSx0LnByb3RvdHlwZS5zdWJydWxlSW50ZXJuYWw9ZnVuY3Rpb24odCxlLG4pe3ZhciByO3RyeXt2YXIgaT12b2lkIDAhPT1uP24uQVJHUzp2b2lkIDA7cmV0dXJuIHI9dC5jYWxsKHRoaXMsZSxpKSx0aGlzLmNzdFBvc3ROb25UZXJtaW5hbChyLHZvaWQgMCE9PW4mJnZvaWQgMCE9PW4uTEFCRUw/bi5MQUJFTDp0LnJ1bGVOYW1lKSxyfWNhdGNoKGUpe3Rocm93IG8uaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSYmdm9pZCAwIT09ZS5wYXJ0aWFsQ3N0UmVzdWx0JiYodGhpcy5jc3RQb3N0Tm9uVGVybWluYWwoZS5wYXJ0aWFsQ3N0UmVzdWx0LHZvaWQgMCE9PW4mJnZvaWQgMCE9PW4uTEFCRUw/bi5MQUJFTDp0LnJ1bGVOYW1lKSxkZWxldGUgZS5wYXJ0aWFsQ3N0UmVzdWx0KSxlfX0sdC5wcm90b3R5cGUuY29uc3VtZUludGVybmFsPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcjt0cnl7dmFyIGk9dGhpcy5MQSgxKTtpZighMCE9PXRoaXMudG9rZW5NYXRjaGVyKGksdCkpe3ZhciBhPXZvaWQgMCxzPXRoaXMuTEEoMCk7dGhyb3cgYT12b2lkIDAhPT1uJiZuLkVSUl9NU0c/bi5FUlJfTVNHOnRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7ZXhwZWN0ZWQ6dCxhY3R1YWw6aSxwcmV2aW91czpzLHJ1bGVOYW1lOnRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpfSksdGhpcy5TQVZFX0VSUk9SKG5ldyBvLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihhLGkscykpfXRoaXMuY29uc3VtZVRva2VuKCkscj1pO31jYXRjaChuKXtpZighdGhpcy5yZWNvdmVyeUVuYWJsZWR8fFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCIhPT1uLm5hbWV8fHRoaXMuaXNCYWNrVHJhY2tpbmcoKSl0aHJvdyBuO3ZhciB1PXRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHQsZSk7dHJ5e3I9dGhpcy50cnlJblJ1bGVSZWNvdmVyeSh0LHUpO31jYXRjaCh0KXt0aHJvdyB0Lm5hbWU9PT1jLklOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OP246dH19cmV0dXJuIHRoaXMuY3N0UG9zdFRlcm1pbmFsKHZvaWQgMCE9PW4mJnZvaWQgMCE9PW4uTEFCRUw/bi5MQUJFTDp0LnRva2VuTmFtZSxyKSxyfSx0LnByb3RvdHlwZS5zYXZlUmVjb2dTdGF0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZXJyb3JzLGU9ci5jbG9uZUFycih0aGlzLlJVTEVfU1RBQ0spO3JldHVybiB7ZXJyb3JzOnQsbGV4ZXJTdGF0ZTp0aGlzLmV4cG9ydExleGVyU3RhdGUoKSxSVUxFX1NUQUNLOmUsQ1NUX1NUQUNLOnRoaXMuQ1NUX1NUQUNLLExBU1RfRVhQTElDSVRfUlVMRV9TVEFDSzp0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS319LHQucHJvdG90eXBlLnJlbG9hZFJlY29nU3RhdGU9ZnVuY3Rpb24odCl7dGhpcy5lcnJvcnM9dC5lcnJvcnMsdGhpcy5pbXBvcnRMZXhlclN0YXRlKHQubGV4ZXJTdGF0ZSksdGhpcy5SVUxFX1NUQUNLPXQuUlVMRV9TVEFDSzt9LHQucHJvdG90eXBlLnJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnB1c2gobiksdGhpcy5SVUxFX1NUQUNLLnB1c2godCksdGhpcy5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUoZSx0KTt9LHQucHJvdG90eXBlLmlzQmFja1RyYWNraW5nPWZ1bmN0aW9uKCl7cmV0dXJuICFyLmlzRW1wdHkodGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrKX0sdC5wcm90b3R5cGUuZ2V0Q3VyclJ1bGVGdWxsTmFtZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO3JldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwuZ2V0KHQpfSx0LnByb3RvdHlwZS5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsLmdldCh0KX0sdC5wcm90b3R5cGUuaXNBdEVuZE9mSW5wdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSxwLkVPRil9LHQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5yZXNldExleGVyU3RhdGUoKSx0aGlzLmlzQmFja1RyYWNraW5nU3RhY2s9W10sdGhpcy5lcnJvcnM9W10sdGhpcy5SVUxFX1NUQUNLPVtdLHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLPVtdLHRoaXMuQ1NUX1NUQUNLPVtdLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLPVtdO30sdH0oKTtlLlJlY29nbml6ZXJFbmdpbmU9Zjt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDYpLGk9bigwKSxvPW4oMTIpLGE9bigzKSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuaW5pdEVycm9ySGFuZGxlcj1mdW5jdGlvbih0KXt0aGlzLl9lcnJvcnM9W10sdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlcj1pLmRlZmF1bHRzKHQuZXJyb3JNZXNzYWdlUHJvdmlkZXIsYS5ERUZBVUxUX1BBUlNFUl9DT05GSUcuZXJyb3JNZXNzYWdlUHJvdmlkZXIpO30sdC5wcm90b3R5cGUuU0FWRV9FUlJPUj1mdW5jdGlvbih0KXtpZihyLmlzUmVjb2duaXRpb25FeGNlcHRpb24odCkpcmV0dXJuIHQuY29udGV4dD17cnVsZVN0YWNrOnRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpLHJ1bGVPY2N1cnJlbmNlU3RhY2s6aS5jbG9uZUFycih0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyl9LHRoaXMuX2Vycm9ycy5wdXNoKHQpLHQ7dGhyb3cgRXJyb3IoXCJUcnlpbmcgdG8gc2F2ZSBhbiBFcnJvciB3aGljaCBpcyBub3QgYSBSZWNvZ25pdGlvbkV4Y2VwdGlvblwiKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZXJyb3JzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBpLmNsb25lQXJyKHRoaXMuX2Vycm9ycyl9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9lcnJvcnM9dDt9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmFpc2VFYXJseUV4aXRFeGNlcHRpb249ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxhPXRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KGkpLHM9by5nZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCh0LGEsZSx0aGlzLm1heExvb2thaGVhZClbMF0sdT1bXSxjPTE7Yzx0aGlzLm1heExvb2thaGVhZDtjKyspdS5wdXNoKHRoaXMuTEEoYykpO3ZhciBwPXRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKHtleHBlY3RlZEl0ZXJhdGlvblBhdGhzOnMsYWN0dWFsOnUscHJldmlvdXM6dGhpcy5MQSgwKSxjdXN0b21Vc2VyRGVzY3JpcHRpb246bixydWxlTmFtZTppfSk7dGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyByLkVhcmx5RXhpdEV4Y2VwdGlvbihwLHRoaXMuTEEoMSksdGhpcy5MQSgwKSkpfSx0LnByb3RvdHlwZS5yYWlzZU5vQWx0RXhjZXB0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLGk9dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQobiksYT1vLmdldExvb2thaGVhZFBhdGhzRm9yT3IodCxpLHRoaXMubWF4TG9va2FoZWFkKSxzPVtdLHU9MTt1PD10aGlzLm1heExvb2thaGVhZDt1Kyspcy5wdXNoKHRoaXMuTEEodSkpO3ZhciBjPXRoaXMuTEEoMCkscD10aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKHtleHBlY3RlZFBhdGhzUGVyQWx0OmEsYWN0dWFsOnMscHJldmlvdXM6YyxjdXN0b21Vc2VyRGVzY3JpcHRpb246ZSxydWxlTmFtZTp0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKX0pO3Rocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbihwLHRoaXMuTEEoMSksYykpfSx0fSgpO2UuRXJyb3JIYW5kbGVyPXM7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigxMyksaT1uKDApLG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0Q29udGVudEFzc2lzdD1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuY29tcHV0ZUNvbnRlbnRBc3Npc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlLmdldCh0KTtpZihpLmlzVW5kZWZpbmVkKG4pKXRocm93IEVycm9yKFwiUnVsZSAtPlwiK3QrXCI8LSBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGdyYW1tYXIuXCIpO3JldHVybiByLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtuXSxlLHRoaXMudG9rZW5NYXRjaGVyLHRoaXMubWF4TG9va2FoZWFkKX0sdC5wcm90b3R5cGUuZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcz1mdW5jdGlvbih0KXt2YXIgZT1pLmZpcnN0KHQucnVsZVN0YWNrKSxuPXRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KGUpO3JldHVybiBuZXcgci5OZXh0QWZ0ZXJUb2tlbldhbGtlcihuLHQpLnN0YXJ0V2Fsa2luZygpfSx0fSgpO2UuQ29udGVudEFzc2lzdD1vO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMTcpO2UuY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dm9pZCAwPT09ZT97fTplLGk9bi5yZXNvdXJjZUJhc2Usbz12b2lkIDA9PT1pP1wiaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkBcIityLlZFUlNJT04rXCIvZGlhZ3JhbXMvXCI6aSxhPW4uY3NzO3JldHVybiBcIlxcblxceDNjIS0tIFRoaXMgaXMgYSBnZW5lcmF0ZWQgZmlsZSAtLVxceDNlXFxuPCFET0NUWVBFIGh0bWw+XFxuPG1ldGEgY2hhcnNldD1cXFwidXRmLThcXFwiPlxcbjxzdHlsZT5cXG4gIGJvZHkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMzAsIDIwJSwgOTUlKVxcbiAgfVxcbjwvc3R5bGU+XFxuXFxuXFxuPGxpbmsgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSdcIisodm9pZCAwPT09YT9cImh0dHBzOi8vdW5wa2cuY29tL2NoZXZyb3RhaW5AXCIrci5WRVJTSU9OK1wiL2RpYWdyYW1zL2RpYWdyYW1zLmNzc1wiOmEpK1wiJz5cXG5cXG48c2NyaXB0IHNyYz0nXCIrbytcInZlbmRvci9yYWlscm9hZC1kaWFncmFtcy5qcyc+PFxcL3NjcmlwdD5cXG48c2NyaXB0IHNyYz0nXCIrbytcInNyYy9kaWFncmFtc19idWlsZGVyLmpzJz48XFwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIitvK1wic3JjL2RpYWdyYW1zX2JlaGF2aW9yLmpzJz48XFwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIitvKydzcmMvbWFpbi5qc1xcJz48XFwvc2NyaXB0PlxcblxcbjxkaXYgaWQ9XCJkaWFncmFtc1wiIGFsaWduPVwiY2VudGVyXCI+PC9kaXY+ICAgIFxcblxcbjxzY3JpcHQ+XFxuICAgIHdpbmRvdy5zZXJpYWxpemVkR3JhbW1hciA9ICcrSlNPTi5zdHJpbmdpZnkodCxudWxsLFwiICBcIikrJztcXG48XFwvc2NyaXB0PlxcblxcbjxzY3JpcHQ+XFxuICAgIHZhciBkaWFncmFtc0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGlhZ3JhbXNcIik7XFxuICAgIG1haW4uZHJhd0RpYWdyYW1zRnJvbVNlcmlhbGl6ZWRHcmFtbWFyKHNlcmlhbGl6ZWRHcmFtbWFyLCBkaWFncmFtc0Rpdik7XFxuPFxcL3NjcmlwdD5cXG4nfTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDQxKTtlLmdlbmVyYXRlUGFyc2VyRmFjdG9yeT1mdW5jdGlvbih0KXt2YXIgZT1yLmdlbldyYXBwZXJGdW5jdGlvbih7bmFtZTp0Lm5hbWUscnVsZXM6dC5ydWxlc30pLGk9bmV3IEZ1bmN0aW9uKFwidG9rZW5Wb2NhYnVsYXJ5XCIsXCJjb25maWdcIixcImNoZXZyb3RhaW5cIixlKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGkodC50b2tlblZvY2FidWxhcnksZSxuKDE4KSl9fSxlLmdlbmVyYXRlUGFyc2VyTW9kdWxlPWZ1bmN0aW9uKHQpe3JldHVybiByLmdlblVtZE1vZHVsZSh7bmFtZTp0Lm5hbWUscnVsZXM6dC5ydWxlc30pfTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9bigyKSxvPW4oMSksYT1cIlxcblwiO2Z1bmN0aW9uIHModCl7cmV0dXJuIFwiXFxuZnVuY3Rpb24gXCIrdC5uYW1lK1wiKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XFxuICAgIC8vIGludm9rZSBzdXBlciBjb25zdHJ1Y3RvclxcbiAgICAvLyBObyBzdXBwb3J0IGZvciBlbWJlZGRlZCBhY3Rpb25zIGN1cnJlbnRseSwgc28gd2UgY2FuICdoYXJkY29kZSdcXG4gICAgLy8gVGhlIHVzZSBvZiBDc3RQYXJzZXIuXFxuICAgIGNoZXZyb3RhaW4uQ3N0UGFyc2VyLmNhbGwodGhpcywgdG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpXFxuXFxuICAgIGNvbnN0ICQgPSB0aGlzXFxuXFxuICAgIFwiK3UodC5ydWxlcykrXCJcXG5cXG4gICAgLy8gdmVyeSBpbXBvcnRhbnQgdG8gY2FsbCB0aGlzIGFmdGVyIGFsbCB0aGUgcnVsZXMgaGF2ZSBiZWVuIGRlZmluZWQuXFxuICAgIC8vIG90aGVyd2lzZSB0aGUgcGFyc2VyIG1heSBub3Qgd29yayBjb3JyZWN0bHkgYXMgaXQgd2lsbCBsYWNrIGluZm9ybWF0aW9uXFxuICAgIC8vIGRlcml2ZWQgZHVyaW5nIHRoZSBzZWxmIGFuYWx5c2lzIHBoYXNlLlxcbiAgICB0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXModGhpcylcXG59XFxuXFxuLy8gaW5oZXJpdGFuY2UgYXMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBpbiB0aGUgcHJldmlvdXMgZGVjYWRlLi4uIDooXFxuXCIrdC5uYW1lK1wiLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY2hldnJvdGFpbi5Dc3RQYXJzZXIucHJvdG90eXBlKVxcblwiK3QubmFtZStcIi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBcIit0Lm5hbWUrXCIgICAgXFxuICAgIFwifWZ1bmN0aW9uIHUodCl7cmV0dXJuIHIubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIGModCwxKX0pLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gYyh0LGUpe3ZhciBuPXkoZSwnJC5SVUxFKFwiJyt0Lm5hbWUrJ1wiLCBmdW5jdGlvbigpIHsnKSthO3JldHVybiBuKz1tKHQuZGVmaW5pdGlvbixlKzEpLG4rPXkoZSsxLFwifSlcIikrYX1mdW5jdGlvbiBwKHQsZSl7dmFyIG49aS50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpO3JldHVybiB5KGUsXCIkLkNPTlNVTUVcIit0LmlkeCtcIih0aGlzLnRva2Vuc01hcC5cIituK1wiKVwiK2EpfWZ1bmN0aW9uIGwodCxlKXtyZXR1cm4geShlLFwiJC5TVUJSVUxFXCIrdC5pZHgrXCIoJC5cIit0Lm5vblRlcm1pbmFsTmFtZStcIilcIithKX1mdW5jdGlvbiBoKHQsZSl7dmFyIG49eShlLFwiJC5PUlwiK3QuaWR4K1wiKFtcIikrYTtyZXR1cm4gbis9ci5tYXAodC5kZWZpbml0aW9uLGZ1bmN0aW9uKHQpe3JldHVybiBmKHQsZSsxKX0pLmpvaW4oXCIsXCIrYSksbis9YSt5KGUsXCJdKVwiK2EpfWZ1bmN0aW9uIGYodCxlKXt2YXIgbj15KGUsXCJ7XCIpK2E7cmV0dXJuIHQubmFtZSYmKG4rPXkoZSsxLCdOQU1FOiBcIicrdC5uYW1lKydcIiwnKSthKSxuKz15KGUrMSxcIkFMVDogZnVuY3Rpb24oKSB7XCIpK2Esbis9bSh0LmRlZmluaXRpb24sZSsxKSxuKz15KGUrMSxcIn1cIikrYSxuKz15KGUsXCJ9XCIpfWZ1bmN0aW9uIGQodCxlLG4pe3ZhciByPXkobixcIiQuXCIrKHQrZS5pZHgpK1wiKFwiKTtyZXR1cm4gZS5uYW1lfHxlLnNlcGFyYXRvcj8ocis9XCJ7XCIrYSxlLm5hbWUmJihyKz15KG4rMSwnTkFNRTogXCInK2UubmFtZSsnXCInKStcIixcIithKSxlLnNlcGFyYXRvciYmKHIrPXkobisxLFwiU0VQOiB0aGlzLnRva2Vuc01hcC5cIitpLnRva2VuTmFtZShlLnNlcGFyYXRvcikpK1wiLFwiK2EpLHIrPVwiREVGOiBcIitFKGUuZGVmaW5pdGlvbixuKzIpK2Escis9eShuLFwifVwiKSthKTpyKz1FKGUuZGVmaW5pdGlvbixuKzEpLHIrPXkobixcIilcIikrYX1mdW5jdGlvbiBFKHQsZSl7dmFyIG49XCJmdW5jdGlvbigpIHtcIithO3JldHVybiBuKz1tKHQsZSksbis9eShlLFwifVwiKSthfWZ1bmN0aW9uIG0odCxlKXt2YXIgbj1cIlwiO3JldHVybiByLmZvckVhY2godCxmdW5jdGlvbih0KXtuKz1mdW5jdGlvbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBvLk5vblRlcm1pbmFsKXJldHVybiBsKHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uT3B0aW9uKXJldHVybiBkKFwiT1BUSU9OXCIsdCxlKTtpZih0IGluc3RhbmNlb2Ygby5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVybiBkKFwiQVRfTEVBU1RfT05FXCIsdCxlKTtpZih0IGluc3RhbmNlb2Ygby5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcilyZXR1cm4gZChcIkFUX0xFQVNUX09ORV9TRVBcIix0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKXJldHVybiBkKFwiTUFOWV9TRVBcIix0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLlJlcGV0aXRpb24pcmV0dXJuIGQoXCJNQU5ZXCIsdCxlKTtpZih0IGluc3RhbmNlb2Ygby5BbHRlcm5hdGlvbilyZXR1cm4gaCh0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLlRlcm1pbmFsKXJldHVybiBwKHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uRmxhdClyZXR1cm4gbSh0LmRlZmluaXRpb24sZSk7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX0odCxlKzEpO30pLG59ZnVuY3Rpb24geSh0LGUpe3JldHVybiBBcnJheSg0KnQrMSkuam9pbihcIiBcIikrZX1lLmdlblVtZE1vZHVsZT1mdW5jdGlvbih0KXtyZXR1cm4gXCJcXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxcbiAgICAgICAgZGVmaW5lKFsnY2hldnJvdGFpbiddLCBmYWN0b3J5KTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdjaGV2cm90YWluJykpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3Rvcnkocm9vdC5iKTtcXG4gICAgfVxcbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChjaGV2cm90YWluKSB7XFxuXFxuXCIrcyh0KStcIlxcbiAgICBcXG5yZXR1cm4ge1xcbiAgICBcIit0Lm5hbWUrXCI6IFwiK3QubmFtZStcIiBcXG59XFxufSkpO1xcblwifSxlLmdlbldyYXBwZXJGdW5jdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gXCIgICAgXFxuXCIrcyh0KStcIlxcbnJldHVybiBuZXcgXCIrdC5uYW1lK1wiKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSAgICBcXG5cIn0sZS5nZW5DbGFzcz1zLGUuZ2VuQWxsUnVsZXM9dSxlLmdlblJ1bGU9YyxlLmdlblRlcm1pbmFsPXAsZS5nZW5Ob25UZXJtaW5hbD1sLGUuZ2VuQWx0ZXJuYXRpb249aCxlLmdlblNpbmdsZUFsdD1mO31dKX0pO1xudmFyIGNoZXZyb3RhaW4gPSB3aW5kb3cuY2hldnJvdGFpbjtcblxudmFyIFZSTUxMb2FkZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBkZXBlbmRlbmN5IGNoZWNrXG5cblx0aWYgKCB0eXBlb2YgY2hldnJvdGFpbiA9PT0gJ3VuZGVmaW5lZCcgKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdHRocm93IEVycm9yKCAnVEhSRUUuVlJNTExvYWRlcjogRXh0ZXJuYWwgbGlicmFyeSBjaGV2cm90YWluLm1pbi5qcyByZXF1aXJlZC4nICk7XG5cblx0fVxuXG5cdC8vIGNsYXNzIGRlZmluaXRpb25zXG5cblx0ZnVuY3Rpb24gVlJNTExvYWRlciggbWFuYWdlciApIHtcblxuXHRcdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0VlJNTExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IFZSTUxMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcGF0aCA9ICggc2NvcGUucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHNjb3BlLnBhdGg7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCwgcGF0aCApICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCBkYXRhLCBwYXRoICkge1xuXG5cdFx0XHR2YXIgbm9kZU1hcCA9IHt9O1xuXG5cdFx0XHRmdW5jdGlvbiBnZW5lcmF0ZVZSTUxUcmVlKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIGNyZWF0ZSBsZXhlciwgcGFyc2VyIGFuZCB2aXNpdG9yXG5cblx0XHRcdFx0dmFyIHRva2VuRGF0YSA9IGNyZWF0ZVRva2VucygpO1xuXG5cdFx0XHRcdHZhciBsZXhlciA9IG5ldyBWUk1MTGV4ZXIoIHRva2VuRGF0YS50b2tlbnMgKTtcblx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBWUk1MUGFyc2VyKCB0b2tlbkRhdGEudG9rZW5Wb2NhYnVsYXJ5ICk7XG5cdFx0XHRcdHZhciB2aXNpdG9yID0gY3JlYXRlVmlzaXRvciggcGFyc2VyLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSApO1xuXG5cdFx0XHRcdC8vIGxleGluZ1xuXG5cdFx0XHRcdHZhciBsZXhpbmdSZXN1bHQgPSBsZXhlci5sZXgoIGRhdGEgKTtcblx0XHRcdFx0cGFyc2VyLmlucHV0ID0gbGV4aW5nUmVzdWx0LnRva2VucztcblxuXHRcdFx0XHQvLyBwYXJzaW5nXG5cblx0XHRcdFx0dmFyIGNzdE91dHB1dCA9IHBhcnNlci52cm1sKCk7XG5cblx0XHRcdFx0aWYgKCBwYXJzZXIuZXJyb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBwYXJzZXIuZXJyb3JzICk7XG5cblx0XHRcdFx0XHR0aHJvdyBFcnJvciggJ1RIUkVFLlZSTUxMb2FkZXI6IFBhcnNpbmcgZXJyb3JzIGRldGVjdGVkLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYWN0aW9uc1xuXG5cdFx0XHRcdHZhciBhc3QgPSB2aXNpdG9yLnZpc2l0KCBjc3RPdXRwdXQgKTtcblxuXHRcdFx0XHRyZXR1cm4gYXN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZVRva2VucygpIHtcblxuXHRcdFx0XHR2YXIgY3JlYXRlVG9rZW4gPSBjaGV2cm90YWluLmNyZWF0ZVRva2VuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0XHRcdFx0Ly8gZnJvbSBodHRwOi8vZ3VuLnRlaXBpci5nci9WUk1MLWFtZ2VtL3NwZWMvcGFydDEvY29uY2VwdHMuaHRtbCNTeW50YXhCYXNpY3NcblxuXHRcdFx0XHR2YXIgUm91dGVJZGVudGlmaWVyID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1JvdXRlSWRlbnRpZmllcicsIHBhdHRlcm46IC9bXlxceDMwLVxceDM5XFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXVteXFwwLVxceDIwXFx4MjJcXHgyN1xceDIzXFx4MmJcXHgyY1xceDJkXFx4MmVcXHg1YlxceDVkXFx4NWNcXHg3YlxceDdkXSpbXFwuXVteXFx4MzAtXFx4MzlcXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdW15cXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdKi8gfSApO1xuXHRcdFx0XHR2YXIgSWRlbnRpZmllciA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdJZGVudGlmaWVyJywgcGF0dGVybjogL1teXFx4MzAtXFx4MzlcXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdW15cXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdKi8sIGxvbmdlcl9hbHQ6IFJvdXRlSWRlbnRpZmllciB9ICk7XG5cblx0XHRcdFx0Ly8gZnJvbSBodHRwOi8vZ3VuLnRlaXBpci5nci9WUk1MLWFtZ2VtL3NwZWMvcGFydDEvbm9kZXNSZWYuaHRtbFxuXG5cdFx0XHRcdHZhciBub2RlVHlwZXMgPSBbXG5cdFx0XHRcdFx0J0FuY2hvcicsICdCaWxsYm9hcmQnLCAnQ29sbGlzaW9uJywgJ0dyb3VwJywgJ1RyYW5zZm9ybScsIC8vIGdyb3VwaW5nIG5vZGVzXG5cdFx0XHRcdFx0J0lubGluZScsICdMT0QnLCAnU3dpdGNoJywgLy8gc3BlY2lhbCBncm91cHNcblx0XHRcdFx0XHQnQXVkaW9DbGlwJywgJ0RpcmVjdGlvbmFsTGlnaHQnLCAnUG9pbnRMaWdodCcsICdTY3JpcHQnLCAnU2hhcGUnLCAnU291bmQnLCAnU3BvdExpZ2h0JywgJ1dvcmxkSW5mbycsIC8vIGNvbW1vbiBub2Rlc1xuXHRcdFx0XHRcdCdDeWxpbmRlclNlbnNvcicsICdQbGFuZVNlbnNvcicsICdQcm94aW1pdHlTZW5zb3InLCAnU3BoZXJlU2Vuc29yJywgJ1RpbWVTZW5zb3InLCAnVG91Y2hTZW5zb3InLCAnVmlzaWJpbGl0eVNlbnNvcicsIC8vIHNlbnNvcnNcblx0XHRcdFx0XHQnQm94JywgJ0NvbmUnLCAnQ3lsaW5kZXInLCAnRWxldmF0aW9uR3JpZCcsICdFeHRydXNpb24nLCAnSW5kZXhlZEZhY2VTZXQnLCAnSW5kZXhlZExpbmVTZXQnLCAnUG9pbnRTZXQnLCAnU3BoZXJlJywgLy8gZ2VvbWV0cmllc1xuXHRcdFx0XHRcdCdDb2xvcicsICdDb29yZGluYXRlJywgJ05vcm1hbCcsICdUZXh0dXJlQ29vcmRpbmF0ZScsIC8vIGdlb21ldHJpYyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0J0FwcGVhcmFuY2UnLCAnRm9udFN0eWxlJywgJ0ltYWdlVGV4dHVyZScsICdNYXRlcmlhbCcsICdNb3ZpZVRleHR1cmUnLCAnUGl4ZWxUZXh0dXJlJywgJ1RleHR1cmVUcmFuc2Zvcm0nLCAvLyBhcHBlYXJhbmNlXG5cdFx0XHRcdFx0J0NvbG9ySW50ZXJwb2xhdG9yJywgJ0Nvb3JkaW5hdGVJbnRlcnBvbGF0b3InLCAnTm9ybWFsSW50ZXJwb2xhdG9yJywgJ09yaWVudGF0aW9uSW50ZXJwb2xhdG9yJywgJ1Bvc2l0aW9uSW50ZXJwb2xhdG9yJywgJ1NjYWxhckludGVycG9sYXRvcicsIC8vIGludGVycG9sYXRvcnNcblx0XHRcdFx0XHQnQmFja2dyb3VuZCcsICdGb2cnLCAnTmF2aWdhdGlvbkluZm8nLCAnVmlld3BvaW50JywgLy8gYmluZGFibGUgbm9kZXNcblx0XHRcdFx0XHQnVGV4dCcgLy8gVGV4dCBtdXN0IGJlIHBsYWNlZCBhdCB0aGUgZW5kIG9mIHRoZSByZWdleCBzbyB0aGVyZSBhcmUgbm8gbWF0Y2hlcyBmb3IgVGV4dHVyZVRyYW5zZm9ybSBhbmQgVGV4dHVyZUNvb3JkaW5hdGVcblx0XHRcdFx0XTtcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdHZhciBWZXJzaW9uID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnVmVyc2lvbicsXG5cdFx0XHRcdFx0cGF0dGVybjogLyNWUk1MLiovLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciBOb2RlTmFtZSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ05vZGVOYW1lJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiBuZXcgUmVnRXhwKCBub2RlVHlwZXMuam9pbiggJ3wnICkgKSxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgREVGID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnREVGJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvREVGLyxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgVVNFID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnVVNFJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvVVNFLyxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgUk9VVEUgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdST1VURScsXG5cdFx0XHRcdFx0cGF0dGVybjogL1JPVVRFLyxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR2YXIgVE8gPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdUTycsXG5cdFx0XHRcdFx0cGF0dGVybjogL1RPLyxcblx0XHRcdFx0XHRsb25nZXJfYWx0OiBJZGVudGlmaWVyXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdHZhciBTdHJpbmdMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1N0cmluZ0xpdGVyYWwnLCBwYXR0ZXJuOiAvXCIoOj9bXlxcXFxcIlxcblxccl0rfFxcXFwoOj9bYmZucnR2XCJcXFxcL118dVswLTlhLWZBLUZdezR9KSkqXCIvIH0gKTtcblx0XHRcdFx0dmFyIEhleExpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnSGV4TGl0ZXJhbCcsIHBhdHRlcm46IC8wW3hYXVswLTlhLWZBLUZdKy8gfSApO1xuXHRcdFx0XHR2YXIgTnVtYmVyTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdOdW1iZXJMaXRlcmFsJywgcGF0dGVybjogL1stK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspPy8gfSApO1xuXHRcdFx0XHR2YXIgVHJ1ZUxpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnVHJ1ZUxpdGVyYWwnLCBwYXR0ZXJuOiAvVFJVRS8gfSApO1xuXHRcdFx0XHR2YXIgRmFsc2VMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0ZhbHNlTGl0ZXJhbCcsIHBhdHRlcm46IC9GQUxTRS8gfSApO1xuXHRcdFx0XHR2YXIgTnVsbExpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnTnVsbExpdGVyYWwnLCBwYXR0ZXJuOiAvTlVMTC8gfSApO1xuXHRcdFx0XHR2YXIgTFNxdWFyZSA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdMU3F1YXJlJywgcGF0dGVybjogL1xcWy8gfSApO1xuXHRcdFx0XHR2YXIgUlNxdWFyZSA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdSU3F1YXJlJywgcGF0dGVybjogL10vIH0gKTtcblx0XHRcdFx0dmFyIExDdXJseSA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdMQ3VybHknLCBwYXR0ZXJuOiAvey8gfSApO1xuXHRcdFx0XHR2YXIgUkN1cmx5ID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1JDdXJseScsIHBhdHRlcm46IC99LyB9ICk7XG5cdFx0XHRcdHZhciBDb21tZW50ID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnQ29tbWVudCcsXG5cdFx0XHRcdFx0cGF0dGVybjogLyMuKi8sXG5cdFx0XHRcdFx0Z3JvdXA6IGNoZXZyb3RhaW4uTGV4ZXIuU0tJUFBFRCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBjb21tYXMsIGJsYW5rcywgdGFicywgbmV3bGluZXMgYW5kIGNhcnJpYWdlIHJldHVybnMgYXJlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB3aGVyZXZlciB0aGV5IGFwcGVhciBvdXRzaWRlIG9mIHN0cmluZyBmaWVsZHNcblxuXHRcdFx0XHR2YXIgV2hpdGVTcGFjZSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ1doaXRlU3BhY2UnLFxuXHRcdFx0XHRcdHBhdHRlcm46IC9bICxcXHNdLyxcblx0XHRcdFx0XHRncm91cDogY2hldnJvdGFpbi5MZXhlci5TS0lQUEVEIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciB0b2tlbnMgPSBbXG5cdFx0XHRcdFx0V2hpdGVTcGFjZSxcblx0XHRcdFx0XHQvLyBrZXl3b3JkcyBhcHBlYXIgYmVmb3JlIHRoZSBJZGVudGlmaWVyXG5cdFx0XHRcdFx0Tm9kZU5hbWUsXG5cdFx0XHRcdFx0REVGLFxuXHRcdFx0XHRcdFVTRSxcblx0XHRcdFx0XHRST1VURSxcblx0XHRcdFx0XHRUTyxcblx0XHRcdFx0XHRUcnVlTGl0ZXJhbCxcblx0XHRcdFx0XHRGYWxzZUxpdGVyYWwsXG5cdFx0XHRcdFx0TnVsbExpdGVyYWwsXG5cdFx0XHRcdFx0Ly8gdGhlIElkZW50aWZpZXIgbXVzdCBhcHBlYXIgYWZ0ZXIgdGhlIGtleXdvcmRzIGJlY2F1c2UgYWxsIGtleXdvcmRzIGFyZSB2YWxpZCBpZGVudGlmaWVyc1xuXHRcdFx0XHRcdFZlcnNpb24sXG5cdFx0XHRcdFx0SWRlbnRpZmllcixcblx0XHRcdFx0XHRSb3V0ZUlkZW50aWZpZXIsXG5cdFx0XHRcdFx0U3RyaW5nTGl0ZXJhbCxcblx0XHRcdFx0XHRIZXhMaXRlcmFsLFxuXHRcdFx0XHRcdE51bWJlckxpdGVyYWwsXG5cdFx0XHRcdFx0TFNxdWFyZSxcblx0XHRcdFx0XHRSU3F1YXJlLFxuXHRcdFx0XHRcdExDdXJseSxcblx0XHRcdFx0XHRSQ3VybHksXG5cdFx0XHRcdFx0Q29tbWVudFxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdHZhciB0b2tlblZvY2FidWxhcnkgPSB7fTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHRcdFx0dG9rZW5Wb2NhYnVsYXJ5WyB0b2tlbi5uYW1lIF0gPSB0b2tlbjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHsgdG9rZW5zOiB0b2tlbnMsIHRva2VuVm9jYWJ1bGFyeTogdG9rZW5Wb2NhYnVsYXJ5IH07XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBjcmVhdGVWaXNpdG9yKCBCYXNlVlJNTFZpc2l0b3IgKSB7XG5cblx0XHRcdFx0Ly8gdGhlIHZpc2l0b3IgaXMgY3JlYXRlZCBkeW5tYWljYWxseSBiYXNlZCBvbiB0aGUgZ2l2ZW4gYmFzZSBjbGFzc1xuXG5cdFx0XHRcdGZ1bmN0aW9uIFZSTUxUb0FTVFZpc2l0b3IoKSB7XG5cblx0XHRcdFx0XHRCYXNlVlJNTFZpc2l0b3IuY2FsbCggdGhpcyApO1xuXG5cdFx0XHRcdFx0dGhpcy52YWxpZGF0ZVZpc2l0b3IoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0VlJNTFRvQVNUVmlzaXRvci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBCYXNlVlJNTFZpc2l0b3IucHJvdG90eXBlICksIHtcblxuXHRcdFx0XHRcdGNvbnN0cnVjdG9yOiBWUk1MVG9BU1RWaXNpdG9yLFxuXG5cdFx0XHRcdFx0dnJtbDogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiB0aGlzLnZpc2l0KCBjdHgudmVyc2lvbiApLFxuXHRcdFx0XHRcdFx0XHRub2RlczogW10sXG5cdFx0XHRcdFx0XHRcdHJvdXRlczogW11cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5ub2RlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG5vZGUgPSBjdHgubm9kZVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEubm9kZXMucHVzaCggdGhpcy52aXNpdCggbm9kZSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBjdHgucm91dGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LnJvdXRlLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgcm91dGUgPSBjdHgucm91dGVbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucm91dGVzLnB1c2goIHRoaXMudmlzaXQoIHJvdXRlICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0dmVyc2lvbjogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBjdHguVmVyc2lvblsgMCBdLmltYWdlO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdG5vZGU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0bmFtZTogY3R4Lk5vZGVOYW1lWyAwIF0uaW1hZ2UsXG5cdFx0XHRcdFx0XHRcdGZpZWxkczogW11cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmICggY3R4LmZpZWxkICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5maWVsZC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZpZWxkID0gY3R4LmZpZWxkWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhLmZpZWxkcy5wdXNoKCB0aGlzLnZpc2l0KCBmaWVsZCApICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIERFRlxuXG5cdFx0XHRcdFx0XHRpZiAoIGN0eC5kZWYgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS5ERUYgPSB0aGlzLnZpc2l0KCBjdHguZGVmWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRmaWVsZDogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiBjdHguSWRlbnRpZmllclsgMCBdLmltYWdlLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IG51bGxcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdFx0XHRcdC8vIFNGVmFsdWVcblxuXHRcdFx0XHRcdFx0aWYgKCBjdHguc2luZ2xlRmllbGRWYWx1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB0aGlzLnZpc2l0KCBjdHguc2luZ2xlRmllbGRWYWx1ZVsgMCBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTUZWYWx1ZVxuXG5cdFx0XHRcdFx0XHRpZiAoIGN0eC5tdWx0aUZpZWxkVmFsdWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gdGhpcy52aXNpdCggY3R4Lm11bHRpRmllbGRWYWx1ZVsgMCBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YS50eXBlID0gcmVzdWx0LnR5cGU7XG5cdFx0XHRcdFx0XHRkYXRhLnZhbHVlcyA9IHJlc3VsdC52YWx1ZXM7XG5cblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGRlZjogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiAoIGN0eC5JZGVudGlmaWVyIHx8IGN0eC5Ob2RlTmFtZSApWyAwIF0uaW1hZ2U7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0dXNlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHsgVVNFOiAoIGN0eC5JZGVudGlmaWVyIHx8IGN0eC5Ob2RlTmFtZSApWyAwIF0uaW1hZ2UgfTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRzaW5nbGVGaWVsZFZhbHVlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NGaWVsZCggdGhpcywgY3R4ICk7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0bXVsdGlGaWVsZFZhbHVlOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NGaWVsZCggdGhpcywgY3R4ICk7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0cm91dGU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0RlJPTTogY3R4LlJvdXRlSWRlbnRpZmllclsgMCBdLmltYWdlLFxuXHRcdFx0XHRcdFx0XHRUTzogY3R4LlJvdXRlSWRlbnRpZmllclsgMSBdLmltYWdlXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0ZnVuY3Rpb24gcHJvY2Vzc0ZpZWxkKCBzY29wZSwgY3R4ICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0ge1xuXHRcdFx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0XHRcdHZhbHVlczogW11cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0aWYgKCBjdHgubm9kZSApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdub2RlJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4Lm5vZGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGN0eC5ub2RlWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIHNjb3BlLnZpc2l0KCBub2RlICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHgudXNlICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ3VzZSc7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC51c2UubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdXNlID0gY3R4LnVzZVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBzY29wZS52aXNpdCggdXNlICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguU3RyaW5nTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdzdHJpbmcnO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguU3RyaW5nTGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzdHJpbmdMaXRlcmFsID0gY3R4LlN0cmluZ0xpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggc3RyaW5nTGl0ZXJhbC5pbWFnZS5yZXBsYWNlKCAvJ3xcIi9nLCAnJyApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4Lk51bWJlckxpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnbnVtYmVyJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4Lk51bWJlckxpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbnVtYmVyTGl0ZXJhbCA9IGN0eC5OdW1iZXJMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIHBhcnNlRmxvYXQoIG51bWJlckxpdGVyYWwuaW1hZ2UgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5IZXhMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ2hleCc7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5IZXhMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGhleExpdGVyYWwgPSBjdHguSGV4TGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBoZXhMaXRlcmFsLmltYWdlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4LlRydWVMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ2Jvb2xlYW4nO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguVHJ1ZUxpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdHJ1ZUxpdGVyYWwgPSBjdHguVHJ1ZUxpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRydWVMaXRlcmFsLmltYWdlID09PSAnVFJVRScgKSBmaWVsZC52YWx1ZXMucHVzaCggdHJ1ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5GYWxzZUxpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnYm9vbGVhbic7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5GYWxzZUxpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZmFsc2VMaXRlcmFsID0gY3R4LkZhbHNlTGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZmFsc2VMaXRlcmFsLmltYWdlID09PSAnRkFMU0UnICkgZmllbGQudmFsdWVzLnB1c2goIGZhbHNlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4Lk51bGxMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ251bGwnO1xuXG5cdFx0XHRcdFx0XHRjdHguTnVsbExpdGVyYWwuZm9yRWFjaCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBudWxsICk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmaWVsZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBWUk1MVG9BU1RWaXNpdG9yKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VUcmVlKCB0cmVlICkge1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBKU09OLnN0cmluZ2lmeSggdHJlZSwgbnVsbCwgMiApICk7XG5cblx0XHRcdFx0dmFyIG5vZGVzID0gdHJlZS5ub2Rlcztcblx0XHRcdFx0dmFyIHNjZW5lID0gbmV3IFNjZW5lKCk7XG5cblx0XHRcdFx0Ly8gZmlyc3QgaXRlcmF0aW9uOiBidWlsZCBub2RlbWFwIGJhc2VkIG9uIERFRiBzdGF0ZW1lbnRzXG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBub2RlID0gbm9kZXNbIGkgXTtcblxuXHRcdFx0XHRcdGJ1aWxkTm9kZU1hcCggbm9kZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZWNvbmQgaXRlcmF0aW9uOiBidWlsZCBub2Rlc1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgbm9kZSA9IG5vZGVzWyBpIF07XG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IGdldE5vZGUoIG5vZGUgKTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0M0QgKSBzY2VuZS5hZGQoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBub2RlLm5hbWUgPT09ICdXb3JsZEluZm8nICkgc2NlbmUudXNlckRhdGEud29ybGRJbmZvID0gb2JqZWN0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc2NlbmU7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGROb2RlTWFwKCBub2RlICkge1xuXG5cdFx0XHRcdGlmICggbm9kZS5ERUYgKSB7XG5cblx0XHRcdFx0XHRub2RlTWFwWyBub2RlLkRFRiBdID0gbm9kZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIGZpZWxkLnR5cGUgPT09ICdub2RlJyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmllbGRWYWx1ZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0YnVpbGROb2RlTWFwKCBmaWVsZFZhbHVlc1sgaiBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGdldE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlcmUgYSBub2RlIHJlZmVycyB0byBhIGRpZmZlcmVudCBvbmVcblxuXHRcdFx0XHRpZiAoIG5vZGUuVVNFICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmVVU0UoIG5vZGUuVVNFICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbm9kZS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIG5vZGUuYnVpbGQ7XG5cblx0XHRcdFx0bm9kZS5idWlsZCA9IGJ1aWxkTm9kZSggbm9kZSApO1xuXG5cdFx0XHRcdHJldHVybiBub2RlLmJ1aWxkO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG5vZGUgYnVpbGRlclxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZS5uYW1lO1xuXHRcdFx0XHR2YXIgYnVpbGQ7XG5cblx0XHRcdFx0c3dpdGNoICggbm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdHcm91cCc6XG5cdFx0XHRcdFx0Y2FzZSAnVHJhbnNmb3JtJzpcblx0XHRcdFx0XHRjYXNlICdDb2xsaXNpb24nOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEdyb3VwaW5nTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdCYWNrZ3JvdW5kJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRCYWNrZ3JvdW5kTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTaGFwZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkU2hhcGVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0FwcGVhcmFuY2UnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEFwcGVhcmFuY2VOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ01hdGVyaWFsJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRNYXRlcmlhbE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSW1hZ2VUZXh0dXJlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRJbWFnZVRleHR1cmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1BpeGVsVGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkUGl4ZWxUZXh0dXJlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdUZXh0dXJlVHJhbnNmb3JtJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRUZXh0dXJlVHJhbnNmb3JtTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdJbmRleGVkRmFjZVNldCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkSW5kZXhlZEZhY2VTZXROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0luZGV4ZWRMaW5lU2V0Jzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRJbmRleGVkTGluZVNldE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUG9pbnRTZXQnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFBvaW50U2V0Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdCb3gnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEJveE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ29uZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQ29uZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXInOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEN5bGluZGVyTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcGhlcmUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFNwaGVyZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRWxldmF0aW9uR3JpZCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkRWxldmF0aW9uR3JpZE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRXh0cnVzaW9uJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRFeHRydXNpb25Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0NvbG9yJzpcblx0XHRcdFx0XHRjYXNlICdDb29yZGluYXRlJzpcblx0XHRcdFx0XHRjYXNlICdOb3JtYWwnOlxuXHRcdFx0XHRcdGNhc2UgJ1RleHR1cmVDb29yZGluYXRlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRHZW9tZXRyaWNOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1dvcmxkSW5mbyc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkV29ybGRJbmZvTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdBbmNob3InOlxuXHRcdFx0XHRcdGNhc2UgJ0JpbGxib2FyZCc6XG5cblx0XHRcdFx0XHRjYXNlICdJbmxpbmUnOlxuXHRcdFx0XHRcdGNhc2UgJ0xPRCc6XG5cdFx0XHRcdFx0Y2FzZSAnU3dpdGNoJzpcblxuXHRcdFx0XHRcdGNhc2UgJ0F1ZGlvQ2xpcCc6XG5cdFx0XHRcdFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XG5cdFx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XG5cdFx0XHRcdFx0Y2FzZSAnU2NyaXB0Jzpcblx0XHRcdFx0XHRjYXNlICdTb3VuZCc6XG5cdFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRcdGNhc2UgJ0N5bGluZGVyU2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdQbGFuZVNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnUHJveGltaXR5U2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdTcGhlcmVTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1RpbWVTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1RvdWNoU2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdWaXNpYmlsaXR5U2Vuc29yJzpcblxuXHRcdFx0XHRcdGNhc2UgJ1RleHQnOlxuXG5cdFx0XHRcdFx0Y2FzZSAnRm9udFN0eWxlJzpcblx0XHRcdFx0XHRjYXNlICdNb3ZpZVRleHR1cmUnOlxuXG5cdFx0XHRcdFx0Y2FzZSAnQ29sb3JJbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRcdGNhc2UgJ0Nvb3JkaW5hdGVJbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRcdGNhc2UgJ05vcm1hbEludGVycG9sYXRvcic6XG5cdFx0XHRcdFx0Y2FzZSAnT3JpZW50YXRpb25JbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRcdGNhc2UgJ1Bvc2l0aW9uSW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0XHRjYXNlICdTY2FsYXJJbnRlcnBvbGF0b3InOlxuXG5cdFx0XHRcdFx0Y2FzZSAnRm9nJzpcblx0XHRcdFx0XHRjYXNlICdOYXZpZ2F0aW9uSW5mbyc6XG5cdFx0XHRcdFx0Y2FzZSAnVmlld3BvaW50Jzpcblx0XHRcdFx0XHRcdC8vIG5vZGUgbm90IHN1cHBvcnRlZCB5ZXRcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gbm9kZTonLCBub2RlTmFtZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYnVpbGQgIT09IHVuZGVmaW5lZCAmJiBub2RlLkRFRiAhPT0gdW5kZWZpbmVkICYmIGJ1aWxkLmhhc093blByb3BlcnR5KCAnbmFtZScgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGJ1aWxkLm5hbWUgPSBub2RlLkRFRjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkR3JvdXBpbmdOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBvYmplY3QgPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmJveENlbnRlcic6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Jib3hTaXplJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2VudGVyJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2hpbGRyZW4nOlxuXHRcdFx0XHRcdFx0XHRwYXJzZUZpZWxkQ2hpbGRyZW4oIGZpZWxkVmFsdWVzLCBvYmplY3QgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbGxpZGUnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyb3RhdGlvbic6XG5cdFx0XHRcdFx0XHRcdHZhciBheGlzID0gbmV3IFZlY3RvcjMoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gZmllbGRWYWx1ZXNbIDMgXTtcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnNjYWxlLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGVPcmllbnRhdGlvbic6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncHJveHknOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEJhY2tncm91bmROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdHZhciBncm91bmRBbmdsZSwgZ3JvdW5kQ29sb3I7XG5cdFx0XHRcdHZhciBza3lBbmdsZSwgc2t5Q29sb3I7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdncm91bmRBbmdsZSc6XG5cdFx0XHRcdFx0XHRcdGdyb3VuZEFuZ2xlID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdncm91bmRDb2xvcic6XG5cdFx0XHRcdFx0XHRcdGdyb3VuZENvbG9yID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiYWNrVXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYm90dG9tVXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZnJvbnRVcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdsZWZ0VXJsJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmlnaHRVcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0b3BVcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdza3lBbmdsZSc6XG5cdFx0XHRcdFx0XHRcdHNreUFuZ2xlID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdza3lDb2xvcic6XG5cdFx0XHRcdFx0XHRcdHNreUNvbG9yID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHJhZGl1cyA9IDEwMDAwO1xuXG5cdFx0XHRcdC8vIHNreVxuXG5cdFx0XHRcdGlmICggc2t5Q29sb3IgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2t5R2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgMzIsIDE2ICk7XG5cdFx0XHRcdFx0dmFyIHNreU1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UsIHNpZGU6IEJhY2tTaWRlLCBkZXB0aFdyaXRlOiBmYWxzZSwgZGVwdGhUZXN0OiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHRpZiAoIHNreUNvbG9yLmxlbmd0aCA+IDMgKSB7XG5cblx0XHRcdFx0XHRcdHBhaW50RmFjZXMoIHNreUdlb21ldHJ5LCByYWRpdXMsIHNreUFuZ2xlLCB0b0NvbG9yQXJyYXkoIHNreUNvbG9yICksIHRydWUgKTtcblx0XHRcdFx0XHRcdHNreU1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRza3lNYXRlcmlhbC5jb2xvci5zZXRSR0IoIHNreUNvbG9yWyAwIF0sIHNreUNvbG9yWyAxIF0sIHNreUNvbG9yWyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBza3kgPSBuZXcgTWVzaCggc2t5R2VvbWV0cnksIHNreU1hdGVyaWFsICk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkKCBza3kgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ3JvdW5kXG5cblx0XHRcdFx0aWYgKCBncm91bmRDb2xvciApIHtcblxuXHRcdFx0XHRcdGlmICggZ3JvdW5kQ29sb3IubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGdyb3VuZEdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIDMyLCAxNiwgMCwgMiAqIE1hdGguUEksIDAuNSAqIE1hdGguUEksIDEuNSAqIE1hdGguUEkgKTtcblx0XHRcdFx0XHRcdHZhciBncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlLCBzaWRlOiBCYWNrU2lkZSwgdmVydGV4Q29sb3JzOiB0cnVlLCBkZXB0aFdyaXRlOiBmYWxzZSwgZGVwdGhUZXN0OiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHRcdHBhaW50RmFjZXMoIGdyb3VuZEdlb21ldHJ5LCByYWRpdXMsIGdyb3VuZEFuZ2xlLCB0b0NvbG9yQXJyYXkoIGdyb3VuZENvbG9yICksIGZhbHNlICk7XG5cblx0XHRcdFx0XHRcdHZhciBncm91bmQgPSBuZXcgTWVzaCggZ3JvdW5kR2VvbWV0cnksIGdyb3VuZE1hdGVyaWFsICk7XG5cdFx0XHRcdFx0XHRncm91cC5hZGQoIGdyb3VuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyByZW5kZXIgYmFja2dyb3VuZCBncm91cCBmaXJzdFxuXG5cdFx0XHRcdGdyb3VwLnJlbmRlck9yZGVyID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRTaGFwZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBhcHBlYXJhbmNlIGZpZWxkIGlzIE5VTEwgb3IgdW5zcGVjaWZpZWQsIGxpZ2h0aW5nIGlzIG9mZiBhbmQgdGhlIHVubGl0IG9iamVjdCBjb2xvciBpcyAoMCwgMCwgMClcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MDAwMDAwIH0gKTtcblx0XHRcdFx0dmFyIGdlb21ldHJ5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdhcHBlYXJhbmNlJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBnZXROb2RlKCBmaWVsZFZhbHVlc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdnZW9tZXRyeSc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJ1aWxkIDNEIG9iamVjdFxuXG5cdFx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHRcdFx0dmFyIHR5cGUgPSBnZW9tZXRyeS5fdHlwZTtcblxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ3BvaW50cycgKSB7IC8vIHBvaW50c1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmIH0gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3IgZmllbGQgaXMgTlVMTCBhbmQgdGhlcmUgaXMgYSBtYXRlcmlhbCBkZWZpbmVkIGZvciB0aGUgYXBwZWFyYW5jZSBhZmZlY3RpbmcgdGhpcyBQb2ludFNldCwgdGhlbiB1c2UgdGhlIGVtaXNzaXZlQ29sb3Igb2YgdGhlIG1hdGVyaWFsIHRvIGRyYXcgdGhlIHBvaW50c1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQb2ludHMoIGdlb21ldHJ5LCBwb2ludHNNYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2xpbmUnICkgeyAvLyBsaW5lc1xuXG5cdFx0XHRcdFx0XHR2YXIgbGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiB9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGxpbmVNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvciBmaWVsZCBpcyBOVUxMIGFuZCB0aGVyZSBpcyBhIG1hdGVyaWFsIGRlZmluZWQgZm9yIHRoZSBhcHBlYXJhbmNlIGFmZmVjdGluZyB0aGlzIEluZGV4ZWRMaW5lU2V0LCB0aGVuIHVzZSB0aGUgZW1pc3NpdmVDb2xvciBvZiB0aGUgbWF0ZXJpYWwgdG8gZHJhdyB0aGUgbGluZXNcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRsaW5lTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIGxpbmVNYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHsgLy8gY29uc2lkZXIgbWVzaGVzXG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIFwic29saWRcIiBoaW50IChpdCdzIHBsYWNlZCBpbiB0aGUgZ2VvbWV0cnkgYnV0IGFmZmVjdHMgdGhlIG1hdGVyaWFsKVxuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Ll9zb2xpZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSAoIGdlb21ldHJ5Ll9zb2xpZCApID8gRnJvbnRTaWRlIDogRG91YmxlU2lkZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBjaGVjayBmb3IgdmVydGV4IGNvbG9yc1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgZmllbGQgaXMgTlVMTCBvciBubyB2ZXJ0aWNlcyBhcmUgZGVmaW5lZCB0aGUgb2JqZWN0IGlzIG5vdCBkcmF3blxuXG5cdFx0XHRcdFx0b2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEFwcGVhcmFuY2VOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHR2YXIgdHJhbnNmb3JtRGF0YTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ21hdGVyaWFsJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsRGF0YSA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLmRpZmZ1c2VDb2xvciApIG1hdGVyaWFsLmNvbG9yLmNvcHkoIG1hdGVyaWFsRGF0YS5kaWZmdXNlQ29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS5lbWlzc2l2ZUNvbG9yICkgbWF0ZXJpYWwuZW1pc3NpdmUuY29weSggbWF0ZXJpYWxEYXRhLmVtaXNzaXZlQ29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS5zaGluaW5lc3MgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBtYXRlcmlhbERhdGEuc2hpbmluZXNzO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnNwZWN1bGFyQ29sb3IgKSBtYXRlcmlhbC5zcGVjdWxhci5jb3B5KCBtYXRlcmlhbERhdGEuc3BlY3VsYXJDb2xvciApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnRyYW5zcGFyZW5jeSApIG1hdGVyaWFsLm9wYWNpdHkgPSAxIC0gbWF0ZXJpYWxEYXRhLnRyYW5zcGFyZW5jeTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsRGF0YS50cmFuc3BhcmVuY3kgPiAwICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgbWF0ZXJpYWwgZmllbGQgaXMgTlVMTCBvciB1bnNwZWNpZmllZCwgbGlnaHRpbmcgaXMgb2ZmIGFuZCB0aGUgdW5saXQgb2JqZWN0IGNvbG9yIGlzICgwLCAwLCAwKVxuXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MDAwMDAwIH0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXHRcdFx0XHRcdFx0XHR2YXIgdGV4dHVyZU5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmVOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlTm9kZS5uYW1lID09PSAnSW1hZ2VUZXh0dXJlJyB8fCB0ZXh0dXJlTm9kZS5uYW1lID09PSAnUGl4ZWxUZXh0dXJlJyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwubWFwID0gZ2V0Tm9kZSggdGV4dHVyZU5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RleHR1cmVUcmFuc2Zvcm0nOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG9ubHkgYXBwbHkgdGV4dHVyZSB0cmFuc2Zvcm0gZGF0YSBpZiBhIHRleHR1cmUgd2FzIGRlZmluZWRcblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0XHRcdC8vIHJlc3BlY3QgVlJNTCBsaWdodGluZyBtb2RlbFxuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAuX190eXBlICkge1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5tYXAuX190eXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLklOVEVOU0lUWV9BTFBIQTpcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gMTsgLy8gaWdub3JlIHRyYW5zcGFyZW5jeVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLlJHQjpcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5jb2xvci5zZXQoIDB4ZmZmZmZmICk7IC8vIGlnbm9yZSBtYXRlcmlhbCBjb2xvclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLlJHQkE6XG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuY29sb3Iuc2V0KCAweGZmZmZmZiApOyAvLyBpZ25vcmUgbWF0ZXJpYWwgY29sb3Jcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gMTsgLy8gaWdub3JlIHRyYW5zcGFyZW5jeVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGRlbGV0ZSBtYXRlcmlhbC5tYXAuX190eXBlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYXBwbHkgdGV4dHVyZSB0cmFuc2Zvcm1cblxuXHRcdFx0XHRcdGlmICggdHJhbnNmb3JtRGF0YSApIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubWFwLmNlbnRlci5jb3B5KCB0cmFuc2Zvcm1EYXRhLmNlbnRlciApO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubWFwLnJvdGF0aW9uID0gdHJhbnNmb3JtRGF0YS5yb3RhdGlvbjtcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5yZXBlYXQuY29weSggdHJhbnNmb3JtRGF0YS5zY2FsZSApO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubWFwLm9mZnNldC5jb3B5KCB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZE1hdGVyaWFsTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWxEYXRhID0ge307XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdhbWJpZW50SW50ZW5zaXR5Jzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZGlmZnVzZUNvbG9yJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLmRpZmZ1c2VDb2xvciA9IG5ldyBDb2xvciggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZW1pc3NpdmVDb2xvcic6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS5lbWlzc2l2ZUNvbG9yID0gbmV3IENvbG9yKCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEuc2hpbmluZXNzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29sb3InOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciA9IG5ldyBDb2xvciggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5Jzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLnRyYW5zcGFyZW5jeSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsRGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZUhleENvbG9yKCBoZXgsIHRleHR1cmVUeXBlLCBjb2xvciApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0ZXh0dXJlVHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLklOVEVOU0lUWTpcblx0XHRcdFx0XHRcdC8vIEludGVuc2l0eSB0ZXh0dXJlOiBBIG9uZS1jb21wb25lbnQgaW1hZ2Ugc3BlY2lmaWVzIG9uZS1ieXRlIGhleGFkZWNpbWFsIG9yIGludGVnZXIgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgaW50ZW5zaXR5IG9mIHRoZSBpbWFnZVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoIGhleCApO1xuXHRcdFx0XHRcdFx0Y29sb3IuciA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29sb3IuZyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29sb3IuYiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5JTlRFTlNJVFlfQUxQSEE6XG5cdFx0XHRcdFx0XHQvLyBJbnRlbnNpdHkrQWxwaGEgdGV4dHVyZTogQSB0d28tY29tcG9uZW50IGltYWdlIHNwZWNpZmllcyB0aGUgaW50ZW5zaXR5IGluIHRoZSBmaXJzdCAoaGlnaCkgYnl0ZSBhbmQgdGhlIGFscGhhIG9wYWNpdHkgaW4gdGhlIHNlY29uZCAobG93KSBieXRlLlxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCAyLCA0ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLnIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGNvbG9yLmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGNvbG9yLmIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGNvbG9yLmEgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDQsIDYgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0I6XG5cdFx0XHRcdFx0XHQvLyBSR0IgdGV4dHVyZTogUGl4ZWxzIGluIGEgdGhyZWUtY29tcG9uZW50IGltYWdlIHNwZWNpZnkgdGhlIHJlZCBjb21wb25lbnQgaW4gdGhlIGZpcnN0IChoaWdoKSBieXRlLCBmb2xsb3dlZCBieSB0aGUgZ3JlZW4gYW5kIGJsdWUgY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0Y29sb3IuciA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggMiwgNCApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5nID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA0LCA2ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLmIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDYsIDggKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRFWFRVUkVfVFlQRS5SR0JBOlxuXHRcdFx0XHRcdFx0Ly8gUkdCQSB0ZXh0dXJlOiBGb3VyLWNvbXBvbmVudCBpbWFnZXMgc3BlY2lmeSB0aGUgYWxwaGEgb3BhY2l0eSBieXRlIGFmdGVyIHJlZC9ncmVlbi9ibHVlXG5cdFx0XHRcdFx0XHRjb2xvci5yID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCAyLCA0ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLmcgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDQsIDYgKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuYiA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggNiwgOCApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5hID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA4LCAxMCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZVR5cGUoIG51bV9jb21wb25lbnRzICkge1xuXG5cdFx0XHRcdHZhciB0eXBlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIG51bV9jb21wb25lbnRzICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5JTlRFTlNJVFk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdHR5cGUgPSBURVhUVVJFX1RZUEUuSU5URU5TSVRZX0FMUEhBO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHR0eXBlID0gVEVYVFVSRV9UWVBFLlJHQjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5SR0JBO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0eXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkUGl4ZWxUZXh0dXJlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgdGV4dHVyZTtcblx0XHRcdFx0dmFyIHdyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdHZhciB3cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaW1hZ2UnOlxuXHRcdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgaGVpZ2h0ID0gZmllbGRWYWx1ZXNbIDEgXTtcblx0XHRcdFx0XHRcdFx0dmFyIG51bV9jb21wb25lbnRzID0gZmllbGRWYWx1ZXNbIDIgXTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdXNlQWxwaGEgPSAoIG51bV9jb21wb25lbnRzID09PSAyIHx8IG51bV9jb21wb25lbnRzID09PSA0ICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0ZXh0dXJlVHlwZSA9IGdldFRleHR1cmVUeXBlKCBudW1fY29tcG9uZW50cyApO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzaXplID0gKCAoIHVzZUFscGhhID09PSB0cnVlICkgPyA0IDogMyApICogKCB3aWR0aCAqIGhlaWdodCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCBzaXplICk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yID0geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH07XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAzLCBrID0gMCwgamwgPSBmaWVsZFZhbHVlcy5sZW5ndGg7IGogPCBqbDsgaiArKywgayArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlSGV4Q29sb3IoIGZpZWxkVmFsdWVzWyBqIF0sIHRleHR1cmVUeXBlLCBjb2xvciApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VBbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGsgKiA0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAwIF0gPSBjb2xvci5yO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDIgXSA9IGNvbG9yLmI7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAzIF0gPSBjb2xvci5hO1xuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGsgKiAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAwIF0gPSBjb2xvci5yO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMSBdID0gY29sb3IuZztcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDIgXSA9IGNvbG9yLmI7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsICggdXNlQWxwaGEgPT09IHRydWUgKSA/IFJHQkFGb3JtYXQgOiBSR0JGb3JtYXQgKTtcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5fX3R5cGUgPSB0ZXh0dXJlVHlwZTsgLy8gbmVlZGVkIGZvciBtYXRlcmlhbCBtb2RpZmljYXRpb25zXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyZXBlYXRTJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFQnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gPT09IGZhbHNlICkgd3JhcFQgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSB3cmFwUztcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gd3JhcFQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkSW1hZ2VUZXh0dXJlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgdGV4dHVyZTtcblx0XHRcdFx0dmFyIHdyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG5cdFx0XHRcdHZhciB3cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAndXJsJzpcblx0XHRcdFx0XHRcdFx0dmFyIHVybCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGlmICggdXJsICkgdGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCggdXJsICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyZXBlYXRTJzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdID09PSBmYWxzZSApIHdyYXBTID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFQnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gPT09IGZhbHNlICkgd3JhcFQgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSB3cmFwUztcblx0XHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gd3JhcFQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkVGV4dHVyZVRyYW5zZm9ybU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHRyYW5zZm9ybURhdGEgPSB7XG5cdFx0XHRcdFx0Y2VudGVyOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdHJvdGF0aW9uOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdHNjYWxlOiBuZXcgVmVjdG9yMigpLFxuXHRcdFx0XHRcdHRyYW5zbGF0aW9uOiBuZXcgVmVjdG9yMigpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjZW50ZXInOlxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLmNlbnRlci5zZXQoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JvdGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YS5yb3RhdGlvbiA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEuc2NhbGUuc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGlvbic6XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24uc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRyYW5zZm9ybURhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRHZW9tZXRyaWNOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHJldHVybiBub2RlLmZpZWxkc1sgMCBdLnZhbHVlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFdvcmxkSW5mb05vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHdvcmxkSW5mbyA9IHt9O1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGl0bGUnOlxuXHRcdFx0XHRcdFx0XHR3b3JsZEluZm8udGl0bGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaW5mbyc6XG5cdFx0XHRcdFx0XHRcdHdvcmxkSW5mby5pbmZvID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHdvcmxkSW5mbztcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEluZGV4ZWRGYWNlU2V0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgY29sb3IsIGNvb3JkLCBub3JtYWwsIHRleENvb3JkO1xuXHRcdFx0XHR2YXIgY2N3ID0gdHJ1ZSwgc29saWQgPSB0cnVlLCBjcmVhc2VBbmdsZSA9IDA7XG5cdFx0XHRcdHZhciBjb2xvckluZGV4LCBjb29yZEluZGV4LCBub3JtYWxJbmRleCwgdGV4Q29vcmRJbmRleDtcblx0XHRcdFx0dmFyIGNvbG9yUGVyVmVydGV4ID0gdHJ1ZSwgbm9ybWFsUGVyVmVydGV4ID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvck5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29vcmQnOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvb3JkID0gZ2V0Tm9kZSggY29vcmROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdub3JtYWwnOlxuXHRcdFx0XHRcdFx0XHR2YXIgbm9ybWFsTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBub3JtYWxOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsID0gZ2V0Tm9kZSggbm9ybWFsTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGV4Q29vcmQnOlxuXHRcdFx0XHRcdFx0XHR2YXIgdGV4Q29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHRleENvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHRleENvb3JkID0gZ2V0Tm9kZSggdGV4Q29vcmROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjY3cnOlxuXHRcdFx0XHRcdFx0XHRjY3cgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JJbmRleCc6XG5cdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29sb3JQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29udmV4Jzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29vcmRJbmRleCc6XG5cdFx0XHRcdFx0XHRcdGNvb3JkSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NyZWFzZUFuZ2xlJzpcblx0XHRcdFx0XHRcdFx0Y3JlYXNlQW5nbGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsSW5kZXgnOlxuXHRcdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdFx0bm9ybWFsUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NvbGlkJzpcblx0XHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGV4Q29vcmRJbmRleCc6XG5cdFx0XHRcdFx0XHRcdHRleENvb3JkSW5kZXggPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvb3JkSW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IE1pc3NpbmcgY29vcmRJbmRleC4nICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7IC8vIGhhbmRsZSBWUk1MIGZpbGVzIHdpdGggaW5jb21wbGV0ZSBnZW9tZXRyeSBkZWZpbml0aW9uXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRDb29yZEluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIGNvb3JkSW5kZXgsIGNjdyApO1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZTtcblx0XHRcdFx0dmFyIGNvbG9yQXR0cmlidXRlO1xuXHRcdFx0XHR2YXIgbm9ybWFsQXR0cmlidXRlO1xuXHRcdFx0XHR2YXIgdXZBdHRyaWJ1dGU7XG5cblx0XHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRcdGlmICggY29sb3JQZXJWZXJ0ZXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3JJbmRleCAmJiBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGl0IGlzIHVzZWQgdG8gY2hvb3NlIGNvbG9ycyBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRGYWNlU2V0LlxuXG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRDb2xvckluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIGNvbG9ySW5kZXgsIGNjdyApO1xuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZENvbG9ySW5kZXgsIGNvbG9yLCAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggZmllbGQgaXMgdXNlZCB0byBjaG9vc2UgY29sb3JzIGZyb20gdGhlIENvbG9yIG5vZGVcblxuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLCAzICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4ICYmIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gdGhleSBhcmUgdXNlZCB0byBjaG9vc2Ugb25lIGNvbG9yIGZvciBlYWNoIGZhY2Ugb2YgdGhlIEluZGV4ZWRGYWNlU2V0XG5cblx0XHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5GYWNlQ29sb3JzID0gZmxhdHRlbkRhdGEoIGNvbG9yLCBjb2xvckluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggZmxhdHRlbkZhY2VDb2xvcnMsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvbG9yIGFyZSBhcHBsaWVkIHRvIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXQgaW4gb3JkZXJcblxuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRmFjZUNvbG9ycyA9IHRyaWFuZ3VsYXRlRmFjZURhdGEoIGNvbG9yLCBjb29yZEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkRmFjZUNvbG9ycyApO1xuXG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub3JtYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbFBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc2lkZXIgdmVydGV4IG5vcm1hbHNcblxuXHRcdFx0XHRcdFx0aWYgKCBub3JtYWxJbmRleCAmJiBub3JtYWxJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWxJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gaXQgaXMgdXNlZCB0byBjaG9vc2Ugbm9ybWFscyBmb3IgZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRGYWNlU2V0LlxuXG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWROb3JtYWxJbmRleCA9IHRyaWFuZ3VsYXRlRmFjZUluZGV4KCBub3JtYWxJbmRleCwgY2N3ICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZE5vcm1hbEluZGV4LCBub3JtYWwsIDMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsSW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggZmllbGQgaXMgdXNlZCB0byBjaG9vc2Ugbm9ybWFscyBmcm9tIHRoZSBOb3JtYWwgbm9kZVxuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgMyApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnNpZGVyIGZhY2Ugbm9ybWFsc1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbEluZGV4ICYmIG5vcm1hbEluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiB0aGV5IGFyZSB1c2VkIHRvIGNob29zZSBvbmUgbm9ybWFsIGZvciBlYWNoIGZhY2Ugb2YgdGhlIEluZGV4ZWRGYWNlU2V0XG5cblx0XHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5GYWNlTm9ybWFscyA9IGZsYXR0ZW5EYXRhKCBub3JtYWwsIG5vcm1hbEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRGYWNlTm9ybWFscyA9IHRyaWFuZ3VsYXRlRmFjZURhdGEoIGZsYXR0ZW5GYWNlTm9ybWFscywgY29vcmRJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlTm9ybWFscyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWxJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgbm9ybWFscyBhcmUgYXBwbGllZCB0byBlYWNoIGZhY2Ugb2YgdGhlIEluZGV4ZWRGYWNlU2V0IGluIG9yZGVyXG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggbm9ybWFsLCBjb29yZEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbCBmaWVsZCBpcyBOVUxMLCB0aGVuIHRoZSBsb2FkZXIgc2hvdWxkIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgbm9ybWFscywgdXNpbmcgY3JlYXNlQW5nbGUgdG8gZGV0ZXJtaW5lIGlmIGFuZCBob3cgbm9ybWFscyBhcmUgc21vb3RoZWQgYWNyb3NzIHNoYXJlZCB2ZXJ0aWNlc1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgY29vcmQsIGNyZWFzZUFuZ2xlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4Q29vcmQgKSB7XG5cblx0XHRcdFx0XHQvLyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFyZSBhbHdheXMgZGVmaW5lZCBvbiB2ZXJ0ZXggbGV2ZWxcblxuXHRcdFx0XHRcdGlmICggdGV4Q29vcmRJbmRleCAmJiB0ZXhDb29yZEluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSB0ZXhDb29yZEluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBpdCBpcyB1c2VkIHRvIGNob29zZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZvciBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZEZhY2VTZXQuXG5cblx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRUZXhDb29yZEluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIHRleENvb3JkSW5kZXgsIGNjdyApO1xuXHRcdFx0XHRcdFx0dXZBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRUZXhDb29yZEluZGV4LCB0ZXhDb29yZCwgMiApO1xuXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgdGV4Q29vcmRJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29vcmRJbmRleCBhcnJheSBpcyB1c2VkIHRvIGNob29zZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZyb20gdGhlIFRleHR1cmVDb29yZGluYXRlIG5vZGVcblxuXHRcdFx0XHRcdFx0dXZBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB0ZXhDb29yZCwgMiApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkLCAzICkgKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdC8vIG9wdGlvbmFsIGF0dHJpYnV0ZXNcblxuXHRcdFx0XHRpZiAoIGNvbG9yQXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXHRcdFx0XHRpZiAoIHV2QXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCB1dkF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdC8vIFwic29saWRcIiBpbmZsdWVuY2VzIHRoZSBtYXRlcmlhbCBzbyBsZXQncyBzdG9yZSBpdCBmb3IgbGF0ZXIgdXNlXG5cblx0XHRcdFx0Z2VvbWV0cnkuX3NvbGlkID0gc29saWQ7XG5cdFx0XHRcdGdlb21ldHJ5Ll90eXBlID0gJ21lc2gnO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEluZGV4ZWRMaW5lU2V0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgY29sb3IsIGNvb3JkO1xuXHRcdFx0XHR2YXIgY29sb3JJbmRleCwgY29vcmRJbmRleDtcblx0XHRcdFx0dmFyIGNvbG9yUGVyVmVydGV4ID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvck5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29vcmQnOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvb3JkID0gZ2V0Tm9kZSggY29vcmROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvckluZGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0XHRjb2xvclBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb29yZEluZGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29vcmRJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJ1aWxkIGxpbmVzXG5cblx0XHRcdFx0dmFyIGNvbG9yQXR0cmlidXRlO1xuXG5cdFx0XHRcdHZhciBleHBhbmRlZExpbmVJbmRleCA9IGV4cGFuZExpbmVJbmRleCggY29vcmRJbmRleCApOyAvLyBjcmVhdGUgYW4gaW5kZXggZm9yIHRocmVlLmpzJ3MgbGluZXNlZ21lbnQgcHJpbWl0aXZlXG5cblx0XHRcdFx0aWYgKCBjb2xvciApIHtcblxuXHRcdFx0XHRcdGlmICggY29sb3JQZXJWZXJ0ZXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3JJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBvbmUgY29sb3IgaXMgdXNlZCBmb3IgZWFjaCBwb2x5bGluZSBvZiB0aGUgSW5kZXhlZExpbmVTZXQuXG5cblx0XHRcdFx0XHRcdFx0dmFyIGV4cGFuZGVkQ29sb3JJbmRleCA9IGV4cGFuZExpbmVJbmRleCggY29sb3JJbmRleCApOyAvLyBjb21wdXRlIGNvbG9ycyBmb3IgZWFjaCBsaW5lIHNlZ21lbnQgKHJlbmRlcmluZyBwcmltaXR2ZSlcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCBleHBhbmRlZExpbmVJbmRleCwgZXhwYW5kZWRDb2xvckluZGV4LCBjb2xvciwgMyApOyAvLyBjb21wdXRlIGRhdGEgb24gdmVydGV4IGxldmVsXG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvbG9ycyBhcmUgYXBwbGllZCB0byBlYWNoIHBvbHlsaW5lIG9mIHRoZSBJbmRleGVkTGluZVNldCBpbiBvcmRlci5cblxuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggZXhwYW5kZWRMaW5lSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvciwgMyApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggY29sb3JJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBjb2xvcnMgYXJlIGFwcGxpZWQgdG8gZWFjaCB2ZXJ0ZXggb2YgdGhlIEluZGV4ZWRMaW5lU2V0XG5cblx0XHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5MaW5lQ29sb3JzID0gZmxhdHRlbkRhdGEoIGNvbG9yLCBjb2xvckluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIFZSTUwgcHJpbWl0dmVcblx0XHRcdFx0XHRcdFx0dmFyIGV4cGFuZGVkTGluZUNvbG9ycyA9IGV4cGFuZExpbmVEYXRhKCBmbGF0dGVuTGluZUNvbG9ycywgY29vcmRJbmRleCApOyAvLyBjb21wdXRlIGNvbG9ycyBmb3IgZWFjaCBsaW5lIHNlZ21lbnQgKHJlbmRlcmluZyBwcmltaXR2ZSlcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUxpbmVEYXRhKCBleHBhbmRlZExpbmVJbmRleCwgZXhwYW5kZWRMaW5lQ29sb3JzICk7IC8vIGNvbXB1dGUgZGF0YSBvbiB2ZXJ0ZXggbGV2ZWxcblxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb29yZEluZGV4IGZpZWxkIGlzIHVzZWQgdG8gY2hvb3NlIGNvbG9ycyBmcm9tIHRoZSBDb2xvciBub2RlXG5cblx0XHRcdFx0XHRcdFx0dmFyIGV4cGFuZGVkTGluZUNvbG9ycyA9IGV4cGFuZExpbmVEYXRhKCBjb2xvciwgY29vcmRJbmRleCApOyAvLyBjb21wdXRlIGNvbG9ycyBmb3IgZWFjaCBsaW5lIHNlZ21lbnQgKHJlbmRlcmluZyBwcmltaXR2ZSlcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUxpbmVEYXRhKCBleHBhbmRlZExpbmVJbmRleCwgZXhwYW5kZWRMaW5lQ29sb3JzICk7IC8vIGNvbXB1dGUgZGF0YSBvbiB2ZXJ0ZXggbGV2ZWxcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggZXhwYW5kZWRMaW5lSW5kZXgsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb29yZCwgMyApICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25BdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yQXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdGdlb21ldHJ5Ll90eXBlID0gJ2xpbmUnO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFBvaW50U2V0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XG5cdFx0XHRcdHZhciBjb2xvciwgY29vcmQ7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29sb3JOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3IgPSBnZXROb2RlKCBjb2xvck5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nvb3JkJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvb3JkTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb29yZCA9IGdldE5vZGUoIGNvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXHRcdFx0XHRpZiAoIGNvbG9yICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IsIDMgKSApO1xuXG5cdFx0XHRcdGdlb21ldHJ5Ll90eXBlID0gJ3BvaW50cyc7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkQm94Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgc2l6ZSA9IG5ldyBWZWN0b3IzKCAyLCAyLCAyICk7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzaXplJzpcblx0XHRcdFx0XHRcdFx0c2l6ZS54ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0c2l6ZS55ID0gZmllbGRWYWx1ZXNbIDEgXTtcblx0XHRcdFx0XHRcdFx0c2l6ZS56ID0gZmllbGRWYWx1ZXNbIDIgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQm94R2VvbWV0cnkoIHNpemUueCwgc2l6ZS55LCBzaXplLnogKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRDb25lTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgcmFkaXVzID0gMSwgaGVpZ2h0ID0gMiwgb3BlbkVuZGVkID0gZmFsc2U7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdib3R0b20nOlxuXHRcdFx0XHRcdFx0XHRvcGVuRW5kZWQgPSAhIGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdib3R0b21SYWRpdXMnOlxuXHRcdFx0XHRcdFx0XHRyYWRpdXMgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaGVpZ2h0Jzpcblx0XHRcdFx0XHRcdFx0aGVpZ2h0ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NpZGUnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IENvbmVHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIDE2LCAxLCBvcGVuRW5kZWQgKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRDeWxpbmRlck5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHJhZGl1cyA9IDEsIGhlaWdodCA9IDI7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdib3R0b20nOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyYWRpdXMnOlxuXHRcdFx0XHRcdFx0XHRyYWRpdXMgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaGVpZ2h0Jzpcblx0XHRcdFx0XHRcdFx0aGVpZ2h0ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NpZGUnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0b3AnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEN5bGluZGVyR2VvbWV0cnkoIHJhZGl1cywgcmFkaXVzLCBoZWlnaHQsIDE2LCAxICk7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkU3BoZXJlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgcmFkaXVzID0gMTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JhZGl1cyc6XG5cdFx0XHRcdFx0XHRcdHJhZGl1cyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIDE2LCAxNiApO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEVsZXZhdGlvbkdyaWROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBjb2xvcjtcblx0XHRcdFx0dmFyIG5vcm1hbDtcblx0XHRcdFx0dmFyIHRleENvb3JkO1xuXHRcdFx0XHR2YXIgaGVpZ2h0O1xuXG5cdFx0XHRcdHZhciBjb2xvclBlclZlcnRleCA9IHRydWU7XG5cdFx0XHRcdHZhciBub3JtYWxQZXJWZXJ0ZXggPSB0cnVlO1xuXHRcdFx0XHR2YXIgc29saWQgPSB0cnVlO1xuXHRcdFx0XHR2YXIgY2N3ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGNyZWFzZUFuZ2xlID0gMDtcblx0XHRcdFx0dmFyIHhEaW1lbnNpb24gPSAyO1xuXHRcdFx0XHR2YXIgekRpbWVuc2lvbiA9IDI7XG5cdFx0XHRcdHZhciB4U3BhY2luZyA9IDE7XG5cdFx0XHRcdHZhciB6U3BhY2luZyA9IDE7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvck5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29sb3JOb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3IgPSBnZXROb2RlKCBjb2xvck5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ25vcm1hbCc6XG5cdFx0XHRcdFx0XHRcdHZhciBub3JtYWxOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vcm1hbE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRub3JtYWwgPSBnZXROb2RlKCBub3JtYWxOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0ZXhDb29yZCc6XG5cdFx0XHRcdFx0XHRcdHZhciB0ZXhDb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGV4Q29vcmROb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dGV4Q29vcmQgPSBnZXROb2RlKCB0ZXhDb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2hlaWdodCc6XG5cdFx0XHRcdFx0XHRcdGhlaWdodCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2N3Jzpcblx0XHRcdFx0XHRcdFx0Y2N3ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yUGVyVmVydGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29sb3JQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY3JlYXNlQW5nbGUnOlxuXHRcdFx0XHRcdFx0XHRjcmVhc2VBbmdsZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdub3JtYWxQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0XHRub3JtYWxQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0XHRzb2xpZCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd4RGltZW5zaW9uJzpcblx0XHRcdFx0XHRcdFx0eERpbWVuc2lvbiA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd4U3BhY2luZyc6XG5cdFx0XHRcdFx0XHRcdHhTcGFjaW5nID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3pEaW1lbnNpb24nOlxuXHRcdFx0XHRcdFx0XHR6RGltZW5zaW9uID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3pTcGFjaW5nJzpcblx0XHRcdFx0XHRcdFx0elNwYWNpbmcgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHZlcnRleCBkYXRhXG5cblx0XHRcdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0XHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0XHRcdHZhciBjb2xvcnMgPSBbXTtcblx0XHRcdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHpEaW1lbnNpb247IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB4RGltZW5zaW9uOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyBjb21wdXRlIGEgcm93IG1ham9yIGluZGV4XG5cblx0XHRcdFx0XHRcdHZhciBpbmRleCA9ICggaSAqIHhEaW1lbnNpb24gKSArIGo7XG5cblx0XHRcdFx0XHRcdC8vIHZlcnRpY2VzXG5cblx0XHRcdFx0XHRcdHZhciB4ID0geFNwYWNpbmcgKiBpO1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBoZWlnaHRbIGluZGV4IF07XG5cdFx0XHRcdFx0XHR2YXIgeiA9IHpTcGFjaW5nICogajtcblxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHRcdFx0XHQvLyBjb2xvcnNcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciAmJiBjb2xvclBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgciA9IGNvbG9yWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdHZhciBnID0gY29sb3JbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdFx0dmFyIGIgPSBjb2xvclsgaW5kZXggKiAzICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdGNvbG9ycy5wdXNoKCByLCBnLCBiICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gbm9ybWFsc1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbCAmJiBub3JtYWxQZXJWZXJ0ZXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHhuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdHZhciB5biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgem4gPSBub3JtYWxbIGluZGV4ICogMyArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyB1dnNcblxuXHRcdFx0XHRcdFx0aWYgKCB0ZXhDb29yZCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcyA9IHRleENvb3JkWyBpbmRleCAqIDIgKyAwIF07XG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gdGV4Q29vcmRbIGluZGV4ICogMiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHR1dnMucHVzaCggcywgdCApO1xuXG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dXZzLnB1c2goIGkgLyAoIHhEaW1lbnNpb24gLSAxICksIGogLyAoIHpEaW1lbnNpb24gLSAxICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpbmRpY2VzXG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4RGltZW5zaW9uIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHpEaW1lbnNpb24gLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmcm9tIGh0dHBzOi8vdGVjZmEudW5pZ2UuY2gvZ3VpZGVzL3ZybWwvdnJtbDk3L3NwZWMvcGFydDEvbm9kZXNSZWYuaHRtbCNFbGV2YXRpb25HcmlkXG5cblx0XHRcdFx0XHRcdHZhciBhID0gaSArIGogKiB4RGltZW5zaW9uO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBpICsgKCBqICsgMSApICogeERpbWVuc2lvbjtcblx0XHRcdFx0XHRcdHZhciBjID0gKCBpICsgMSApICsgKCBqICsgMSApICogeERpbWVuc2lvbjtcblx0XHRcdFx0XHRcdHZhciBkID0gKCBpICsgMSApICsgaiAqIHhEaW1lbnNpb247XG5cblx0XHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRcdGlmICggY2N3ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYywgYiApO1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGEsIGQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBkLCBhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0XHRcdHZhciB1dkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cdFx0XHRcdHZhciBjb2xvckF0dHJpYnV0ZTtcblx0XHRcdFx0dmFyIG5vcm1hbEF0dHJpYnV0ZTtcblxuXHRcdFx0XHQvLyBjb2xvciBhdHRyaWJ1dGVcblxuXHRcdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvclBlclZlcnRleCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhEaW1lbnNpb24gLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHpEaW1lbnNpb24gLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gaSArIGogKiAoIHhEaW1lbnNpb24gLSAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgciA9IGNvbG9yWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGcgPSBjb2xvclsgaW5kZXggKiAzICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBiID0gY29sb3JbIGluZGV4ICogMyArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIG9uZSBjb2xvciBwZXIgcXVhZFxuXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JzLnB1c2goIHIsIGcsIGIgKTsgY29sb3JzLnB1c2goIHIsIGcsIGIgKTsgY29sb3JzLnB1c2goIHIsIGcsIGIgKTtcblx0XHRcdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbm9ybWFsIGF0dHJpYnV0ZVxuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxQZXJWZXJ0ZXggPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4RGltZW5zaW9uIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB6RGltZW5zaW9uIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IGkgKyBqICogKCB4RGltZW5zaW9uIC0gMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHhuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHluID0gbm9ybWFsWyBpbmRleCAqIDMgKyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHpuID0gbm9ybWFsWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBvbmUgbm9ybWFsIHBlciBxdWFkXG5cblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7IG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApO1xuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZU5vcm1hbEF0dHJpYnV0ZSggaW5kaWNlcywgdmVydGljZXMsIGNyZWFzZUFuZ2xlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25BdHRyaWJ1dGUgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgdXZBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yQXR0cmlidXRlICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBjb2xvckF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdC8vIFwic29saWRcIiBpbmZsdWVuY2VzIHRoZSBtYXRlcmlhbCBzbyBsZXQncyBzdG9yZSBpdCBmb3IgbGF0ZXIgdXNlXG5cblx0XHRcdFx0Z2VvbWV0cnkuX3NvbGlkID0gc29saWQ7XG5cdFx0XHRcdGdlb21ldHJ5Ll90eXBlID0gJ21lc2gnO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEV4dHJ1c2lvbk5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGNyb3NzU2VjdGlvbiA9IFsgMSwgMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAxLCAxIF07XG5cdFx0XHRcdHZhciBzcGluZSA9IFsgMCwgMCwgMCwgMCwgMSwgMCBdO1xuXHRcdFx0XHR2YXIgc2NhbGU7XG5cdFx0XHRcdHZhciBvcmllbnRhdGlvbjtcblxuXHRcdFx0XHR2YXIgYmVnaW5DYXAgPSB0cnVlO1xuXHRcdFx0XHR2YXIgY2N3ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGNyZWFzZUFuZ2xlID0gMDtcblx0XHRcdFx0dmFyIGVuZENhcCA9IHRydWU7XG5cdFx0XHRcdHZhciBzb2xpZCA9IHRydWU7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiZWdpbkNhcCc6XG5cdFx0XHRcdFx0XHRcdGJlZ2luQ2FwID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Njdyc6XG5cdFx0XHRcdFx0XHRcdGNjdyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb252ZXgnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjcmVhc2VBbmdsZSc6XG5cdFx0XHRcdFx0XHRcdGNyZWFzZUFuZ2xlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nyb3NzU2VjdGlvbic6XG5cdFx0XHRcdFx0XHRcdGNyb3NzU2VjdGlvbiA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnZW5kQ2FwJzpcblx0XHRcdFx0XHRcdFx0ZW5kQ2FwID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ29yaWVudGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0b3JpZW50YXRpb24gPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdFx0c2NhbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NvbGlkJzpcblx0XHRcdFx0XHRcdFx0c29saWQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc3BpbmUnOlxuXHRcdFx0XHRcdFx0XHRzcGluZSA9IGZpZWxkVmFsdWVzOyAvLyBvbmx5IGV4dHJ1c2lvbiBhbG9uZyB0aGUgWS1heGlzIGFyZSBzdXBwb3J0ZWQgc28gZmFyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNyb3NzU2VjdGlvbkNsb3NlZCA9ICggY3Jvc3NTZWN0aW9uWyAwIF0gPT09IGNyb3NzU2VjdGlvblsgY3Jvc3NTZWN0aW9uLmxlbmd0aCAtIDIgXSAmJiBjcm9zc1NlY3Rpb25bIDEgXSA9PT0gY3Jvc3NTZWN0aW9uWyBjcm9zc1NlY3Rpb24ubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdFx0Ly8gdmVydGljZXNcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHRcdFx0dmFyIHNwaW5lVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIHNjYWxpbmcgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRcdHZhciBheGlzID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBvID0gMCwgaWwgPSBzcGluZS5sZW5ndGg7IGkgPCBpbDsgaSArPSAzLCBqICs9IDIsIG8gKz0gNCApIHtcblxuXHRcdFx0XHRcdHNwaW5lVmVjdG9yLmZyb21BcnJheSggc3BpbmUsIGkgKTtcblxuXHRcdFx0XHRcdHNjYWxpbmcueCA9IHNjYWxlID8gc2NhbGVbIGogKyAwIF0gOiAxO1xuXHRcdFx0XHRcdHNjYWxpbmcueSA9IDE7XG5cdFx0XHRcdFx0c2NhbGluZy56ID0gc2NhbGUgPyBzY2FsZVsgaiArIDEgXSA6IDE7XG5cblx0XHRcdFx0XHRheGlzLnggPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMCBdIDogMDtcblx0XHRcdFx0XHRheGlzLnkgPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMSBdIDogMDtcblx0XHRcdFx0XHRheGlzLnogPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMiBdIDogMTtcblx0XHRcdFx0XHR2YXIgYW5nbGUgPSBvcmllbnRhdGlvbiA/IG9yaWVudGF0aW9uWyBvICsgMyBdIDogMDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBrID0gMCwga2wgPSBjcm9zc1NlY3Rpb24ubGVuZ3RoOyBrIDwga2w7IGsgKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0dmVydGV4LnggPSBjcm9zc1NlY3Rpb25bIGsgKyAwIF07XG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueSA9IDA7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IGNyb3NzU2VjdGlvblsgayArIDEgXTtcblxuXHRcdFx0XHRcdFx0Ly8gc2NhbGVcblxuXHRcdFx0XHRcdFx0dmVydGV4Lm11bHRpcGx5KCBzY2FsaW5nICk7XG5cblx0XHRcdFx0XHRcdC8vIHJvdGF0ZVxuXG5cdFx0XHRcdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cdFx0XHRcdFx0XHR2ZXJ0ZXguYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdFx0XHRcdC8vIHRyYW5zbGF0ZVxuXG5cdFx0XHRcdFx0XHR2ZXJ0ZXguYWRkKCBzcGluZVZlY3RvciApO1xuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdHZhciBzcGluZUNvdW50ID0gc3BpbmUubGVuZ3RoIC8gMztcblx0XHRcdFx0dmFyIGNyb3NzU2VjdGlvbkNvdW50ID0gY3Jvc3NTZWN0aW9uLmxlbmd0aCAvIDI7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc3BpbmVDb3VudCAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBjcm9zc1NlY3Rpb25Db3VudCAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0gaiArIGkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblx0XHRcdFx0XHRcdHZhciBiID0gKCBqICsgMSApICsgaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdFx0dmFyIGMgPSBqICsgKCBpICsgMSApICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cdFx0XHRcdFx0XHR2YXIgZCA9ICggaiArIDEgKSArICggaSArIDEgKSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoICggaiA9PT0gY3Jvc3NTZWN0aW9uQ291bnQgLSAyICkgJiYgKCBjcm9zc1NlY3Rpb25DbG9zZWQgPT09IHRydWUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRiID0gaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdFx0XHRkID0gKCBpICsgMSApICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgYiwgZCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYywgYiApO1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0cmlhbmd1bGF0ZSBjYXBcblxuXHRcdFx0XHRpZiAoIGJlZ2luQ2FwID09PSB0cnVlIHx8IGVuZENhcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBjb250b3VyID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjcm9zc1NlY3Rpb24ubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRjb250b3VyLnB1c2goIG5ldyBWZWN0b3IyKCBjcm9zc1NlY3Rpb25bIGkgXSwgY3Jvc3NTZWN0aW9uWyBpICsgMSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggY29udG91ciwgW10gKTtcblx0XHRcdFx0XHR2YXIgY2FwSW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRjYXBJbmRpY2VzLnB1c2goIGZhY2VbIDAgXSwgZmFjZVsgMSBdLCBmYWNlWyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGJlZ2luIGNhcFxuXG5cdFx0XHRcdFx0aWYgKCBiZWdpbkNhcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2FwSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGNhcEluZGljZXNbIGkgKyAwIF0sIGNhcEluZGljZXNbIGkgKyAxIF0sIGNhcEluZGljZXNbIGkgKyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjYXBJbmRpY2VzWyBpICsgMCBdLCBjYXBJbmRpY2VzWyBpICsgMiBdLCBjYXBJbmRpY2VzWyBpICsgMSBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlbmQgY2FwXG5cblx0XHRcdFx0XHRpZiAoIGVuZENhcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluZGV4T2Zmc2V0ID0gY3Jvc3NTZWN0aW9uQ291bnQgKiAoIHNwaW5lQ291bnQgLSAxICk7IC8vIHJlZmVyZW5jZXMgdG8gdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgbGFzdCBjcm9zcyBzZWN0aW9uXG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNhcEluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY2N3ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAwIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDIgXSwgaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMSBdICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMCBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAxIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0XHRcdHZhciBub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCBpbmRpY2VzLCB2ZXJ0aWNlcywgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblx0XHRcdFx0Ly8gbm8gdXZzIHlldFxuXG5cdFx0XHRcdC8vIFwic29saWRcIiBpbmZsdWVuY2VzIHRoZSBtYXRlcmlhbCBzbyBsZXQncyBzdG9yZSBpdCBmb3IgbGF0ZXIgdXNlXG5cblx0XHRcdFx0Z2VvbWV0cnkuX3NvbGlkID0gc29saWQ7XG5cdFx0XHRcdGdlb21ldHJ5Ll90eXBlID0gJ21lc2gnO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVVU0UoIGlkZW50aWZpZXIgKSB7XG5cblx0XHRcdFx0dmFyIG5vZGUgPSBub2RlTWFwWyBpZGVudGlmaWVyIF07XG5cdFx0XHRcdHZhciBidWlsZCA9IGdldE5vZGUoIG5vZGUgKTtcblxuXHRcdFx0XHQvLyBiZWNhdXNlIHRoZSBzYW1lIDNEIG9iamVjdHMgY2FuIGhhdmUgZGlmZmVyZW50IHRyYW5zZm9ybWF0aW9ucywgaXQncyBuZWNlc3NhcnkgdG8gY2xvbmUgdGhlbS5cblx0XHRcdFx0Ly8gbWF0ZXJpYWxzIGNhbiBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBnZW9tZXRyeSAoZS5nLiB2ZXJ0ZXggbm9ybWFscykuIGNsb25pbmcgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkXG5cdFx0XHRcdC8vIGFueSBzaWRlIGVmZmVjdHNcblxuXHRcdFx0XHRyZXR1cm4gKCBidWlsZC5pc09iamVjdDNEIHx8IGJ1aWxkLmlzTWF0ZXJpYWwgKSA/IGJ1aWxkLmNsb25lKCkgOiBidWlsZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZUZpZWxkQ2hpbGRyZW4oIGNoaWxkcmVuLCBvd25lciApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG9iamVjdCA9IGdldE5vZGUoIGNoaWxkcmVuWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0M0QgKSBvd25lci5hZGQoIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0cmlhbmd1bGF0ZUZhY2VJbmRleCggaW5kZXgsIGNjdyApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdC8vIHNpbmNlIGZhY2UgZGVmaW50aW9ucyBjYW4gaGF2ZSBtb3JlIHRoYW4gdGhyZWUgdmVydGljZXMsIGl0J3MgbmVjZXNzYXJ5IHRvXG5cdFx0XHRcdC8vIHBlcmZvcm0gYSBzaW1wbGUgdHJpYW5ndWxhdGlvblxuXG5cdFx0XHRcdHZhciBzdGFydCA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpMSA9IGluZGV4WyBzdGFydCBdO1xuXHRcdFx0XHRcdHZhciBpMiA9IGluZGV4WyBpICsgKCBjY3cgPyAxIDogMiApIF07XG5cdFx0XHRcdFx0dmFyIGkzID0gaW5kZXhbIGkgKyAoIGNjdyA/IDIgOiAxICkgXTtcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaTEsIGkyLCBpMyApO1xuXG5cdFx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgZmFjZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRcdGlmICggaW5kZXhbIGkgKyAzIF0gPT09IC0gMSB8fCBpICsgMyA+PSBsICkge1xuXG5cdFx0XHRcdFx0XHRpICs9IDM7XG5cdFx0XHRcdFx0XHRzdGFydCA9IGkgKyAxO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaW5kaWNlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBkYXRhLCBpbmRleCApIHtcblxuXHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRGF0YSA9IFtdO1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBzdHJpZGUgPSBzdGFydCAqIDM7XG5cblx0XHRcdFx0XHR2YXIgeCA9IGRhdGFbIHN0cmlkZSBdO1xuXHRcdFx0XHRcdHZhciB5ID0gZGF0YVsgc3RyaWRlICsgMSBdO1xuXHRcdFx0XHRcdHZhciB6ID0gZGF0YVsgc3RyaWRlICsgMiBdO1xuXG5cdFx0XHRcdFx0dHJpYW5ndWxhdGVkRGF0YS5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0XHQvLyBhbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBmYWNlIGhhcyBlbmRlZCBhbmQgdGhlIG5leHQgb25lIGJlZ2luc1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleFsgaSArIDMgXSA9PT0gLSAxIHx8IGkgKyAzID49IGwgKSB7XG5cblx0XHRcdFx0XHRcdGkgKz0gMztcblx0XHRcdFx0XHRcdHN0YXJ0ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJpYW5ndWxhdGVkRGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBmbGF0dGVuRGF0YSggZGF0YSwgaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIGZsYXR0ZW5EYXRhID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpMSA9IGluZGV4WyBpIF07XG5cblx0XHRcdFx0XHR2YXIgc3RyaWRlID0gaTEgKiAzO1xuXG5cdFx0XHRcdFx0dmFyIHggPSBkYXRhWyBzdHJpZGUgXTtcblx0XHRcdFx0XHR2YXIgeSA9IGRhdGFbIHN0cmlkZSArIDEgXTtcblx0XHRcdFx0XHR2YXIgeiA9IGRhdGFbIHN0cmlkZSArIDIgXTtcblxuXHRcdFx0XHRcdGZsYXR0ZW5EYXRhLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZsYXR0ZW5EYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGV4cGFuZExpbmVJbmRleCggaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGkxID0gaW5kZXhbIGkgXTtcblx0XHRcdFx0XHR2YXIgaTIgPSBpbmRleFsgaSArIDEgXTtcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaTEsIGkyICk7XG5cblx0XHRcdFx0XHQvLyBhbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBsaW5lIGhhcyBlbmRlZCBhbmQgdGhlIG5leHQgb25lIGJlZ2luc1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleFsgaSArIDIgXSA9PT0gLSAxIHx8IGkgKyAyID49IGwgKSB7XG5cblx0XHRcdFx0XHRcdGkgKz0gMjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGluZGljZXM7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kTGluZURhdGEoIGRhdGEsIGluZGV4ICkge1xuXG5cdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWREYXRhID0gW107XG5cblx0XHRcdFx0dmFyIHN0YXJ0ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0cmlkZSA9IHN0YXJ0ICogMztcblxuXHRcdFx0XHRcdHZhciB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdFx0dmFyIHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdFx0dmFyIHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0XHR0cmlhbmd1bGF0ZWREYXRhLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHRcdC8vIGFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaGFzIGVuZGVkIGFuZCB0aGUgbmV4dCBvbmUgYmVnaW5zXG5cblx0XHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMiBdID09PSAtIDEgfHwgaSArIDIgPj0gbCApIHtcblxuXHRcdFx0XHRcdFx0aSArPSAyO1xuXHRcdFx0XHRcdFx0c3RhcnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cmlhbmd1bGF0ZWREYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB2QSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdkIgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0dmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlQXR0cmlidXRlRnJvbUluZGV4ZWREYXRhKCBjb29yZEluZGV4LCBpbmRleCwgZGF0YSwgaXRlbVNpemUgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBjb29yZEluZGV4Lmxlbmd0aCBhcyBkZWxpbWl0ZXIgc2luY2Ugbm9ybWFsSW5kZXggbXVzdCBjb250YWluIGF0IGxlYXN0IGFzIG1hbnkgaW5kaWNlc1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvb3JkSW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRleFsgaSBdO1xuXHRcdFx0XHRcdHZhciBiID0gaW5kZXhbIGkgKyAxIF07XG5cdFx0XHRcdFx0dmFyIGMgPSBpbmRleFsgaSArIDIgXTtcblxuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPT09IDIgKSB7XG5cblx0XHRcdFx0XHRcdHV2QS5mcm9tQXJyYXkoIGRhdGEsIGEgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRcdFx0dXZCLmZyb21BcnJheSggZGF0YSwgYiAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0XHR1dkMuZnJvbUFycmF5KCBkYXRhLCBjICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdXZBLngsIHV2QS55ICk7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkIueCwgdXZCLnkgKTtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHV2Qy54LCB1dkMueSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBkYXRhLCBhICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRcdHZCLmZyb21BcnJheSggZGF0YSwgYiAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0XHR2Qy5mcm9tQXJyYXkoIGRhdGEsIGMgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB2Qi54LCB2Qi55LCB2Qi56ICk7XG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB2Qy54LCB2Qy55LCB2Qy56ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggaW5kZXgsIGZhY2VEYXRhICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGogKysgKSB7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIGZhY2VEYXRhLCBqICogMyApO1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIDMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlQXR0cmlidXRlRnJvbUxpbmVEYXRhKCBpbmRleCwgbGluZURhdGEgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMiwgaiArKyApIHtcblxuXHRcdFx0XHRcdHZBLmZyb21BcnJheSggbGluZURhdGEsIGogKiAzICk7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCAzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xuXHRcdFx0XHR2YXIgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRcdFx0dmFyIGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdHZhciBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBpdGVtU2l6ZTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRhcnJheTJbIGluZGV4MiArKyBdID0gYXJyYXlbIGluZGV4ICsrIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCBpbmRleCwgY29vcmQsIGNyZWFzZUFuZ2xlICkge1xuXG5cdFx0XHRcdHZhciBmYWNlcyA9IFtdO1xuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IHt9O1xuXG5cdFx0XHRcdC8vIHByZXBhcmUgZmFjZSBhbmQgcmF3IHZlcnRleCBub3JtYWxzXG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRleFsgaSBdO1xuXHRcdFx0XHRcdHZhciBiID0gaW5kZXhbIGkgKyAxIF07XG5cdFx0XHRcdFx0dmFyIGMgPSBpbmRleFsgaSArIDIgXTtcblxuXHRcdFx0XHRcdHZhciBmYWNlID0gbmV3IEZhY2UoIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdHZBLmZyb21BcnJheSggY29vcmQsIGEgKiAzICk7XG5cdFx0XHRcdFx0dkIuZnJvbUFycmF5KCBjb29yZCwgYiAqIDMgKTtcblx0XHRcdFx0XHR2Qy5mcm9tQXJyYXkoIGNvb3JkLCBjICogMyApO1xuXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRjYi5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cblx0XHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHNbIGEgXSA9PT0gdW5kZWZpbmVkICkgdmVydGV4Tm9ybWFsc1sgYSBdID0gW107XG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzWyBiIF0gPT09IHVuZGVmaW5lZCApIHZlcnRleE5vcm1hbHNbIGIgXSA9IFtdO1xuXHRcdFx0XHRcdGlmICggdmVydGV4Tm9ybWFsc1sgYyBdID09PSB1bmRlZmluZWQgKSB2ZXJ0ZXhOb3JtYWxzWyBjIF0gPSBbXTtcblxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIGEgXS5wdXNoKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIGIgXS5wdXNoKCBmYWNlLm5vcm1hbCApO1xuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIGMgXS5wdXNoKCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb21wdXRlIHZlcnRleCBub3JtYWxzIGFuZCBidWlsZCBmaW5hbCBnZW9tZXRyeVxuXG5cdFx0XHRcdHZhciBub3JtYWxzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRcdHZhciBuQSA9IHdlaWdodGVkTm9ybWFsKCB2ZXJ0ZXhOb3JtYWxzWyBmYWNlLmEgXSwgZmFjZS5ub3JtYWwsIGNyZWFzZUFuZ2xlICk7XG5cdFx0XHRcdFx0dmFyIG5CID0gd2VpZ2h0ZWROb3JtYWwoIHZlcnRleE5vcm1hbHNbIGZhY2UuYiBdLCBmYWNlLm5vcm1hbCwgY3JlYXNlQW5nbGUgKTtcblx0XHRcdFx0XHR2YXIgbkMgPSB3ZWlnaHRlZE5vcm1hbCggdmVydGV4Tm9ybWFsc1sgZmFjZS5jIF0sIGZhY2Uubm9ybWFsLCBjcmVhc2VBbmdsZSApO1xuXG5cdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBjb29yZCwgZmFjZS5hICogMyApO1xuXHRcdFx0XHRcdHZCLmZyb21BcnJheSggY29vcmQsIGZhY2UuYiAqIDMgKTtcblx0XHRcdFx0XHR2Qy5mcm9tQXJyYXkoIGNvb3JkLCBmYWNlLmMgKiAzICk7XG5cblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5BLngsIG5BLnksIG5BLnogKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5CLngsIG5CLnksIG5CLnogKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5DLngsIG5DLnksIG5DLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gd2VpZ2h0ZWROb3JtYWwoIG5vcm1hbHMsIHZlY3RvciwgY3JlYXNlQW5nbGUgKSB7XG5cblx0XHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0aWYgKCBjcmVhc2VBbmdsZSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC5jb3B5KCB2ZWN0b3IgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbHNbIGkgXS5hbmdsZVRvKCB2ZWN0b3IgKSA8IGNyZWFzZUFuZ2xlICkge1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbC5hZGQoIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gdG9Db2xvckFycmF5KCBjb2xvcnMgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVmVydGljYWxseSBwYWludHMgdGhlIGZhY2VzIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGVcblx0XHRcdCAqIHNwZWNpZmllZCBjb2xvcnMgYXQgdGhlIHNwZWNpZmllZCBhbmdlbHMuIFRoaXMgaXMgdXNlZCBmb3IgdGhlIEJhY2tncm91bmRcblx0XHRcdCAqIG5vZGUsIGJ1dCBjb3VsZCBiZSBhcHBsaWVkIHRvIG90aGVyIG5vZGVzIHdpdGggbXVsdGlwbGUgZmFjZXMgYXMgd2VsbC5cblx0XHRcdCAqXG5cdFx0XHQgKiBXaGVuIHVzZWQgd2l0aCB0aGUgQmFja2dyb3VuZCBub2RlLCBkZWZhdWx0IGlzIGRpcmVjdGlvbklzRG93biBpcyB0cnVlIGlmXG5cdFx0XHQgKiBpbnRlcnBvbGF0aW5nIHRoZSBza3lDb2xvciBkb3duIGZyb20gdGhlIFplbml0aC4gV2hlbiBpbnRlcnBvbGF0aW9uZyB1cCBmcm9tXG5cdFx0XHQgKiB0aGUgTmFkaXIgaS5lLiBpbnRlcnBvbGF0aW5nIHRoZSBncm91bmRDb2xvciwgdGhlIGRpcmVjdGlvbklzRG93biBpcyBmYWxzZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgZmlyc3QgYW5nbGUgaXMgbmV2ZXIgc3BlY2lmaWVkLCBpdCBpcyB0aGUgWmVuaXRoICgwIHJhZCkuIEFuZ2xlcyBhcmUgc3BlY2lmaWVkXG5cdFx0XHQgKiBpbiByYWRpYW5zLiBUaGUgZ2VvbWV0cnkgaXMgdGhvdWdodCBhIHNwaGVyZSwgYnV0IGNvdWxkIGJlIGFueXRoaW5nLiBUaGUgY29sb3IgaW50ZXJwb2xhdGlvblxuXHRcdFx0ICogaXMgbGluZWFyIGFsb25nIHRoZSBZIGF4aXMgaW4gYW55IGNhc2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogWW91IG11c3Qgc3BlY2lmeSBvbmUgbW9yZSBjb2xvciB0aGFuIHlvdSBoYXZlIGFuZ2xlcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xvcnMgYXJyYXkuXG5cdFx0XHQgKiBUaGlzIGlzIHRoZSBjb2xvciBvZiB0aGUgWmVuaXRoICh0aGUgdG9wIG9mIHRoZSBzaGFwZSkuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcblx0XHRcdCAqIEBwYXJhbSB7YXJyYXl9IGFuZ2xlc1xuXHRcdFx0ICogQHBhcmFtIHthcnJheX0gY29sb3JzXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRvcERvd24gLSBXaGV0aGVyIHRvIHdvcmsgdG9wIGRvd24gb3IgYm90dG9tIHVwLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwYWludEZhY2VzKCBnZW9tZXRyeSwgcmFkaXVzLCBhbmdsZXMsIGNvbG9ycywgdG9wRG93biApIHtcblxuXHRcdFx0XHQvLyBjb21wdXRlIHRocmVzaG9sZCB2YWx1ZXNcblxuXHRcdFx0XHR2YXIgdGhyZXNob2xkcyA9IFtdO1xuXHRcdFx0XHR2YXIgc3RhcnRBbmdsZSA9ICggdG9wRG93biA9PT0gdHJ1ZSApID8gMCA6IE1hdGguUEk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgYW5nbGUgPSAoIGkgPT09IDAgKSA/IDAgOiBhbmdsZXNbIGkgLSAxIF07XG5cdFx0XHRcdFx0YW5nbGUgPSAoIHRvcERvd24gPT09IHRydWUgKSA/IGFuZ2xlIDogKCBzdGFydEFuZ2xlIC0gYW5nbGUgKTtcblxuXHRcdFx0XHRcdHZhciBwb2ludCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0cG9pbnQuc2V0RnJvbVNwaGVyaWNhbENvb3JkcyggcmFkaXVzLCBhbmdsZSwgMCApO1xuXG5cdFx0XHRcdFx0dGhyZXNob2xkcy5wdXNoKCBwb2ludCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0ZXggY29sb3JzXG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0dmFyIGNvbG9yQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIDMgKSwgMyApO1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSBpbmRpY2VzLmdldFgoIGkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgaW5kZXggKTtcblxuXHRcdFx0XHRcdHZhciB0aHJlc2hvbGRJbmRleEEsIHRocmVzaG9sZEluZGV4Qjtcblx0XHRcdFx0XHR2YXIgdCA9IDE7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPCB0aHJlc2hvbGRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dGhyZXNob2xkSW5kZXhBID0gaiAtIDE7XG5cdFx0XHRcdFx0XHR0aHJlc2hvbGRJbmRleEIgPSBqO1xuXG5cdFx0XHRcdFx0XHR2YXIgdGhyZXNob2xkQSA9IHRocmVzaG9sZHNbIHRocmVzaG9sZEluZGV4QSBdO1xuXHRcdFx0XHRcdFx0dmFyIHRocmVzaG9sZEIgPSB0aHJlc2hvbGRzWyB0aHJlc2hvbGRJbmRleEIgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0b3BEb3duID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGludGVycG9sYXRpb24gZm9yIHNreSBjb2xvclxuXG5cdFx0XHRcdFx0XHRcdGlmICggcG9zaXRpb24ueSA8PSB0aHJlc2hvbGRBLnkgJiYgcG9zaXRpb24ueSA+IHRocmVzaG9sZEIueSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHQgPSBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gcG9zaXRpb24ueSApIC8gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHRocmVzaG9sZEIueSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGludGVycG9sYXRpb24gZm9yIGdyb3VuZCBjb2xvclxuXG5cdFx0XHRcdFx0XHRcdGlmICggcG9zaXRpb24ueSA+PSB0aHJlc2hvbGRBLnkgJiYgcG9zaXRpb24ueSA8IHRocmVzaG9sZEIueSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHQgPSBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gcG9zaXRpb24ueSApIC8gTWF0aC5hYnMoIHRocmVzaG9sZEEueSAtIHRocmVzaG9sZEIueSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY29sb3JBID0gY29sb3JzWyB0aHJlc2hvbGRJbmRleEEgXTtcblx0XHRcdFx0XHR2YXIgY29sb3JCID0gY29sb3JzWyB0aHJlc2hvbGRJbmRleEIgXTtcblxuXHRcdFx0XHRcdGNvbG9yLmNvcHkoIGNvbG9yQSApLmxlcnAoIGNvbG9yQiwgdCApO1xuXG5cdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUuc2V0WFlaKCBpbmRleCwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9yQXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHR0ZXh0dXJlTG9hZGVyLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKS5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHQvLyBjaGVjayB2ZXJzaW9uIChvbmx5IDIuMCBpcyBzdXBwb3J0ZWQpXG5cblx0XHRcdGlmICggZGF0YS5pbmRleE9mKCAnI1ZSTUwgVjIuMCcgKSA9PT0gLSAxICkge1xuXG5cdFx0XHRcdHRocm93IEVycm9yKCAnVEhSRUUuVlJNTExleGVyOiBWZXJzaW9uIG9mIFZSTUwgYXNzZXQgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY3JlYXRlIEpTT04gcmVwcmVzZW50aW5nIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgVlJNTCBhc3NldFxuXG5cdFx0XHR2YXIgdHJlZSA9IGdlbmVyYXRlVlJNTFRyZWUoIGRhdGEgKTtcblxuXHRcdFx0Ly8gcGFyc2UgdGhlIHRyZWUgc3RydWN0dXJlIHRvIGEgdGhyZWUuanMgc2NlbmVcblxuXHRcdFx0dmFyIHNjZW5lID0gcGFyc2VUcmVlKCB0cmVlICk7XG5cblx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0ZnVuY3Rpb24gVlJNTExleGVyKCB0b2tlbnMgKSB7XG5cblx0XHR0aGlzLmxleGVyID0gbmV3IGNoZXZyb3RhaW4uTGV4ZXIoIHRva2VucyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0fVxuXG5cdFZSTUxMZXhlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVlJNTExleGVyLFxuXG5cdFx0bGV4OiBmdW5jdGlvbiAoIGlucHV0VGV4dCApIHtcblxuXHRcdFx0dmFyIGxleGluZ1Jlc3VsdCA9IHRoaXMubGV4ZXIudG9rZW5pemUoIGlucHV0VGV4dCApO1xuXG5cdFx0XHRpZiAoIGxleGluZ1Jlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBsZXhpbmdSZXN1bHQuZXJyb3JzICk7XG5cblx0XHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTGV4ZXI6IExleGluZyBlcnJvcnMgZGV0ZWN0ZWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsZXhpbmdSZXN1bHQ7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBWUk1MUGFyc2VyKCB0b2tlblZvY2FidWxhcnkgKSB7XG5cblx0XHRjaGV2cm90YWluLlBhcnNlci5jYWxsKCB0aGlzLCB0b2tlblZvY2FidWxhcnkgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0dmFyICQgPSB0aGlzO1xuXG5cdFx0dmFyIFZlcnNpb24gPSB0b2tlblZvY2FidWxhcnlbICdWZXJzaW9uJyBdO1xuXHRcdHZhciBMQ3VybHkgPSB0b2tlblZvY2FidWxhcnlbICdMQ3VybHknIF07XG5cdFx0dmFyIFJDdXJseSA9IHRva2VuVm9jYWJ1bGFyeVsgJ1JDdXJseScgXTtcblx0XHR2YXIgTFNxdWFyZSA9IHRva2VuVm9jYWJ1bGFyeVsgJ0xTcXVhcmUnIF07XG5cdFx0dmFyIFJTcXVhcmUgPSB0b2tlblZvY2FidWxhcnlbICdSU3F1YXJlJyBdO1xuXHRcdHZhciBJZGVudGlmaWVyID0gdG9rZW5Wb2NhYnVsYXJ5WyAnSWRlbnRpZmllcicgXTtcblx0XHR2YXIgUm91dGVJZGVudGlmaWVyID0gdG9rZW5Wb2NhYnVsYXJ5WyAnUm91dGVJZGVudGlmaWVyJyBdO1xuXHRcdHZhciBTdHJpbmdMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnU3RyaW5nTGl0ZXJhbCcgXTtcblx0XHR2YXIgSGV4TGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ0hleExpdGVyYWwnIF07XG5cdFx0dmFyIE51bWJlckxpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdOdW1iZXJMaXRlcmFsJyBdO1xuXHRcdHZhciBUcnVlTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ1RydWVMaXRlcmFsJyBdO1xuXHRcdHZhciBGYWxzZUxpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdGYWxzZUxpdGVyYWwnIF07XG5cdFx0dmFyIE51bGxMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTnVsbExpdGVyYWwnIF07XG5cdFx0dmFyIERFRiA9IHRva2VuVm9jYWJ1bGFyeVsgJ0RFRicgXTtcblx0XHR2YXIgVVNFID0gdG9rZW5Wb2NhYnVsYXJ5WyAnVVNFJyBdO1xuXHRcdHZhciBST1VURSA9IHRva2VuVm9jYWJ1bGFyeVsgJ1JPVVRFJyBdO1xuXHRcdHZhciBUTyA9IHRva2VuVm9jYWJ1bGFyeVsgJ1RPJyBdO1xuXHRcdHZhciBOb2RlTmFtZSA9IHRva2VuVm9jYWJ1bGFyeVsgJ05vZGVOYW1lJyBdO1xuXG5cdFx0JC5SVUxFKCAndnJtbCcsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5TVUJSVUxFKCAkLnZlcnNpb24gKTtcblx0XHRcdCQuQVRfTEVBU1RfT05FKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5TVUJSVUxFKCAkLm5vZGUgKTtcblxuXHRcdFx0fSApO1xuXHRcdFx0JC5NQU5ZKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5TVUJSVUxFKCAkLnJvdXRlICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3ZlcnNpb24nLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggVmVyc2lvbiApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnbm9kZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5PUFRJT04oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQuZGVmICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0JC5DT05TVU1FKCBOb2RlTmFtZSApO1xuXHRcdFx0JC5DT05TVU1FKCBMQ3VybHkgKTtcblx0XHRcdCQuTUFOWSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuU1VCUlVMRSggJC5maWVsZCApO1xuXG5cdFx0XHR9ICk7XG5cdFx0XHQkLkNPTlNVTUUoIFJDdXJseSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnZmllbGQnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggSWRlbnRpZmllciApO1xuXG5cdFx0XHQkLk9SMiggW1xuXHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0JC5TVUJSVUxFKCAkLnNpbmdsZUZpZWxkVmFsdWUgKTtcblxuXHRcdFx0XHR9IH0sXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLlNVQlJVTEUoICQubXVsdGlGaWVsZFZhbHVlICk7XG5cblx0XHRcdFx0fSB9XG5cdFx0XHRdICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdkZWYnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggREVGICk7XG5cdFx0XHQkLk9SKCBbXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLkNPTlNVTUUoIElkZW50aWZpZXIgKTtcblxuXHRcdFx0XHR9IH0sXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLkNPTlNVTUUoIE5vZGVOYW1lICk7XG5cblx0XHRcdFx0fSB9XG5cdFx0XHRdICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICd1c2UnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQ09OU1VNRSggVVNFICk7XG5cdFx0XHQkLk9SKCBbXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLkNPTlNVTUUoIElkZW50aWZpZXIgKTtcblxuXHRcdFx0XHR9IH0sXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLkNPTlNVTUUoIE5vZGVOYW1lICk7XG5cblx0XHRcdFx0fSB9XG5cdFx0XHRdICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdzaW5nbGVGaWVsZFZhbHVlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkFUX0xFQVNUX09ORSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuT1IoIFtcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLlNVQlJVTEUoICQubm9kZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC51c2UgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIFN0cmluZ0xpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIEhleExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bWJlckxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIFRydWVMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBGYWxzZUxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bGxMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XSApO1xuXG5cblx0XHRcdH0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ211bHRpRmllbGRWYWx1ZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBMU3F1YXJlICk7XG5cdFx0XHQkLk1BTlkoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLk9SKCBbXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5TVUJSVUxFKCAkLm5vZGUgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLlNVQlJVTEUoICQudXNlICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBTdHJpbmdMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBIZXhMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBOdW1iZXJMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5DT05TVU1FKCBOdWxsTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9XG5cdFx0XHRcdF0gKTtcblxuXHRcdFx0fSApO1xuXHRcdFx0JC5DT05TVU1FKCBSU3F1YXJlICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdyb3V0ZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBST1VURSApO1xuXHRcdFx0JC5DT05TVU1FKCBSb3V0ZUlkZW50aWZpZXIgKTtcblx0XHRcdCQuQ09OU1VNRSggVE8gKTtcblx0XHRcdCQuQ09OU1VNRTIoIFJvdXRlSWRlbnRpZmllciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG5cblx0fVxuXG5cdFZSTUxQYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggY2hldnJvdGFpbi5QYXJzZXIucHJvdG90eXBlICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0VlJNTFBhcnNlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWUk1MUGFyc2VyO1xuXG5cdGZ1bmN0aW9uIEZhY2UoIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmEgPSBhO1xuXHRcdHRoaXMuYiA9IGI7XG5cdFx0dGhpcy5jID0gYztcblx0XHR0aGlzLm5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0fVxuXG5cdHZhciBURVhUVVJFX1RZUEUgPSB7XG5cdFx0SU5URU5TSVRZOiAxLFxuXHRcdElOVEVOU0lUWV9BTFBIQTogMixcblx0XHRSR0I6IDMsXG5cdFx0UkdCQTogNFxuXHR9O1xuXG5cdHJldHVybiBWUk1MTG9hZGVyO1xuXG59ICkoKTtcblxudmFyIFBDRExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0dGhpcy5saXR0bGVFbmRpYW4gPSB0cnVlO1xuXG59O1xuXG5cblBDRExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBQQ0RMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggc2NvcGUucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBkYXRhLCB1cmwgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBkYXRhLCB1cmwgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHBzOi8vZ2l0bGFiLmNvbS90YWtldHdvL3RocmVlLXBjZC1sb2FkZXIvYmxvYi9tYXN0ZXIvZGVjb21wcmVzcy1semYuanNcblxuXHRcdGZ1bmN0aW9uIGRlY29tcHJlc3NMWkYoIGluRGF0YSwgb3V0TGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgaW5MZW5ndGggPSBpbkRhdGEubGVuZ3RoO1xuXHRcdFx0dmFyIG91dERhdGEgPSBuZXcgVWludDhBcnJheSggb3V0TGVuZ3RoICk7XG5cdFx0XHR2YXIgaW5QdHIgPSAwO1xuXHRcdFx0dmFyIG91dFB0ciA9IDA7XG5cdFx0XHR2YXIgY3RybDtcblx0XHRcdHZhciBsZW47XG5cdFx0XHR2YXIgcmVmO1xuXHRcdFx0ZG8ge1xuXG5cdFx0XHRcdGN0cmwgPSBpbkRhdGFbIGluUHRyICsrIF07XG5cdFx0XHRcdGlmICggY3RybCA8ICggMSA8PCA1ICkgKSB7XG5cblx0XHRcdFx0XHRjdHJsICsrO1xuXHRcdFx0XHRcdGlmICggb3V0UHRyICsgY3RybCA+IG91dExlbmd0aCApIHRocm93IG5ldyBFcnJvciggJ091dHB1dCBidWZmZXIgaXMgbm90IGxhcmdlIGVub3VnaCcgKTtcblx0XHRcdFx0XHRpZiAoIGluUHRyICsgY3RybCA+IGluTGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wcmVzc2VkIGRhdGEnICk7XG5cdFx0XHRcdFx0ZG8ge1xuXG5cdFx0XHRcdFx0XHRvdXREYXRhWyBvdXRQdHIgKysgXSA9IGluRGF0YVsgaW5QdHIgKysgXTtcblxuXHRcdFx0XHRcdH0gd2hpbGUgKCAtLSBjdHJsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGxlbiA9IGN0cmwgPj4gNTtcblx0XHRcdFx0XHRyZWYgPSBvdXRQdHIgLSAoICggY3RybCAmIDB4MWYgKSA8PCA4ICkgLSAxO1xuXHRcdFx0XHRcdGlmICggaW5QdHIgPj0gaW5MZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXByZXNzZWQgZGF0YScgKTtcblx0XHRcdFx0XHRpZiAoIGxlbiA9PT0gNyApIHtcblxuXHRcdFx0XHRcdFx0bGVuICs9IGluRGF0YVsgaW5QdHIgKysgXTtcblx0XHRcdFx0XHRcdGlmICggaW5QdHIgPj0gaW5MZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXByZXNzZWQgZGF0YScgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlZiAtPSBpbkRhdGFbIGluUHRyICsrIF07XG5cdFx0XHRcdFx0aWYgKCBvdXRQdHIgKyBsZW4gKyAyID4gb3V0TGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKCAnT3V0cHV0IGJ1ZmZlciBpcyBub3QgbGFyZ2UgZW5vdWdoJyApO1xuXHRcdFx0XHRcdGlmICggcmVmIDwgMCApIHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcHJlc3NlZCBkYXRhJyApO1xuXHRcdFx0XHRcdGlmICggcmVmID49IG91dFB0ciApIHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcHJlc3NlZCBkYXRhJyApO1xuXHRcdFx0XHRcdGRvIHtcblxuXHRcdFx0XHRcdFx0b3V0RGF0YVsgb3V0UHRyICsrIF0gPSBvdXREYXRhWyByZWYgKysgXTtcblxuXHRcdFx0XHRcdH0gd2hpbGUgKCAtLSBsZW4gKyAyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IHdoaWxlICggaW5QdHIgPCBpbkxlbmd0aCApO1xuXG5cdFx0XHRyZXR1cm4gb3V0RGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSGVhZGVyKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgUENEaGVhZGVyID0ge307XG5cdFx0XHR2YXIgcmVzdWx0MSA9IGRhdGEuc2VhcmNoKCAvW1xcclxcbl1EQVRBXFxzKFxcUyopXFxzL2kgKTtcblx0XHRcdHZhciByZXN1bHQyID0gL1tcXHJcXG5dREFUQVxccyhcXFMqKVxccy9pLmV4ZWMoIGRhdGEuc3Vic3RyKCByZXN1bHQxIC0gMSApICk7XG5cblx0XHRcdFBDRGhlYWRlci5kYXRhID0gcmVzdWx0MlsgMSBdO1xuXHRcdFx0UENEaGVhZGVyLmhlYWRlckxlbiA9IHJlc3VsdDJbIDAgXS5sZW5ndGggKyByZXN1bHQxO1xuXHRcdFx0UENEaGVhZGVyLnN0ciA9IGRhdGEuc3Vic3RyKCAwLCBQQ0RoZWFkZXIuaGVhZGVyTGVuICk7XG5cblx0XHRcdC8vIHJlbW92ZSBjb21tZW50c1xuXG5cdFx0XHRQQ0RoZWFkZXIuc3RyID0gUENEaGVhZGVyLnN0ci5yZXBsYWNlKCAvXFwjLiovZ2ksICcnICk7XG5cblx0XHRcdC8vIHBhcnNlXG5cblx0XHRcdFBDRGhlYWRlci52ZXJzaW9uID0gL1ZFUlNJT04gKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci5maWVsZHMgPSAvRklFTERTICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIuc2l6ZSA9IC9TSVpFICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIudHlwZSA9IC9UWVBFICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIuY291bnQgPSAvQ09VTlQgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci53aWR0aCA9IC9XSURUSCAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLmhlaWdodCA9IC9IRUlHSFQgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci52aWV3cG9pbnQgPSAvVklFV1BPSU5UICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIucG9pbnRzID0gL1BPSU5UUyAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXG5cdFx0XHQvLyBldmFsdWF0ZVxuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci52ZXJzaW9uICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLnZlcnNpb24gPSBwYXJzZUZsb2F0KCBQQ0RoZWFkZXIudmVyc2lvblsgMSBdICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLmZpZWxkcyAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci5maWVsZHMgPSBQQ0RoZWFkZXIuZmllbGRzWyAxIF0uc3BsaXQoICcgJyApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci50eXBlICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLnR5cGUgPSBQQ0RoZWFkZXIudHlwZVsgMSBdLnNwbGl0KCAnICcgKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIud2lkdGggIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIud2lkdGggPSBwYXJzZUludCggUENEaGVhZGVyLndpZHRoWyAxIF0gKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIuaGVpZ2h0ICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLmhlaWdodCA9IHBhcnNlSW50KCBQQ0RoZWFkZXIuaGVpZ2h0WyAxIF0gKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIudmlld3BvaW50ICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLnZpZXdwb2ludCA9IFBDRGhlYWRlci52aWV3cG9pbnRbIDEgXTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIucG9pbnRzICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLnBvaW50cyA9IHBhcnNlSW50KCBQQ0RoZWFkZXIucG9pbnRzWyAxIF0sIDEwICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLnBvaW50cyA9PT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci5wb2ludHMgPSBQQ0RoZWFkZXIud2lkdGggKiBQQ0RoZWFkZXIuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5zaXplICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFBDRGhlYWRlci5zaXplID0gUENEaGVhZGVyLnNpemVbIDEgXS5zcGxpdCggJyAnICkubWFwKCBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHgsIDEwICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggUENEaGVhZGVyLmNvdW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFBDRGhlYWRlci5jb3VudCA9IFBDRGhlYWRlci5jb3VudFsgMSBdLnNwbGl0KCAnICcgKS5tYXAoIGZ1bmN0aW9uICggeCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggeCwgMTAgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0UENEaGVhZGVyLmNvdW50ID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gUENEaGVhZGVyLmZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0UENEaGVhZGVyLmNvdW50LnB1c2goIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0UENEaGVhZGVyLm9mZnNldCA9IHt9O1xuXG5cdFx0XHR2YXIgc2l6ZVN1bSA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IFBDRGhlYWRlci5maWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIFBDRGhlYWRlci5kYXRhID09PSAnYXNjaWknICkge1xuXG5cdFx0XHRcdFx0UENEaGVhZGVyLm9mZnNldFsgUENEaGVhZGVyLmZpZWxkc1sgaSBdIF0gPSBpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRQQ0RoZWFkZXIub2Zmc2V0WyBQQ0RoZWFkZXIuZmllbGRzWyBpIF0gXSA9IHNpemVTdW07XG5cdFx0XHRcdFx0c2l6ZVN1bSArPSBQQ0RoZWFkZXIuc2l6ZVsgaSBdICogUENEaGVhZGVyLmNvdW50WyBpIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBiaW5hcnkgb25seVxuXG5cdFx0XHRQQ0RoZWFkZXIucm93U2l6ZSA9IHNpemVTdW07XG5cblx0XHRcdHJldHVybiBQQ0RoZWFkZXI7XG5cblx0XHR9XG5cblx0XHR2YXIgdGV4dERhdGEgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSApICk7XG5cblx0XHQvLyBwYXJzZSBoZWFkZXIgKGFsd2F5cyBhc2NpaSBmb3JtYXQpXG5cblx0XHR2YXIgUENEaGVhZGVyID0gcGFyc2VIZWFkZXIoIHRleHREYXRhICk7XG5cblx0XHQvLyBwYXJzZSBkYXRhXG5cblx0XHR2YXIgcG9zaXRpb24gPSBbXTtcblx0XHR2YXIgbm9ybWFsID0gW107XG5cdFx0dmFyIGNvbG9yID0gW107XG5cblx0XHQvLyBhc2NpaVxuXG5cdFx0aWYgKCBQQ0RoZWFkZXIuZGF0YSA9PT0gJ2FzY2lpJyApIHtcblxuXHRcdFx0dmFyIG9mZnNldCA9IFBDRGhlYWRlci5vZmZzZXQ7XG5cdFx0XHR2YXIgcGNkRGF0YSA9IHRleHREYXRhLnN1YnN0ciggUENEaGVhZGVyLmhlYWRlckxlbiApO1xuXHRcdFx0dmFyIGxpbmVzID0gcGNkRGF0YS5zcGxpdCggJ1xcbicgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGxpbmVzWyBpIF0gPT09ICcnICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGxpbmUgPSBsaW5lc1sgaSBdLnNwbGl0KCAnICcgKTtcblxuXHRcdFx0XHRpZiAoIG9mZnNldC54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQueCBdICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQueSBdICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQueiBdICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQucmdiICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgcmdiID0gcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0LnJnYiBdICk7XG5cdFx0XHRcdFx0dmFyIHIgPSAoIHJnYiA+PiAxNiApICYgMHgwMDAwZmY7XG5cdFx0XHRcdFx0dmFyIGcgPSAoIHJnYiA+PiA4ICkgJiAweDAwMDBmZjtcblx0XHRcdFx0XHR2YXIgYiA9ICggcmdiID4+IDAgKSAmIDB4MDAwMGZmO1xuXHRcdFx0XHRcdGNvbG9yLnB1c2goIHIgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQubm9ybWFsX3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQubm9ybWFsX3ggXSApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC5ub3JtYWxfeSBdICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0Lm5vcm1hbF96IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYmluYXJ5LWNvbXByZXNzZWRcblxuXHRcdC8vIG5vcm1hbGx5IGRhdGEgaW4gUENEIGZpbGVzIGFyZSBvcmdhbml6ZWQgYXMgYXJyYXkgb2Ygc3RydWN0dXJlczogWFlaUkdCWFlaUkdCXG5cdFx0Ly8gYmluYXJ5IGNvbXByZXNzZWQgUENEIGZpbGVzIG9yZ2FuaXplIHRoZWlyIGRhdGEgYXMgc3RydWN0dXJlIG9mIGFycmF5czogWFhZWVpaUkdCUkdCXG5cdFx0Ly8gdGhhdCByZXF1aXJlcyBhIHRvdGFsbHkgZGlmZmVyZW50IHBhcnNpbmcgYXBwcm9hY2ggY29tcGFyZWQgdG8gbm9uLWNvbXByZXNzZWQgZGF0YVxuXG5cdFx0aWYgKCBQQ0RoZWFkZXIuZGF0YSA9PT0gJ2JpbmFyeV9jb21wcmVzc2VkJyApIHtcblxuXHRcdFx0dmFyIHNpemVzID0gbmV3IFVpbnQzMkFycmF5KCBkYXRhLnNsaWNlKCBQQ0RoZWFkZXIuaGVhZGVyTGVuLCBQQ0RoZWFkZXIuaGVhZGVyTGVuICsgOCApICk7XG5cdFx0XHR2YXIgY29tcHJlc3NlZFNpemUgPSBzaXplc1sgMCBdO1xuXHRcdFx0dmFyIGRlY29tcHJlc3NlZFNpemUgPSBzaXplc1sgMSBdO1xuXHRcdFx0dmFyIGRlY29tcHJlc3NlZCA9IGRlY29tcHJlc3NMWkYoIG5ldyBVaW50OEFycmF5KCBkYXRhLCBQQ0RoZWFkZXIuaGVhZGVyTGVuICsgOCwgY29tcHJlc3NlZFNpemUgKSwgZGVjb21wcmVzc2VkU2l6ZSApO1xuXHRcdFx0dmFyIGRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KCBkZWNvbXByZXNzZWQuYnVmZmVyICk7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBQQ0RoZWFkZXIub2Zmc2V0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBQQ0RoZWFkZXIucG9pbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC54ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMCBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC55ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMSBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC56ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMiBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5yZ2IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQucmdiICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMyBdICogaSArIDAgKSAvIDI1NS4wICk7XG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5yZ2IgKSArIFBDRGhlYWRlci5zaXplWyAzIF0gKiBpICsgMSApIC8gMjU1LjAgKTtcblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnJnYiApICsgUENEaGVhZGVyLnNpemVbIDMgXSAqIGkgKyAyICkgLyAyNTUuMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5ub3JtYWxfeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5ub3JtYWxfeCApICsgUENEaGVhZGVyLnNpemVbIDQgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0Lm5vcm1hbF95ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgNSBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQubm9ybWFsX3ogKSArIFBDRGhlYWRlci5zaXplWyA2IF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBiaW5hcnlcblxuXHRcdGlmICggUENEaGVhZGVyLmRhdGEgPT09ICdiaW5hcnknICkge1xuXG5cdFx0XHR2YXIgZGF0YXZpZXcgPSBuZXcgRGF0YVZpZXcoIGRhdGEsIFBDRGhlYWRlci5oZWFkZXJMZW4gKTtcblx0XHRcdHZhciBvZmZzZXQgPSBQQ0RoZWFkZXIub2Zmc2V0O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIHJvdyA9IDA7IGkgPCBQQ0RoZWFkZXIucG9pbnRzOyBpICsrLCByb3cgKz0gUENEaGVhZGVyLnJvd1NpemUgKSB7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0LngsIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQueSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC56LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnJnYiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoIHJvdyArIG9mZnNldC5yZ2IgKyAyICkgLyAyNTUuMCApO1xuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCByb3cgKyBvZmZzZXQucmdiICsgMSApIC8gMjU1LjAgKTtcblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggcm93ICsgb2Zmc2V0LnJnYiArIDAgKSAvIDI1NS4wICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0Lm5vcm1hbF94ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0Lm5vcm1hbF94LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC5ub3JtYWxfeSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQubm9ybWFsX3osIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdGlmICggcG9zaXRpb24ubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcblx0XHRpZiAoIG5vcm1hbC5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgMyApICk7XG5cdFx0aWYgKCBjb2xvci5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IsIDMgKSApO1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHQvLyBidWlsZCBtYXRlcmlhbFxuXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IHNpemU6IDAuMDA1IH0gKTtcblxuXHRcdGlmICggY29sb3IubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1hdGVyaWFsLmNvbG9yLnNldEhleCggTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmICk7XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBwb2ludCBjbG91ZFxuXG5cdFx0dmFyIG1lc2ggPSBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR2YXIgbmFtZSA9IHVybC5zcGxpdCggJycgKS5yZXZlcnNlKCkuam9pbiggJycgKTtcblx0XHRuYW1lID0gLyhbXlxcL10qKS8uZXhlYyggbmFtZSApO1xuXHRcdG5hbWUgPSBuYW1lWyAxIF0uc3BsaXQoICcnICkucmV2ZXJzZSgpLmpvaW4oICcnICk7XG5cdFx0bWVzaC5uYW1lID0gbmFtZTtcblxuXHRcdHJldHVybiBtZXNoO1xuXG5cdH1cblxufSApO1xuXG4vKipcbiAqIERlc2NyaXB0aW9uOiBBIFRIUkVFIGxvYWRlciBmb3IgUExZIEFTQ0lJIGZpbGVzIChrbm93biBhcyB0aGUgUG9seWdvblxuICogRmlsZSBGb3JtYXQgb3IgdGhlIFN0YW5mb3JkIFRyaWFuZ2xlIEZvcm1hdCkuXG4gKlxuICogTGltaXRhdGlvbnM6IEFTQ0lJIGRlY29kaW5nIGFzc3VtZXMgZmlsZSBpcyBVVEYtOC5cbiAqXG4gKiBVc2FnZTpcbiAqXHR2YXIgbG9hZGVyID0gbmV3IFBMWUxvYWRlcigpO1xuICpcdGxvYWRlci5sb2FkKCcuL21vZGVscy9wbHkvYXNjaWkvZG9scGhpbnMucGx5JywgZnVuY3Rpb24gKGdlb21ldHJ5KSB7XG4gKlxuICpcdFx0c2NlbmUuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnkgKSApO1xuICpcbiAqXHR9ICk7XG4gKlxuICogSWYgdGhlIFBMWSBmaWxlIHVzZXMgbm9uIHN0YW5kYXJkIHByb3BlcnR5IG5hbWVzLCB0aGV5IGNhbiBiZSBtYXBwZWQgd2hpbGVcbiAqIGxvYWRpbmcuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIG1hcHMgdGhlIHByb3BlcnRpZXNcbiAqIOKAnGRpZmZ1c2VfKHJlZHxncmVlbnxibHVlKeKAnSBpbiB0aGUgZmlsZSB0byBzdGFuZGFyZCBjb2xvciBuYW1lcy5cbiAqXG4gKiBsb2FkZXIuc2V0UHJvcGVydHlOYW1lTWFwcGluZygge1xuICpcdGRpZmZ1c2VfcmVkOiAncmVkJyxcbiAqXHRkaWZmdXNlX2dyZWVuOiAnZ3JlZW4nLFxuICpcdGRpZmZ1c2VfYmx1ZTogJ2JsdWUnXG4gKiB9ICk7XG4gKlxuICovXG5cblxudmFyIFBMWUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0dGhpcy5wcm9wZXJ0eU5hbWVNYXBwaW5nID0ge307XG5cbn07XG5cblBMWUxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBQTFlMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRQcm9wZXJ0eU5hbWVNYXBwaW5nOiBmdW5jdGlvbiAoIG1hcHBpbmcgKSB7XG5cblx0XHR0aGlzLnByb3BlcnR5TmFtZU1hcHBpbmcgPSBtYXBwaW5nO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlSGVhZGVyKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgcGF0dGVybkhlYWRlciA9IC9wbHkoW1xcc1xcU10qKWVuZF9oZWFkZXJcXHI/XFxuLztcblx0XHRcdHZhciBoZWFkZXJUZXh0ID0gJyc7XG5cdFx0XHR2YXIgaGVhZGVyTGVuZ3RoID0gMDtcblx0XHRcdHZhciByZXN1bHQgPSBwYXR0ZXJuSGVhZGVyLmV4ZWMoIGRhdGEgKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aGVhZGVyVGV4dCA9IHJlc3VsdFsgMSBdO1xuXHRcdFx0XHRoZWFkZXJMZW5ndGggPSBuZXcgQmxvYiggWyByZXN1bHRbIDAgXSBdICkuc2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaGVhZGVyID0ge1xuXHRcdFx0XHRjb21tZW50czogW10sXG5cdFx0XHRcdGVsZW1lbnRzOiBbXSxcblx0XHRcdFx0aGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsXG5cdFx0XHRcdG9iakluZm86ICcnXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbGluZXMgPSBoZWFkZXJUZXh0LnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0dmFyIGN1cnJlbnRFbGVtZW50O1xuXHRcdFx0dmFyIGxpbmVUeXBlLCBsaW5lVmFsdWVzO1xuXG5cdFx0XHRmdW5jdGlvbiBtYWtlX3BseV9lbGVtZW50X3Byb3BlcnR5KCBwcm9wZXJ0VmFsdWVzLCBwcm9wZXJ0eU5hbWVNYXBwaW5nICkge1xuXG5cdFx0XHRcdHZhciBwcm9wZXJ0eSA9IHsgdHlwZTogcHJvcGVydFZhbHVlc1sgMCBdIH07XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eS50eXBlID09PSAnbGlzdCcgKSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eS5uYW1lID0gcHJvcGVydFZhbHVlc1sgMyBdO1xuXHRcdFx0XHRcdHByb3BlcnR5LmNvdW50VHlwZSA9IHByb3BlcnRWYWx1ZXNbIDEgXTtcblx0XHRcdFx0XHRwcm9wZXJ0eS5pdGVtVHlwZSA9IHByb3BlcnRWYWx1ZXNbIDIgXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cHJvcGVydHkubmFtZSA9IHByb3BlcnRWYWx1ZXNbIDEgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eS5uYW1lIGluIHByb3BlcnR5TmFtZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eS5uYW1lID0gcHJvcGVydHlOYW1lTWFwcGluZ1sgcHJvcGVydHkubmFtZSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXTtcblx0XHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRcdGlmICggbGluZSA9PT0gJycgKSBjb250aW51ZTtcblxuXHRcdFx0XHRsaW5lVmFsdWVzID0gbGluZS5zcGxpdCggL1xccysvICk7XG5cdFx0XHRcdGxpbmVUeXBlID0gbGluZVZhbHVlcy5zaGlmdCgpO1xuXHRcdFx0XHRsaW5lID0gbGluZVZhbHVlcy5qb2luKCAnICcgKTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBsaW5lVHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2Zvcm1hdCc6XG5cblx0XHRcdFx0XHRcdGhlYWRlci5mb3JtYXQgPSBsaW5lVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRoZWFkZXIudmVyc2lvbiA9IGxpbmVWYWx1ZXNbIDEgXTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjb21tZW50JzpcblxuXHRcdFx0XHRcdFx0aGVhZGVyLmNvbW1lbnRzLnB1c2goIGxpbmUgKTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdlbGVtZW50JzpcblxuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50RWxlbWVudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGhlYWRlci5lbGVtZW50cy5wdXNoKCBjdXJyZW50RWxlbWVudCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50ID0ge307XG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudC5uYW1lID0gbGluZVZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQuY291bnQgPSBwYXJzZUludCggbGluZVZhbHVlc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudC5wcm9wZXJ0aWVzID0gW107XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncHJvcGVydHknOlxuXG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudC5wcm9wZXJ0aWVzLnB1c2goIG1ha2VfcGx5X2VsZW1lbnRfcHJvcGVydHkoIGxpbmVWYWx1ZXMsIHNjb3BlLnByb3BlcnR5TmFtZU1hcHBpbmcgKSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ29ial9pbmZvJzpcblxuXHRcdFx0XHRcdFx0aGVhZGVyLm9iakluZm8gPSBsaW5lO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICd1bmhhbmRsZWQnLCBsaW5lVHlwZSwgbGluZVZhbHVlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1cnJlbnRFbGVtZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aGVhZGVyLmVsZW1lbnRzLnB1c2goIGN1cnJlbnRFbGVtZW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhlYWRlcjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQVNDSUlOdW1iZXIoIG4sIHR5cGUgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnY2hhcic6IGNhc2UgJ3VjaGFyJzogY2FzZSAnc2hvcnQnOiBjYXNlICd1c2hvcnQnOiBjYXNlICdpbnQnOiBjYXNlICd1aW50Jzpcblx0XHRcdFx0Y2FzZSAnaW50OCc6IGNhc2UgJ3VpbnQ4JzogY2FzZSAnaW50MTYnOiBjYXNlICd1aW50MTYnOiBjYXNlICdpbnQzMic6IGNhc2UgJ3VpbnQzMic6XG5cblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIG4gKTtcblxuXHRcdFx0XHRjYXNlICdmbG9hdCc6IGNhc2UgJ2RvdWJsZSc6IGNhc2UgJ2Zsb2F0MzInOiBjYXNlICdmbG9hdDY0JzpcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCBuICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQVNDSUlFbGVtZW50KCBwcm9wZXJ0aWVzLCBsaW5lICkge1xuXG5cdFx0XHR2YXIgdmFsdWVzID0gbGluZS5zcGxpdCggL1xccysvICk7XG5cblx0XHRcdHZhciBlbGVtZW50ID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcHJvcGVydGllc1sgaSBdLnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRcdFx0dmFyIG4gPSBwYXJzZUFTQ0lJTnVtYmVyKCB2YWx1ZXMuc2hpZnQoKSwgcHJvcGVydGllc1sgaSBdLmNvdW50VHlwZSApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbjsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBwYXJzZUFTQ0lJTnVtYmVyKCB2YWx1ZXMuc2hpZnQoKSwgcHJvcGVydGllc1sgaSBdLml0ZW1UeXBlICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSBsaXN0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRlbGVtZW50WyBwcm9wZXJ0aWVzWyBpIF0ubmFtZSBdID0gcGFyc2VBU0NJSU51bWJlciggdmFsdWVzLnNoaWZ0KCksIHByb3BlcnRpZXNbIGkgXS50eXBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSSggZGF0YSwgaGVhZGVyICkge1xuXG5cdFx0XHQvLyBQTFkgYXNjaWkgZm9ybWF0IHNwZWNpZmljYXRpb24sIGFzIHBlciBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BMWV8oZmlsZV9mb3JtYXQpXG5cblx0XHRcdHZhciBidWZmZXIgPSB7XG5cdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRmYWNlVmVydGV4VXZzOiBbXSxcblx0XHRcdFx0Y29sb3JzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0dmFyIHBhdHRlcm5Cb2R5ID0gL2VuZF9oZWFkZXJcXHMoW1xcc1xcU10qKSQvO1xuXHRcdFx0dmFyIGJvZHkgPSAnJztcblx0XHRcdGlmICggKCByZXN1bHQgPSBwYXR0ZXJuQm9keS5leGVjKCBkYXRhICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRib2R5ID0gcmVzdWx0WyAxIF07XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpbmVzID0gYm9keS5zcGxpdCggJ1xcbicgKTtcblx0XHRcdHZhciBjdXJyZW50RWxlbWVudCA9IDA7XG5cdFx0XHR2YXIgY3VycmVudEVsZW1lbnRDb3VudCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XG5cdFx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0aWYgKCBsaW5lID09PSAnJyApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGN1cnJlbnRFbGVtZW50Q291bnQgPj0gaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLmNvdW50ICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQgKys7XG5cdFx0XHRcdFx0Y3VycmVudEVsZW1lbnRDb3VudCA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBlbGVtZW50ID0gcGFyc2VBU0NJSUVsZW1lbnQoIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5wcm9wZXJ0aWVzLCBsaW5lICk7XG5cblx0XHRcdFx0aGFuZGxlRWxlbWVudCggYnVmZmVyLCBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0ubmFtZSwgZWxlbWVudCApO1xuXG5cdFx0XHRcdGN1cnJlbnRFbGVtZW50Q291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvc3RQcm9jZXNzKCBidWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBvc3RQcm9jZXNzKCBidWZmZXIgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHQvLyBtYW5kYXRvcnkgYnVmZmVyIGRhdGFcblxuXHRcdFx0aWYgKCBidWZmZXIuaW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBidWZmZXIuaW5kaWNlcyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci52ZXJ0aWNlcywgMyApICk7XG5cblx0XHRcdC8vIG9wdGlvbmFsIGJ1ZmZlciBkYXRhXG5cblx0XHRcdGlmICggYnVmZmVyLm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLm5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLnV2cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci51dnMsIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci5jb2xvcnMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVyLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeSA9IGdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIuZmFjZVZlcnRleFV2cywgMiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGJ1ZmZlciwgZWxlbWVudE5hbWUsIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggZWxlbWVudE5hbWUgPT09ICd2ZXJ0ZXgnICkge1xuXG5cdFx0XHRcdGJ1ZmZlci52ZXJ0aWNlcy5wdXNoKCBlbGVtZW50LngsIGVsZW1lbnQueSwgZWxlbWVudC56ICk7XG5cblx0XHRcdFx0aWYgKCAnbngnIGluIGVsZW1lbnQgJiYgJ255JyBpbiBlbGVtZW50ICYmICdueicgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5ub3JtYWxzLnB1c2goIGVsZW1lbnQubngsIGVsZW1lbnQubnksIGVsZW1lbnQubnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAncycgaW4gZWxlbWVudCAmJiAndCcgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci51dnMucHVzaCggZWxlbWVudC5zLCBlbGVtZW50LnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAncmVkJyBpbiBlbGVtZW50ICYmICdncmVlbicgaW4gZWxlbWVudCAmJiAnYmx1ZScgaW4gZWxlbWVudCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5jb2xvcnMucHVzaCggZWxlbWVudC5yZWQgLyAyNTUuMCwgZWxlbWVudC5ncmVlbiAvIDI1NS4wLCBlbGVtZW50LmJsdWUgLyAyNTUuMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudE5hbWUgPT09ICdmYWNlJyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4X2luZGljZXMgPSBlbGVtZW50LnZlcnRleF9pbmRpY2VzIHx8IGVsZW1lbnQudmVydGV4X2luZGV4OyAvLyBpc3N1ZSAjOTMzOFxuXHRcdFx0XHR2YXIgdGV4Y29vcmQgPSBlbGVtZW50LnRleGNvb3JkO1xuXG5cdFx0XHRcdGlmICggdmVydGV4X2luZGljZXMubGVuZ3RoID09PSAzICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLmluZGljZXMucHVzaCggdmVydGV4X2luZGljZXNbIDAgXSwgdmVydGV4X2luZGljZXNbIDEgXSwgdmVydGV4X2luZGljZXNbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXhjb29yZCAmJiB0ZXhjb29yZC5sZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlci5mYWNlVmVydGV4VXZzLnB1c2goIHRleGNvb3JkWyAwIF0sIHRleGNvb3JkWyAxIF0gKTtcblx0XHRcdFx0XHRcdGJ1ZmZlci5mYWNlVmVydGV4VXZzLnB1c2goIHRleGNvb3JkWyAyIF0sIHRleGNvb3JkWyAzIF0gKTtcblx0XHRcdFx0XHRcdGJ1ZmZlci5mYWNlVmVydGV4VXZzLnB1c2goIHRleGNvb3JkWyA0IF0sIHRleGNvb3JkWyA1IF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB2ZXJ0ZXhfaW5kaWNlcy5sZW5ndGggPT09IDQgKSB7XG5cblx0XHRcdFx0XHRidWZmZXIuaW5kaWNlcy5wdXNoKCB2ZXJ0ZXhfaW5kaWNlc1sgMCBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMSBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMyBdICk7XG5cdFx0XHRcdFx0YnVmZmVyLmluZGljZXMucHVzaCggdmVydGV4X2luZGljZXNbIDEgXSwgdmVydGV4X2luZGljZXNbIDIgXSwgdmVydGV4X2luZGljZXNbIDMgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYmluYXJ5UmVhZCggZGF0YXZpZXcsIGF0LCB0eXBlLCBsaXR0bGVfZW5kaWFuICkge1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdC8vIGNvcmVzcG9uZGVuY2VzIGZvciBub24tc3BlY2lmaWMgbGVuZ3RoIHR5cGVzIGhlcmUgbWF0Y2ggcnBseTpcblx0XHRcdFx0Y2FzZSAnaW50OCc6XHRcdGNhc2UgJ2NoYXInOlx0IHJldHVybiBbIGRhdGF2aWV3LmdldEludDgoIGF0ICksIDEgXTtcblx0XHRcdFx0Y2FzZSAndWludDgnOlx0XHRjYXNlICd1Y2hhcic6XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0VWludDgoIGF0ICksIDEgXTtcblx0XHRcdFx0Y2FzZSAnaW50MTYnOlx0XHRjYXNlICdzaG9ydCc6XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0SW50MTYoIGF0LCBsaXR0bGVfZW5kaWFuICksIDIgXTtcblx0XHRcdFx0Y2FzZSAndWludDE2JzpcdGNhc2UgJ3VzaG9ydCc6IHJldHVybiBbIGRhdGF2aWV3LmdldFVpbnQxNiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgMiBdO1xuXHRcdFx0XHRjYXNlICdpbnQzMic6XHRcdGNhc2UgJ2ludCc6XHRcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRJbnQzMiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgNCBdO1xuXHRcdFx0XHRjYXNlICd1aW50MzInOlx0Y2FzZSAndWludCc6XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0VWludDMyKCBhdCwgbGl0dGxlX2VuZGlhbiApLCA0IF07XG5cdFx0XHRcdGNhc2UgJ2Zsb2F0MzInOiBjYXNlICdmbG9hdCc6XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0RmxvYXQzMiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgNCBdO1xuXHRcdFx0XHRjYXNlICdmbG9hdDY0JzogY2FzZSAnZG91YmxlJzogcmV0dXJuIFsgZGF0YXZpZXcuZ2V0RmxvYXQ2NCggYXQsIGxpdHRsZV9lbmRpYW4gKSwgOCBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBiaW5hcnlSZWFkRWxlbWVudCggZGF0YXZpZXcsIGF0LCBwcm9wZXJ0aWVzLCBsaXR0bGVfZW5kaWFuICkge1xuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHt9O1xuXHRcdFx0dmFyIHJlc3VsdCwgcmVhZCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcHJvcGVydGllc1sgaSBdLnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdHZhciBsaXN0ID0gW107XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkKCBkYXRhdmlldywgYXQgKyByZWFkLCBwcm9wZXJ0aWVzWyBpIF0uY291bnRUeXBlLCBsaXR0bGVfZW5kaWFuICk7XG5cdFx0XHRcdFx0dmFyIG4gPSByZXN1bHRbIDAgXTtcblx0XHRcdFx0XHRyZWFkICs9IHJlc3VsdFsgMSBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbjsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gYmluYXJ5UmVhZCggZGF0YXZpZXcsIGF0ICsgcmVhZCwgcHJvcGVydGllc1sgaSBdLml0ZW1UeXBlLCBsaXR0bGVfZW5kaWFuICk7XG5cdFx0XHRcdFx0XHRsaXN0LnB1c2goIHJlc3VsdFsgMCBdICk7XG5cdFx0XHRcdFx0XHRyZWFkICs9IHJlc3VsdFsgMSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbWVudFsgcHJvcGVydGllc1sgaSBdLm5hbWUgXSA9IGxpc3Q7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCArIHJlYWQsIHByb3BlcnRpZXNbIGkgXS50eXBlLCBsaXR0bGVfZW5kaWFuICk7XG5cdFx0XHRcdFx0ZWxlbWVudFsgcHJvcGVydGllc1sgaSBdLm5hbWUgXSA9IHJlc3VsdFsgMCBdO1xuXHRcdFx0XHRcdHJlYWQgKz0gcmVzdWx0WyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBbIGVsZW1lbnQsIHJlYWQgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQmluYXJ5KCBkYXRhLCBoZWFkZXIgKSB7XG5cblx0XHRcdHZhciBidWZmZXIgPSB7XG5cdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRmYWNlVmVydGV4VXZzOiBbXSxcblx0XHRcdFx0Y29sb3JzOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGxpdHRsZV9lbmRpYW4gPSAoIGhlYWRlci5mb3JtYXQgPT09ICdiaW5hcnlfbGl0dGxlX2VuZGlhbicgKTtcblx0XHRcdHZhciBib2R5ID0gbmV3IERhdGFWaWV3KCBkYXRhLCBoZWFkZXIuaGVhZGVyTGVuZ3RoICk7XG5cdFx0XHR2YXIgcmVzdWx0LCBsb2MgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgY3VycmVudEVsZW1lbnQgPSAwOyBjdXJyZW50RWxlbWVudCA8IGhlYWRlci5lbGVtZW50cy5sZW5ndGg7IGN1cnJlbnRFbGVtZW50ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBjdXJyZW50RWxlbWVudENvdW50ID0gMDsgY3VycmVudEVsZW1lbnRDb3VudCA8IGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5jb3VudDsgY3VycmVudEVsZW1lbnRDb3VudCArKyApIHtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWRFbGVtZW50KCBib2R5LCBsb2MsIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5wcm9wZXJ0aWVzLCBsaXR0bGVfZW5kaWFuICk7XG5cdFx0XHRcdFx0bG9jICs9IHJlc3VsdFsgMSBdO1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gcmVzdWx0WyAwIF07XG5cblx0XHRcdFx0XHRoYW5kbGVFbGVtZW50KCBidWZmZXIsIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5uYW1lLCBlbGVtZW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwb3N0UHJvY2VzcyggYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIGdlb21ldHJ5O1xuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRpZiAoIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIHRleHQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YSApICk7XG5cdFx0XHR2YXIgaGVhZGVyID0gcGFyc2VIZWFkZXIoIHRleHQgKTtcblxuXHRcdFx0Z2VvbWV0cnkgPSBoZWFkZXIuZm9ybWF0ID09PSAnYXNjaWknID8gcGFyc2VBU0NJSSggdGV4dCwgaGVhZGVyICkgOiBwYXJzZUJpbmFyeSggZGF0YSwgaGVhZGVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeSA9IHBhcnNlQVNDSUkoIGRhdGEsIHBhcnNlSGVhZGVyKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cbn0gKTtcblxuLyohXG5mZmxhdGUgLSBmYXN0IEphdmFTY3JpcHQgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvblxuPGh0dHBzOi8vMTAxYXJyb3d6LmdpdGh1Yi5pby9mZmxhdGU+XG5MaWNlbnNlZCB1bmRlciBNSVQuIGh0dHBzOi8vZ2l0aHViLmNvbS8xMDFhcnJvd3ovZmZsYXRlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG52YXIgZ249e30sYm49ZnVuY3Rpb24obixyLHQsZSxpKXt2YXIgYT1nbltyXXx8KGduW3JdPVVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25dLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSkpLG89bmV3IFdvcmtlcihhKTtyZXR1cm4gby5vbmVycm9yPWZ1bmN0aW9uKGYpe3JldHVybiBpKGYuZXJyb3IsbnVsbCl9LG8ub25tZXNzYWdlPWZ1bmN0aW9uKGYpe3JldHVybiBpKG51bGwsZi5kYXRhKX0sby5wb3N0TWVzc2FnZSh0LGUpLG99LEE9VWludDhBcnJheSxSPVVpbnQxNkFycmF5LG5yPVVpbnQzMkFycmF5LHVyPW5ldyBBKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxscj1uZXcgQShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxNcj1uZXcgQShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLHduPWZ1bmN0aW9uKG4scil7Zm9yKHZhciB0PW5ldyBSKDMxKSxlPTA7ZTwzMTsrK2UpdFtlXT1yKz0xPDxuW2UtMV07Zm9yKHZhciBpPW5ldyBucih0WzMwXSksZT0xO2U8MzA7KytlKWZvcih2YXIgYT10W2VdO2E8dFtlKzFdOysrYSlpW2FdPWEtdFtlXTw8NXxlO3JldHVybiBbdCxpXX0seW49d24odXIsMiksTnI9eW5bMF0sSXI9eW5bMV07TnJbMjhdPTI1OCxJclsyNThdPTI4O2Zvcih2YXIgbW49d24obHIsMCksem49bW5bMF0sUXI9bW5bMV0sVXI9bmV3IFIoMzI3NjgpLFQ9MDtUPDMyNzY4OysrVCl7dmFyIGlyPShUJjQzNjkwKT4+PjF8KFQmMjE4NDUpPDwxO2lyPShpciY1MjQyOCk+Pj4yfChpciYxMzEwNyk8PDIsaXI9KGlyJjYxNjgwKT4+PjR8KGlyJjM4NTUpPDw0LFVyW1RdPSgoaXImNjUyODApPj4+OHwoaXImMjU1KTw8OCk+Pj4xO31mb3IodmFyIFY9ZnVuY3Rpb24obixyLHQpe2Zvcih2YXIgZT1uLmxlbmd0aCxpPTAsYT1uZXcgUihyKTtpPGU7KytpKSsrYVtuW2ldLTFdO3ZhciBvPW5ldyBSKHIpO2ZvcihpPTA7aTxyOysraSlvW2ldPW9baS0xXSthW2ktMV08PDE7dmFyIGY7aWYodCl7Zj1uZXcgUigxPDxyKTt2YXIgaD0xNS1yO2ZvcihpPTA7aTxlOysraSlpZihuW2ldKWZvcih2YXIgcz1pPDw0fG5baV0sdT1yLW5baV0sbD1vW25baV0tMV0rKzw8dSxwPWx8KDE8PHUpLTE7bDw9cDsrK2wpZltVcltsXT4+PmhdPXM7fWVsc2UgZm9yKGY9bmV3IFIoZSksaT0wO2k8ZTsrK2kpbltpXSYmKGZbaV09VXJbb1tuW2ldLTFdKytdPj4+MTUtbltpXSk7cmV0dXJuIGZ9LHRyPW5ldyBBKDI4OCksVD0wO1Q8MTQ0OysrVCl0cltUXT04O2Zvcih2YXIgVD0xNDQ7VDwyNTY7KytUKXRyW1RdPTk7Zm9yKHZhciBUPTI1NjtUPDI4MDsrK1QpdHJbVF09Nztmb3IodmFyIFQ9MjgwO1Q8Mjg4OysrVCl0cltUXT04O2Zvcih2YXIgdnI9bmV3IEEoMzIpLFQ9MDtUPDMyOysrVCl2cltUXT01O3ZhciB4bj1WKHRyLDksMCksQW49Vih0ciw5LDEpLERuPVYodnIsNSwwKSxNbj1WKHZyLDUsMSksR3I9ZnVuY3Rpb24obil7Zm9yKHZhciByPW5bMF0sdD0xO3Q8bi5sZW5ndGg7Kyt0KW5bdF0+ciYmKHI9blt0XSk7cmV0dXJuIHJ9LFg9ZnVuY3Rpb24obixyLHQpe3ZhciBlPXIvOHwwO3JldHVybiAobltlXXxuW2UrMV08PDgpPj4ociY3KSZ0fSxPcj1mdW5jdGlvbihuLHIpe3ZhciB0PXIvOHwwO3JldHVybiAoblt0XXxuW3QrMV08PDh8blt0KzJdPDwxNik+PihyJjcpfSxDcj1mdW5jdGlvbihuKXtyZXR1cm4gKG4vOHwwKSsobiY3JiYxKX0sJD1mdW5jdGlvbihuLHIsdCl7KHI9PW51bGx8fHI8MCkmJihyPTApLCh0PT1udWxsfHx0Pm4ubGVuZ3RoKSYmKHQ9bi5sZW5ndGgpO3ZhciBlPW5ldyhuIGluc3RhbmNlb2YgUj9SOm4gaW5zdGFuY2VvZiBucj9ucjpBKSh0LXIpO3JldHVybiBlLnNldChuLnN1YmFycmF5KHIsdCkpLGV9LEZyPWZ1bmN0aW9uKG4scix0KXt2YXIgZT1uLmxlbmd0aDtpZighZXx8dCYmIXQubCYmZTw1KXJldHVybiByfHxuZXcgQSgwKTt2YXIgaT0hcnx8dCxhPSF0fHx0Lmk7dHx8KHQ9e30pLHJ8fChyPW5ldyBBKGUqMykpO3ZhciBvPWZ1bmN0aW9uKFRyKXt2YXIgRHI9ci5sZW5ndGg7aWYoVHI+RHIpe3ZhciBocj1uZXcgQShNYXRoLm1heChEcioyLFRyKSk7aHIuc2V0KHIpLHI9aHI7fX0sZj10LmZ8fDAsaD10LnB8fDAscz10LmJ8fDAsdT10LmwsbD10LmQscD10Lm0seT10Lm4sYz1lKjg7ZG97aWYoIXUpe3QuZj1mPVgobixoLDEpO3ZhciBnPVgobixoKzEsMyk7aWYoaCs9MyxnKWlmKGc9PTEpdT1BbixsPU1uLHA9OSx5PTU7ZWxzZSBpZihnPT0yKXt2YXIgbT1YKG4saCwzMSkrMjU3LEQ9WChuLGgrMTAsMTUpKzQsQz1tK1gobixoKzUsMzEpKzE7aCs9MTQ7Zm9yKHZhciBVPW5ldyBBKEMpLHg9bmV3IEEoMTkpLHY9MDt2PEQ7Kyt2KXhbTXJbdl1dPVgobixoK3YqMyw3KTtoKz1EKjM7dmFyIEU9R3IoeCksUz0oMTw8RSktMTtpZighYSYmaCtDKihFKzcpPmMpYnJlYWs7Zm9yKHZhciBLPVYoeCxFLDEpLHY9MDt2PEM7KXt2YXIgST1LW1gobixoLFMpXTtoKz1JJjE1O3ZhciB3PUk+Pj40O2lmKHc8MTYpVVt2KytdPXc7ZWxzZSB7dmFyIFo9MCxCPTA7Zm9yKHc9PTE2PyhCPTMrWChuLGgsMyksaCs9MixaPVVbdi0xXSk6dz09MTc/KEI9MytYKG4saCw3KSxoKz0zKTp3PT0xOCYmKEI9MTErWChuLGgsMTI3KSxoKz03KTtCLS07KVVbdisrXT1aO319dmFyIEc9VS5zdWJhcnJheSgwLG0pLGs9VS5zdWJhcnJheShtKTtwPUdyKEcpLHk9R3IoayksdT1WKEcscCwxKSxsPVYoayx5LDEpO31lbHNlIHRocm93IFwiaW52YWxpZCBibG9jayB0eXBlXCI7ZWxzZSB7dmFyIHc9Q3IoaCkrNCxNPW5bdy00XXxuW3ctM108PDgsej13K007aWYoej5lKXtpZihhKXRocm93IFwidW5leHBlY3RlZCBFT0ZcIjticmVha31pJiZvKHMrTSksci5zZXQobi5zdWJhcnJheSh3LHopLHMpLHQuYj1zKz1NLHQucD1oPXoqODtjb250aW51ZX1pZihoPmMpdGhyb3cgXCJ1bmV4cGVjdGVkIEVPRlwifWkmJm8ocysxMzEwNzIpO2Zvcih2YXIgTz0oMTw8cCktMSxIPSgxPDx5KS0xLE49cCt5KzE4O2F8fGgrTjxjOyl7dmFyIFo9dVtPcihuLGgpJk9dLFE9Wj4+PjQ7aWYoaCs9WiYxNSxoPmMpdGhyb3cgXCJ1bmV4cGVjdGVkIEVPRlwiO2lmKCFaKXRocm93IFwiaW52YWxpZCBsZW5ndGgvbGl0ZXJhbFwiO2lmKFE8MjU2KXJbcysrXT1RO2Vsc2UgaWYoUT09MjU2KXt1PW51bGw7YnJlYWt9ZWxzZSB7dmFyIFc9US0yNTQ7aWYoUT4yNjQpe3ZhciB2PVEtMjU3LGQ9dXJbdl07Vz1YKG4saCwoMTw8ZCktMSkrTnJbdl0saCs9ZDt9dmFyIF89bFtPcihuLGgpJkhdLGo9Xz4+PjQ7aWYoIV8pdGhyb3cgXCJpbnZhbGlkIGRpc3RhbmNlXCI7aCs9XyYxNTt2YXIgaz16bltqXTtpZihqPjMpe3ZhciBkPWxyW2pdO2srPU9yKG4saCkmKDE8PGQpLTEsaCs9ZDt9aWYoaD5jKXRocm93IFwidW5leHBlY3RlZCBFT0ZcIjtpJiZvKHMrMTMxMDcyKTtmb3IodmFyIHE9cytXO3M8cTtzKz00KXJbc109cltzLWtdLHJbcysxXT1yW3MrMS1rXSxyW3MrMl09cltzKzIta10scltzKzNdPXJbcyszLWtdO3M9cTt9fXQubD11LHQucD1oLHQuYj1zLHUmJihmPTEsdC5tPXAsdC5kPWwsdC5uPXkpO313aGlsZSghZik7cmV0dXJuIHM9PXIubGVuZ3RoP3I6JChyLDAscyl9LGI9ZnVuY3Rpb24obixyLHQpe3Q8PD1yJjc7dmFyIGU9ci84fDA7bltlXXw9dCxuW2UrMV18PXQ+Pj44O30sY3I9ZnVuY3Rpb24obixyLHQpe3Q8PD1yJjc7dmFyIGU9ci84fDA7bltlXXw9dCxuW2UrMV18PXQ+Pj44LG5bZSsyXXw9dD4+PjE2O30sRXI9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9W10sZT0wO2U8bi5sZW5ndGg7KytlKW5bZV0mJnQucHVzaCh7czplLGY6bltlXX0pO3ZhciBpPXQubGVuZ3RoLGE9dC5zbGljZSgpO2lmKCFpKXJldHVybiBbZXIsMF07aWYoaT09MSl7dmFyIG89bmV3IEEodFswXS5zKzEpO3JldHVybiBvW3RbMF0uc109MSxbbywxXX10LnNvcnQoZnVuY3Rpb24oQyxVKXtyZXR1cm4gQy5mLVUuZn0pLHQucHVzaCh7czotMSxmOjI1MDAxfSk7dmFyIGY9dFswXSxoPXRbMV0scz0wLHU9MSxsPTI7Zm9yKHRbMF09e3M6LTEsZjpmLmYraC5mLGw6ZixyOmh9O3UhPWktMTspZj10W3Rbc10uZjx0W2xdLmY/cysrOmwrK10saD10W3MhPXUmJnRbc10uZjx0W2xdLmY/cysrOmwrK10sdFt1KytdPXtzOi0xLGY6Zi5mK2guZixsOmYscjpofTtmb3IodmFyIHA9YVswXS5zLGU9MTtlPGk7KytlKWFbZV0ucz5wJiYocD1hW2VdLnMpO3ZhciB5PW5ldyBSKHArMSksYz1Qcih0W3UtMV0seSwwKTtpZihjPnIpe3ZhciBlPTAsZz0wLHc9Yy1yLE09MTw8dztmb3IoYS5zb3J0KGZ1bmN0aW9uKFUseCl7cmV0dXJuIHlbeC5zXS15W1Uuc118fFUuZi14LmZ9KTtlPGk7KytlKXt2YXIgej1hW2VdLnM7aWYoeVt6XT5yKWcrPU0tKDE8PGMteVt6XSkseVt6XT1yO2Vsc2UgYnJlYWt9Zm9yKGc+Pj49dztnPjA7KXt2YXIgbT1hW2VdLnM7eVttXTxyP2ctPTE8PHIteVttXSsrLTE6KytlO31mb3IoO2U+PTAmJmc7LS1lKXt2YXIgRD1hW2VdLnM7eVtEXT09ciYmKC0teVtEXSwrK2cpO31jPXI7fXJldHVybiBbbmV3IEEoeSksY119LFByPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gbi5zPT0tMT9NYXRoLm1heChQcihuLmwscix0KzEpLFByKG4ucixyLHQrMSkpOnJbbi5zXT10fSxWcj1mdW5jdGlvbihuKXtmb3IodmFyIHI9bi5sZW5ndGg7ciYmIW5bLS1yXTspO2Zvcih2YXIgdD1uZXcgUigrK3IpLGU9MCxpPW5bMF0sYT0xLG89ZnVuY3Rpb24oaCl7dFtlKytdPWg7fSxmPTE7Zjw9cjsrK2YpaWYobltmXT09aSYmZiE9cikrK2E7ZWxzZSB7aWYoIWkmJmE+Mil7Zm9yKDthPjEzODthLT0xMzgpbygzMjc1NCk7YT4yJiYobyhhPjEwP2EtMTE8PDV8Mjg2OTA6YS0zPDw1fDEyMzA1KSxhPTApO31lbHNlIGlmKGE+Myl7Zm9yKG8oaSksLS1hO2E+NjthLT02KW8oODMwNCk7YT4yJiYobyhhLTM8PDV8ODIwOCksYT0wKTt9Zm9yKDthLS07KW8oaSk7YT0xLGk9bltmXTt9cmV0dXJuIFt0LnN1YmFycmF5KDAsZSkscl19LHByPWZ1bmN0aW9uKG4scil7Zm9yKHZhciB0PTAsZT0wO2U8ci5sZW5ndGg7KytlKXQrPW5bZV0qcltlXTtyZXR1cm4gdH0sU3I9ZnVuY3Rpb24obixyLHQpe3ZhciBlPXQubGVuZ3RoLGk9Q3IocisyKTtuW2ldPWUmMjU1LG5baSsxXT1lPj4+OCxuW2krMl09bltpXV4yNTUsbltpKzNdPW5baSsxXV4yNTU7Zm9yKHZhciBhPTA7YTxlOysrYSluW2krYSs0XT10W2FdO3JldHVybiAoaSs0K2UpKjh9LFhyPWZ1bmN0aW9uKG4scix0LGUsaSxhLG8sZixoLHMsdSl7YihyLHUrKyx0KSwrK2lbMjU2XTtmb3IodmFyIGw9RXIoaSwxNSkscD1sWzBdLHk9bFsxXSxjPUVyKGEsMTUpLGc9Y1swXSx3PWNbMV0sTT1WcihwKSx6PU1bMF0sbT1NWzFdLEQ9VnIoZyksQz1EWzBdLFU9RFsxXSx4PW5ldyBSKDE5KSx2PTA7djx6Lmxlbmd0aDsrK3YpeFt6W3ZdJjMxXSsrO2Zvcih2YXIgdj0wO3Y8Qy5sZW5ndGg7Kyt2KXhbQ1t2XSYzMV0rKztmb3IodmFyIEU9RXIoeCw3KSxTPUVbMF0sSz1FWzFdLEk9MTk7ST40JiYhU1tNcltJLTFdXTstLUkpO3ZhciBaPXMrNTw8MyxCPXByKGksdHIpK3ByKGEsdnIpK28sRz1wcihpLHApK3ByKGEsZykrbysxNCszKkkrcHIoeCxTKSsoMip4WzE2XSszKnhbMTddKzcqeFsxOF0pO2lmKFo8PUImJlo8PUcpcmV0dXJuIFNyKHIsdSxuLnN1YmFycmF5KGgsaCtzKSk7dmFyIGssTyxILE47aWYoYihyLHUsMSsoRzxCKSksdSs9MixHPEIpe2s9VihwLHksMCksTz1wLEg9VihnLHcsMCksTj1nO3ZhciBRPVYoUyxLLDApO2Iocix1LG0tMjU3KSxiKHIsdSs1LFUtMSksYihyLHUrMTAsSS00KSx1Kz0xNDtmb3IodmFyIHY9MDt2PEk7Kyt2KWIocix1KzMqdixTW01yW3ZdXSk7dSs9MypJO2Zvcih2YXIgVz1beixDXSxkPTA7ZDwyOysrZClmb3IodmFyIF89V1tkXSx2PTA7djxfLmxlbmd0aDsrK3Ype3ZhciBqPV9bdl0mMzE7YihyLHUsUVtqXSksdSs9U1tqXSxqPjE1JiYoYihyLHUsX1t2XT4+PjUmMTI3KSx1Kz1fW3ZdPj4+MTIpO319ZWxzZSBrPXhuLE89dHIsSD1EbixOPXZyO2Zvcih2YXIgdj0wO3Y8ZjsrK3YpaWYoZVt2XT4yNTUpe3ZhciBqPWVbdl0+Pj4xOCYzMTtjcihyLHUsa1tqKzI1N10pLHUrPU9baisyNTddLGo+NyYmKGIocix1LGVbdl0+Pj4yMyYzMSksdSs9dXJbal0pO3ZhciBxPWVbdl0mMzE7Y3Iocix1LEhbcV0pLHUrPU5bcV0scT4zJiYoY3Iocix1LGVbdl0+Pj41JjgxOTEpLHUrPWxyW3FdKTt9ZWxzZSBjcihyLHUsa1tlW3ZdXSksdSs9T1tlW3ZdXTtyZXR1cm4gY3Iocix1LGtbMjU2XSksdStPWzI1Nl19LFVuPW5ldyBucihbNjU1NDAsMTMxMDgwLDEzMTA4OCwxMzExMDQsMjYyMTc2LDEwNDg3MDQsMTA0ODgzMiwyMTE0NTYwLDIxMTc2MzJdKSxlcj1uZXcgQSgwKSxDbj1mdW5jdGlvbihuLHIsdCxlLGksYSl7dmFyIG89bi5sZW5ndGgsZj1uZXcgQShlK28rNSooMStNYXRoLmNlaWwoby83ZTMpKStpKSxoPWYuc3ViYXJyYXkoZSxmLmxlbmd0aC1pKSxzPTA7aWYoIXJ8fG88OClmb3IodmFyIHU9MDt1PD1vO3UrPTY1NTM1KXt2YXIgbD11KzY1NTM1O2w8bz9zPVNyKGgscyxuLnN1YmFycmF5KHUsbCkpOihoW3VdPWEscz1TcihoLHMsbi5zdWJhcnJheSh1LG8pKSk7fWVsc2Uge2Zvcih2YXIgcD1VbltyLTFdLHk9cD4+PjEzLGM9cCY4MTkxLGc9KDE8PHQpLTEsdz1uZXcgUigzMjc2OCksTT1uZXcgUihnKzEpLHo9TWF0aC5jZWlsKHQvMyksbT0yKnosRD1mdW5jdGlvbihLcil7cmV0dXJuIChuW0tyXV5uW0tyKzFdPDx6Xm5bS3IrMl08PG0pJmd9LEM9bmV3IG5yKDI1ZTMpLFU9bmV3IFIoMjg4KSx4PW5ldyBSKDMyKSx2PTAsRT0wLHU9MCxTPTAsSz0wLEk9MDt1PG87Kyt1KXt2YXIgWj1EKHUpLEI9dSYzMjc2NyxHPU1bWl07aWYod1tCXT1HLE1bWl09QixLPD11KXt2YXIgaz1vLXU7aWYoKHY+N2UzfHxTPjI0NTc2KSYmaz40MjMpe3M9WHIobixoLDAsQyxVLHgsRSxTLEksdS1JLHMpLFM9dj1FPTAsST11O2Zvcih2YXIgTz0wO088Mjg2OysrTylVW09dPTA7Zm9yKHZhciBPPTA7TzwzMDsrK08peFtPXT0wO312YXIgSD0yLE49MCxRPWMsVz1CLUcmMzI3Njc7aWYoaz4yJiZaPT1EKHUtVykpZm9yKHZhciBkPU1hdGgubWluKHksayktMSxfPU1hdGgubWluKDMyNzY3LHUpLGo9TWF0aC5taW4oMjU4LGspO1c8PV8mJi0tUSYmQiE9Rzspe2lmKG5bdStIXT09blt1K0gtV10pe2Zvcih2YXIgcT0wO3E8aiYmblt1K3FdPT1uW3UrcS1XXTsrK3EpO2lmKHE+SCl7aWYoSD1xLE49VyxxPmQpYnJlYWs7Zm9yKHZhciBUcj1NYXRoLm1pbihXLHEtMiksRHI9MCxPPTA7TzxUcjsrK08pe3ZhciBocj11LVcrTyszMjc2OCYzMjc2Nyxfbj13W2hyXSx2bj1oci1fbiszMjc2OCYzMjc2Nzt2bj5EciYmKERyPXZuLEc9aHIpO319fUI9RyxHPXdbQl0sVys9Qi1HKzMyNzY4JjMyNzY3O31pZihOKXtDW1MrK109MjY4NDM1NDU2fElyW0hdPDwxOHxRcltOXTt2YXIgY249SXJbSF0mMzEscG49UXJbTl0mMzE7RSs9dXJbY25dK2xyW3BuXSwrK1VbMjU3K2NuXSwrK3hbcG5dLEs9dStILCsrdjt9ZWxzZSBDW1MrK109blt1XSwrK1Vbblt1XV07fX1zPVhyKG4saCxhLEMsVSx4LEUsUyxJLHUtSSxzKSwhYSYmcyY3JiYocz1TcihoLHMrMSxlcikpO31yZXR1cm4gJChmLDAsZStDcihzKStpKX0sRm49ZnVuY3Rpb24oKXtmb3IodmFyIG49bmV3IG5yKDI1Nikscj0wO3I8MjU2Oysrcil7Zm9yKHZhciB0PXIsZT05Oy0tZTspdD0odCYxJiYzOTg4MjkyMzg0KV50Pj4+MTtuW3JdPXQ7fXJldHVybiBufSgpLGdyPWZ1bmN0aW9uKCl7dmFyIG49LTE7cmV0dXJuIHtwOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uLGU9MDtlPHIubGVuZ3RoOysrZSl0PUZuW3QmMjU1XnJbZV1dXnQ+Pj44O249dDt9LGQ6ZnVuY3Rpb24oKXtyZXR1cm4gfm59fX0sJHI9ZnVuY3Rpb24oKXt2YXIgbj0xLHI9MDtyZXR1cm4ge3A6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW4saT1yLGE9dC5sZW5ndGgsbz0wO28hPWE7KXtmb3IodmFyIGY9TWF0aC5taW4obysyNjU1LGEpO288ZjsrK28paSs9ZSs9dFtvXTtlPShlJjY1NTM1KSsxNSooZT4+MTYpLGk9KGkmNjU1MzUpKzE1KihpPj4xNik7fW49ZSxyPWk7fSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG4lPTY1NTIxLHIlPTY1NTIxLChuPj4+ODw8MTZ8KHImMjU1KTw8OHxyPj4+OCkrKChuJjI1NSk8PDIzKSoyfX19LHNyPWZ1bmN0aW9uKG4scix0LGUsaSl7cmV0dXJuIENuKG4sci5sZXZlbD09bnVsbD82OnIubGV2ZWwsci5tZW09PW51bGw/TWF0aC5jZWlsKE1hdGgubWF4KDgsTWF0aC5taW4oMTMsTWF0aC5sb2cobi5sZW5ndGgpKSkqMS41KToxMityLm1lbSx0LGUsIWkpfSxacj1mdW5jdGlvbihuLHIpe3ZhciB0PXt9O2Zvcih2YXIgZSBpbiBuKXRbZV09bltlXTtmb3IodmFyIGUgaW4gcil0W2VdPXJbZV07cmV0dXJuIHR9LFNuPWZ1bmN0aW9uKG4scix0KXtmb3IodmFyIGU9bigpLGk9bi50b1N0cmluZygpLGE9aS5zbGljZShpLmluZGV4T2YoXCJbXCIpKzEsaS5sYXN0SW5kZXhPZihcIl1cIikpLnJlcGxhY2UoLyAvZyxcIlwiKS5zcGxpdChcIixcIiksbz0wO288ZS5sZW5ndGg7KytvKXt2YXIgZj1lW29dLGg9YVtvXTtpZih0eXBlb2YgZj09XCJmdW5jdGlvblwiKXtyKz1cIjtcIitoK1wiPVwiO3ZhciBzPWYudG9TdHJpbmcoKTtpZihmLnByb3RvdHlwZSlpZihzLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpIT0tMSl7dmFyIHU9cy5pbmRleE9mKFwiIFwiLDgpKzE7cis9cy5zbGljZSh1LHMuaW5kZXhPZihcIihcIix1KSk7fWVsc2Uge3IrPXM7Zm9yKHZhciBsIGluIGYucHJvdG90eXBlKXIrPVwiO1wiK2grXCIucHJvdG90eXBlLlwiK2wrXCI9XCIrZi5wcm90b3R5cGVbbF0udG9TdHJpbmcoKTt9ZWxzZSByKz1zO31lbHNlIHRbaF09Zjt9cmV0dXJuIFtyLHRdfSxScj1bXSxydD1mdW5jdGlvbihuKXt2YXIgcj1bXTtmb3IodmFyIHQgaW4gbikoblt0XWluc3RhbmNlb2YgQXx8blt0XWluc3RhbmNlb2YgUnx8blt0XWluc3RhbmNlb2YgbnIpJiZyLnB1c2goKG5bdF09bmV3IG5bdF0uY29uc3RydWN0b3Ioblt0XSkpLmJ1ZmZlcik7cmV0dXJuIHJ9LFpuPWZ1bmN0aW9uKG4scix0LGUpe3ZhciBpO2lmKCFSclt0XSl7Zm9yKHZhciBhPVwiXCIsbz17fSxmPW4ubGVuZ3RoLTEsaD0wO2g8ZjsrK2gpaT1TbihuW2hdLGEsbyksYT1pWzBdLG89aVsxXTtSclt0XT1TbihuW2ZdLGEsbyk7fXZhciBzPVpyKHt9LFJyW3RdWzFdKTtyZXR1cm4gYm4oUnJbdF1bMF0rXCI7b25tZXNzYWdlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgayBpbiBlLmRhdGEpc2VsZltrXT1lLmRhdGFba107b25tZXNzYWdlPVwiK3IudG9TdHJpbmcoKStcIn1cIix0LHMscnQocyksZSl9LHdyPWZ1bmN0aW9uKCl7cmV0dXJuIFtBLFIsbnIsdXIsbHIsTXIsTnIsem4sQW4sTW4sVXIsVixHcixYLE9yLENyLCQsRnIseHIsYXIsTHJdfSx5cj1mdW5jdGlvbigpe3JldHVybiBbQSxSLG5yLHVyLGxyLE1yLElyLFFyLHhuLHRyLERuLHZyLFVyLFVuLGVyLFYsYixjcixFcixQcixWcixwcixTcixYcixDciwkLENuLHNyLGtyLGFyXX0sa249ZnVuY3Rpb24oKXtyZXR1cm4gW19yLHJuLEYsZ3IsRm5dfSxCbj1mdW5jdGlvbigpe3JldHVybiBbYnIsR25dfSxUbj1mdW5jdGlvbigpe3JldHVybiBbbm4sRiwkcl19LEluPWZ1bmN0aW9uKCl7cmV0dXJuIFtPbl19LGFyPWZ1bmN0aW9uKG4pe3JldHVybiBwb3N0TWVzc2FnZShuLFtuLmJ1ZmZlcl0pfSxMcj1mdW5jdGlvbihuKXtyZXR1cm4gbiYmbi5zaXplJiZuZXcgQShuLnNpemUpfSxtcj1mdW5jdGlvbihuLHIsdCxlLGksYSl7dmFyIG89Wm4odCxlLGksZnVuY3Rpb24oZixoKXtvLnRlcm1pbmF0ZSgpLGEoZixoKTt9KTtyZXR1cm4gby5wb3N0TWVzc2FnZShbbixyXSxyLmNvbnN1bWU/W24uYnVmZmVyXTpbXSksZnVuY3Rpb24oKXtvLnRlcm1pbmF0ZSgpO319LEw9ZnVuY3Rpb24obil7cmV0dXJuIG4ub25kYXRhPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIHBvc3RNZXNzYWdlKFtyLHRdLFtyLmJ1ZmZlcl0pfSxmdW5jdGlvbihyKXtyZXR1cm4gbi5wdXNoKHIuZGF0YVswXSxyLmRhdGFbMV0pfX0senI9ZnVuY3Rpb24obixyLHQsZSxpKXt2YXIgYSxvPVpuKG4sZSxpLGZ1bmN0aW9uKGYsaCl7Zj8oby50ZXJtaW5hdGUoKSxyLm9uZGF0YS5jYWxsKHIsZikpOihoWzFdJiZvLnRlcm1pbmF0ZSgpLHIub25kYXRhLmNhbGwocixmLGhbMF0saFsxXSkpO30pO28ucG9zdE1lc3NhZ2UodCksci5wdXNoPWZ1bmN0aW9uKGYsaCl7aWYoYSl0aHJvdyBcInN0cmVhbSBmaW5pc2hlZFwiO2lmKCFyLm9uZGF0YSl0aHJvdyBcIm5vIHN0cmVhbSBoYW5kbGVyXCI7by5wb3N0TWVzc2FnZShbZixhPWhdLFtmLmJ1ZmZlcl0pO30sci50ZXJtaW5hdGU9ZnVuY3Rpb24oKXtvLnRlcm1pbmF0ZSgpO307fSxZPWZ1bmN0aW9uKG4scil7cmV0dXJuIG5bcl18bltyKzFdPDw4fSxQPWZ1bmN0aW9uKG4scil7cmV0dXJuIChuW3JdfG5bcisxXTw8OHxuW3IrMl08PDE2KSsobltyKzNdPDwyMykqMn0sZHI9ZnVuY3Rpb24obixyKXtyZXR1cm4gUChuLHIpfFAobixyKSo0Mjk0OTY3Mjk2fSxGPWZ1bmN0aW9uKG4scix0KXtmb3IoO3Q7KytyKW5bcl09dCx0Pj4+PTg7fSxfcj1mdW5jdGlvbihuLHIpe3ZhciB0PXIuZmlsZW5hbWU7aWYoblswXT0zMSxuWzFdPTEzOSxuWzJdPTgsbls4XT1yLmxldmVsPDI/NDpyLmxldmVsPT05PzI6MCxuWzldPTMsci5tdGltZSE9MCYmRihuLDQsTWF0aC5mbG9vcihuZXcgRGF0ZShyLm10aW1lfHxEYXRlLm5vdygpKS8xZTMpKSx0KXtuWzNdPTg7Zm9yKHZhciBlPTA7ZTw9dC5sZW5ndGg7KytlKW5bZSsxMF09dC5jaGFyQ29kZUF0KGUpO319LGJyPWZ1bmN0aW9uKG4pe2lmKG5bMF0hPTMxfHxuWzFdIT0xMzl8fG5bMl0hPTgpdGhyb3cgXCJpbnZhbGlkIGd6aXAgZGF0YVwiO3ZhciByPW5bM10sdD0xMDtyJjQmJih0Kz1uWzEwXXwoblsxMV08PDgpKzIpO2Zvcih2YXIgZT0ocj4+MyYxKSsocj4+NCYxKTtlPjA7ZS09IW5bdCsrXSk7cmV0dXJuIHQrKHImMil9LEduPWZ1bmN0aW9uKG4pe3ZhciByPW4ubGVuZ3RoO3JldHVybiAobltyLTRdfG5bci0zXTw8OHxuW3ItMl08PDE2KSsyKihuW3ItMV08PDIzKX0scm49ZnVuY3Rpb24obil7cmV0dXJuIDEwKyhuLmZpbGVuYW1lJiZuLmZpbGVuYW1lLmxlbmd0aCsxfHwwKX0sbm49ZnVuY3Rpb24obixyKXt2YXIgdD1yLmxldmVsLGU9dD09MD8wOnQ8Nj8xOnQ9PTk/MzoyO25bMF09MTIwLG5bMV09ZTw8NnwoZT8zMi0yKmU6MSk7fSxPbj1mdW5jdGlvbihuKXtpZigoblswXSYxNSkhPTh8fG5bMF0+Pj40Pjd8fChuWzBdPDw4fG5bMV0pJTMxKXRocm93IFwiaW52YWxpZCB6bGliIGRhdGFcIjtpZihuWzFdJjMyKXRocm93IFwiaW52YWxpZCB6bGliIGRhdGE6IHByZXNldCBkaWN0aW9uYXJpZXMgbm90IHN1cHBvcnRlZFwifTtmdW5jdGlvbiB0bihuLHIpe3JldHVybiAhciYmdHlwZW9mIG49PVwiZnVuY3Rpb25cIiYmKHI9bixuPXt9KSx0aGlzLm9uZGF0YT1yLG59dmFyIHJyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpeyF0JiZ0eXBlb2Ygcj09XCJmdW5jdGlvblwiJiYodD1yLHI9e30pLHRoaXMub25kYXRhPXQsdGhpcy5vPXJ8fHt9O31yZXR1cm4gbi5wcm90b3R5cGUucD1mdW5jdGlvbihyLHQpe3RoaXMub25kYXRhKHNyKHIsdGhpcy5vLDAsMCwhdCksdCk7fSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYodGhpcy5kKXRocm93IFwic3RyZWFtIGZpbmlzaGVkXCI7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gc3RyZWFtIGhhbmRsZXJcIjt0aGlzLmQ9dCx0aGlzLnAocix0fHwhMSk7fSxufSgpLEVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3pyKFt5cixmdW5jdGlvbigpe3JldHVybiBbTCxycl19XSx0aGlzLHRuLmNhbGwodGhpcyxyLHQpLGZ1bmN0aW9uKGUpe3ZhciBpPW5ldyBycihlLmRhdGEpO29ubWVzc2FnZT1MKGkpO30sNik7fXJldHVybiBufSgpO2Z1bmN0aW9uIFBuKG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3lyXSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoa3IoZS5kYXRhWzBdLGUuZGF0YVsxXSkpfSwwLHQpfWZ1bmN0aW9uIGtyKG4scil7cmV0dXJuIHNyKG4scnx8e30sMCwwKX12YXIgSj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5zPXt9LHRoaXMucD1uZXcgQSgwKSx0aGlzLm9uZGF0YT1yO31yZXR1cm4gbi5wcm90b3R5cGUuZT1mdW5jdGlvbihyKXtpZih0aGlzLmQpdGhyb3cgXCJzdHJlYW0gZmluaXNoZWRcIjtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBzdHJlYW0gaGFuZGxlclwiO3ZhciB0PXRoaXMucC5sZW5ndGgsZT1uZXcgQSh0K3IubGVuZ3RoKTtlLnNldCh0aGlzLnApLGUuc2V0KHIsdCksdGhpcy5wPWU7fSxuLnByb3RvdHlwZS5jPWZ1bmN0aW9uKHIpe3RoaXMuZD10aGlzLnMuaT1yfHwhMTt2YXIgdD10aGlzLnMuYixlPUZyKHRoaXMucCx0aGlzLm8sdGhpcy5zKTt0aGlzLm9uZGF0YSgkKGUsdCx0aGlzLnMuYiksdGhpcy5kKSx0aGlzLm89JChlLHRoaXMucy5iLTMyNzY4KSx0aGlzLnMuYj10aGlzLm8ubGVuZ3RoLHRoaXMucD0kKHRoaXMucCx0aGlzLnMucC84fDApLHRoaXMucy5wJj03O30sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3RoaXMuZShyKSx0aGlzLmModCk7fSxufSgpLGVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yLHpyKFt3cixmdW5jdGlvbigpe3JldHVybiBbTCxKXX1dLHRoaXMsMCxmdW5jdGlvbigpe3ZhciB0PW5ldyBKO29ubWVzc2FnZT1MKHQpO30sNyk7fXJldHVybiBufSgpO2Z1bmN0aW9uIGFuKG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3dyXSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoeHIoZS5kYXRhWzBdLExyKGUuZGF0YVsxXSkpKX0sMSx0KX1mdW5jdGlvbiB4cihuLHIpe3JldHVybiBGcihuLHIpfXZhciBxcj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt0aGlzLmM9Z3IoKSx0aGlzLmw9MCx0aGlzLnY9MSxyci5jYWxsKHRoaXMscix0KTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtyci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMscix0KTt9LG4ucHJvdG90eXBlLnA9ZnVuY3Rpb24ocix0KXt0aGlzLmMucChyKSx0aGlzLmwrPXIubGVuZ3RoO3ZhciBlPXNyKHIsdGhpcy5vLHRoaXMudiYmcm4odGhpcy5vKSx0JiY4LCF0KTt0aGlzLnYmJihfcihlLHRoaXMubyksdGhpcy52PTApLHQmJihGKGUsZS5sZW5ndGgtOCx0aGlzLmMuZCgpKSxGKGUsZS5sZW5ndGgtNCx0aGlzLmwpKSx0aGlzLm9uZGF0YShlLHQpO30sbn0oKSxSbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt6cihbeXIsa24sZnVuY3Rpb24oKXtyZXR1cm4gW0wscnIscXJdfV0sdGhpcyx0bi5jYWxsKHRoaXMscix0KSxmdW5jdGlvbihlKXt2YXIgaT1uZXcgcXIoZS5kYXRhKTtvbm1lc3NhZ2U9TChpKTt9LDgpO31yZXR1cm4gbn0oKTtmdW5jdGlvbiBxbihuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt5cixrbixmdW5jdGlvbigpe3JldHVybiBbSHJdfV0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKEhyKGUuZGF0YVswXSxlLmRhdGFbMV0pKX0sMix0KX1mdW5jdGlvbiBIcihuLHIpe3J8fChyPXt9KTt2YXIgdD1ncigpLGU9bi5sZW5ndGg7dC5wKG4pO3ZhciBpPXNyKG4scixybihyKSw4KSxhPWkubGVuZ3RoO3JldHVybiBfcihpLHIpLEYoaSxhLTgsdC5kKCkpLEYoaSxhLTQsZSksaX12YXIgV3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMudj0xLEouY2FsbCh0aGlzLHIpO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKEoucHJvdG90eXBlLmUuY2FsbCh0aGlzLHIpLHRoaXMudil7dmFyIGU9dGhpcy5wLmxlbmd0aD4zP2JyKHRoaXMucCk6NDtpZihlPj10aGlzLnAubGVuZ3RoJiYhdClyZXR1cm47dGhpcy5wPXRoaXMucC5zdWJhcnJheShlKSx0aGlzLnY9MDt9aWYodCl7aWYodGhpcy5wLmxlbmd0aDw4KXRocm93IFwiaW52YWxpZCBnemlwIHN0cmVhbVwiO3RoaXMucD10aGlzLnAuc3ViYXJyYXkoMCwtOCk7fUoucHJvdG90eXBlLmMuY2FsbCh0aGlzLHQpO30sbn0oKSxIbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cix6cihbd3IsQm4sZnVuY3Rpb24oKXtyZXR1cm4gW0wsSixXcl19XSx0aGlzLDAsZnVuY3Rpb24oKXt2YXIgdD1uZXcgV3I7b25tZXNzYWdlPUwodCk7fSw5KTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gV24obixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbd3IsQm4sZnVuY3Rpb24oKXtyZXR1cm4gW1lyXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBhcihZcihlLmRhdGFbMF0pKX0sMyx0KX1mdW5jdGlvbiBZcihuLHIpe3JldHVybiBGcihuLnN1YmFycmF5KGJyKG4pLC04KSxyfHxuZXcgQShHbihuKSkpfXZhciBvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt0aGlzLmM9JHIoKSx0aGlzLnY9MSxyci5jYWxsKHRoaXMscix0KTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtyci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMscix0KTt9LG4ucHJvdG90eXBlLnA9ZnVuY3Rpb24ocix0KXt0aGlzLmMucChyKTt2YXIgZT1zcihyLHRoaXMubyx0aGlzLnYmJjIsdCYmNCwhdCk7dGhpcy52JiYobm4oZSx0aGlzLm8pLHRoaXMudj0wKSx0JiZGKGUsZS5sZW5ndGgtNCx0aGlzLmMuZCgpKSx0aGlzLm9uZGF0YShlLHQpO30sbn0oKSxudD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt6cihbeXIsVG4sZnVuY3Rpb24oKXtyZXR1cm4gW0wscnIsb25dfV0sdGhpcyx0bi5jYWxsKHRoaXMscix0KSxmdW5jdGlvbihlKXt2YXIgaT1uZXcgb24oZS5kYXRhKTtvbm1lc3NhZ2U9TChpKTt9LDEwKTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gdHQobixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbeXIsVG4sZnVuY3Rpb24oKXtyZXR1cm4gW2ZuXX1dLGZ1bmN0aW9uKGUpe3JldHVybiBhcihmbihlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDQsdCl9ZnVuY3Rpb24gZm4obixyKXtyfHwocj17fSk7dmFyIHQ9JHIoKTt0LnAobik7dmFyIGU9c3IobixyLDIsNCk7cmV0dXJuIG5uKGUsciksRihlLGUubGVuZ3RoLTQsdC5kKCkpLGV9dmFyIGpyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLnY9MSxKLmNhbGwodGhpcyxyKTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZihKLnByb3RvdHlwZS5lLmNhbGwodGhpcyxyKSx0aGlzLnYpe2lmKHRoaXMucC5sZW5ndGg8MiYmIXQpcmV0dXJuO3RoaXMucD10aGlzLnAuc3ViYXJyYXkoMiksdGhpcy52PTA7fWlmKHQpe2lmKHRoaXMucC5sZW5ndGg8NCl0aHJvdyBcImludmFsaWQgemxpYiBzdHJlYW1cIjt0aGlzLnA9dGhpcy5wLnN1YmFycmF5KDAsLTQpO31KLnByb3RvdHlwZS5jLmNhbGwodGhpcyx0KTt9LG59KCksWW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXIsenIoW3dyLEluLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLEosanJdfV0sdGhpcywwLGZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGpyO29ubWVzc2FnZT1MKHQpO30sMTEpO31yZXR1cm4gbn0oKTtmdW5jdGlvbiBqbihuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt3cixJbixmdW5jdGlvbigpe3JldHVybiBbSnJdfV0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKEpyKGUuZGF0YVswXSxMcihlLmRhdGFbMV0pKSl9LDUsdCl9ZnVuY3Rpb24gSnIobixyKXtyZXR1cm4gRnIoKE9uKG4pLG4uc3ViYXJyYXkoMiwtNCkpLHIpfXZhciBKbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5HPVdyLHRoaXMuST1KLHRoaXMuWj1qcix0aGlzLm9uZGF0YT1yO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIHN0cmVhbSBoYW5kbGVyXCI7aWYodGhpcy5zKXRoaXMucy5wdXNoKHIsdCk7ZWxzZSB7aWYodGhpcy5wJiZ0aGlzLnAubGVuZ3RoKXt2YXIgZT1uZXcgQSh0aGlzLnAubGVuZ3RoK3IubGVuZ3RoKTtlLnNldCh0aGlzLnApLGUuc2V0KHIsdGhpcy5wLmxlbmd0aCk7fWVsc2UgdGhpcy5wPXI7aWYodGhpcy5wLmxlbmd0aD4yKXt2YXIgaT10aGlzLGE9ZnVuY3Rpb24oKXtpLm9uZGF0YS5hcHBseShpLGFyZ3VtZW50cyk7fTt0aGlzLnM9dGhpcy5wWzBdPT0zMSYmdGhpcy5wWzFdPT0xMzkmJnRoaXMucFsyXT09OD9uZXcgdGhpcy5HKGEpOih0aGlzLnBbMF0mMTUpIT04fHx0aGlzLnBbMF0+PjQ+N3x8KHRoaXMucFswXTw8OHx0aGlzLnBbMV0pJTMxP25ldyB0aGlzLkkoYSk6bmV3IHRoaXMuWihhKSx0aGlzLnMucHVzaCh0aGlzLnAsdCksdGhpcy5wPW51bGw7fX19LG59KCksZXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMuRz1Ibix0aGlzLkk9ZW4sdGhpcy5aPVluLHRoaXMub25kYXRhPXI7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7Sm4ucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLHIsdCk7fSxufSgpO2Z1bmN0aW9uIGl0KG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBuWzBdPT0zMSYmblsxXT09MTM5JiZuWzJdPT04P1duKG4scix0KTooblswXSYxNSkhPTh8fG5bMF0+PjQ+N3x8KG5bMF08PDh8blsxXSklMzE/YW4obixyLHQpOmpuKG4scix0KX1mdW5jdGlvbiBhdChuLHIpe3JldHVybiBuWzBdPT0zMSYmblsxXT09MTM5JiZuWzJdPT04P1lyKG4scik6KG5bMF0mMTUpIT04fHxuWzBdPj40Pjd8fChuWzBdPDw4fG5bMV0pJTMxP3hyKG4scik6SnIobixyKX12YXIgc249ZnVuY3Rpb24obixyLHQsZSl7Zm9yKHZhciBpIGluIG4pe3ZhciBhPW5baV0sbz1yK2k7YSBpbnN0YW5jZW9mIEE/dFtvXT1bYSxlXTpBcnJheS5pc0FycmF5KGEpP3Rbb109W2FbMF0sWnIoZSxhWzFdKV06c24oYSxvK1wiL1wiLHQsZSk7fX0sS249dHlwZW9mIFRleHRFbmNvZGVyIT1cInVuZGVmaW5lZFwiJiZuZXcgVGV4dEVuY29kZXIsaG49dHlwZW9mIFRleHREZWNvZGVyIT1cInVuZGVmaW5lZFwiJiZuZXcgVGV4dERlY29kZXIsTm49MDt0cnl7aG4uZGVjb2RlKGVyLHtzdHJlYW06ITB9KSxObj0xO31jYXRjaChuKXt9dmFyIFFuPWZ1bmN0aW9uKG4pe2Zvcih2YXIgcj1cIlwiLHQ9MDs7KXt2YXIgZT1uW3QrK10saT0oZT4xMjcpKyhlPjIyMykrKGU+MjM5KTtpZih0K2k+bi5sZW5ndGgpcmV0dXJuIFtyLCQobix0LTEpXTtpP2k9PTM/KGU9KChlJjE1KTw8MTh8KG5bdCsrXSY2Myk8PDEyfChuW3QrK10mNjMpPDw2fG5bdCsrXSY2MyktNjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxlPj4xMCw1NjMyMHxlJjEwMjMpKTppJjE/cis9U3RyaW5nLmZyb21DaGFyQ29kZSgoZSYzMSk8PDZ8blt0KytdJjYzKTpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChlJjE1KTw8MTJ8KG5bdCsrXSY2Myk8PDZ8blt0KytdJjYzKTpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGUpO319LG90PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yLE5uP3RoaXMudD1uZXcgVGV4dERlY29kZXI6dGhpcy5wPWVyO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIGNhbGxiYWNrXCI7aWYodHx8KHQ9ITEpLHRoaXMudClyZXR1cm4gdGhpcy5vbmRhdGEodGhpcy50LmRlY29kZShyLHtzdHJlYW06IXR9KSx0KTt2YXIgZT1uZXcgQSh0aGlzLnAubGVuZ3RoK3IubGVuZ3RoKTtlLnNldCh0aGlzLnApLGUuc2V0KHIsdGhpcy5wLmxlbmd0aCk7dmFyIGk9UW4oZSksYT1pWzBdLG89aVsxXTtpZih0JiZvLmxlbmd0aCl0aHJvdyBcImludmFsaWQgdXRmLTggZGF0YVwiO3RoaXMucD1vLHRoaXMub25kYXRhKGEsdCk7fSxufSgpLGZ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIGNhbGxiYWNrXCI7dGhpcy5vbmRhdGEob3IociksdHx8ITEpO30sbn0oKTtmdW5jdGlvbiBvcihuLHIpe2lmKHIpe2Zvcih2YXIgdD1uZXcgQShuLmxlbmd0aCksZT0wO2U8bi5sZW5ndGg7KytlKXRbZV09bi5jaGFyQ29kZUF0KGUpO3JldHVybiB0fWlmKEtuKXJldHVybiBLbi5lbmNvZGUobik7Zm9yKHZhciBpPW4ubGVuZ3RoLGE9bmV3IEEobi5sZW5ndGgrKG4ubGVuZ3RoPj4xKSksbz0wLGY9ZnVuY3Rpb24odSl7YVtvKytdPXU7fSxlPTA7ZTxpOysrZSl7aWYobys1PmEubGVuZ3RoKXt2YXIgaD1uZXcgQShvKzgrKGktZTw8MSkpO2guc2V0KGEpLGE9aDt9dmFyIHM9bi5jaGFyQ29kZUF0KGUpO3M8MTI4fHxyP2Yocyk6czwyMDQ4PyhmKDE5MnxzPj4+NiksZigxMjh8cyY2MykpOnM+NTUyOTUmJnM8NTczNDQ/KHM9NjU1MzYrKHMmMTAyMzw8MTApfG4uY2hhckNvZGVBdCgrK2UpJjEwMjMsZigyNDB8cz4+PjE4KSxmKDEyOHxzPj4+MTImNjMpLGYoMTI4fHM+Pj42JjYzKSxmKDEyOHxzJjYzKSk6KGYoMjI0fHM+Pj4xMiksZigxMjh8cz4+PjYmNjMpLGYoMTI4fHMmNjMpKTt9cmV0dXJuICQoYSwwLG8pfWZ1bmN0aW9uIHVuKG4scil7aWYocil7Zm9yKHZhciB0PVwiXCIsZT0wO2U8bi5sZW5ndGg7ZSs9MTYzODQpdCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG4uc3ViYXJyYXkoZSxlKzE2Mzg0KSk7cmV0dXJuIHR9ZWxzZSB7aWYoaG4pcmV0dXJuIGhuLmRlY29kZShuKTt2YXIgaT1RbihuKSxhPWlbMF0sbz1pWzFdO2lmKG8ubGVuZ3RoKXRocm93IFwiaW52YWxpZCB1dGYtOCBkYXRhXCI7cmV0dXJuIGF9fXZhciBWbj1mdW5jdGlvbihuKXtyZXR1cm4gbj09MT8zOm48Nj8yOm49PTk/MTowfSxYbj1mdW5jdGlvbihuLHIpe3JldHVybiByKzMwK1kobixyKzI2KStZKG4scisyOCl9LCRuPWZ1bmN0aW9uKG4scix0KXt2YXIgZT1ZKG4scisyOCksaT11bihuLnN1YmFycmF5KHIrNDYscis0NitlKSwhKFkobixyKzgpJjIwNDgpKSxhPXIrNDYrZSxvPVAobixyKzIwKSxmPXQmJm89PTQyOTQ5NjcyOTU/TG4obixhKTpbbyxQKG4scisyNCksUChuLHIrNDIpXSxoPWZbMF0scz1mWzFdLHU9ZlsyXTtyZXR1cm4gW1kobixyKzEwKSxoLHMsaSxhK1kobixyKzMwKStZKG4sciszMiksdV19LExuPWZ1bmN0aW9uKG4scil7Zm9yKDtZKG4scikhPTE7cis9NCtZKG4scisyKSk7cmV0dXJuIFtkcihuLHIrMTIpLGRyKG4scis0KSxkcihuLHIrMjApXX0sZnI9ZnVuY3Rpb24obil7dmFyIHI9MDtpZihuKWZvcih2YXIgdCBpbiBuKXt2YXIgZT1uW3RdLmxlbmd0aDtpZihlPjY1NTM1KXRocm93IFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIjtyKz1lKzQ7fXJldHVybiByfSxBcj1mdW5jdGlvbihuLHIsdCxlLGksYSxvLGYpe3ZhciBoPWUubGVuZ3RoLHM9dC5leHRyYSx1PWYmJmYubGVuZ3RoLGw9ZnIocyk7RihuLHIsbyE9bnVsbD8zMzYzOTI0ODo2NzMyNDc1Mikscis9NCxvIT1udWxsJiYobltyKytdPTIwLG5bcisrXT10Lm9zKSxuW3JdPTIwLHIrPTIsbltyKytdPXQuZmxhZzw8MXwoYT09bnVsbCYmOCksbltyKytdPWkmJjgsbltyKytdPXQuY29tcHJlc3Npb24mMjU1LG5bcisrXT10LmNvbXByZXNzaW9uPj44O3ZhciBwPW5ldyBEYXRlKHQubXRpbWU9PW51bGw/RGF0ZS5ub3coKTp0Lm10aW1lKSx5PXAuZ2V0RnVsbFllYXIoKS0xOTgwO2lmKHk8MHx8eT4xMTkpdGhyb3cgXCJkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTlcIjtpZihGKG4sciwoeTw8MjQpKjJ8cC5nZXRNb250aCgpKzE8PDIxfHAuZ2V0RGF0ZSgpPDwxNnxwLmdldEhvdXJzKCk8PDExfHAuZ2V0TWludXRlcygpPDw1fHAuZ2V0U2Vjb25kcygpPj4+MSkscis9NCxhIT1udWxsJiYoRihuLHIsdC5jcmMpLEYobixyKzQsYSksRihuLHIrOCx0LnNpemUpKSxGKG4scisxMixoKSxGKG4scisxNCxsKSxyKz0xNixvIT1udWxsJiYoRihuLHIsdSksRihuLHIrNix0LmF0dHJzKSxGKG4scisxMCxvKSxyKz0xNCksbi5zZXQoZSxyKSxyKz1oLGwpZm9yKHZhciBjIGluIHMpe3ZhciBnPXNbY10sdz1nLmxlbmd0aDtGKG4sciwrYyksRihuLHIrMix3KSxuLnNldChnLHIrNCkscis9NCt3O31yZXR1cm4gdSYmKG4uc2V0KGYscikscis9dSkscn0sbG49ZnVuY3Rpb24obixyLHQsZSxpKXtGKG4sciwxMDEwMTAyNTYpLEYobixyKzgsdCksRihuLHIrMTAsdCksRihuLHIrMTIsZSksRihuLHIrMTYsaSk7fSxCcj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5maWxlbmFtZT1yLHRoaXMuYz1ncigpLHRoaXMuc2l6ZT0wLHRoaXMuY29tcHJlc3Npb249MDt9cmV0dXJuIG4ucHJvdG90eXBlLnByb2Nlc3M9ZnVuY3Rpb24ocix0KXt0aGlzLm9uZGF0YShudWxsLHIsdCk7fSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gY2FsbGJhY2sgLSBhZGQgdG8gWklQIGFyY2hpdmUgYmVmb3JlIHB1c2hpbmdcIjt0aGlzLmMucChyKSx0aGlzLnNpemUrPXIubGVuZ3RoLHQmJih0aGlzLmNyYz10aGlzLmMuZCgpKSx0aGlzLnByb2Nlc3Mocix0fHwhMSk7fSxufSgpLHN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3ZhciBlPXRoaXM7dHx8KHQ9e30pLEJyLmNhbGwodGhpcyxyKSx0aGlzLmQ9bmV3IHJyKHQsZnVuY3Rpb24oaSxhKXtlLm9uZGF0YShudWxsLGksYSk7fSksdGhpcy5jb21wcmVzc2lvbj04LHRoaXMuZmxhZz1Wbih0LmxldmVsKTt9cmV0dXJuIG4ucHJvdG90eXBlLnByb2Nlc3M9ZnVuY3Rpb24ocix0KXt0cnl7dGhpcy5kLnB1c2gocix0KTt9Y2F0Y2goZSl7dGhpcy5vbmRhdGEoZSxudWxsLHQpO319LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtCci5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMscix0KTt9LG59KCksaHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7dmFyIGU9dGhpczt0fHwodD17fSksQnIuY2FsbCh0aGlzLHIpLHRoaXMuZD1uZXcgRW4odCxmdW5jdGlvbihpLGEsbyl7ZS5vbmRhdGEoaSxhLG8pO30pLHRoaXMuY29tcHJlc3Npb249OCx0aGlzLmZsYWc9Vm4odC5sZXZlbCksdGhpcy50ZXJtaW5hdGU9dGhpcy5kLnRlcm1pbmF0ZTt9cmV0dXJuIG4ucHJvdG90eXBlLnByb2Nlc3M9ZnVuY3Rpb24ocix0KXt0aGlzLmQucHVzaChyLHQpO30sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe0JyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxyLHQpO30sbn0oKSx1dD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cix0aGlzLnU9W10sdGhpcy5kPTE7fXJldHVybiBuLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24ocil7dmFyIHQ9dGhpcztpZih0aGlzLmQmMil0aHJvdyBcInN0cmVhbSBmaW5pc2hlZFwiO3ZhciBlPW9yKHIuZmlsZW5hbWUpLGk9ZS5sZW5ndGgsYT1yLmNvbW1lbnQsbz1hJiZvcihhKSxmPWkhPXIuZmlsZW5hbWUubGVuZ3RofHxvJiZhLmxlbmd0aCE9by5sZW5ndGgsaD1pK2ZyKHIuZXh0cmEpKzMwO2lmKGk+NjU1MzUpdGhyb3cgXCJmaWxlbmFtZSB0b28gbG9uZ1wiO3ZhciBzPW5ldyBBKGgpO0FyKHMsMCxyLGUsZik7dmFyIHU9W3NdLGw9ZnVuY3Rpb24oKXtmb3IodmFyIHc9MCxNPXU7dzxNLmxlbmd0aDt3Kyspe3ZhciB6PU1bd107dC5vbmRhdGEobnVsbCx6LCExKTt9dT1bXTt9LHA9dGhpcy5kO3RoaXMuZD0wO3ZhciB5PXRoaXMudS5sZW5ndGgsYz1acihyLHtmOmUsdTpmLG8sdDpmdW5jdGlvbigpe3IudGVybWluYXRlJiZyLnRlcm1pbmF0ZSgpO30scjpmdW5jdGlvbigpe2lmKGwoKSxwKXt2YXIgdz10LnVbeSsxXTt3P3cucigpOnQuZD0xO31wPTE7fX0pLGc9MDtyLm9uZGF0YT1mdW5jdGlvbih3LE0seil7aWYodyl0Lm9uZGF0YSh3LE0seiksdC50ZXJtaW5hdGUoKTtlbHNlIGlmKGcrPU0ubGVuZ3RoLHUucHVzaChNKSx6KXt2YXIgbT1uZXcgQSgxNik7RihtLDAsMTM0Njk1NzYwKSxGKG0sNCxyLmNyYyksRihtLDgsZyksRihtLDEyLHIuc2l6ZSksdS5wdXNoKG0pLGMuYz1nLGMuYj1oK2crMTYsYy5jcmM9ci5jcmMsYy5zaXplPXIuc2l6ZSxwJiZjLnIoKSxwPTE7fWVsc2UgcCYmbCgpO30sdGhpcy51LnB1c2goYyk7fSxuLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24oKXt2YXIgcj10aGlzO2lmKHRoaXMuZCYyKXRocm93IHRoaXMuZCYxP1wic3RyZWFtIGZpbmlzaGluZ1wiOlwic3RyZWFtIGZpbmlzaGVkXCI7dGhpcy5kP3RoaXMuZSgpOnRoaXMudS5wdXNoKHtyOmZ1bmN0aW9uKCl7aWYoIShyLmQmMSkpcmV0dXJuO3IudS5zcGxpY2UoLTEsMSksci5lKCk7fSx0OmZ1bmN0aW9uKCl7fX0pLHRoaXMuZD0zO30sbi5wcm90b3R5cGUuZT1mdW5jdGlvbigpe2Zvcih2YXIgcj0wLHQ9MCxlPTAsaT0wLGE9dGhpcy51O2k8YS5sZW5ndGg7aSsrKXt2YXIgbz1hW2ldO2UrPTQ2K28uZi5sZW5ndGgrZnIoby5leHRyYSkrKG8ubz9vLm8ubGVuZ3RoOjApO31mb3IodmFyIGY9bmV3IEEoZSsyMiksaD0wLHM9dGhpcy51O2g8cy5sZW5ndGg7aCsrKXt2YXIgbz1zW2hdO0FyKGYscixvLG8uZixvLnUsby5jLHQsby5vKSxyKz00NitvLmYubGVuZ3RoK2ZyKG8uZXh0cmEpKyhvLm8/by5vLmxlbmd0aDowKSx0Kz1vLmI7fWxuKGYscix0aGlzLnUubGVuZ3RoLGUsdCksdGhpcy5vbmRhdGEobnVsbCxmLCEwKSx0aGlzLmQ9Mjt9LG4ucHJvdG90eXBlLnRlcm1pbmF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgcj0wLHQ9dGhpcy51O3I8dC5sZW5ndGg7cisrKXt2YXIgZT10W3JdO2UudCgpO310aGlzLmQ9Mjt9LG59KCk7ZnVuY3Rpb24gbHQobixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7dmFyIGU9e307c24obixcIlwiLGUscik7dmFyIGk9T2JqZWN0LmtleXMoZSksYT1pLmxlbmd0aCxvPTAsZj0wLGg9YSxzPW5ldyBBcnJheShhKSx1PVtdLGw9ZnVuY3Rpb24oKXtmb3IodmFyIGc9MDtnPHUubGVuZ3RoOysrZyl1W2ddKCk7fSxwPWZ1bmN0aW9uKCl7dmFyIGc9bmV3IEEoZisyMiksdz1vLE09Zi1vO2Y9MDtmb3IodmFyIHo9MDt6PGg7Kyt6KXt2YXIgbT1zW3pdO3RyeXt2YXIgRD1tLmMubGVuZ3RoO0FyKGcsZixtLG0uZixtLnUsRCk7dmFyIEM9MzArbS5mLmxlbmd0aCtmcihtLmV4dHJhKSxVPWYrQztnLnNldChtLmMsVSksQXIoZyxvLG0sbS5mLG0udSxELGYsbS5tKSxvKz0xNitDKyhtLm0/bS5tLmxlbmd0aDowKSxmPVUrRDt9Y2F0Y2goeCl7cmV0dXJuIHQoeCxudWxsKX19bG4oZyxvLHMubGVuZ3RoLE0sdyksdChudWxsLGcpO307YXx8cCgpO2Zvcih2YXIgeT1mdW5jdGlvbihnKXt2YXIgdz1pW2ddLE09ZVt3XSx6PU1bMF0sbT1NWzFdLEQ9Z3IoKSxDPXoubGVuZ3RoO0QucCh6KTt2YXIgVT1vcih3KSx4PVUubGVuZ3RoLHY9bS5jb21tZW50LEU9diYmb3IodiksUz1FJiZFLmxlbmd0aCxLPWZyKG0uZXh0cmEpLEk9bS5sZXZlbD09MD8wOjgsWj1mdW5jdGlvbihCLEcpe2lmKEIpbCgpLHQoQixudWxsKTtlbHNlIHt2YXIgaz1HLmxlbmd0aDtzW2ddPVpyKG0se3NpemU6QyxjcmM6RC5kKCksYzpHLGY6VSxtOkUsdTp4IT13Lmxlbmd0aHx8RSYmdi5sZW5ndGghPVMsY29tcHJlc3Npb246SX0pLG8rPTMwK3grSytrLGYrPTc2KzIqKHgrSykrKFN8fDApK2ssLS1hfHxwKCk7fX07aWYoeD42NTUzNSYmWihcImZpbGVuYW1lIHRvbyBsb25nXCIsbnVsbCksIUkpWihudWxsLHopO2Vsc2UgaWYoQzwxNmU0KXRyeXtaKG51bGwsa3IoeixtKSk7fWNhdGNoKEIpe1ooQixudWxsKTt9ZWxzZSB1LnB1c2goUG4oeixtLFopKTt9LGM9MDtjPGg7KytjKXkoYyk7cmV0dXJuIGx9ZnVuY3Rpb24gdnQobixyKXtyfHwocj17fSk7dmFyIHQ9e30sZT1bXTtzbihuLFwiXCIsdCxyKTt2YXIgaT0wLGE9MDtmb3IodmFyIG8gaW4gdCl7dmFyIGY9dFtvXSxoPWZbMF0scz1mWzFdLHU9cy5sZXZlbD09MD8wOjgsbD1vcihvKSxwPWwubGVuZ3RoLHk9cy5jb21tZW50LGM9eSYmb3IoeSksZz1jJiZjLmxlbmd0aCx3PWZyKHMuZXh0cmEpO2lmKHA+NjU1MzUpdGhyb3cgXCJmaWxlbmFtZSB0b28gbG9uZ1wiO3ZhciBNPXU/a3IoaCxzKTpoLHo9TS5sZW5ndGgsbT1ncigpO20ucChoKSxlLnB1c2goWnIocyx7c2l6ZTpoLmxlbmd0aCxjcmM6bS5kKCksYzpNLGY6bCxtOmMsdTpwIT1vLmxlbmd0aHx8YyYmeS5sZW5ndGghPWcsbzppLGNvbXByZXNzaW9uOnV9KSksaSs9MzArcCt3K3osYSs9NzYrMioocCt3KSsoZ3x8MCkrejt9Zm9yKHZhciBEPW5ldyBBKGErMjIpLEM9aSxVPWEtaSx4PTA7eDxlLmxlbmd0aDsrK3gpe3ZhciBsPWVbeF07QXIoRCxsLm8sbCxsLmYsbC51LGwuYy5sZW5ndGgpO3ZhciB2PTMwK2wuZi5sZW5ndGgrZnIobC5leHRyYSk7RC5zZXQobC5jLGwubyt2KSxBcihELGksbCxsLmYsbC51LGwuYy5sZW5ndGgsbC5vLGwubSksaSs9MTYrdisobC5tP2wubS5sZW5ndGg6MCk7fXJldHVybiBsbihELGksZS5sZW5ndGgsVSxDKSxEfXZhciBkbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oKXt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXt0aGlzLm9uZGF0YShudWxsLHIsdCk7fSxuLmNvbXByZXNzaW9uPTAsbn0oKSxjdD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oKXt2YXIgcj10aGlzO3RoaXMuaT1uZXcgSihmdW5jdGlvbih0LGUpe3Iub25kYXRhKG51bGwsdCxlKTt9KTt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXt0cnl7dGhpcy5pLnB1c2gocix0KTt9Y2F0Y2goZSl7dGhpcy5vbmRhdGEoZSxyLHQpO319LG4uY29tcHJlc3Npb249OCxufSgpLHB0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3ZhciBlPXRoaXM7dDwzMmU0P3RoaXMuaT1uZXcgSihmdW5jdGlvbihpLGEpe2Uub25kYXRhKG51bGwsaSxhKTt9KToodGhpcy5pPW5ldyBlbihmdW5jdGlvbihpLGEsbyl7ZS5vbmRhdGEoaSxhLG8pO30pLHRoaXMudGVybWluYXRlPXRoaXMuaS50ZXJtaW5hdGUpO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3RoaXMuaS50ZXJtaW5hdGUmJihyPSQociwwKSksdGhpcy5pLnB1c2gocix0KTt9LG4uY29tcHJlc3Npb249OCxufSgpLGd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZmlsZT1yLHRoaXMuaz1bXSx0aGlzLm89ezA6ZG59LHRoaXMucD1lcjt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXt2YXIgZT10aGlzO2lmKCF0aGlzLm9uZmlsZSl0aHJvdyBcIm5vIGNhbGxiYWNrXCI7aWYodGhpcy5jPjApe3ZhciBpPU1hdGgubWluKHRoaXMuYyxyLmxlbmd0aCksYT1yLnN1YmFycmF5KDAsaSk7aWYodGhpcy5jLT1pLHRoaXMuZD90aGlzLmQucHVzaChhLCF0aGlzLmMpOnRoaXMua1swXS5wdXNoKGEpLHI9ci5zdWJhcnJheShpKSxyLmxlbmd0aClyZXR1cm4gdGhpcy5wdXNoKHIsdCl9ZWxzZSB7dmFyIG89MCxmPTAsaD12b2lkIDAscz12b2lkIDA7dGhpcy5wLmxlbmd0aD9yLmxlbmd0aD8ocz1uZXcgQSh0aGlzLnAubGVuZ3RoK3IubGVuZ3RoKSxzLnNldCh0aGlzLnApLHMuc2V0KHIsdGhpcy5wLmxlbmd0aCkpOnM9dGhpcy5wOnM9cjtmb3IodmFyIHU9cy5sZW5ndGgsbD10aGlzLmMscD1sJiZ0aGlzLmQseT1mdW5jdGlvbigpe3ZhciBNLHo9UChzLGYpO2lmKHo9PTY3MzI0NzUyKXtvPTEsaD1mLGMuZD1udWxsLGMuYz0wO3ZhciBtPVkocyxmKzYpLEQ9WShzLGYrOCksQz1tJjIwNDgsVT1tJjgseD1ZKHMsZisyNiksdj1ZKHMsZisyOCk7aWYodT5mKzMwK3grdil7dmFyIEU9W107Yy5rLnVuc2hpZnQoRSksbz0yO3ZhciBTPVAocyxmKzE4KSxLPVAocyxmKzIyKSxJPXVuKHMuc3ViYXJyYXkoZiszMCxmKz0zMCt4KSwhQyk7Uz09NDI5NDk2NzI5NT8oTT1VP1stMl06TG4ocyxmKSxTPU1bMF0sSz1NWzFdKTpVJiYoUz0tMSksZis9dixjLmM9Uzt2YXIgWj17bmFtZTpJLGNvbXByZXNzaW9uOkQsc3RhcnQ6ZnVuY3Rpb24oKXtpZighWi5vbmRhdGEpdGhyb3cgXCJubyBjYWxsYmFja1wiO2lmKCFTKVoub25kYXRhKG51bGwsZXIsITApO2Vsc2Uge3ZhciBCPWUub1tEXTtpZighQil0aHJvdyBcInVua25vd24gY29tcHJlc3Npb24gdHlwZSBcIitEO3ZhciBHPVM8MD9uZXcgQihJKTpuZXcgQihJLFMsSyk7Ry5vbmRhdGE9ZnVuY3Rpb24oTixRLFcpe1oub25kYXRhKE4sUSxXKTt9O2Zvcih2YXIgaz0wLE89RTtrPE8ubGVuZ3RoO2srKyl7dmFyIEg9T1trXTtHLnB1c2goSCwhMSk7fWUua1swXT09RT9lLmQ9RzpHLnB1c2goZXIsITApO319LHRlcm1pbmF0ZTpmdW5jdGlvbigpe2Uua1swXT09RSYmZS5kLnRlcm1pbmF0ZSYmZS5kLnRlcm1pbmF0ZSgpO319O1M+PTAmJihaLnNpemU9UyxaLm9yaWdpbmFsU2l6ZT1LKSxjLm9uZmlsZShaKTt9cmV0dXJuIFwiYnJlYWtcIn1lbHNlIGlmKGwpe2lmKHo9PTEzNDY5NTc2MClyZXR1cm4gaD1mKz0xMisobD09LTImJjgpLG89MixjLmM9MCxcImJyZWFrXCI7aWYoej09MzM2MzkyNDgpcmV0dXJuIGg9Zi09NCxvPTIsYy5jPTAsXCJicmVha1wifX0sYz10aGlzO2Y8dS00OysrZil7dmFyIGc9eSgpO2lmKGc9PT1cImJyZWFrXCIpYnJlYWt9aWYodGhpcy5wPWVyLGw8MCl7dmFyIHc9bz9zLnN1YmFycmF5KDAsaC0xMi0obD09LTImJjgpLShQKHMsaC0xNik9PTEzNDY5NTc2MCYmNCkpOnMuc3ViYXJyYXkoMCxmKTtwP3AucHVzaCh3LCEhbyk6dGhpcy5rWysobz09MildLnB1c2godyk7fWlmKG8mMilyZXR1cm4gdGhpcy5wdXNoKHMuc3ViYXJyYXkoZiksdCk7dGhpcy5wPXMuc3ViYXJyYXkoZik7fWlmKHQmJnRoaXMuYyl0aHJvdyBcImludmFsaWQgemlwIGZpbGVcIn0sbi5wcm90b3R5cGUucmVnaXN0ZXI9ZnVuY3Rpb24ocil7dGhpcy5vW3IuY29tcHJlc3Npb25dPXI7fSxufSgpO2Z1bmN0aW9uIHd0KG4scil7aWYodHlwZW9mIHIhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7Zm9yKHZhciB0PVtdLGU9ZnVuY3Rpb24oKXtmb3IodmFyIHA9MDtwPHQubGVuZ3RoOysrcCl0W3BdKCk7fSxpPXt9LGE9bi5sZW5ndGgtMjI7UChuLGEpIT0xMDEwMTAyNTY7LS1hKWlmKCFhfHxuLmxlbmd0aC1hPjY1NTU4KXtyKFwiaW52YWxpZCB6aXAgZmlsZVwiLG51bGwpO3JldHVybn12YXIgbz1ZKG4sYSs4KTtvfHxyKG51bGwse30pO3ZhciBmPW8saD1QKG4sYSsxNikscz1oPT00Mjk0OTY3Mjk1O2lmKHMpe2lmKGE9UChuLGEtMTIpLFAobixhKSE9MTAxMDc1NzkyKXtyKFwiaW52YWxpZCB6aXAgZmlsZVwiLG51bGwpO3JldHVybn1mPW89UChuLGErMzIpLGg9UChuLGErNDgpO31mb3IodmFyIHU9ZnVuY3Rpb24ocCl7dmFyIHk9JG4obixoLHMpLGM9eVswXSxnPXlbMV0sdz15WzJdLE09eVszXSx6PXlbNF0sbT15WzVdLEQ9WG4obixtKTtoPXo7dmFyIEM9ZnVuY3Rpb24oeCx2KXt4PyhlKCkscih4LG51bGwpKTooaVtNXT12LC0tb3x8cihudWxsLGkpKTt9O2lmKCFjKUMobnVsbCwkKG4sRCxEK2cpKTtlbHNlIGlmKGM9PTgpe3ZhciBVPW4uc3ViYXJyYXkoRCxEK2cpO2lmKGc8MzJlNCl0cnl7QyhudWxsLHhyKFUsbmV3IEEodykpKTt9Y2F0Y2goeCl7Qyh4LG51bGwpO31lbHNlIHQucHVzaChhbihVLHtzaXplOnd9LEMpKTt9ZWxzZSBDKFwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlIFwiK2MsbnVsbCk7fSxsPTA7bDxmOysrbCl1KCk7cmV0dXJuIGV9ZnVuY3Rpb24geXQobil7Zm9yKHZhciByPXt9LHQ9bi5sZW5ndGgtMjI7UChuLHQpIT0xMDEwMTAyNTY7LS10KWlmKCF0fHxuLmxlbmd0aC10PjY1NTU4KXRocm93IFwiaW52YWxpZCB6aXAgZmlsZVwiO3ZhciBlPVkobix0KzgpO2lmKCFlKXJldHVybiB7fTt2YXIgaT1QKG4sdCsxNiksYT1pPT00Mjk0OTY3Mjk1O2lmKGEpe2lmKHQ9UChuLHQtMTIpLFAobix0KSE9MTAxMDc1NzkyKXRocm93IFwiaW52YWxpZCB6aXAgZmlsZVwiO2U9UChuLHQrMzIpLGk9UChuLHQrNDgpO31mb3IodmFyIG89MDtvPGU7KytvKXt2YXIgZj0kbihuLGksYSksaD1mWzBdLHM9ZlsxXSx1PWZbMl0sbD1mWzNdLHA9Zls0XSx5PWZbNV0sYz1YbihuLHkpO2lmKGk9cCwhaClyW2xdPSQobixjLGMrcyk7ZWxzZSBpZihoPT04KXJbbF09eHIobi5zdWJhcnJheShjLGMrcyksbmV3IEEodSkpO2Vsc2UgdGhyb3cgXCJ1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgXCIraH1yZXR1cm4gcn12YXIgZmZsYXRlX21vZHVsZV9taW4gPSBudWxsO1xuXG52YXIgZmZsYXRlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEFzeW5jQ29tcHJlc3M6IFJuLFxuXHRBc3luY0RlY29tcHJlc3M6IGV0LFxuXHRBc3luY0RlZmxhdGU6IEVuLFxuXHRBc3luY0d1bnppcDogSG4sXG5cdEFzeW5jR3ppcDogUm4sXG5cdEFzeW5jSW5mbGF0ZTogZW4sXG5cdEFzeW5jVW56aXBJbmZsYXRlOiBwdCxcblx0QXN5bmNVbnpsaWI6IFluLFxuXHRBc3luY1ppcERlZmxhdGU6IGh0LFxuXHRBc3luY1psaWI6IG50LFxuXHRDb21wcmVzczogcXIsXG5cdERlY29kZVVURjg6IG90LFxuXHREZWNvbXByZXNzOiBKbixcblx0RGVmbGF0ZTogcnIsXG5cdEVuY29kZVVURjg6IGZ0LFxuXHRHdW56aXA6IFdyLFxuXHRHemlwOiBxcixcblx0SW5mbGF0ZTogSixcblx0VW56aXA6IGd0LFxuXHRVbnppcEluZmxhdGU6IGN0LFxuXHRVbnppcFBhc3NUaHJvdWdoOiBkbixcblx0VW56bGliOiBqcixcblx0WmlwOiB1dCxcblx0WmlwRGVmbGF0ZTogc3QsXG5cdFppcFBhc3NUaHJvdWdoOiBCcixcblx0WmxpYjogb24sXG5cdGNvbXByZXNzOiBxbixcblx0Y29tcHJlc3NTeW5jOiBIcixcblx0ZGVjb21wcmVzczogaXQsXG5cdGRlY29tcHJlc3NTeW5jOiBhdCxcblx0ZGVmbGF0ZTogUG4sXG5cdGRlZmxhdGVTeW5jOiBrcixcblx0Z3VuemlwOiBXbixcblx0Z3VuemlwU3luYzogWXIsXG5cdGd6aXA6IHFuLFxuXHRnemlwU3luYzogSHIsXG5cdGluZmxhdGU6IGFuLFxuXHRpbmZsYXRlU3luYzogeHIsXG5cdHN0ckZyb21VODogdW4sXG5cdHN0clRvVTg6IG9yLFxuXHR1bnppcDogd3QsXG5cdHVuemlwU3luYzogeXQsXG5cdHVuemxpYjogam4sXG5cdHVuemxpYlN5bmM6IEpyLFxuXHR6aXA6IGx0LFxuXHR6aXBTeW5jOiB2dCxcblx0emxpYjogdHQsXG5cdHpsaWJTeW5jOiBmbixcblx0J2RlZmF1bHQnOiBmZmxhdGVfbW9kdWxlX21pblxufSk7XG5cbi8qKlxuICogTlVSQlMgdXRpbHNcbiAqXG4gKiBTZWUgTlVSQlNDdXJ2ZSBhbmQgTlVSQlNTdXJmYWNlLlxuICoqL1xuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdE5VUkJTIFV0aWxzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBOVVJCU1V0aWxzID0ge1xuXG5cdC8qXG5cdEZpbmRzIGtub3QgdmVjdG9yIHNwYW4uXG5cblx0cCA6IGRlZ3JlZVxuXHR1IDogcGFyYW1ldHJpYyB2YWx1ZVxuXHRVIDoga25vdCB2ZWN0b3JcblxuXHRyZXR1cm5zIHRoZSBzcGFuXG5cdCovXG5cdGZpbmRTcGFuOiBmdW5jdGlvbiAoIHAsIHUsIFUgKSB7XG5cblx0XHR2YXIgbiA9IFUubGVuZ3RoIC0gcCAtIDE7XG5cblx0XHRpZiAoIHUgPj0gVVsgbiBdICkge1xuXG5cdFx0XHRyZXR1cm4gbiAtIDE7XG5cblx0XHR9XG5cblx0XHRpZiAoIHUgPD0gVVsgcCBdICkge1xuXG5cdFx0XHRyZXR1cm4gcDtcblxuXHRcdH1cblxuXHRcdHZhciBsb3cgPSBwO1xuXHRcdHZhciBoaWdoID0gbjtcblx0XHR2YXIgbWlkID0gTWF0aC5mbG9vciggKCBsb3cgKyBoaWdoICkgLyAyICk7XG5cblx0XHR3aGlsZSAoIHUgPCBVWyBtaWQgXSB8fCB1ID49IFVbIG1pZCArIDEgXSApIHtcblxuXHRcdFx0aWYgKCB1IDwgVVsgbWlkIF0gKSB7XG5cblx0XHRcdFx0aGlnaCA9IG1pZDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsb3cgPSBtaWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0bWlkID0gTWF0aC5mbG9vciggKCBsb3cgKyBoaWdoICkgLyAyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWlkO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgYmFzaXMgZnVuY3Rpb25zLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgNzAsIGFsZ29yaXRobSBBMi4yXG5cblx0c3BhbiA6IHNwYW4gaW4gd2hpY2ggdSBsaWVzXG5cdHUgICAgOiBwYXJhbWV0cmljIHBvaW50XG5cdHAgICAgOiBkZWdyZWVcblx0VSAgICA6IGtub3QgdmVjdG9yXG5cblx0cmV0dXJucyBhcnJheVtwKzFdIHdpdGggYmFzaXMgZnVuY3Rpb25zIHZhbHVlcy5cblx0Ki9cblx0Y2FsY0Jhc2lzRnVuY3Rpb25zOiBmdW5jdGlvbiAoIHNwYW4sIHUsIHAsIFUgKSB7XG5cblx0XHR2YXIgTiA9IFtdO1xuXHRcdHZhciBsZWZ0ID0gW107XG5cdFx0dmFyIHJpZ2h0ID0gW107XG5cdFx0TlsgMCBdID0gMS4wO1xuXG5cdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdGxlZnRbIGogXSA9IHUgLSBVWyBzcGFuICsgMSAtIGogXTtcblx0XHRcdHJpZ2h0WyBqIF0gPSBVWyBzcGFuICsgaiBdIC0gdTtcblxuXHRcdFx0dmFyIHNhdmVkID0gMC4wO1xuXG5cdFx0XHRmb3IgKCB2YXIgciA9IDA7IHIgPCBqOyArKyByICkge1xuXG5cdFx0XHRcdHZhciBydiA9IHJpZ2h0WyByICsgMSBdO1xuXHRcdFx0XHR2YXIgbHYgPSBsZWZ0WyBqIC0gciBdO1xuXHRcdFx0XHR2YXIgdGVtcCA9IE5bIHIgXSAvICggcnYgKyBsdiApO1xuXHRcdFx0XHROWyByIF0gPSBzYXZlZCArIHJ2ICogdGVtcDtcblx0XHRcdFx0c2F2ZWQgPSBsdiAqIHRlbXA7XG5cblx0XHRcdCB9XG5cblx0XHRcdCBOWyBqIF0gPSBzYXZlZDtcblxuXHRcdCB9XG5cblx0XHQgcmV0dXJuIE47XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBCLVNwbGluZSBjdXJ2ZSBwb2ludHMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA4MiwgYWxnb3JpdGhtIEEzLjEuXG5cblx0cCA6IGRlZ3JlZSBvZiBCLVNwbGluZVxuXHRVIDoga25vdCB2ZWN0b3Jcblx0UCA6IGNvbnRyb2wgcG9pbnRzICh4LCB5LCB6LCB3KVxuXHR1IDogcGFyYW1ldHJpYyBwb2ludFxuXG5cdHJldHVybnMgcG9pbnQgZm9yIGdpdmVuIHVcblx0Ki9cblx0Y2FsY0JTcGxpbmVQb2ludDogZnVuY3Rpb24gKCBwLCBVLCBQLCB1ICkge1xuXG5cdFx0dmFyIHNwYW4gPSB0aGlzLmZpbmRTcGFuKCBwLCB1LCBVICk7XG5cdFx0dmFyIE4gPSB0aGlzLmNhbGNCYXNpc0Z1bmN0aW9ucyggc3BhbiwgdSwgcCwgVSApO1xuXHRcdHZhciBDID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBQWyBzcGFuIC0gcCArIGogXTtcblx0XHRcdHZhciBOaiA9IE5bIGogXTtcblx0XHRcdHZhciB3TmogPSBwb2ludC53ICogTmo7XG5cdFx0XHRDLnggKz0gcG9pbnQueCAqIHdOajtcblx0XHRcdEMueSArPSBwb2ludC55ICogd05qO1xuXHRcdFx0Qy56ICs9IHBvaW50LnogKiB3Tmo7XG5cdFx0XHRDLncgKz0gcG9pbnQudyAqIE5qO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIEM7XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBiYXNpcyBmdW5jdGlvbnMgZGVyaXZhdGl2ZXMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA3MiwgYWxnb3JpdGhtIEEyLjMuXG5cblx0c3BhbiA6IHNwYW4gaW4gd2hpY2ggdSBsaWVzXG5cdHUgICAgOiBwYXJhbWV0cmljIHBvaW50XG5cdHAgICAgOiBkZWdyZWVcblx0biAgICA6IG51bWJlciBvZiBkZXJpdmF0aXZlcyB0byBjYWxjdWxhdGVcblx0VSAgICA6IGtub3QgdmVjdG9yXG5cblx0cmV0dXJucyBhcnJheVtuKzFdW3ArMV0gd2l0aCBiYXNpcyBmdW5jdGlvbnMgZGVyaXZhdGl2ZXNcblx0Ki9cblx0Y2FsY0Jhc2lzRnVuY3Rpb25EZXJpdmF0aXZlczogZnVuY3Rpb24gKCBzcGFuLCB1LCBwLCBuLCBVICkge1xuXG5cdFx0dmFyIHplcm9BcnIgPSBbXTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gcDsgKysgaSApXG5cdFx0XHR6ZXJvQXJyWyBpIF0gPSAwLjA7XG5cblx0XHR2YXIgZGVycyA9IFtdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBuOyArKyBpIClcblx0XHRcdGRlcnNbIGkgXSA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblxuXHRcdHZhciBuZHUgPSBbXTtcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gcDsgKysgaSApXG5cdFx0XHRuZHVbIGkgXSA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblxuXHRcdG5kdVsgMCBdWyAwIF0gPSAxLjA7XG5cblx0XHR2YXIgbGVmdCA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblx0XHR2YXIgcmlnaHQgPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0bGVmdFsgaiBdID0gdSAtIFVbIHNwYW4gKyAxIC0gaiBdO1xuXHRcdFx0cmlnaHRbIGogXSA9IFVbIHNwYW4gKyBqIF0gLSB1O1xuXG5cdFx0XHR2YXIgc2F2ZWQgPSAwLjA7XG5cblx0XHRcdGZvciAoIHZhciByID0gMDsgciA8IGo7ICsrIHIgKSB7XG5cblx0XHRcdFx0dmFyIHJ2ID0gcmlnaHRbIHIgKyAxIF07XG5cdFx0XHRcdHZhciBsdiA9IGxlZnRbIGogLSByIF07XG5cdFx0XHRcdG5kdVsgaiBdWyByIF0gPSBydiArIGx2O1xuXG5cdFx0XHRcdHZhciB0ZW1wID0gbmR1WyByIF1bIGogLSAxIF0gLyBuZHVbIGogXVsgciBdO1xuXHRcdFx0XHRuZHVbIHIgXVsgaiBdID0gc2F2ZWQgKyBydiAqIHRlbXA7XG5cdFx0XHRcdHNhdmVkID0gbHYgKiB0ZW1wO1xuXG5cdFx0XHR9XG5cblx0XHRcdG5kdVsgaiBdWyBqIF0gPSBzYXZlZDtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRkZXJzWyAwIF1bIGogXSA9IG5kdVsgaiBdWyBwIF07XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgciA9IDA7IHIgPD0gcDsgKysgciApIHtcblxuXHRcdFx0dmFyIHMxID0gMDtcblx0XHRcdHZhciBzMiA9IDE7XG5cblx0XHRcdHZhciBhID0gW107XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gcDsgKysgaSApIHtcblxuXHRcdFx0XHRhWyBpIF0gPSB6ZXJvQXJyLnNsaWNlKCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YVsgMCBdWyAwIF0gPSAxLjA7XG5cblx0XHRcdGZvciAoIHZhciBrID0gMTsgayA8PSBuOyArKyBrICkge1xuXG5cdFx0XHRcdHZhciBkID0gMC4wO1xuXHRcdFx0XHR2YXIgcmsgPSByIC0gaztcblx0XHRcdFx0dmFyIHBrID0gcCAtIGs7XG5cblx0XHRcdFx0aWYgKCByID49IGsgKSB7XG5cblx0XHRcdFx0XHRhWyBzMiBdWyAwIF0gPSBhWyBzMSBdWyAwIF0gLyBuZHVbIHBrICsgMSBdWyByayBdO1xuXHRcdFx0XHRcdGQgPSBhWyBzMiBdWyAwIF0gKiBuZHVbIHJrIF1bIHBrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBqMSA9ICggcmsgPj0gLSAxICkgPyAxIDogLSByaztcblx0XHRcdFx0dmFyIGoyID0gKCByIC0gMSA8PSBwayApID8gayAtIDEgOiBwIC0gcjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IGoxOyBqIDw9IGoyOyArKyBqICkge1xuXG5cdFx0XHRcdFx0YVsgczIgXVsgaiBdID0gKCBhWyBzMSBdWyBqIF0gLSBhWyBzMSBdWyBqIC0gMSBdICkgLyBuZHVbIHBrICsgMSBdWyByayArIGogXTtcblx0XHRcdFx0XHRkICs9IGFbIHMyIF1bIGogXSAqIG5kdVsgcmsgKyBqIF1bIHBrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggciA8PSBwayApIHtcblxuXHRcdFx0XHRcdGFbIHMyIF1bIGsgXSA9IC0gYVsgczEgXVsgayAtIDEgXSAvIG5kdVsgcGsgKyAxIF1bIHIgXTtcblx0XHRcdFx0XHRkICs9IGFbIHMyIF1bIGsgXSAqIG5kdVsgciBdWyBwayBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZXJzWyBrIF1bIHIgXSA9IGQ7XG5cblx0XHRcdFx0dmFyIGogPSBzMTtcblx0XHRcdFx0czEgPSBzMjtcblx0XHRcdFx0czIgPSBqO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgciA9IHA7XG5cblx0XHRmb3IgKCB2YXIgayA9IDE7IGsgPD0gbjsgKysgayApIHtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdFx0ZGVyc1sgayBdWyBqIF0gKj0gcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyICo9IHAgLSBrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlcnM7XG5cblx0fSxcblxuXG5cdC8qXG5cdFx0Q2FsY3VsYXRlIGRlcml2YXRpdmVzIG9mIGEgQi1TcGxpbmUuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA5MywgYWxnb3JpdGhtIEEzLjIuXG5cblx0XHRwICA6IGRlZ3JlZVxuXHRcdFUgIDoga25vdCB2ZWN0b3Jcblx0XHRQICA6IGNvbnRyb2wgcG9pbnRzXG5cdFx0dSAgOiBQYXJhbWV0cmljIHBvaW50c1xuXHRcdG5kIDogbnVtYmVyIG9mIGRlcml2YXRpdmVzXG5cblx0XHRyZXR1cm5zIGFycmF5W2QrMV0gd2l0aCBkZXJpdmF0aXZlc1xuXHRcdCovXG5cdGNhbGNCU3BsaW5lRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICggcCwgVSwgUCwgdSwgbmQgKSB7XG5cblx0XHR2YXIgZHUgPSBuZCA8IHAgPyBuZCA6IHA7XG5cdFx0dmFyIENLID0gW107XG5cdFx0dmFyIHNwYW4gPSB0aGlzLmZpbmRTcGFuKCBwLCB1LCBVICk7XG5cdFx0dmFyIG5kZXJzID0gdGhpcy5jYWxjQmFzaXNGdW5jdGlvbkRlcml2YXRpdmVzKCBzcGFuLCB1LCBwLCBkdSwgVSApO1xuXHRcdHZhciBQdyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgUC5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IFBbIGkgXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHcgPSBwb2ludC53O1xuXG5cdFx0XHRwb2ludC54ICo9IHc7XG5cdFx0XHRwb2ludC55ICo9IHc7XG5cdFx0XHRwb2ludC56ICo9IHc7XG5cblx0XHRcdFB3WyBpIF0gPSBwb2ludDtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBrID0gMDsgayA8PSBkdTsgKysgayApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gUHdbIHNwYW4gLSBwIF0uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggbmRlcnNbIGsgXVsgMCBdICk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRcdHBvaW50LmFkZCggUHdbIHNwYW4gLSBwICsgaiBdLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIG5kZXJzWyBrIF1bIGogXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Q0tbIGsgXSA9IHBvaW50O1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGsgPSBkdSArIDE7IGsgPD0gbmQgKyAxOyArKyBrICkge1xuXG5cdFx0XHRDS1sgayBdID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDSztcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIFwiSyBvdmVyIElcIlxuXG5cdHJldHVybnMgayEvKGkhKGstaSkhKVxuXHQqL1xuXHRjYWxjS292ZXJJOiBmdW5jdGlvbiAoIGssIGkgKSB7XG5cblx0XHR2YXIgbm9tID0gMTtcblxuXHRcdGZvciAoIHZhciBqID0gMjsgaiA8PSBrOyArKyBqICkge1xuXG5cdFx0XHRub20gKj0gajtcblxuXHRcdH1cblxuXHRcdHZhciBkZW5vbSA9IDE7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDI7IGogPD0gaTsgKysgaiApIHtcblxuXHRcdFx0ZGVub20gKj0gajtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBqID0gMjsgaiA8PSBrIC0gaTsgKysgaiApIHtcblxuXHRcdFx0ZGVub20gKj0gajtcblxuXHRcdH1cblxuXHRcdHJldHVybiBub20gLyBkZW5vbTtcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIGRlcml2YXRpdmVzICgwLW5kKSBvZiByYXRpb25hbCBjdXJ2ZS4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDEyNywgYWxnb3JpdGhtIEE0LjIuXG5cblx0UGRlcnMgOiByZXN1bHQgb2YgZnVuY3Rpb24gY2FsY0JTcGxpbmVEZXJpdmF0aXZlc1xuXG5cdHJldHVybnMgYXJyYXkgd2l0aCBkZXJpdmF0aXZlcyBmb3IgcmF0aW9uYWwgY3VydmUuXG5cdCovXG5cdGNhbGNSYXRpb25hbEN1cnZlRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICggUGRlcnMgKSB7XG5cblx0XHR2YXIgbmQgPSBQZGVycy5sZW5ndGg7XG5cdFx0dmFyIEFkZXJzID0gW107XG5cdFx0dmFyIHdkZXJzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuZDsgKysgaSApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gUGRlcnNbIGkgXTtcblx0XHRcdEFkZXJzWyBpIF0gPSBuZXcgVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiApO1xuXHRcdFx0d2RlcnNbIGkgXSA9IHBvaW50Lnc7XG5cblx0XHR9XG5cblx0XHR2YXIgQ0sgPSBbXTtcblxuXHRcdGZvciAoIHZhciBrID0gMDsgayA8IG5kOyArKyBrICkge1xuXG5cdFx0XHR2YXIgdiA9IEFkZXJzWyBrIF0uY2xvbmUoKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IGs7ICsrIGkgKSB7XG5cblx0XHRcdFx0di5zdWIoIENLWyBrIC0gaSBdLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuY2FsY0tvdmVySSggaywgaSApICogd2RlcnNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Q0tbIGsgXSA9IHYuZGl2aWRlU2NhbGFyKCB3ZGVyc1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gQ0s7XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBOVVJCUyBjdXJ2ZSBkZXJpdmF0aXZlcy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDEyNywgYWxnb3JpdGhtIEE0LjIuXG5cblx0cCAgOiBkZWdyZWVcblx0VSAgOiBrbm90IHZlY3RvclxuXHRQICA6IGNvbnRyb2wgcG9pbnRzIGluIGhvbW9nZW5lb3VzIHNwYWNlXG5cdHUgIDogcGFyYW1ldHJpYyBwb2ludHNcblx0bmQgOiBudW1iZXIgb2YgZGVyaXZhdGl2ZXNcblxuXHRyZXR1cm5zIGFycmF5IHdpdGggZGVyaXZhdGl2ZXMuXG5cdCovXG5cdGNhbGNOVVJCU0Rlcml2YXRpdmVzOiBmdW5jdGlvbiAoIHAsIFUsIFAsIHUsIG5kICkge1xuXG5cdFx0dmFyIFBkZXJzID0gdGhpcy5jYWxjQlNwbGluZURlcml2YXRpdmVzKCBwLCBVLCBQLCB1LCBuZCApO1xuXHRcdHJldHVybiB0aGlzLmNhbGNSYXRpb25hbEN1cnZlRGVyaXZhdGl2ZXMoIFBkZXJzICk7XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSByYXRpb25hbCBCLVNwbGluZSBzdXJmYWNlIHBvaW50LiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgMTM0LCBhbGdvcml0aG0gQTQuMy5cblxuXHRwMSwgcDIgOiBkZWdyZWVzIG9mIEItU3BsaW5lIHN1cmZhY2Vcblx0VTEsIFUyIDoga25vdCB2ZWN0b3JzXG5cdFAgICAgICA6IGNvbnRyb2wgcG9pbnRzICh4LCB5LCB6LCB3KVxuXHR1LCB2ICAgOiBwYXJhbWV0cmljIHZhbHVlc1xuXG5cdHJldHVybnMgcG9pbnQgZm9yIGdpdmVuICh1LCB2KVxuXHQqL1xuXHRjYWxjU3VyZmFjZVBvaW50OiBmdW5jdGlvbiAoIHAsIHEsIFUsIFYsIFAsIHUsIHYsIHRhcmdldCApIHtcblxuXHRcdHZhciB1c3BhbiA9IHRoaXMuZmluZFNwYW4oIHAsIHUsIFUgKTtcblx0XHR2YXIgdnNwYW4gPSB0aGlzLmZpbmRTcGFuKCBxLCB2LCBWICk7XG5cdFx0dmFyIE51ID0gdGhpcy5jYWxjQmFzaXNGdW5jdGlvbnMoIHVzcGFuLCB1LCBwLCBVICk7XG5cdFx0dmFyIE52ID0gdGhpcy5jYWxjQmFzaXNGdW5jdGlvbnMoIHZzcGFuLCB2LCBxLCBWICk7XG5cdFx0dmFyIHRlbXAgPSBbXTtcblxuXHRcdGZvciAoIHZhciBsID0gMDsgbCA8PSBxOyArKyBsICkge1xuXG5cdFx0XHR0ZW1wWyBsIF0gPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xuXHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDw9IHA7ICsrIGsgKSB7XG5cblx0XHRcdFx0dmFyIHBvaW50ID0gUFsgdXNwYW4gLSBwICsgayBdWyB2c3BhbiAtIHEgKyBsIF0uY2xvbmUoKTtcblx0XHRcdFx0dmFyIHcgPSBwb2ludC53O1xuXHRcdFx0XHRwb2ludC54ICo9IHc7XG5cdFx0XHRcdHBvaW50LnkgKj0gdztcblx0XHRcdFx0cG9pbnQueiAqPSB3O1xuXHRcdFx0XHR0ZW1wWyBsIF0uYWRkKCBwb2ludC5tdWx0aXBseVNjYWxhciggTnVbIGsgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBTdyA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XG5cdFx0Zm9yICggdmFyIGwgPSAwOyBsIDw9IHE7ICsrIGwgKSB7XG5cblx0XHRcdFN3LmFkZCggdGVtcFsgbCBdLm11bHRpcGx5U2NhbGFyKCBOdlsgbCBdICkgKTtcblxuXHRcdH1cblxuXHRcdFN3LmRpdmlkZVNjYWxhciggU3cudyApO1xuXHRcdHRhcmdldC5zZXQoIFN3LngsIFN3LnksIFN3LnogKTtcblxuXHR9XG5cbn07XG5cbi8qKlxuICogTlVSQlMgY3VydmUgb2JqZWN0XG4gKlxuICogRGVyaXZlcyBmcm9tIEN1cnZlLCBvdmVycmlkaW5nIGdldFBvaW50IGFuZCBnZXRUYW5nZW50LlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uICh4LCB5IFssIHo9MCBbLCB3PTFdXSkgY29udHJvbCBwb2ludHMgd2l0aCB3PXdlaWdodC5cbiAqXG4gKiovXG5cbnZhciBOVVJCU0N1cnZlID0gZnVuY3Rpb24gKCBkZWdyZWUsIGtub3RzIC8qIGFycmF5IG9mIHJlYWxzICovLCBjb250cm9sUG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcigyfDN8NCkgKi8sIHN0YXJ0S25vdCAvKiBpbmRleCBpbiBrbm90cyAqLywgZW5kS25vdCAvKiBpbmRleCBpbiBrbm90cyAqLyApIHtcblxuXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5kZWdyZWUgPSBkZWdyZWU7XG5cdHRoaXMua25vdHMgPSBrbm90cztcblx0dGhpcy5jb250cm9sUG9pbnRzID0gW107XG5cdC8vIFVzZWQgYnkgcGVyaW9kaWMgTlVSQlMgdG8gcmVtb3ZlIGhpZGRlbiBzcGFuc1xuXHR0aGlzLnN0YXJ0S25vdCA9IHN0YXJ0S25vdCB8fCAwO1xuXHR0aGlzLmVuZEtub3QgPSBlbmRLbm90IHx8ICggdGhpcy5rbm90cy5sZW5ndGggLSAxICk7XG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbnRyb2xQb2ludHMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0Ly8gZW5zdXJlIFZlY3RvcjQgZm9yIGNvbnRyb2wgcG9pbnRzXG5cdFx0dmFyIHBvaW50ID0gY29udHJvbFBvaW50c1sgaSBdO1xuXHRcdHRoaXMuY29udHJvbFBvaW50c1sgaSBdID0gbmV3IFZlY3RvcjQoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnosIHBvaW50LncgKTtcblxuXHR9XG5cbn07XG5cblxuTlVSQlNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbk5VUkJTQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTlVSQlNDdXJ2ZTtcblxuXG5OVVJCU0N1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHR2YXIgdSA9IHRoaXMua25vdHNbIHRoaXMuc3RhcnRLbm90IF0gKyB0ICogKCB0aGlzLmtub3RzWyB0aGlzLmVuZEtub3QgXSAtIHRoaXMua25vdHNbIHRoaXMuc3RhcnRLbm90IF0gKTsgLy8gbGluZWFyIG1hcHBpbmcgdC0+dVxuXG5cdC8vIGZvbGxvd2luZyByZXN1bHRzIGluICh3eCwgd3ksIHd6LCB3KSBob21vZ2VuZW91cyBwb2ludFxuXHR2YXIgaHBvaW50ID0gTlVSQlNVdGlscy5jYWxjQlNwbGluZVBvaW50KCB0aGlzLmRlZ3JlZSwgdGhpcy5rbm90cywgdGhpcy5jb250cm9sUG9pbnRzLCB1ICk7XG5cblx0aWYgKCBocG9pbnQudyAhPSAxLjAgKSB7XG5cblx0XHQvLyBwcm9qZWN0IHRvIDNEIHNwYWNlOiAod3gsIHd5LCB3eiwgdykgLT4gKHgsIHksIHosIDEpXG5cdFx0aHBvaW50LmRpdmlkZVNjYWxhciggaHBvaW50LncgKTtcblxuXHR9XG5cblx0cmV0dXJuIHBvaW50LnNldCggaHBvaW50LngsIGhwb2ludC55LCBocG9pbnQueiApO1xuXG59O1xuXG5cbk5VUkJTQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdHZhciB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuXHR2YXIgdSA9IHRoaXMua25vdHNbIDAgXSArIHQgKiAoIHRoaXMua25vdHNbIHRoaXMua25vdHMubGVuZ3RoIC0gMSBdIC0gdGhpcy5rbm90c1sgMCBdICk7XG5cdHZhciBkZXJzID0gTlVSQlNVdGlscy5jYWxjTlVSQlNEZXJpdmF0aXZlcyggdGhpcy5kZWdyZWUsIHRoaXMua25vdHMsIHRoaXMuY29udHJvbFBvaW50cywgdSwgMSApO1xuXHR0YW5nZW50LmNvcHkoIGRlcnNbIDEgXSApLm5vcm1hbGl6ZSgpO1xuXG5cdHJldHVybiB0YW5nZW50O1xuXG59O1xuXG4vKipcbiAqIExvYWRlciBsb2FkcyBGQlggZmlsZSBhbmQgZ2VuZXJhdGVzIEdyb3VwIHJlcHJlc2VudGluZyBGQlggc2NlbmUuXG4gKiBSZXF1aXJlcyBGQlggZmlsZSB0byBiZSA+PSA3LjAgYW5kIGluIEFTQ0lJIG9yID49IDY0MDAgaW4gQmluYXJ5IGZvcm1hdFxuICogVmVyc2lvbnMgbG93ZXIgdGhhbiB0aGlzIG1heSBsb2FkIGJ1dCB3aWxsIHByb2JhYmx5IGhhdmUgZXJyb3JzXG4gKlxuICogTmVlZHMgU3VwcG9ydDpcbiAqICBNb3JwaCBub3JtYWxzIC8gYmxlbmQgc2hhcGUgbm9ybWFsc1xuICpcbiAqIEZCWCBmb3JtYXQgcmVmZXJlbmNlczpcbiAqIFx0aHR0cHM6Ly93aWtpLmJsZW5kZXIub3JnL2luZGV4LnBocC9Vc2VyOk1vbnQyOS9Gb3VuZGF0aW9uL0ZCWF9GaWxlX1N0cnVjdHVyZVxuICogXHRodHRwOi8vaGVscC5hdXRvZGVzay5jb20vdmlldy9GQlgvMjAxNy9FTlUvP2d1aWQ9X19jcHBfcmVmX2luZGV4X2h0bWwgKEMrKyBTREsgcmVmZXJlbmNlKVxuICpcbiAqIFx0QmluYXJ5IGZvcm1hdCBzcGVjaWZpY2F0aW9uOlxuICpcdFx0aHR0cHM6Ly9jb2RlLmJsZW5kZXIub3JnLzIwMTMvMDgvZmJ4LWJpbmFyeS1maWxlLWZvcm1hdC1zcGVjaWZpY2F0aW9uL1xuICovXG5cblxudmFyIEZCWExvYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBmYnhUcmVlO1xuXHR2YXIgY29ubmVjdGlvbnM7XG5cdHZhciBzY2VuZUdyYXBoO1xuXG5cdGZ1bmN0aW9uIEZCWExvYWRlciggbWFuYWdlciApIHtcblxuXHRcdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHR9XG5cblx0RkJYTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogRkJYTG9hZGVyLFxuXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdFx0dmFyIHBhdGggPSAoIHNjb3BlLnBhdGggPT09ICcnICkgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICkgOiBzY29wZS5wYXRoO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHNjb3BlLnBhdGggKTtcblx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIGJ1ZmZlciwgcGF0aCApICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCBGQlhCdWZmZXIsIHBhdGggKSB7XG5cblx0XHRcdGlmICggaXNGYnhGb3JtYXRCaW5hcnkoIEZCWEJ1ZmZlciApICkge1xuXG5cdFx0XHRcdGZieFRyZWUgPSBuZXcgQmluYXJ5UGFyc2VyKCkucGFyc2UoIEZCWEJ1ZmZlciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBGQlhUZXh0ID0gY29udmVydEFycmF5QnVmZmVyVG9TdHJpbmcoIEZCWEJ1ZmZlciApO1xuXG5cdFx0XHRcdGlmICggISBpc0ZieEZvcm1hdEFTQ0lJKCBGQlhUZXh0ICkgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IFVua25vd24gZm9ybWF0LicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZXRGYnhWZXJzaW9uKCBGQlhUZXh0ICkgPCA3MDAwICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBGQlggdmVyc2lvbiBub3Qgc3VwcG9ydGVkLCBGaWxlVmVyc2lvbjogJyArIGdldEZieFZlcnNpb24oIEZCWFRleHQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYnhUcmVlID0gbmV3IFRleHRQYXJzZXIoKS5wYXJzZSggRkJYVGV4dCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbnNvbGUubG9nKCBmYnhUcmVlICk7XG5cblx0XHRcdHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMubWFuYWdlciApLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKS5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRyZXR1cm4gbmV3IEZCWFRyZWVQYXJzZXIoIHRleHR1cmVMb2FkZXIsIHRoaXMubWFuYWdlciApLnBhcnNlKCBmYnhUcmVlICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8vIFBhcnNlIHRoZSBGQlhUcmVlIG9iamVjdCByZXR1cm5lZCBieSB0aGUgQmluYXJ5UGFyc2VyIG9yIFRleHRQYXJzZXIgYW5kIHJldHVybiBhIEdyb3VwXG5cdGZ1bmN0aW9uIEZCWFRyZWVQYXJzZXIoIHRleHR1cmVMb2FkZXIsIG1hbmFnZXIgKSB7XG5cblx0XHR0aGlzLnRleHR1cmVMb2FkZXIgPSB0ZXh0dXJlTG9hZGVyO1xuXHRcdHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG5cblx0fVxuXG5cdEZCWFRyZWVQYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEZCWFRyZWVQYXJzZXIsXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRjb25uZWN0aW9ucyA9IHRoaXMucGFyc2VDb25uZWN0aW9ucygpO1xuXG5cdFx0XHR2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygpO1xuXHRcdFx0dmFyIHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBpbWFnZXMgKTtcblx0XHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCB0ZXh0dXJlcyApO1xuXHRcdFx0dmFyIGRlZm9ybWVycyA9IHRoaXMucGFyc2VEZWZvcm1lcnMoKTtcblx0XHRcdHZhciBnZW9tZXRyeU1hcCA9IG5ldyBHZW9tZXRyeVBhcnNlcigpLnBhcnNlKCBkZWZvcm1lcnMgKTtcblxuXHRcdFx0dGhpcy5wYXJzZVNjZW5lKCBkZWZvcm1lcnMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbHMgKTtcblxuXHRcdFx0cmV0dXJuIHNjZW5lR3JhcGg7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2VzIEZCWFRyZWUuQ29ubmVjdGlvbnMgd2hpY2ggaG9sZHMgcGFyZW50LWNoaWxkIGNvbm5lY3Rpb25zIGJldHdlZW4gb2JqZWN0cyAoZS5nLiBtYXRlcmlhbCAtPiB0ZXh0dXJlLCBtb2RlbC0+Z2VvbWV0cnkgKVxuXHRcdC8vIGFuZCBkZXRhaWxzIHRoZSBjb25uZWN0aW9uIHR5cGVcblx0XHRwYXJzZUNvbm5lY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBjb25uZWN0aW9uTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRpZiAoICdDb25uZWN0aW9ucycgaW4gZmJ4VHJlZSApIHtcblxuXHRcdFx0XHR2YXIgcmF3Q29ubmVjdGlvbnMgPSBmYnhUcmVlLkNvbm5lY3Rpb25zLmNvbm5lY3Rpb25zO1xuXG5cdFx0XHRcdHJhd0Nvbm5lY3Rpb25zLmZvckVhY2goIGZ1bmN0aW9uICggcmF3Q29ubmVjdGlvbiApIHtcblxuXHRcdFx0XHRcdHZhciBmcm9tSUQgPSByYXdDb25uZWN0aW9uWyAwIF07XG5cdFx0XHRcdFx0dmFyIHRvSUQgPSByYXdDb25uZWN0aW9uWyAxIF07XG5cdFx0XHRcdFx0dmFyIHJlbGF0aW9uc2hpcCA9IHJhd0Nvbm5lY3Rpb25bIDIgXTtcblxuXHRcdFx0XHRcdGlmICggISBjb25uZWN0aW9uTWFwLmhhcyggZnJvbUlEICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbm5lY3Rpb25NYXAuc2V0KCBmcm9tSUQsIHtcblx0XHRcdFx0XHRcdFx0cGFyZW50czogW10sXG5cdFx0XHRcdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHBhcmVudFJlbGF0aW9uc2hpcCA9IHsgSUQ6IHRvSUQsIHJlbGF0aW9uc2hpcDogcmVsYXRpb25zaGlwIH07XG5cdFx0XHRcdFx0Y29ubmVjdGlvbk1hcC5nZXQoIGZyb21JRCApLnBhcmVudHMucHVzaCggcGFyZW50UmVsYXRpb25zaGlwICk7XG5cblx0XHRcdFx0XHRpZiAoICEgY29ubmVjdGlvbk1hcC5oYXMoIHRvSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29ubmVjdGlvbk1hcC5zZXQoIHRvSUQsIHtcblx0XHRcdFx0XHRcdFx0cGFyZW50czogW10sXG5cdFx0XHRcdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGNoaWxkUmVsYXRpb25zaGlwID0geyBJRDogZnJvbUlELCByZWxhdGlvbnNoaXA6IHJlbGF0aW9uc2hpcCB9O1xuXHRcdFx0XHRcdGNvbm5lY3Rpb25NYXAuZ2V0KCB0b0lEICkuY2hpbGRyZW4ucHVzaCggY2hpbGRSZWxhdGlvbnNoaXAgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbm5lY3Rpb25NYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgRkJYVHJlZS5PYmplY3RzLlZpZGVvIGZvciBlbWJlZGRlZCBpbWFnZSBkYXRhXG5cdFx0Ly8gVGhlc2UgaW1hZ2VzIGFyZSBjb25uZWN0ZWQgdG8gdGV4dHVyZXMgaW4gRkJYVHJlZS5PYmplY3RzLlRleHR1cmVzXG5cdFx0Ly8gdmlhIEZCWFRyZWUuQ29ubmVjdGlvbnMuXG5cdFx0cGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGltYWdlcyA9IHt9O1xuXHRcdFx0dmFyIGJsb2JzID0ge307XG5cblx0XHRcdGlmICggJ1ZpZGVvJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIHZpZGVvTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuVmlkZW87XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiB2aWRlb05vZGVzICkge1xuXG5cdFx0XHRcdFx0dmFyIHZpZGVvTm9kZSA9IHZpZGVvTm9kZXNbIG5vZGVJRCBdO1xuXG5cdFx0XHRcdFx0dmFyIGlkID0gcGFyc2VJbnQoIG5vZGVJRCApO1xuXG5cdFx0XHRcdFx0aW1hZ2VzWyBpZCBdID0gdmlkZW9Ob2RlLlJlbGF0aXZlRmlsZW5hbWUgfHwgdmlkZW9Ob2RlLkZpbGVuYW1lO1xuXG5cdFx0XHRcdFx0Ly8gcmF3IGltYWdlIGRhdGEgaXMgaW4gdmlkZW9Ob2RlLkNvbnRlbnRcblx0XHRcdFx0XHRpZiAoICdDb250ZW50JyBpbiB2aWRlb05vZGUgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhcnJheUJ1ZmZlckNvbnRlbnQgPSAoIHZpZGVvTm9kZS5Db250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSAmJiAoIHZpZGVvTm9kZS5Db250ZW50LmJ5dGVMZW5ndGggPiAwICk7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZTY0Q29udGVudCA9ICggdHlwZW9mIHZpZGVvTm9kZS5Db250ZW50ID09PSAnc3RyaW5nJyApICYmICggdmlkZW9Ob2RlLkNvbnRlbnQgIT09ICcnICk7XG5cblx0XHRcdFx0XHRcdGlmICggYXJyYXlCdWZmZXJDb250ZW50IHx8IGJhc2U2NENvbnRlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGltYWdlID0gdGhpcy5wYXJzZUltYWdlKCB2aWRlb05vZGVzWyBub2RlSUQgXSApO1xuXG5cdFx0XHRcdFx0XHRcdGJsb2JzWyB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWUgXSA9IGltYWdlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpZCBpbiBpbWFnZXMgKSB7XG5cblx0XHRcdFx0dmFyIGZpbGVuYW1lID0gaW1hZ2VzWyBpZCBdO1xuXG5cdFx0XHRcdGlmICggYmxvYnNbIGZpbGVuYW1lIF0gIT09IHVuZGVmaW5lZCApIGltYWdlc1sgaWQgXSA9IGJsb2JzWyBmaWxlbmFtZSBdO1xuXHRcdFx0XHRlbHNlIGltYWdlc1sgaWQgXSA9IGltYWdlc1sgaWQgXS5zcGxpdCggJ1xcXFwnICkucG9wKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlcztcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBlbWJlZGRlZCBpbWFnZSBkYXRhIGluIEZCWFRyZWUuVmlkZW8uQ29udGVudFxuXHRcdHBhcnNlSW1hZ2U6IGZ1bmN0aW9uICggdmlkZW9Ob2RlICkge1xuXG5cdFx0XHR2YXIgY29udGVudCA9IHZpZGVvTm9kZS5Db250ZW50O1xuXHRcdFx0dmFyIGZpbGVOYW1lID0gdmlkZW9Ob2RlLlJlbGF0aXZlRmlsZW5hbWUgfHwgdmlkZW9Ob2RlLkZpbGVuYW1lO1xuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGZpbGVOYW1lLnNsaWNlKCBmaWxlTmFtZS5sYXN0SW5kZXhPZiggJy4nICkgKyAxICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dmFyIHR5cGU7XG5cblx0XHRcdHN3aXRjaCAoIGV4dGVuc2lvbiApIHtcblxuXHRcdFx0XHRjYXNlICdibXAnOlxuXG5cdFx0XHRcdFx0dHlwZSA9ICdpbWFnZS9ibXAnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2pwZyc6XG5cdFx0XHRcdGNhc2UgJ2pwZWcnOlxuXG5cdFx0XHRcdFx0dHlwZSA9ICdpbWFnZS9qcGVnJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwbmcnOlxuXG5cdFx0XHRcdFx0dHlwZSA9ICdpbWFnZS9wbmcnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RpZic6XG5cblx0XHRcdFx0XHR0eXBlID0gJ2ltYWdlL3RpZmYnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RnYSc6XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubWFuYWdlci5nZXRIYW5kbGVyKCAnLnRnYScgKSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBUR0EgbG9hZGVyIG5vdCBmb3VuZCwgc2tpcHBpbmcgJywgZmlsZU5hbWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHR5cGUgPSAnaW1hZ2UvdGdhJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnRkJYTG9hZGVyOiBJbWFnZSB0eXBlIFwiJyArIGV4dGVuc2lvbiArICdcIiBpcyBub3Qgc3VwcG9ydGVkLicgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgKSB7IC8vIEFTQ0lJIGZvcm1hdFxuXG5cdFx0XHRcdHJldHVybiAnZGF0YTonICsgdHlwZSArICc7YmFzZTY0LCcgKyBjb250ZW50O1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBCaW5hcnkgRm9ybWF0XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGNvbnRlbnQgKTtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKCBuZXcgQmxvYiggWyBhcnJheSBdLCB7IHR5cGU6IHR5cGUgfSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZVxuXHRcdC8vIFRoZXNlIGNvbnRhaW4gZGV0YWlscyBzdWNoIGFzIFVWIHNjYWxpbmcsIGNyb3BwaW5nLCByb3RhdGlvbiBldGMgYW5kIGFyZSBjb25uZWN0ZWRcblx0XHQvLyB0byBpbWFnZXMgaW4gRkJYVHJlZS5PYmplY3RzLlZpZGVvXG5cdFx0cGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBpbWFnZXMgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRpZiAoICdUZXh0dXJlJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmVOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5UZXh0dXJlO1xuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHRleHR1cmVOb2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5wYXJzZVRleHR1cmUoIHRleHR1cmVOb2Rlc1sgbm9kZUlEIF0sIGltYWdlcyApO1xuXHRcdFx0XHRcdHRleHR1cmVNYXAuc2V0KCBwYXJzZUludCggbm9kZUlEICksIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVNYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgaW5kaXZpZHVhbCBub2RlIGluIEZCWFRyZWUuT2JqZWN0cy5UZXh0dXJlXG5cdFx0cGFyc2VUZXh0dXJlOiBmdW5jdGlvbiAoIHRleHR1cmVOb2RlLCBpbWFnZXMgKSB7XG5cblx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5sb2FkVGV4dHVyZSggdGV4dHVyZU5vZGUsIGltYWdlcyApO1xuXG5cdFx0XHR0ZXh0dXJlLklEID0gdGV4dHVyZU5vZGUuaWQ7XG5cblx0XHRcdHRleHR1cmUubmFtZSA9IHRleHR1cmVOb2RlLmF0dHJOYW1lO1xuXG5cdFx0XHR2YXIgd3JhcE1vZGVVID0gdGV4dHVyZU5vZGUuV3JhcE1vZGVVO1xuXHRcdFx0dmFyIHdyYXBNb2RlViA9IHRleHR1cmVOb2RlLldyYXBNb2RlVjtcblxuXHRcdFx0dmFyIHZhbHVlVSA9IHdyYXBNb2RlVSAhPT0gdW5kZWZpbmVkID8gd3JhcE1vZGVVLnZhbHVlIDogMDtcblx0XHRcdHZhciB2YWx1ZVYgPSB3cmFwTW9kZVYgIT09IHVuZGVmaW5lZCA/IHdyYXBNb2RlVi52YWx1ZSA6IDA7XG5cblx0XHRcdC8vIGh0dHA6Ly9kb3dubG9hZC5hdXRvZGVzay5jb20vdXMvZmJ4L1NES2RvY3MvRkJYX1NES19IZWxwL2ZpbGVzL2ZieHNka3JlZi9jbGFzc19rX2ZieF90ZXh0dXJlLmh0bWwjODg5NjQwZTYzZTJlNjgxMjU5ZWE4MTA2MWI4NTE0M2Fcblx0XHRcdC8vIDA6IHJlcGVhdChkZWZhdWx0KSwgMTogY2xhbXBcblxuXHRcdFx0dGV4dHVyZS53cmFwUyA9IHZhbHVlVSA9PT0gMCA/IFJlcGVhdFdyYXBwaW5nIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSB2YWx1ZVYgPT09IDAgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRcdGlmICggJ1NjYWxpbmcnIGluIHRleHR1cmVOb2RlICkge1xuXG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0ZXh0dXJlTm9kZS5TY2FsaW5nLnZhbHVlO1xuXG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnggPSB2YWx1ZXNbIDAgXTtcblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueSA9IHZhbHVlc1sgMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0fSxcblxuXHRcdC8vIGxvYWQgYSB0ZXh0dXJlIHNwZWNpZmllZCBhcyBhIGJsb2Igb3IgZGF0YSBVUkksIG9yIHZpYSBhbiBleHRlcm5hbCBVUkwgdXNpbmcgVGV4dHVyZUxvYWRlclxuXHRcdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHRleHR1cmVOb2RlLCBpbWFnZXMgKSB7XG5cblx0XHRcdHZhciBmaWxlTmFtZTtcblxuXHRcdFx0dmFyIGN1cnJlbnRQYXRoID0gdGhpcy50ZXh0dXJlTG9hZGVyLnBhdGg7XG5cblx0XHRcdHZhciBjaGlsZHJlbiA9IGNvbm5lY3Rpb25zLmdldCggdGV4dHVyZU5vZGUuaWQgKS5jaGlsZHJlbjtcblxuXHRcdFx0aWYgKCBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgaW1hZ2VzWyBjaGlsZHJlblsgMCBdLklEIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmaWxlTmFtZSA9IGltYWdlc1sgY2hpbGRyZW5bIDAgXS5JRCBdO1xuXG5cdFx0XHRcdGlmICggZmlsZU5hbWUuaW5kZXhPZiggJ2Jsb2I6JyApID09PSAwIHx8IGZpbGVOYW1lLmluZGV4T2YoICdkYXRhOicgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRQYXRoKCB1bmRlZmluZWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRleHR1cmU7XG5cblx0XHRcdHZhciBleHRlbnNpb24gPSB0ZXh0dXJlTm9kZS5GaWxlTmFtZS5zbGljZSggLSAzICkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09ICd0Z2EnICkge1xuXG5cdFx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLm1hbmFnZXIuZ2V0SGFuZGxlciggJy50Z2EnICk7XG5cblx0XHRcdFx0aWYgKCBsb2FkZXIgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdGQlhMb2FkZXI6IFRHQSBsb2FkZXIgbm90IGZvdW5kLCBjcmVhdGluZyBwbGFjZWhvbGRlciB0ZXh0dXJlIGZvcicsIHRleHR1cmVOb2RlLlJlbGF0aXZlRmlsZW5hbWUgKTtcblx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmaWxlTmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggZXh0ZW5zaW9uID09PSAncHNkJyApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdGQlhMb2FkZXI6IFBTRCB0ZXh0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCwgY3JlYXRpbmcgcGxhY2Vob2xkZXIgdGV4dHVyZSBmb3InLCB0ZXh0dXJlTm9kZS5SZWxhdGl2ZUZpbGVuYW1lICk7XG5cdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRleHR1cmUgPSB0aGlzLnRleHR1cmVMb2FkZXIubG9hZCggZmlsZU5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnRleHR1cmVMb2FkZXIuc2V0UGF0aCggY3VycmVudFBhdGggKTtcblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLk1hdGVyaWFsXG5cdFx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICggdGV4dHVyZU1hcCApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRpZiAoICdNYXRlcmlhbCcgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbE5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLk1hdGVyaWFsO1xuXG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gbWF0ZXJpYWxOb2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMucGFyc2VNYXRlcmlhbCggbWF0ZXJpYWxOb2Rlc1sgbm9kZUlEIF0sIHRleHR1cmVNYXAgKTtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgIT09IG51bGwgKSBtYXRlcmlhbE1hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsTWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIHNpbmdsZSBub2RlIGluIEZCWFRyZWUuT2JqZWN0cy5NYXRlcmlhbFxuXHRcdC8vIE1hdGVyaWFscyBhcmUgY29ubmVjdGVkIHRvIHRleHR1cmUgbWFwcyBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZXNcblx0XHQvLyBGQlggZm9ybWF0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIExhbWJlcnQgYW5kIFBob25nIHNoYWRpbmcgbW9kZWxzXG5cdFx0cGFyc2VNYXRlcmlhbDogZnVuY3Rpb24gKCBtYXRlcmlhbE5vZGUsIHRleHR1cmVNYXAgKSB7XG5cblx0XHRcdHZhciBJRCA9IG1hdGVyaWFsTm9kZS5pZDtcblx0XHRcdHZhciBuYW1lID0gbWF0ZXJpYWxOb2RlLmF0dHJOYW1lO1xuXHRcdFx0dmFyIHR5cGUgPSBtYXRlcmlhbE5vZGUuU2hhZGluZ01vZGVsO1xuXG5cdFx0XHQvLyBDYXNlIHdoZXJlIEZCWCB3cmFwcyBzaGFkaW5nIG1vZGVsIGluIHByb3BlcnR5IG9iamVjdC5cblx0XHRcdGlmICggdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRcdHR5cGUgPSB0eXBlLnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIElnbm9yZSB1bnVzZWQgbWF0ZXJpYWxzIHdoaWNoIGRvbid0IGhhdmUgYW55IGNvbm5lY3Rpb25zLlxuXHRcdFx0aWYgKCAhIGNvbm5lY3Rpb25zLmhhcyggSUQgKSApIHJldHVybiBudWxsO1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyc2VQYXJhbWV0ZXJzKCBtYXRlcmlhbE5vZGUsIHRleHR1cmVNYXAsIElEICk7XG5cblx0XHRcdHZhciBtYXRlcmlhbDtcblxuXHRcdFx0c3dpdGNoICggdHlwZS50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0XHRcdGNhc2UgJ3Bob25nJzpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdsYW1iZXJ0Jzpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoTGFtYmVydE1hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiB1bmtub3duIG1hdGVyaWFsIHR5cGUgXCIlc1wiLiBEZWZhdWx0aW5nIHRvIE1lc2hQaG9uZ01hdGVyaWFsLicsIHR5cGUgKTtcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXHRcdFx0bWF0ZXJpYWwubmFtZSA9IG5hbWU7XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBGQlggbWF0ZXJpYWwgYW5kIHJldHVybiBwYXJhbWV0ZXJzIHN1aXRhYmxlIGZvciBhIHRocmVlLmpzIG1hdGVyaWFsXG5cdFx0Ly8gQWxzbyBwYXJzZSB0aGUgdGV4dHVyZSBtYXAgYW5kIHJldHVybiBhbnkgdGV4dHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXRlcmlhbFxuXHRcdHBhcnNlUGFyYW1ldGVyczogZnVuY3Rpb24gKCBtYXRlcmlhbE5vZGUsIHRleHR1cmVNYXAsIElEICkge1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHt9O1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5CdW1wRmFjdG9yICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuYnVtcFNjYWxlID0gbWF0ZXJpYWxOb2RlLkJ1bXBGYWN0b3IudmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuRGlmZnVzZSApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuRGlmZnVzZS52YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE5vZGUuRGlmZnVzZUNvbG9yICYmICggbWF0ZXJpYWxOb2RlLkRpZmZ1c2VDb2xvci50eXBlID09PSAnQ29sb3InIHx8IG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IudHlwZSA9PT0gJ0NvbG9yUkdCJyApICkge1xuXG5cdFx0XHRcdC8vIFRoZSBibGVuZGVyIGV4cG9ydGVyIGV4cG9ydHMgZGlmZnVzZSBoZXJlIGluc3RlYWQgb2YgaW4gbWF0ZXJpYWxOb2RlLkRpZmZ1c2Vcblx0XHRcdFx0cGFyYW1ldGVycy5jb2xvciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkRpZmZ1c2VDb2xvci52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLkRpc3BsYWNlbWVudEZhY3RvciApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudFNjYWxlID0gbWF0ZXJpYWxOb2RlLkRpc3BsYWNlbWVudEZhY3Rvci52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZSApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuRW1pc3NpdmUudmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlQ29sb3IgJiYgKCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVDb2xvci50eXBlID09PSAnQ29sb3InIHx8IG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yLnR5cGUgPT09ICdDb2xvclJHQicgKSApIHtcblxuXHRcdFx0XHQvLyBUaGUgYmxlbmRlciBleHBvcnRlciBleHBvcnRzIGVtaXNzaXZlIGNvbG9yIGhlcmUgaW5zdGVhZCBvZiBpbiBtYXRlcmlhbE5vZGUuRW1pc3NpdmVcblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlQ29sb3IudmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUZhY3RvciApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlSW50ZW5zaXR5ID0gcGFyc2VGbG9hdCggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlRmFjdG9yLnZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuT3BhY2l0eSApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm9wYWNpdHkgPSBwYXJzZUZsb2F0KCBtYXRlcmlhbE5vZGUuT3BhY2l0eS52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcGFyYW1ldGVycy5vcGFjaXR5IDwgMS4wICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLlJlZmxlY3Rpb25GYWN0b3IgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5yZWZsZWN0aXZpdHkgPSBtYXRlcmlhbE5vZGUuUmVmbGVjdGlvbkZhY3Rvci52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5TaGluaW5lc3MgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5zaGluaW5lc3MgPSBtYXRlcmlhbE5vZGUuU2hpbmluZXNzLnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5TcGVjdWxhci52YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE5vZGUuU3BlY3VsYXJDb2xvciAmJiBtYXRlcmlhbE5vZGUuU3BlY3VsYXJDb2xvci50eXBlID09PSAnQ29sb3InICkge1xuXG5cdFx0XHRcdC8vIFRoZSBibGVuZGVyIGV4cG9ydGVyIGV4cG9ydHMgc3BlY3VsYXIgY29sb3IgaGVyZSBpbnN0ZWFkIG9mIGluIG1hdGVyaWFsTm9kZS5TcGVjdWxhclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuU3BlY3VsYXJDb2xvci52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRjb25uZWN0aW9ucy5nZXQoIElEICkuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHR2YXIgdHlwZSA9IGNoaWxkLnJlbGF0aW9uc2hpcDtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnQnVtcCc6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdNYXlhfFRFWF9hb19tYXAnOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5hb01hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0RpZmZ1c2VDb2xvcic6XG5cdFx0XHRcdFx0Y2FzZSAnTWF5YXxURVhfY29sb3JfbWFwJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMubWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMubWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdEaXNwbGFjZW1lbnRDb2xvcic6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0VtaXNzaXZlQ29sb3InOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdOb3JtYWxNYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ01heWF8VEVYX25vcm1hbF9tYXAnOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdSZWZsZWN0aW9uQ29sb3InOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAubWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwZWN1bGFyQ29sb3InOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwLmVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdUcmFuc3BhcmVudENvbG9yJzpcblx0XHRcdFx0XHRjYXNlICdUcmFuc3BhcmVuY3lGYWN0b3InOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQW1iaWVudENvbG9yJzpcblx0XHRcdFx0XHRjYXNlICdTaGluaW5lc3NFeHBvbmVudCc6IC8vIEFLQSBnbG9zc2luZXNzIG1hcFxuXHRcdFx0XHRcdGNhc2UgJ1NwZWN1bGFyRmFjdG9yJzogLy8gQUtBIHNwZWN1bGFyTGV2ZWxcblx0XHRcdFx0XHRjYXNlICdWZWN0b3JEaXNwbGFjZW1lbnRDb2xvcic6IC8vIE5PVEU6IFNlZW1zIHRvIGJlIGEgY29weSBvZiBEaXNwbGFjZW1lbnRDb2xvclxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6ICVzIG1hcCBpcyBub3Qgc3VwcG9ydGVkIGluIHRocmVlLmpzLCBza2lwcGluZyB0ZXh0dXJlLicsIHR5cGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVycztcblxuXHRcdH0sXG5cblx0XHQvLyBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmVNYXAgZm9yIHVzZSBieSBhIG1hdGVyaWFsLlxuXHRcdGdldFRleHR1cmU6IGZ1bmN0aW9uICggdGV4dHVyZU1hcCwgaWQgKSB7XG5cblx0XHRcdC8vIGlmIHRoZSB0ZXh0dXJlIGlzIGEgbGF5ZXJlZCB0ZXh0dXJlLCBqdXN0IHVzZSB0aGUgZmlyc3QgbGF5ZXIgYW5kIGlzc3VlIGEgd2FybmluZ1xuXHRcdFx0aWYgKCAnTGF5ZXJlZFRleHR1cmUnIGluIGZieFRyZWUuT2JqZWN0cyAmJiBpZCBpbiBmYnhUcmVlLk9iamVjdHMuTGF5ZXJlZFRleHR1cmUgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBsYXllcmVkIHRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRocmVlLmpzLiBEaXNjYXJkaW5nIGFsbCBidXQgZmlyc3QgbGF5ZXIuJyApO1xuXHRcdFx0XHRpZCA9IGNvbm5lY3Rpb25zLmdldCggaWQgKS5jaGlsZHJlblsgMCBdLklEO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZXh0dXJlTWFwLmdldCggaWQgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuRGVmb3JtZXJcblx0XHQvLyBEZWZvcm1lciBub2RlIGNhbiBjb250YWluIHNraW5uaW5nIG9yIFZlcnRleCBDYWNoZSBhbmltYXRpb24gZGF0YSwgaG93ZXZlciBvbmx5IHNraW5uaW5nIGlzIHN1cHBvcnRlZCBoZXJlXG5cdFx0Ly8gR2VuZXJhdGVzIG1hcCBvZiBTa2VsZXRvbi1saWtlIG9iamVjdHMgZm9yIHVzZSBsYXRlciB3aGVuIGdlbmVyYXRpbmcgYW5kIGJpbmRpbmcgc2tlbGV0b25zLlxuXHRcdHBhcnNlRGVmb3JtZXJzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBza2VsZXRvbnMgPSB7fTtcblx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSB7fTtcblxuXHRcdFx0aWYgKCAnRGVmb3JtZXInIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgRGVmb3JtZXJOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5EZWZvcm1lcjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIERlZm9ybWVyTm9kZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGVmb3JtZXJOb2RlID0gRGVmb3JtZXJOb2Rlc1sgbm9kZUlEIF07XG5cblx0XHRcdFx0XHR2YXIgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIG5vZGVJRCApICk7XG5cblx0XHRcdFx0XHRpZiAoIGRlZm9ybWVyTm9kZS5hdHRyVHlwZSA9PT0gJ1NraW4nICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgc2tlbGV0b24gPSB0aGlzLnBhcnNlU2tlbGV0b24oIHJlbGF0aW9uc2hpcHMsIERlZm9ybWVyTm9kZXMgKTtcblx0XHRcdFx0XHRcdHNrZWxldG9uLklEID0gbm9kZUlEO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJlbGF0aW9uc2hpcHMucGFyZW50cy5sZW5ndGggPiAxICkgY29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBza2VsZXRvbiBhdHRhY2hlZCB0byBtb3JlIHRoYW4gb25lIGdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdFx0c2tlbGV0b24uZ2VvbWV0cnlJRCA9IHJlbGF0aW9uc2hpcHMucGFyZW50c1sgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRza2VsZXRvbnNbIG5vZGVJRCBdID0gc2tlbGV0b247XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkZWZvcm1lck5vZGUuYXR0clR5cGUgPT09ICdCbGVuZFNoYXBlJyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0ge1xuXHRcdFx0XHRcdFx0XHRpZDogbm9kZUlELFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXQucmF3VGFyZ2V0cyA9IHRoaXMucGFyc2VNb3JwaFRhcmdldHMoIHJlbGF0aW9uc2hpcHMsIERlZm9ybWVyTm9kZXMgKTtcblx0XHRcdFx0XHRcdG1vcnBoVGFyZ2V0LmlkID0gbm9kZUlEO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJlbGF0aW9uc2hpcHMucGFyZW50cy5sZW5ndGggPiAxICkgY29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBtb3JwaCB0YXJnZXQgYXR0YWNoZWQgdG8gbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXRzWyBub2RlSUQgXSA9IG1vcnBoVGFyZ2V0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXG5cdFx0XHRcdHNrZWxldG9uczogc2tlbGV0b25zLFxuXHRcdFx0XHRtb3JwaFRhcmdldHM6IG1vcnBoVGFyZ2V0cyxcblxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBzaW5nbGUgbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkRlZm9ybWVyXG5cdFx0Ly8gVGhlIHRvcCBsZXZlbCBza2VsZXRvbiBub2RlIGhhcyB0eXBlICdTa2luJyBhbmQgc3ViIG5vZGVzIGhhdmUgdHlwZSAnQ2x1c3Rlcidcblx0XHQvLyBFYWNoIHNraW4gbm9kZSByZXByZXNlbnRzIGEgc2tlbGV0b24gYW5kIGVhY2ggY2x1c3RlciBub2RlIHJlcHJlc2VudHMgYSBib25lXG5cdFx0cGFyc2VTa2VsZXRvbjogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBkZWZvcm1lck5vZGVzICkge1xuXG5cdFx0XHR2YXIgcmF3Qm9uZXMgPSBbXTtcblxuXHRcdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdHZhciBib25lTm9kZSA9IGRlZm9ybWVyTm9kZXNbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0aWYgKCBib25lTm9kZS5hdHRyVHlwZSAhPT0gJ0NsdXN0ZXInICkgcmV0dXJuO1xuXG5cdFx0XHRcdHZhciByYXdCb25lID0ge1xuXG5cdFx0XHRcdFx0SUQ6IGNoaWxkLklELFxuXHRcdFx0XHRcdGluZGljZXM6IFtdLFxuXHRcdFx0XHRcdHdlaWdodHM6IFtdLFxuXHRcdFx0XHRcdHRyYW5zZm9ybUxpbms6IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBib25lTm9kZS5UcmFuc2Zvcm1MaW5rLmEgKSxcblx0XHRcdFx0XHQvLyB0cmFuc2Zvcm06IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBib25lTm9kZS5UcmFuc2Zvcm0uYSApLFxuXHRcdFx0XHRcdC8vIGxpbmtNb2RlOiBib25lTm9kZS5Nb2RlLFxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCAnSW5kZXhlcycgaW4gYm9uZU5vZGUgKSB7XG5cblx0XHRcdFx0XHRyYXdCb25lLmluZGljZXMgPSBib25lTm9kZS5JbmRleGVzLmE7XG5cdFx0XHRcdFx0cmF3Qm9uZS53ZWlnaHRzID0gYm9uZU5vZGUuV2VpZ2h0cy5hO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyYXdCb25lcy5wdXNoKCByYXdCb25lICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHtcblxuXHRcdFx0XHRyYXdCb25lczogcmF3Qm9uZXMsXG5cdFx0XHRcdGJvbmVzOiBbXVxuXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIFRoZSB0b3AgbGV2ZWwgbW9ycGggZGVmb3JtZXIgbm9kZSBoYXMgdHlwZSBcIkJsZW5kU2hhcGVcIiBhbmQgc3ViIG5vZGVzIGhhdmUgdHlwZSBcIkJsZW5kU2hhcGVDaGFubmVsXCJcblx0XHRwYXJzZU1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBkZWZvcm1lck5vZGVzICkge1xuXG5cdFx0XHR2YXIgcmF3TW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHJlbGF0aW9uc2hpcHMuY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROb2RlID0gZGVmb3JtZXJOb2Rlc1sgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHR2YXIgcmF3TW9ycGhUYXJnZXQgPSB7XG5cblx0XHRcdFx0XHRuYW1lOiBtb3JwaFRhcmdldE5vZGUuYXR0ck5hbWUsXG5cdFx0XHRcdFx0aW5pdGlhbFdlaWdodDogbW9ycGhUYXJnZXROb2RlLkRlZm9ybVBlcmNlbnQsXG5cdFx0XHRcdFx0aWQ6IG1vcnBoVGFyZ2V0Tm9kZS5pZCxcblx0XHRcdFx0XHRmdWxsV2VpZ2h0czogbW9ycGhUYXJnZXROb2RlLkZ1bGxXZWlnaHRzLmFcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmICggbW9ycGhUYXJnZXROb2RlLmF0dHJUeXBlICE9PSAnQmxlbmRTaGFwZUNoYW5uZWwnICkgcmV0dXJuO1xuXG5cdFx0XHRcdHJhd01vcnBoVGFyZ2V0Lmdlb0lEID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggY2hpbGQuSUQgKSApLmNoaWxkcmVuLmZpbHRlciggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBjaGlsZC5yZWxhdGlvbnNoaXAgPT09IHVuZGVmaW5lZDtcblxuXHRcdFx0XHR9IClbIDAgXS5JRDtcblxuXHRcdFx0XHRyYXdNb3JwaFRhcmdldHMucHVzaCggcmF3TW9ycGhUYXJnZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmF3TW9ycGhUYXJnZXRzO1xuXG5cdFx0fSxcblxuXHRcdC8vIGNyZWF0ZSB0aGUgbWFpbiBHcm91cCgpIHRvIGJlIHJldHVybmVkIGJ5IHRoZSBsb2FkZXJcblx0XHRwYXJzZVNjZW5lOiBmdW5jdGlvbiAoIGRlZm9ybWVycywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICkge1xuXG5cdFx0XHRzY2VuZUdyYXBoID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdHZhciBtb2RlbE1hcCA9IHRoaXMucGFyc2VNb2RlbHMoIGRlZm9ybWVycy5za2VsZXRvbnMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApO1xuXG5cdFx0XHR2YXIgbW9kZWxOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbDtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdG1vZGVsTWFwLmZvckVhY2goIGZ1bmN0aW9uICggbW9kZWwgKSB7XG5cblx0XHRcdFx0dmFyIG1vZGVsTm9kZSA9IG1vZGVsTm9kZXNbIG1vZGVsLklEIF07XG5cdFx0XHRcdHNjb3BlLnNldExvb2tBdFByb3BlcnRpZXMoIG1vZGVsLCBtb2RlbE5vZGUgKTtcblxuXHRcdFx0XHR2YXIgcGFyZW50Q29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucy5nZXQoIG1vZGVsLklEICkucGFyZW50cztcblxuXHRcdFx0XHRwYXJlbnRDb25uZWN0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbiAoIGNvbm5lY3Rpb24gKSB7XG5cblx0XHRcdFx0XHR2YXIgcGFyZW50ID0gbW9kZWxNYXAuZ2V0KCBjb25uZWN0aW9uLklEICk7XG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgIT09IHVuZGVmaW5lZCApIHBhcmVudC5hZGQoIG1vZGVsICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGlmICggbW9kZWwucGFyZW50ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0c2NlbmVHcmFwaC5hZGQoIG1vZGVsICk7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5iaW5kU2tlbGV0b24oIGRlZm9ybWVycy5za2VsZXRvbnMsIGdlb21ldHJ5TWFwLCBtb2RlbE1hcCApO1xuXG5cdFx0XHR0aGlzLmNyZWF0ZUFtYmllbnRMaWdodCgpO1xuXG5cdFx0XHR0aGlzLnNldHVwTW9ycGhNYXRlcmlhbHMoKTtcblxuXHRcdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdGlmICggbm9kZS51c2VyRGF0YS50cmFuc2Zvcm1EYXRhICkge1xuXG5cdFx0XHRcdFx0aWYgKCBub2RlLnBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0bm9kZS51c2VyRGF0YS50cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeCA9IG5vZGUucGFyZW50Lm1hdHJpeDtcblx0XHRcdFx0XHRcdG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXhXb3JsZCA9IG5vZGUucGFyZW50Lm1hdHJpeFdvcmxkO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IGdlbmVyYXRlVHJhbnNmb3JtKCBub2RlLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEgKTtcblxuXHRcdFx0XHRcdG5vZGUuYXBwbHlNYXRyaXg0KCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRub2RlLnVwZGF0ZVdvcmxkTWF0cml4KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvblBhcnNlcigpLnBhcnNlKCk7XG5cblx0XHRcdC8vIGlmIGFsbCB0aGUgbW9kZWxzIHdoZXJlIGFscmVhZHkgY29tYmluZWQgaW4gYSBzaW5nbGUgZ3JvdXAsIGp1c3QgcmV0dXJuIHRoYXRcblx0XHRcdGlmICggc2NlbmVHcmFwaC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgc2NlbmVHcmFwaC5jaGlsZHJlblsgMCBdLmlzR3JvdXAgKSB7XG5cblx0XHRcdFx0c2NlbmVHcmFwaC5jaGlsZHJlblsgMCBdLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0XHRzY2VuZUdyYXBoID0gc2NlbmVHcmFwaC5jaGlsZHJlblsgMCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjZW5lR3JhcGguYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLk1vZGVsXG5cdFx0cGFyc2VNb2RlbHM6IGZ1bmN0aW9uICggc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKSB7XG5cblx0XHRcdHZhciBtb2RlbE1hcCA9IG5ldyBNYXAoKTtcblx0XHRcdHZhciBtb2RlbE5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsO1xuXG5cdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIG1vZGVsTm9kZXMgKSB7XG5cblx0XHRcdFx0dmFyIGlkID0gcGFyc2VJbnQoIG5vZGVJRCApO1xuXHRcdFx0XHR2YXIgbm9kZSA9IG1vZGVsTm9kZXNbIG5vZGVJRCBdO1xuXHRcdFx0XHR2YXIgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggaWQgKTtcblxuXHRcdFx0XHR2YXIgbW9kZWwgPSB0aGlzLmJ1aWxkU2tlbGV0b24oIHJlbGF0aW9uc2hpcHMsIHNrZWxldG9ucywgaWQsIG5vZGUuYXR0ck5hbWUgKTtcblxuXHRcdFx0XHRpZiAoICEgbW9kZWwgKSB7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBub2RlLmF0dHJUeXBlICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdDYW1lcmEnOlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IHRoaXMuY3JlYXRlQ2FtZXJhKCByZWxhdGlvbnNoaXBzICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTGlnaHQnOlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IHRoaXMuY3JlYXRlTGlnaHQoIHJlbGF0aW9uc2hpcHMgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdNZXNoJzpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSB0aGlzLmNyZWF0ZU1lc2goIHJlbGF0aW9uc2hpcHMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ051cmJzQ3VydmUnOlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IHRoaXMuY3JlYXRlQ3VydmUoIHJlbGF0aW9uc2hpcHMsIGdlb21ldHJ5TWFwICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTGltYk5vZGUnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnUm9vdCc6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IEJvbmUoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdOdWxsJzpcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bW9kZWwubmFtZSA9IG5vZGUuYXR0ck5hbWUgPyBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggbm9kZS5hdHRyTmFtZSApIDogJyc7XG5cblx0XHRcdFx0XHRtb2RlbC5JRCA9IGlkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmdldFRyYW5zZm9ybURhdGEoIG1vZGVsLCBub2RlICk7XG5cdFx0XHRcdG1vZGVsTWFwLnNldCggaWQsIG1vZGVsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1vZGVsTWFwO1xuXG5cdFx0fSxcblxuXHRcdGJ1aWxkU2tlbGV0b246IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgc2tlbGV0b25zLCBpZCwgbmFtZSApIHtcblxuXHRcdFx0dmFyIGJvbmUgPSBudWxsO1xuXG5cdFx0XHRyZWxhdGlvbnNoaXBzLnBhcmVudHMuZm9yRWFjaCggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIElEIGluIHNrZWxldG9ucyApIHtcblxuXHRcdFx0XHRcdHZhciBza2VsZXRvbiA9IHNrZWxldG9uc1sgSUQgXTtcblxuXHRcdFx0XHRcdHNrZWxldG9uLnJhd0JvbmVzLmZvckVhY2goIGZ1bmN0aW9uICggcmF3Qm9uZSwgaSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCByYXdCb25lLklEID09PSBwYXJlbnQuSUQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHN1YkJvbmUgPSBib25lO1xuXHRcdFx0XHRcdFx0XHRib25lID0gbmV3IEJvbmUoKTtcblxuXHRcdFx0XHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmNvcHkoIHJhd0JvbmUudHJhbnNmb3JtTGluayApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHNldCBuYW1lIGFuZCBpZCBoZXJlIC0gb3RoZXJ3aXNlIGluIGNhc2VzIHdoZXJlIFwic3ViQm9uZVwiIGlzIGNyZWF0ZWQgaXQgd2lsbCBub3QgaGF2ZSBhIG5hbWUgLyBpZFxuXG5cdFx0XHRcdFx0XHRcdGJvbmUubmFtZSA9IG5hbWUgPyBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggbmFtZSApIDogJyc7XG5cdFx0XHRcdFx0XHRcdGJvbmUuSUQgPSBpZDtcblxuXHRcdFx0XHRcdFx0XHRza2VsZXRvbi5ib25lc1sgaSBdID0gYm9uZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBJbiBjYXNlcyB3aGVyZSBhIGJvbmUgaXMgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgbWVzaGVzXG5cdFx0XHRcdFx0XHRcdC8vIGR1cGxpY2F0ZSB0aGUgYm9uZSBoZXJlIGFuZCBhbmQgaXQgYXMgYSBjaGlsZCBvZiB0aGUgZmlyc3QgYm9uZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHN1YkJvbmUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRib25lLmFkZCggc3ViQm9uZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gYm9uZTtcblxuXHRcdH0sXG5cblx0XHQvLyBjcmVhdGUgYSBQZXJzcGVjdGl2ZUNhbWVyYSBvciBPcnRob2dyYXBoaWNDYW1lcmFcblx0XHRjcmVhdGVDYW1lcmE6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcyApIHtcblxuXHRcdFx0dmFyIG1vZGVsO1xuXHRcdFx0dmFyIGNhbWVyYUF0dHJpYnV0ZTtcblxuXHRcdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdHZhciBhdHRyID0gZmJ4VHJlZS5PYmplY3RzLk5vZGVBdHRyaWJ1dGVbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0aWYgKCBhdHRyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjYW1lcmFBdHRyaWJ1dGUgPSBhdHRyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1vZGVsID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHR5cGUgPSAwO1xuXHRcdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5DYW1lcmFQcm9qZWN0aW9uVHlwZSAhPT0gdW5kZWZpbmVkICYmIGNhbWVyYUF0dHJpYnV0ZS5DYW1lcmFQcm9qZWN0aW9uVHlwZS52YWx1ZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdHR5cGUgPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbmVhckNsaXBwaW5nUGxhbmUgPSAxO1xuXHRcdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5OZWFyUGxhbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5lYXJDbGlwcGluZ1BsYW5lID0gY2FtZXJhQXR0cmlidXRlLk5lYXJQbGFuZS52YWx1ZSAvIDEwMDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmYXJDbGlwcGluZ1BsYW5lID0gMTAwMDtcblx0XHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUuRmFyUGxhbmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZhckNsaXBwaW5nUGxhbmUgPSBjYW1lcmFBdHRyaWJ1dGUuRmFyUGxhbmUudmFsdWUgLyAxMDAwO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdFx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkFzcGVjdFdpZHRoICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhQXR0cmlidXRlLkFzcGVjdEhlaWdodCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0d2lkdGggPSBjYW1lcmFBdHRyaWJ1dGUuQXNwZWN0V2lkdGgudmFsdWU7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gY2FtZXJhQXR0cmlidXRlLkFzcGVjdEhlaWdodC52YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuXG5cdFx0XHRcdHZhciBmb3YgPSA0NTtcblx0XHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUuRmllbGRPZlZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGZvdiA9IGNhbWVyYUF0dHJpYnV0ZS5GaWVsZE9mVmlldy52YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZvY2FsTGVuZ3RoID0gY2FtZXJhQXR0cmlidXRlLkZvY2FsTGVuZ3RoID8gY2FtZXJhQXR0cmlidXRlLkZvY2FsTGVuZ3RoLnZhbHVlIDogbnVsbDtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAwOiAvLyBQZXJzcGVjdGl2ZVxuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyQ2xpcHBpbmdQbGFuZSwgZmFyQ2xpcHBpbmdQbGFuZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBmb2NhbExlbmd0aCAhPT0gbnVsbCApIG1vZGVsLnNldEZvY2FsTGVuZ3RoKCBmb2NhbExlbmd0aCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDE6IC8vIE9ydGhvZ3JhcGhpY1xuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIHdpZHRoIC8gMiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAtIGhlaWdodCAvIDIsIG5lYXJDbGlwcGluZ1BsYW5lLCBmYXJDbGlwcGluZ1BsYW5lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IFVua25vd24gY2FtZXJhIHR5cGUgJyArIHR5cGUgKyAnLicgKTtcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1vZGVsO1xuXG5cdFx0fSxcblxuXHRcdC8vIENyZWF0ZSBhIERpcmVjdGlvbmFsTGlnaHQsIFBvaW50TGlnaHQgb3IgU3BvdExpZ2h0XG5cdFx0Y3JlYXRlTGlnaHQ6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcyApIHtcblxuXHRcdFx0dmFyIG1vZGVsO1xuXHRcdFx0dmFyIGxpZ2h0QXR0cmlidXRlO1xuXG5cdFx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0dmFyIGF0dHIgPSBmYnhUcmVlLk9iamVjdHMuTm9kZUF0dHJpYnV0ZVsgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGxpZ2h0QXR0cmlidXRlID0gYXR0cjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1vZGVsID0gbmV3IE9iamVjdDNEKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHR5cGU7XG5cblx0XHRcdFx0Ly8gTGlnaHRUeXBlIGNhbiBiZSB1bmRlZmluZWQgZm9yIFBvaW50IGxpZ2h0c1xuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkxpZ2h0VHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dHlwZSA9IDA7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHR5cGUgPSBsaWdodEF0dHJpYnV0ZS5MaWdodFR5cGUudmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb2xvciA9IDB4ZmZmZmZmO1xuXG5cdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuQ29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBsaWdodEF0dHJpYnV0ZS5Db2xvci52YWx1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW50ZW5zaXR5ID0gKCBsaWdodEF0dHJpYnV0ZS5JbnRlbnNpdHkgPT09IHVuZGVmaW5lZCApID8gMSA6IGxpZ2h0QXR0cmlidXRlLkludGVuc2l0eS52YWx1ZSAvIDEwMDtcblxuXHRcdFx0XHQvLyBsaWdodCBkaXNhYmxlZFxuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkNhc3RMaWdodE9uT2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgbGlnaHRBdHRyaWJ1dGUuQ2FzdExpZ2h0T25PYmplY3QudmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRpbnRlbnNpdHkgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSAwO1xuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkZhckF0dGVudWF0aW9uRW5kICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkVuYWJsZUZhckF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgJiYgbGlnaHRBdHRyaWJ1dGUuRW5hYmxlRmFyQXR0ZW51YXRpb24udmFsdWUgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gMDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGRpc3RhbmNlID0gbGlnaHRBdHRyaWJ1dGUuRmFyQXR0ZW51YXRpb25FbmQudmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRPRE86IGNvdWxkIHRoaXMgYmUgY2FsY3VsYXRlZCBsaW5lYXJseSBmcm9tIEZhckF0dGVudWF0aW9uU3RhcnQgdG8gRmFyQXR0ZW51YXRpb25FbmQ/XG5cdFx0XHRcdHZhciBkZWNheSA9IDE7XG5cblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgMDogLy8gUG9pbnRcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDE6IC8vIERpcmVjdGlvbmFsXG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMjogLy8gU3BvdFxuXHRcdFx0XHRcdFx0dmFyIGFuZ2xlID0gTWF0aC5QSSAvIDM7XG5cblx0XHRcdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuSW5uZXJBbmdsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBsaWdodEF0dHJpYnV0ZS5Jbm5lckFuZ2xlLnZhbHVlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIHBlbnVtYnJhID0gMDtcblx0XHRcdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuT3V0ZXJBbmdsZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IHRoaXMgaXMgbm90IGNvcnJlY3QgLSBGQlggY2FsY3VsYXRlcyBvdXRlciBhbmQgaW5uZXIgYW5nbGUgaW4gZGVncmVlc1xuXHRcdFx0XHRcdFx0XHQvLyB3aXRoIE91dGVyQW5nbGUgPiBJbm5lckFuZ2xlICYmIE91dGVyQW5nbGUgPD0gTWF0aC5QSVxuXHRcdFx0XHRcdFx0XHQvLyB3aGlsZSB0aHJlZS5qcyB1c2VzIGEgcGVudW1icmEgYmV0d2VlbiAoMCwgMSkgdG8gYXR0ZW51YXRlIHRoZSBpbm5lciBhbmdsZVxuXHRcdFx0XHRcdFx0XHRwZW51bWJyYSA9IE1hdGhVdGlscy5kZWdUb1JhZCggbGlnaHRBdHRyaWJ1dGUuT3V0ZXJBbmdsZS52YWx1ZSApO1xuXHRcdFx0XHRcdFx0XHRwZW51bWJyYSA9IE1hdGgubWF4KCBwZW51bWJyYSwgMSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IFNwb3RMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBwZW51bWJyYSwgZGVjYXkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBsaWdodCB0eXBlICcgKyBsaWdodEF0dHJpYnV0ZS5MaWdodFR5cGUudmFsdWUgKyAnLCBkZWZhdWx0aW5nIHRvIGEgUG9pbnRMaWdodC4nICk7XG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBQb2ludExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5DYXN0U2hhZG93cyAhPT0gdW5kZWZpbmVkICYmIGxpZ2h0QXR0cmlidXRlLkNhc3RTaGFkb3dzLnZhbHVlID09PSAxICkge1xuXG5cdFx0XHRcdFx0bW9kZWwuY2FzdFNoYWRvdyA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtb2RlbDtcblxuXHRcdH0sXG5cblx0XHRjcmVhdGVNZXNoOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApIHtcblxuXHRcdFx0dmFyIG1vZGVsO1xuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbnVsbDtcblx0XHRcdHZhciBtYXRlcmlhbCA9IG51bGw7XG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gW107XG5cblx0XHRcdC8vIGdldCBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzKHMpIGZyb20gY29ubmVjdGlvbnNcblx0XHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5TWFwLmhhcyggY2hpbGQuSUQgKSApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5ID0gZ2VvbWV0cnlNYXAuZ2V0KCBjaGlsZC5JRCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsTWFwLmhhcyggY2hpbGQuSUQgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbE1hcC5nZXQoIGNoaWxkLklEICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFscztcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBtYXRlcmlhbHNbIDAgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCggeyBjb2xvcjogMHhjY2NjY2MgfSApO1xuXHRcdFx0XHRtYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICdjb2xvcicgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbHMuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuRkJYX0RlZm9ybWVyICkge1xuXG5cdFx0XHRcdG1hdGVyaWFscy5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRtb2RlbCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0XHRcdG1vZGVsLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bW9kZWwgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1vZGVsO1xuXG5cdFx0fSxcblxuXHRcdGNyZWF0ZUN1cnZlOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGdlb21ldHJ5TWFwICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSByZWxhdGlvbnNoaXBzLmNoaWxkcmVuLnJlZHVjZSggZnVuY3Rpb24gKCBnZW8sIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlNYXAuaGFzKCBjaGlsZC5JRCApICkgZ2VvID0gZ2VvbWV0cnlNYXAuZ2V0KCBjaGlsZC5JRCApO1xuXG5cdFx0XHRcdHJldHVybiBnZW87XG5cblx0XHRcdH0sIG51bGwgKTtcblxuXHRcdFx0Ly8gRkJYIGRvZXMgbm90IGxpc3QgbWF0ZXJpYWxzIGZvciBOdXJicyBsaW5lcywgc28gd2UnbGwganVzdCBwdXQgb3VyIG93biBpbiBoZXJlLlxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweDMzMDBmZiwgbGluZXdpZHRoOiAxIH0gKTtcblx0XHRcdHJldHVybiBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2UgdGhlIG1vZGVsIG5vZGUgZm9yIHRyYW5zZm9ybSBkYXRhXG5cdFx0Z2V0VHJhbnNmb3JtRGF0YTogZnVuY3Rpb24gKCBtb2RlbCwgbW9kZWxOb2RlICkge1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtRGF0YSA9IHt9O1xuXG5cdFx0XHRpZiAoICdJbmhlcml0VHlwZScgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSA9IHBhcnNlSW50KCBtb2RlbE5vZGUuSW5oZXJpdFR5cGUudmFsdWUgKTtcblxuXHRcdFx0aWYgKCAnUm90YXRpb25PcmRlcicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyID0gZ2V0RXVsZXJPcmRlciggbW9kZWxOb2RlLlJvdGF0aW9uT3JkZXIudmFsdWUgKTtcblx0XHRcdGVsc2UgdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyID0gJ1pZWCc7XG5cblx0XHRcdGlmICggJ0xjbF9UcmFuc2xhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiA9IG1vZGVsTm9kZS5MY2xfVHJhbnNsYXRpb24udmFsdWU7XG5cblx0XHRcdGlmICggJ1ByZVJvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnByZVJvdGF0aW9uID0gbW9kZWxOb2RlLlByZVJvdGF0aW9uLnZhbHVlO1xuXHRcdFx0aWYgKCAnTGNsX1JvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uID0gbW9kZWxOb2RlLkxjbF9Sb3RhdGlvbi52YWx1ZTtcblx0XHRcdGlmICggJ1Bvc3RSb3RhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5wb3N0Um90YXRpb24gPSBtb2RlbE5vZGUuUG9zdFJvdGF0aW9uLnZhbHVlO1xuXG5cdFx0XHRpZiAoICdMY2xfU2NhbGluZycgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsZSA9IG1vZGVsTm9kZS5MY2xfU2NhbGluZy52YWx1ZTtcblxuXHRcdFx0aWYgKCAnU2NhbGluZ09mZnNldCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsaW5nT2Zmc2V0ID0gbW9kZWxOb2RlLlNjYWxpbmdPZmZzZXQudmFsdWU7XG5cdFx0XHRpZiAoICdTY2FsaW5nUGl2b3QnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuc2NhbGluZ1Bpdm90ID0gbW9kZWxOb2RlLlNjYWxpbmdQaXZvdC52YWx1ZTtcblxuXHRcdFx0aWYgKCAnUm90YXRpb25PZmZzZXQnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb25PZmZzZXQgPSBtb2RlbE5vZGUuUm90YXRpb25PZmZzZXQudmFsdWU7XG5cdFx0XHRpZiAoICdSb3RhdGlvblBpdm90JyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uUGl2b3QgPSBtb2RlbE5vZGUuUm90YXRpb25QaXZvdC52YWx1ZTtcblxuXHRcdFx0bW9kZWwudXNlckRhdGEudHJhbnNmb3JtRGF0YSA9IHRyYW5zZm9ybURhdGE7XG5cblx0XHR9LFxuXG5cdFx0c2V0TG9va0F0UHJvcGVydGllczogZnVuY3Rpb24gKCBtb2RlbCwgbW9kZWxOb2RlICkge1xuXG5cdFx0XHRpZiAoICdMb29rQXRQcm9wZXJ0eScgaW4gbW9kZWxOb2RlICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IGNvbm5lY3Rpb25zLmdldCggbW9kZWwuSUQgKS5jaGlsZHJlbjtcblxuXHRcdFx0XHRjaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC5yZWxhdGlvbnNoaXAgPT09ICdMb29rQXRQcm9wZXJ0eScgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBsb29rQXRUYXJnZXQgPSBmYnhUcmVlLk9iamVjdHMuTW9kZWxbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0XHRcdGlmICggJ0xjbF9UcmFuc2xhdGlvbicgaW4gbG9va0F0VGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBwb3MgPSBsb29rQXRUYXJnZXQuTGNsX1RyYW5zbGF0aW9uLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIERpcmVjdGlvbmFsTGlnaHQsIFNwb3RMaWdodFxuXHRcdFx0XHRcdFx0XHRpZiAoIG1vZGVsLnRhcmdldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bW9kZWwudGFyZ2V0LnBvc2l0aW9uLmZyb21BcnJheSggcG9zICk7XG5cdFx0XHRcdFx0XHRcdFx0c2NlbmVHcmFwaC5hZGQoIG1vZGVsLnRhcmdldCApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIENhbWVyYXMgYW5kIG90aGVyIE9iamVjdDNEc1xuXG5cdFx0XHRcdFx0XHRcdFx0bW9kZWwubG9va0F0KCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9zICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRiaW5kU2tlbGV0b246IGZ1bmN0aW9uICggc2tlbGV0b25zLCBnZW9tZXRyeU1hcCwgbW9kZWxNYXAgKSB7XG5cblx0XHRcdHZhciBiaW5kTWF0cmljZXMgPSB0aGlzLnBhcnNlUG9zZU5vZGVzKCk7XG5cblx0XHRcdGZvciAoIHZhciBJRCBpbiBza2VsZXRvbnMgKSB7XG5cblx0XHRcdFx0dmFyIHNrZWxldG9uID0gc2tlbGV0b25zWyBJRCBdO1xuXG5cdFx0XHRcdHZhciBwYXJlbnRzID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggc2tlbGV0b24uSUQgKSApLnBhcmVudHM7XG5cblx0XHRcdFx0cGFyZW50cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlNYXAuaGFzKCBwYXJlbnQuSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGdlb0lEID0gcGFyZW50LklEO1xuXHRcdFx0XHRcdFx0dmFyIGdlb1JlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIGdlb0lEICk7XG5cblx0XHRcdFx0XHRcdGdlb1JlbGF0aW9uc2hpcHMucGFyZW50cy5mb3JFYWNoKCBmdW5jdGlvbiAoIGdlb0Nvbm5QYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtb2RlbE1hcC5oYXMoIGdlb0Nvbm5QYXJlbnQuSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBtb2RlbCA9IG1vZGVsTWFwLmdldCggZ2VvQ29ublBhcmVudC5JRCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0bW9kZWwuYmluZCggbmV3IFNrZWxldG9uKCBza2VsZXRvbi5ib25lcyApLCBiaW5kTWF0cmljZXNbIGdlb0Nvbm5QYXJlbnQuSUQgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHBhcnNlUG9zZU5vZGVzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBiaW5kTWF0cmljZXMgPSB7fTtcblxuXHRcdFx0aWYgKCAnUG9zZScgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciBCaW5kUG9zZU5vZGUgPSBmYnhUcmVlLk9iamVjdHMuUG9zZTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIEJpbmRQb3NlTm9kZSApIHtcblxuXHRcdFx0XHRcdGlmICggQmluZFBvc2VOb2RlWyBub2RlSUQgXS5hdHRyVHlwZSA9PT0gJ0JpbmRQb3NlJyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHBvc2VOb2RlcyA9IEJpbmRQb3NlTm9kZVsgbm9kZUlEIF0uUG9zZU5vZGU7XG5cblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggcG9zZU5vZGVzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9zZU5vZGVzLmZvckVhY2goIGZ1bmN0aW9uICggcG9zZU5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRiaW5kTWF0cmljZXNbIHBvc2VOb2RlLk5vZGUgXSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBwb3NlTm9kZS5NYXRyaXguYSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRiaW5kTWF0cmljZXNbIHBvc2VOb2Rlcy5Ob2RlIF0gPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggcG9zZU5vZGVzLk1hdHJpeC5hICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJpbmRNYXRyaWNlcztcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBhbWJpZW50IGNvbG9yIGluIEZCWFRyZWUuR2xvYmFsU2V0dGluZ3MgLSBpZiBpdCdzIG5vdCBzZXQgdG8gYmxhY2sgKGRlZmF1bHQpLCBjcmVhdGUgYW4gYW1iaWVudCBsaWdodFxuXHRcdGNyZWF0ZUFtYmllbnRMaWdodDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoICdHbG9iYWxTZXR0aW5ncycgaW4gZmJ4VHJlZSAmJiAnQW1iaWVudENvbG9yJyBpbiBmYnhUcmVlLkdsb2JhbFNldHRpbmdzICkge1xuXG5cdFx0XHRcdHZhciBhbWJpZW50Q29sb3IgPSBmYnhUcmVlLkdsb2JhbFNldHRpbmdzLkFtYmllbnRDb2xvci52YWx1ZTtcblx0XHRcdFx0dmFyIHIgPSBhbWJpZW50Q29sb3JbIDAgXTtcblx0XHRcdFx0dmFyIGcgPSBhbWJpZW50Q29sb3JbIDEgXTtcblx0XHRcdFx0dmFyIGIgPSBhbWJpZW50Q29sb3JbIDIgXTtcblxuXHRcdFx0XHRpZiAoIHIgIT09IDAgfHwgZyAhPT0gMCB8fCBiICE9PSAwICkge1xuXG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gbmV3IENvbG9yKCByLCBnLCBiICk7XG5cdFx0XHRcdFx0c2NlbmVHcmFwaC5hZGQoIG5ldyBBbWJpZW50TGlnaHQoIGNvbG9yLCAxICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRzZXR1cE1vcnBoTWF0ZXJpYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggY2hpbGQuaXNNZXNoICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gJiYgY2hpbGQuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBjaGlsZC5tYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRcdGNoaWxkLm1hdGVyaWFsLmZvckVhY2goIGZ1bmN0aW9uICggbWF0ZXJpYWwsIGkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzY29wZS5zZXR1cE1vcnBoTWF0ZXJpYWwoIGNoaWxkLCBtYXRlcmlhbCwgaSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzY29wZS5zZXR1cE1vcnBoTWF0ZXJpYWwoIGNoaWxkLCBjaGlsZC5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0dXBNb3JwaE1hdGVyaWFsOiBmdW5jdGlvbiAoIGNoaWxkLCBtYXRlcmlhbCwgaW5kZXggKSB7XG5cblx0XHRcdHZhciB1dWlkID0gY2hpbGQudXVpZDtcblx0XHRcdHZhciBtYXRVdWlkID0gbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0Ly8gaWYgYSBnZW9tZXRyeSBoYXMgbW9ycGggdGFyZ2V0cywgaXQgY2Fubm90IHNoYXJlIHRoZSBtYXRlcmlhbCB3aXRoIG90aGVyIGdlb21ldHJpZXNcblx0XHRcdHZhciBzaGFyZWRNYXQgPSBmYWxzZTtcblxuXHRcdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHRcdGlmICggbm9kZS5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5vZGUubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdFx0bm9kZS5tYXRlcmlhbC5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdC51dWlkID09PSBtYXRVdWlkICYmIG5vZGUudXVpZCAhPT0gdXVpZCApIHNoYXJlZE1hdCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUubWF0ZXJpYWwudXVpZCA9PT0gbWF0VXVpZCAmJiBub2RlLnV1aWQgIT09IHV1aWQgKSBzaGFyZWRNYXQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIHNoYXJlZE1hdCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR2YXIgY2xvbmVkTWF0ID0gbWF0ZXJpYWwuY2xvbmUoKTtcblx0XHRcdFx0Y2xvbmVkTWF0Lm1vcnBoVGFyZ2V0cyA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkgY2hpbGQubWF0ZXJpYWwgPSBjbG9uZWRNYXQ7XG5cdFx0XHRcdGVsc2UgY2hpbGQubWF0ZXJpYWxbIGluZGV4IF0gPSBjbG9uZWRNYXQ7XG5cblx0XHRcdH0gZWxzZSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gcGFyc2UgR2VvbWV0cnkgZGF0YSBmcm9tIEZCWFRyZWUgYW5kIHJldHVybiBtYXAgb2YgQnVmZmVyR2VvbWV0cmllc1xuXHRmdW5jdGlvbiBHZW9tZXRyeVBhcnNlcigpIHt9XG5cblx0R2VvbWV0cnlQYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEdlb21ldHJ5UGFyc2VyLFxuXG5cdFx0Ly8gUGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggZGVmb3JtZXJzICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnlNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGlmICggJ0dlb21ldHJ5JyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIGdlb05vZGVzID0gZmJ4VHJlZS5PYmplY3RzLkdlb21ldHJ5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gZ2VvTm9kZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIG5vZGVJRCApICk7XG5cdFx0XHRcdFx0dmFyIGdlbyA9IHRoaXMucGFyc2VHZW9tZXRyeSggcmVsYXRpb25zaGlwcywgZ2VvTm9kZXNbIG5vZGVJRCBdLCBkZWZvcm1lcnMgKTtcblxuXHRcdFx0XHRcdGdlb21ldHJ5TWFwLnNldCggcGFyc2VJbnQoIG5vZGVJRCApLCBnZW8gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5TWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIHNpbmdsZSBub2RlIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRcdHBhcnNlR2VvbWV0cnk6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZ2VvTm9kZSwgZGVmb3JtZXJzICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBnZW9Ob2RlLmF0dHJUeXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ01lc2gnOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlTWVzaEdlb21ldHJ5KCByZWxhdGlvbnNoaXBzLCBnZW9Ob2RlLCBkZWZvcm1lcnMgKTtcblxuXHRcdFx0XHRjYXNlICdOdXJic0N1cnZlJzpcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJzZU51cmJzR2VvbWV0cnkoIGdlb05vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXG5cdFx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGUgbWVzaCBnZW9tZXRyeSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0XHRwYXJzZU1lc2hHZW9tZXRyeTogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBnZW9Ob2RlLCBkZWZvcm1lcnMgKSB7XG5cblx0XHRcdHZhciBza2VsZXRvbnMgPSBkZWZvcm1lcnMuc2tlbGV0b25zO1xuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IFtdO1xuXG5cdFx0XHR2YXIgbW9kZWxOb2RlcyA9IHJlbGF0aW9uc2hpcHMucGFyZW50cy5tYXAoIGZ1bmN0aW9uICggcGFyZW50ICkge1xuXG5cdFx0XHRcdHJldHVybiBmYnhUcmVlLk9iamVjdHMuTW9kZWxbIHBhcmVudC5JRCBdO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIGRvbid0IGNyZWF0ZSBnZW9tZXRyeSBpZiBpdCBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSBtb2RlbHNcblx0XHRcdGlmICggbW9kZWxOb2Rlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHRcdHZhciBza2VsZXRvbiA9IHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4ucmVkdWNlKCBmdW5jdGlvbiAoIHNrZWxldG9uLCBjaGlsZCApIHtcblxuXHRcdFx0XHRpZiAoIHNrZWxldG9uc1sgY2hpbGQuSUQgXSAhPT0gdW5kZWZpbmVkICkgc2tlbGV0b24gPSBza2VsZXRvbnNbIGNoaWxkLklEIF07XG5cblx0XHRcdFx0cmV0dXJuIHNrZWxldG9uO1xuXG5cdFx0XHR9LCBudWxsICk7XG5cblx0XHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRpZiAoIGRlZm9ybWVycy5tb3JwaFRhcmdldHNbIGNoaWxkLklEIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1vcnBoVGFyZ2V0cy5wdXNoKCBkZWZvcm1lcnMubW9ycGhUYXJnZXRzWyBjaGlsZC5JRCBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIEFzc3VtZSBvbmUgbW9kZWwgYW5kIGdldCB0aGUgcHJlUm90YXRpb24gZnJvbSB0aGF0XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2VvbWV0cnkgdGhpcyBtYXkgY2F1c2UgcHJvYmxlbXNcblx0XHRcdHZhciBtb2RlbE5vZGUgPSBtb2RlbE5vZGVzWyAwIF07XG5cblx0XHRcdHZhciB0cmFuc2Zvcm1EYXRhID0ge307XG5cblx0XHRcdGlmICggJ1JvdGF0aW9uT3JkZXInIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciA9IGdldEV1bGVyT3JkZXIoIG1vZGVsTm9kZS5Sb3RhdGlvbk9yZGVyLnZhbHVlICk7XG5cdFx0XHRpZiAoICdJbmhlcml0VHlwZScgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5pbmhlcml0VHlwZSA9IHBhcnNlSW50KCBtb2RlbE5vZGUuSW5oZXJpdFR5cGUudmFsdWUgKTtcblxuXHRcdFx0aWYgKCAnR2VvbWV0cmljVHJhbnNsYXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gPSBtb2RlbE5vZGUuR2VvbWV0cmljVHJhbnNsYXRpb24udmFsdWU7XG5cdFx0XHRpZiAoICdHZW9tZXRyaWNSb3RhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvbiA9IG1vZGVsTm9kZS5HZW9tZXRyaWNSb3RhdGlvbi52YWx1ZTtcblx0XHRcdGlmICggJ0dlb21ldHJpY1NjYWxpbmcnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEuc2NhbGUgPSBtb2RlbE5vZGUuR2VvbWV0cmljU2NhbGluZy52YWx1ZTtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IGdlbmVyYXRlVHJhbnNmb3JtKCB0cmFuc2Zvcm1EYXRhICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmdlbkdlb21ldHJ5KCBnZW9Ob2RlLCBza2VsZXRvbiwgbW9ycGhUYXJnZXRzLCB0cmFuc2Zvcm0gKTtcblxuXHRcdH0sXG5cblx0XHQvLyBHZW5lcmF0ZSBhIEJ1ZmZlckdlb21ldHJ5IGZyb20gYSBub2RlIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRcdGdlbkdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb05vZGUsIHNrZWxldG9uLCBtb3JwaFRhcmdldHMsIHByZVRyYW5zZm9ybSApIHtcblxuXHRcdFx0dmFyIGdlbyA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0aWYgKCBnZW9Ob2RlLmF0dHJOYW1lICkgZ2VvLm5hbWUgPSBnZW9Ob2RlLmF0dHJOYW1lO1xuXG5cdFx0XHR2YXIgZ2VvSW5mbyA9IHRoaXMucGFyc2VHZW9Ob2RlKCBnZW9Ob2RlLCBza2VsZXRvbiApO1xuXHRcdFx0dmFyIGJ1ZmZlcnMgPSB0aGlzLmdlbkJ1ZmZlcnMoIGdlb0luZm8gKTtcblxuXHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMudmVydGV4LCAzICk7XG5cblx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLmFwcGx5TWF0cml4NCggcHJlVHJhbnNmb3JtICk7XG5cblx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cblx0XHRcdGlmICggYnVmZmVycy5jb2xvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy5jb2xvcnMsIDMgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2tlbGV0b24gKSB7XG5cblx0XHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIG5ldyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMsIDQgKSApO1xuXG5cdFx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdza2luV2VpZ2h0JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMudmVydGV4V2VpZ2h0cywgNCApICk7XG5cblx0XHRcdFx0Ly8gdXNlZCBsYXRlciB0byBiaW5kIHRoZSBza2VsZXRvbiB0byB0aGUgbW9kZWxcblx0XHRcdFx0Z2VvLkZCWF9EZWZvcm1lciA9IHNrZWxldG9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVmZmVycy5ub3JtYWwubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIHByZVRyYW5zZm9ybSApO1xuXG5cdFx0XHRcdHZhciBub3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy5ub3JtYWwsIDMgKTtcblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLmFwcGx5Tm9ybWFsTWF0cml4KCBub3JtYWxNYXRyaXggKTtcblxuXHRcdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnVmZmVycy51dnMuZm9yRWFjaCggZnVuY3Rpb24gKCB1dkJ1ZmZlciwgaSApIHtcblxuXHRcdFx0XHQvLyBzdWJzZXF1ZW50IHV2IGJ1ZmZlcnMgYXJlIGNhbGxlZCAndXYxJywgJ3V2MicsIC4uLlxuXHRcdFx0XHR2YXIgbmFtZSA9ICd1dicgKyAoIGkgKyAxICkudG9TdHJpbmcoKTtcblxuXHRcdFx0XHQvLyB0aGUgZmlyc3QgdXYgYnVmZmVyIGlzIGp1c3QgY2FsbGVkICd1didcblx0XHRcdFx0aWYgKCBpID09PSAwICkge1xuXG5cdFx0XHRcdFx0bmFtZSA9ICd1dic7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLnV2c1sgaSBdLCAyICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIGdlb0luZm8ubWF0ZXJpYWwgJiYgZ2VvSW5mby5tYXRlcmlhbC5tYXBwaW5nVHlwZSAhPT0gJ0FsbFNhbWUnICkge1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgdGhlIG1hdGVyaWFsIGluZGljZXMgb2YgZWFjaCB2ZXJ0ZXggaW50byByZW5kZXJpbmcgZ3JvdXBzIG9uIHRoZSBnZW9tZXRyeS5cblx0XHRcdFx0dmFyIHByZXZNYXRlcmlhbEluZGV4ID0gYnVmZmVycy5tYXRlcmlhbEluZGV4WyAwIF07XG5cdFx0XHRcdHZhciBzdGFydEluZGV4ID0gMDtcblxuXHRcdFx0XHRidWZmZXJzLm1hdGVyaWFsSW5kZXguZm9yRWFjaCggZnVuY3Rpb24gKCBjdXJyZW50SW5kZXgsIGkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRJbmRleCAhPT0gcHJldk1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdGdlby5hZGRHcm91cCggc3RhcnRJbmRleCwgaSAtIHN0YXJ0SW5kZXgsIHByZXZNYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdFx0XHRcdHByZXZNYXRlcmlhbEluZGV4ID0gY3VycmVudEluZGV4O1xuXHRcdFx0XHRcdFx0c3RhcnRJbmRleCA9IGk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIHRoZSBsb29wIGFib3ZlIGRvZXNuJ3QgYWRkIHRoZSBsYXN0IGdyb3VwLCBkbyB0aGF0IGhlcmUuXG5cdFx0XHRcdGlmICggZ2VvLmdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0dmFyIGxhc3RHcm91cCA9IGdlby5ncm91cHNbIGdlby5ncm91cHMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdHZhciBsYXN0SW5kZXggPSBsYXN0R3JvdXAuc3RhcnQgKyBsYXN0R3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRpZiAoIGxhc3RJbmRleCAhPT0gYnVmZmVycy5tYXRlcmlhbEluZGV4Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0Z2VvLmFkZEdyb3VwKCBsYXN0SW5kZXgsIGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5sZW5ndGggLSBsYXN0SW5kZXgsIHByZXZNYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNhc2Ugd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGVyaWFscyBidXQgdGhlIHdob2xlIGdlb21ldHJ5IGlzIG9ubHlcblx0XHRcdFx0Ly8gdXNpbmcgb25lIG9mIHRoZW1cblx0XHRcdFx0aWYgKCBnZW8uZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGdlby5hZGRHcm91cCggMCwgYnVmZmVycy5tYXRlcmlhbEluZGV4Lmxlbmd0aCwgYnVmZmVycy5tYXRlcmlhbEluZGV4WyAwIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hZGRNb3JwaFRhcmdldHMoIGdlbywgZ2VvTm9kZSwgbW9ycGhUYXJnZXRzLCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdFx0cmV0dXJuIGdlbztcblxuXHRcdH0sXG5cblx0XHRwYXJzZUdlb05vZGU6IGZ1bmN0aW9uICggZ2VvTm9kZSwgc2tlbGV0b24gKSB7XG5cblx0XHRcdHZhciBnZW9JbmZvID0ge307XG5cblx0XHRcdGdlb0luZm8udmVydGV4UG9zaXRpb25zID0gKCBnZW9Ob2RlLlZlcnRpY2VzICE9PSB1bmRlZmluZWQgKSA/IGdlb05vZGUuVmVydGljZXMuYSA6IFtdO1xuXHRcdFx0Z2VvSW5mby52ZXJ0ZXhJbmRpY2VzID0gKCBnZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBnZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleC5hIDogW107XG5cblx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRDb2xvciApIHtcblxuXHRcdFx0XHRnZW9JbmZvLmNvbG9yID0gdGhpcy5wYXJzZVZlcnRleENvbG9ycyggZ2VvTm9kZS5MYXllckVsZW1lbnRDb2xvclsgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdGdlb0luZm8ubWF0ZXJpYWwgPSB0aGlzLnBhcnNlTWF0ZXJpYWxJbmRpY2VzKCBnZW9Ob2RlLkxheWVyRWxlbWVudE1hdGVyaWFsWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50Tm9ybWFsICkge1xuXG5cdFx0XHRcdGdlb0luZm8ubm9ybWFsID0gdGhpcy5wYXJzZU5vcm1hbHMoIGdlb05vZGUuTGF5ZXJFbGVtZW50Tm9ybWFsWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50VVYgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby51diA9IFtdO1xuXG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0d2hpbGUgKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWWyBpIF0gKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50VVZbIGkgXS5VViApIHtcblxuXHRcdFx0XHRcdFx0Z2VvSW5mby51di5wdXNoKCB0aGlzLnBhcnNlVVZzKCBnZW9Ob2RlLkxheWVyRWxlbWVudFVWWyBpIF0gKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aSArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvSW5mby53ZWlnaHRUYWJsZSA9IHt9O1xuXG5cdFx0XHRpZiAoIHNrZWxldG9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGdlb0luZm8uc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRcdFx0XHRza2VsZXRvbi5yYXdCb25lcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd0JvbmUsIGkgKSB7XG5cblx0XHRcdFx0XHQvLyBsb29wIG92ZXIgdGhlIGJvbmUncyB2ZXJ0ZXggaW5kaWNlcyBhbmQgd2VpZ2h0c1xuXHRcdFx0XHRcdHJhd0JvbmUuaW5kaWNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIGluZGV4LCBqICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb0luZm8ud2VpZ2h0VGFibGVbIGluZGV4IF0gPT09IHVuZGVmaW5lZCApIGdlb0luZm8ud2VpZ2h0VGFibGVbIGluZGV4IF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0Z2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXS5wdXNoKCB7XG5cblx0XHRcdFx0XHRcdFx0aWQ6IGksXG5cdFx0XHRcdFx0XHRcdHdlaWdodDogcmF3Qm9uZS53ZWlnaHRzWyBqIF0sXG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb0luZm87XG5cblx0XHR9LFxuXG5cdFx0Z2VuQnVmZmVyczogZnVuY3Rpb24gKCBnZW9JbmZvICkge1xuXG5cdFx0XHR2YXIgYnVmZmVycyA9IHtcblx0XHRcdFx0dmVydGV4OiBbXSxcblx0XHRcdFx0bm9ybWFsOiBbXSxcblx0XHRcdFx0Y29sb3JzOiBbXSxcblx0XHRcdFx0dXZzOiBbXSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogW10sXG5cdFx0XHRcdHZlcnRleFdlaWdodHM6IFtdLFxuXHRcdFx0XHR3ZWlnaHRzSW5kaWNlczogW10sXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcG9seWdvbkluZGV4ID0gMDtcblx0XHRcdHZhciBmYWNlTGVuZ3RoID0gMDtcblx0XHRcdHZhciBkaXNwbGF5ZWRXZWlnaHRzV2FybmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyB0aGVzZSB3aWxsIGhvbGQgZGF0YSBmb3IgYSBzaW5nbGUgZmFjZVxuXHRcdFx0dmFyIGZhY2VQb3NpdGlvbkluZGV4ZXMgPSBbXTtcblx0XHRcdHZhciBmYWNlTm9ybWFscyA9IFtdO1xuXHRcdFx0dmFyIGZhY2VDb2xvcnMgPSBbXTtcblx0XHRcdHZhciBmYWNlVVZzID0gW107XG5cdFx0XHR2YXIgZmFjZVdlaWdodHMgPSBbXTtcblx0XHRcdHZhciBmYWNlV2VpZ2h0SW5kaWNlcyA9IFtdO1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0Z2VvSW5mby52ZXJ0ZXhJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uICggdmVydGV4SW5kZXgsIHBvbHlnb25WZXJ0ZXhJbmRleCApIHtcblxuXHRcdFx0XHR2YXIgZW5kT2ZGYWNlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gRmFjZSBpbmRleCBhbmQgdmVydGV4IGluZGV4IGFycmF5cyBhcmUgY29tYmluZWQgaW4gYSBzaW5nbGUgYXJyYXlcblx0XHRcdFx0Ly8gQSBjdWJlIHdpdGggcXVhZCBmYWNlcyBsb29rcyBsaWtlIHRoaXM6XG5cdFx0XHRcdC8vIFBvbHlnb25WZXJ0ZXhJbmRleDogKjI0IHtcblx0XHRcdFx0Ly8gIGE6IDAsIDEsIDMsIC0zLCAyLCAzLCA1LCAtNSwgNCwgNSwgNywgLTcsIDYsIDcsIDEsIC0xLCAxLCA3LCA1LCAtNCwgNiwgMCwgMiwgLTVcblx0XHRcdFx0Ly8gIH1cblx0XHRcdFx0Ly8gTmVnYXRpdmUgbnVtYmVycyBtYXJrIHRoZSBlbmQgb2YgYSBmYWNlIC0gZmlyc3QgZmFjZSBoZXJlIGlzIDAsIDEsIDMsIC0zXG5cdFx0XHRcdC8vIHRvIGZpbmQgaW5kZXggb2YgbGFzdCB2ZXJ0ZXggYml0IHNoaWZ0IHRoZSBpbmRleDogXiAtIDFcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhJbmRleCA8IDAgKSB7XG5cblx0XHRcdFx0XHR2ZXJ0ZXhJbmRleCA9IHZlcnRleEluZGV4IF4gLSAxOyAvLyBlcXVpdmFsZW50IHRvICggeCAqIC0xICkgLSAxXG5cdFx0XHRcdFx0ZW5kT2ZGYWNlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHdlaWdodEluZGljZXMgPSBbXTtcblx0XHRcdFx0dmFyIHdlaWdodHMgPSBbXTtcblxuXHRcdFx0XHRmYWNlUG9zaXRpb25JbmRleGVzLnB1c2goIHZlcnRleEluZGV4ICogMywgdmVydGV4SW5kZXggKiAzICsgMSwgdmVydGV4SW5kZXggKiAzICsgMiApO1xuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5jb2xvciApIHtcblxuXHRcdFx0XHRcdHZhciBkYXRhID0gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCBnZW9JbmZvLmNvbG9yICk7XG5cblx0XHRcdFx0XHRmYWNlQ29sb3JzLnB1c2goIGRhdGFbIDAgXSwgZGF0YVsgMSBdLCBkYXRhWyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9JbmZvLndlaWdodFRhYmxlWyB2ZXJ0ZXhJbmRleCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGdlb0luZm8ud2VpZ2h0VGFibGVbIHZlcnRleEluZGV4IF0uZm9yRWFjaCggZnVuY3Rpb24gKCB3dCApIHtcblxuXHRcdFx0XHRcdFx0XHR3ZWlnaHRzLnB1c2goIHd0LndlaWdodCApO1xuXHRcdFx0XHRcdFx0XHR3ZWlnaHRJbmRpY2VzLnB1c2goIHd0LmlkICk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB3ZWlnaHRzLmxlbmd0aCA+IDQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISBkaXNwbGF5ZWRXZWlnaHRzV2FybmluZyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IFZlcnRleCBoYXMgbW9yZSB0aGFuIDQgc2tpbm5pbmcgd2VpZ2h0cyBhc3NpZ25lZCB0byB2ZXJ0ZXguIERlbGV0aW5nIGFkZGl0aW9uYWwgd2VpZ2h0cy4nICk7XG5cdFx0XHRcdFx0XHRcdGRpc3BsYXllZFdlaWdodHNXYXJuaW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgd0luZGV4ID0gWyAwLCAwLCAwLCAwIF07XG5cdFx0XHRcdFx0XHR2YXIgV2VpZ2h0ID0gWyAwLCAwLCAwLCAwIF07XG5cblx0XHRcdFx0XHRcdHdlaWdodHMuZm9yRWFjaCggZnVuY3Rpb24gKCB3ZWlnaHQsIHdlaWdodEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudEluZGV4ID0gd2VpZ2h0SW5kaWNlc1sgd2VpZ2h0SW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRXZWlnaHQuZm9yRWFjaCggZnVuY3Rpb24gKCBjb21wYXJlZFdlaWdodCwgY29tcGFyZWRXZWlnaHRJbmRleCwgY29tcGFyZWRXZWlnaHRBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggY3VycmVudFdlaWdodCA+IGNvbXBhcmVkV2VpZ2h0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wYXJlZFdlaWdodEFycmF5WyBjb21wYXJlZFdlaWdodEluZGV4IF0gPSBjdXJyZW50V2VpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFdlaWdodCA9IGNvbXBhcmVkV2VpZ2h0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdG1wID0gd0luZGV4WyBjb21wYXJlZFdlaWdodEluZGV4IF07XG5cdFx0XHRcdFx0XHRcdFx0XHR3SW5kZXhbIGNvbXBhcmVkV2VpZ2h0SW5kZXggXSA9IGN1cnJlbnRJbmRleDtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRJbmRleCA9IHRtcDtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0d2VpZ2h0SW5kaWNlcyA9IHdJbmRleDtcblx0XHRcdFx0XHRcdHdlaWdodHMgPSBXZWlnaHQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgd2VpZ2h0IGFycmF5IGlzIHNob3J0ZXIgdGhhbiA0IHBhZCB3aXRoIDBzXG5cdFx0XHRcdFx0d2hpbGUgKCB3ZWlnaHRzLmxlbmd0aCA8IDQgKSB7XG5cblx0XHRcdFx0XHRcdHdlaWdodHMucHVzaCggMCApO1xuXHRcdFx0XHRcdFx0d2VpZ2h0SW5kaWNlcy5wdXNoKCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA0OyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRmYWNlV2VpZ2h0cy5wdXNoKCB3ZWlnaHRzWyBpIF0gKTtcblx0XHRcdFx0XHRcdGZhY2VXZWlnaHRJbmRpY2VzLnB1c2goIHdlaWdodEluZGljZXNbIGkgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8ubm9ybWFsICkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIGdlb0luZm8ubm9ybWFsICk7XG5cblx0XHRcdFx0XHRmYWNlTm9ybWFscy5wdXNoKCBkYXRhWyAwIF0sIGRhdGFbIDEgXSwgZGF0YVsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5tYXRlcmlhbCAmJiBnZW9JbmZvLm1hdGVyaWFsLm1hcHBpbmdUeXBlICE9PSAnQWxsU2FtZScgKSB7XG5cblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgZ2VvSW5mby5tYXRlcmlhbCApWyAwIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby51diApIHtcblxuXHRcdFx0XHRcdGdlb0luZm8udXYuZm9yRWFjaCggZnVuY3Rpb24gKCB1diwgaSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIHV2ICk7XG5cblx0XHRcdFx0XHRcdGlmICggZmFjZVVWc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZVVWc1sgaSBdID0gW107XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZmFjZVVWc1sgaSBdLnB1c2goIGRhdGFbIDAgXSApO1xuXHRcdFx0XHRcdFx0ZmFjZVVWc1sgaSBdLnB1c2goIGRhdGFbIDEgXSApO1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmYWNlTGVuZ3RoICsrO1xuXG5cdFx0XHRcdGlmICggZW5kT2ZGYWNlICkge1xuXG5cdFx0XHRcdFx0c2NvcGUuZ2VuRmFjZSggYnVmZmVycywgZ2VvSW5mbywgZmFjZVBvc2l0aW9uSW5kZXhlcywgbWF0ZXJpYWxJbmRleCwgZmFjZU5vcm1hbHMsIGZhY2VDb2xvcnMsIGZhY2VVVnMsIGZhY2VXZWlnaHRzLCBmYWNlV2VpZ2h0SW5kaWNlcywgZmFjZUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0cG9seWdvbkluZGV4ICsrO1xuXHRcdFx0XHRcdGZhY2VMZW5ndGggPSAwO1xuXG5cdFx0XHRcdFx0Ly8gcmVzZXQgYXJyYXlzIGZvciB0aGUgbmV4dCBmYWNlXG5cdFx0XHRcdFx0ZmFjZVBvc2l0aW9uSW5kZXhlcyA9IFtdO1xuXHRcdFx0XHRcdGZhY2VOb3JtYWxzID0gW107XG5cdFx0XHRcdFx0ZmFjZUNvbG9ycyA9IFtdO1xuXHRcdFx0XHRcdGZhY2VVVnMgPSBbXTtcblx0XHRcdFx0XHRmYWNlV2VpZ2h0cyA9IFtdO1xuXHRcdFx0XHRcdGZhY2VXZWlnaHRJbmRpY2VzID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBidWZmZXJzO1xuXG5cdFx0fSxcblxuXHRcdC8vIEdlbmVyYXRlIGRhdGEgZm9yIGEgc2luZ2xlIGZhY2UgaW4gYSBnZW9tZXRyeS4gSWYgdGhlIGZhY2UgaXMgYSBxdWFkIHRoZW4gc3BsaXQgaXQgaW50byAyIHRyaXNcblx0XHRnZW5GYWNlOiBmdW5jdGlvbiAoIGJ1ZmZlcnMsIGdlb0luZm8sIGZhY2VQb3NpdGlvbkluZGV4ZXMsIG1hdGVyaWFsSW5kZXgsIGZhY2VOb3JtYWxzLCBmYWNlQ29sb3JzLCBmYWNlVVZzLCBmYWNlV2VpZ2h0cywgZmFjZVdlaWdodEluZGljZXMsIGZhY2VMZW5ndGggKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMjsgaSA8IGZhY2VMZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIDAgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAxIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgMiBdIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgKCBpIC0gMSApICogMyBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbICggaSAtIDEgKSAqIDMgKyAxIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgKCBpIC0gMSApICogMyArIDIgXSBdICk7XG5cblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIGkgKiAzIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgaSAqIDMgKyAxIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgaSAqIDMgKyAyIF0gXSApO1xuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5za2VsZXRvbiApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMyBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbICggaSAtIDEgKSAqIDQgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgKCBpIC0gMSApICogNCArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgKCBpIC0gMSApICogNCArIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgKCBpIC0gMSApICogNCArIDMgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyBpICogNCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyBpICogNCArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgaSAqIDQgKyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0ICsgMyBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAwIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAzIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbICggaSAtIDEgKSAqIDQgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbICggaSAtIDEgKSAqIDQgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgKCBpIC0gMSApICogNCArIDMgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgaSAqIDQgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgaSAqIDQgKyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyBpICogNCArIDMgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8uY29sb3IgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAwIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAyIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbICggaSAtIDEgKSAqIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbICggaSAtIDEgKSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyAoIGkgLSAxICkgKiAzICsgMiBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyBpICogMyBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgaSAqIDMgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyBpICogMyArIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8ubWF0ZXJpYWwgJiYgZ2VvSW5mby5tYXRlcmlhbC5tYXBwaW5nVHlwZSAhPT0gJ0FsbFNhbWUnICkge1xuXG5cdFx0XHRcdFx0YnVmZmVycy5tYXRlcmlhbEluZGV4LnB1c2goIG1hdGVyaWFsSW5kZXggKTtcblx0XHRcdFx0XHRidWZmZXJzLm1hdGVyaWFsSW5kZXgucHVzaCggbWF0ZXJpYWxJbmRleCApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5ub3JtYWwgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgMCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAoIGkgLSAxICkgKiAzIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgKCBpIC0gMSApICogMyArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAoIGkgLSAxICkgKiAzICsgMiBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgaSAqIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyBpICogMyArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyBpICogMyArIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8udXYgKSB7XG5cblx0XHRcdFx0XHRnZW9JbmZvLnV2LmZvckVhY2goIGZ1bmN0aW9uICggdXYsIGogKSB7XG5cblx0XHRcdFx0XHRcdGlmICggYnVmZmVycy51dnNbIGogXSA9PT0gdW5kZWZpbmVkICkgYnVmZmVycy51dnNbIGogXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgMCBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgMSBdICk7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAoIGkgLSAxICkgKiAyIF0gKTtcblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAoIGkgLSAxICkgKiAyICsgMSBdICk7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyBpICogMiBdICk7XG5cdFx0XHRcdFx0XHRidWZmZXJzLnV2c1sgaiBdLnB1c2goIGZhY2VVVnNbIGogXVsgaSAqIDIgKyAxIF0gKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRhZGRNb3JwaFRhcmdldHM6IGZ1bmN0aW9uICggcGFyZW50R2VvLCBwYXJlbnRHZW9Ob2RlLCBtb3JwaFRhcmdldHMsIHByZVRyYW5zZm9ybSApIHtcblxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0XHRwYXJlbnRHZW8ubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuXG5cdFx0XHRwYXJlbnRHZW8ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID0gW107XG5cdFx0XHQvLyBwYXJlbnRHZW8ubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IFtdOyAvLyBub3QgaW1wbGVtZW50ZWRcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdG1vcnBoVGFyZ2V0cy5mb3JFYWNoKCBmdW5jdGlvbiAoIG1vcnBoVGFyZ2V0ICkge1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0LnJhd1RhcmdldHMuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHR2YXIgbW9ycGhHZW9Ob2RlID0gZmJ4VHJlZS5PYmplY3RzLkdlb21ldHJ5WyByYXdUYXJnZXQuZ2VvSUQgXTtcblxuXHRcdFx0XHRcdGlmICggbW9ycGhHZW9Ob2RlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHNjb3BlLmdlbk1vcnBoR2VvbWV0cnkoIHBhcmVudEdlbywgcGFyZW50R2VvTm9kZSwgbW9ycGhHZW9Ob2RlLCBwcmVUcmFuc2Zvcm0sIHJhd1RhcmdldC5uYW1lICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gYSBtb3JwaCBnZW9tZXRyeSBub2RlIGlzIHNpbWlsYXIgdG8gYSBzdGFuZGFyZCAgbm9kZSwgYW5kIHRoZSBub2RlIGlzIGFsc28gY29udGFpbmVkXG5cdFx0Ly8gaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LCBob3dldmVyIGl0IGNhbiBvbmx5IGhhdmUgYXR0cmlidXRlcyBmb3IgcG9zaXRpb24sIG5vcm1hbFxuXHRcdC8vIGFuZCBhIHNwZWNpYWwgYXR0cmlidXRlIEluZGV4IGRlZmluaW5nIHdoaWNoIHZlcnRpY2VzIG9mIHRoZSBvcmlnaW5hbCBnZW9tZXRyeSBhcmUgYWZmZWN0ZWRcblx0XHQvLyBOb3JtYWwgYW5kIHBvc2l0aW9uIGF0dHJpYnV0ZXMgb25seSBoYXZlIGRhdGEgZm9yIHRoZSB2ZXJ0aWNlcyB0aGF0IGFyZSBhZmZlY3RlZCBieSB0aGUgbW9ycGhcblx0XHRnZW5Nb3JwaEdlb21ldHJ5OiBmdW5jdGlvbiAoIHBhcmVudEdlbywgcGFyZW50R2VvTm9kZSwgbW9ycGhHZW9Ob2RlLCBwcmVUcmFuc2Zvcm0sIG5hbWUgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXhJbmRpY2VzID0gKCBwYXJlbnRHZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleCAhPT0gdW5kZWZpbmVkICkgPyBwYXJlbnRHZW9Ob2RlLlBvbHlnb25WZXJ0ZXhJbmRleC5hIDogW107XG5cblx0XHRcdHZhciBtb3JwaFBvc2l0aW9uc1NwYXJzZSA9ICggbW9ycGhHZW9Ob2RlLlZlcnRpY2VzICE9PSB1bmRlZmluZWQgKSA/IG1vcnBoR2VvTm9kZS5WZXJ0aWNlcy5hIDogW107XG5cdFx0XHR2YXIgaW5kaWNlcyA9ICggbW9ycGhHZW9Ob2RlLkluZGV4ZXMgIT09IHVuZGVmaW5lZCApID8gbW9ycGhHZW9Ob2RlLkluZGV4ZXMuYSA6IFtdO1xuXG5cdFx0XHR2YXIgbGVuZ3RoID0gcGFyZW50R2VvLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKiAzO1xuXHRcdFx0dmFyIG1vcnBoUG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggbGVuZ3RoICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBtb3JwaEluZGV4ID0gaW5kaWNlc1sgaSBdICogMztcblxuXHRcdFx0XHRtb3JwaFBvc2l0aW9uc1sgbW9ycGhJbmRleCBdID0gbW9ycGhQb3NpdGlvbnNTcGFyc2VbIGkgKiAzIF07XG5cdFx0XHRcdG1vcnBoUG9zaXRpb25zWyBtb3JwaEluZGV4ICsgMSBdID0gbW9ycGhQb3NpdGlvbnNTcGFyc2VbIGkgKiAzICsgMSBdO1xuXHRcdFx0XHRtb3JwaFBvc2l0aW9uc1sgbW9ycGhJbmRleCArIDIgXSA9IG1vcnBoUG9zaXRpb25zU3BhcnNlWyBpICogMyArIDIgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBhZGQgbW9ycGggbm9ybWFsIHN1cHBvcnRcblx0XHRcdHZhciBtb3JwaEdlb0luZm8gPSB7XG5cdFx0XHRcdHZlcnRleEluZGljZXM6IHZlcnRleEluZGljZXMsXG5cdFx0XHRcdHZlcnRleFBvc2l0aW9uczogbW9ycGhQb3NpdGlvbnMsXG5cblx0XHRcdH07XG5cblx0XHRcdHZhciBtb3JwaEJ1ZmZlcnMgPSB0aGlzLmdlbkJ1ZmZlcnMoIG1vcnBoR2VvSW5mbyApO1xuXG5cdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhCdWZmZXJzLnZlcnRleCwgMyApO1xuXHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUubmFtZSA9IG5hbWUgfHwgbW9ycGhHZW9Ob2RlLmF0dHJOYW1lO1xuXG5cdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5hcHBseU1hdHJpeDQoIHByZVRyYW5zZm9ybSApO1xuXG5cdFx0XHRwYXJlbnRHZW8ubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLnB1c2goIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugbm9ybWFsIGZyb20gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LkxheWVyRWxlbWVudE5vcm1hbCBpZiBpdCBleGlzdHNcblx0XHRwYXJzZU5vcm1hbHM6IGZ1bmN0aW9uICggTm9ybWFsTm9kZSApIHtcblxuXHRcdFx0dmFyIG1hcHBpbmdUeXBlID0gTm9ybWFsTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIHJlZmVyZW5jZVR5cGUgPSBOb3JtYWxOb2RlLlJlZmVyZW5jZUluZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciBidWZmZXIgPSBOb3JtYWxOb2RlLk5vcm1hbHMuYTtcblx0XHRcdHZhciBpbmRleEJ1ZmZlciA9IFtdO1xuXHRcdFx0aWYgKCByZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSB7XG5cblx0XHRcdFx0aWYgKCAnTm9ybWFsSW5kZXgnIGluIE5vcm1hbE5vZGUgKSB7XG5cblx0XHRcdFx0XHRpbmRleEJ1ZmZlciA9IE5vcm1hbE5vZGUuTm9ybWFsSW5kZXguYTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCAnTm9ybWFsc0luZGV4JyBpbiBOb3JtYWxOb2RlICkge1xuXG5cdFx0XHRcdFx0aW5kZXhCdWZmZXIgPSBOb3JtYWxOb2RlLk5vcm1hbHNJbmRleC5hO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhU2l6ZTogMyxcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRcdGluZGljZXM6IGluZGV4QnVmZmVyLFxuXHRcdFx0XHRtYXBwaW5nVHlwZTogbWFwcGluZ1R5cGUsXG5cdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgVVZzIGZyb20gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LkxheWVyRWxlbWVudFVWIGlmIGl0IGV4aXN0c1xuXHRcdHBhcnNlVVZzOiBmdW5jdGlvbiAoIFVWTm9kZSApIHtcblxuXHRcdFx0dmFyIG1hcHBpbmdUeXBlID0gVVZOb2RlLk1hcHBpbmdJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgcmVmZXJlbmNlVHlwZSA9IFVWTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgYnVmZmVyID0gVVZOb2RlLlVWLmE7XG5cdFx0XHR2YXIgaW5kZXhCdWZmZXIgPSBbXTtcblx0XHRcdGlmICggcmVmZXJlbmNlVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnICkge1xuXG5cdFx0XHRcdGluZGV4QnVmZmVyID0gVVZOb2RlLlVWSW5kZXguYTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhU2l6ZTogMixcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXG5cdFx0XHRcdGluZGljZXM6IGluZGV4QnVmZmVyLFxuXHRcdFx0XHRtYXBwaW5nVHlwZTogbWFwcGluZ1R5cGUsXG5cdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2UgVmVydGV4IENvbG9ycyBmcm9tIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeS5MYXllckVsZW1lbnRDb2xvciBpZiBpdCBleGlzdHNcblx0XHRwYXJzZVZlcnRleENvbG9yczogZnVuY3Rpb24gKCBDb2xvck5vZGUgKSB7XG5cblx0XHRcdHZhciBtYXBwaW5nVHlwZSA9IENvbG9yTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIHJlZmVyZW5jZVR5cGUgPSBDb2xvck5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIGJ1ZmZlciA9IENvbG9yTm9kZS5Db2xvcnMuYTtcblx0XHRcdHZhciBpbmRleEJ1ZmZlciA9IFtdO1xuXHRcdFx0aWYgKCByZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSB7XG5cblx0XHRcdFx0aW5kZXhCdWZmZXIgPSBDb2xvck5vZGUuQ29sb3JJbmRleC5hO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGFTaXplOiA0LFxuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdFx0aW5kaWNlczogaW5kZXhCdWZmZXIsXG5cdFx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBtYXBwaW5nIGFuZCBtYXRlcmlhbCBkYXRhIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeS5MYXllckVsZW1lbnRNYXRlcmlhbCBpZiBpdCBleGlzdHNcblx0XHRwYXJzZU1hdGVyaWFsSW5kaWNlczogZnVuY3Rpb24gKCBNYXRlcmlhbE5vZGUgKSB7XG5cblx0XHRcdHZhciBtYXBwaW5nVHlwZSA9IE1hdGVyaWFsTm9kZS5NYXBwaW5nSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIHJlZmVyZW5jZVR5cGUgPSBNYXRlcmlhbE5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXG5cdFx0XHRpZiAoIG1hcHBpbmdUeXBlID09PSAnTm9NYXBwaW5nSW5mb3JtYXRpb24nICkge1xuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YVNpemU6IDEsXG5cdFx0XHRcdFx0YnVmZmVyOiBbIDAgXSxcblx0XHRcdFx0XHRpbmRpY2VzOiBbIDAgXSxcblx0XHRcdFx0XHRtYXBwaW5nVHlwZTogJ0FsbFNhbWUnLFxuXHRcdFx0XHRcdHJlZmVyZW5jZVR5cGU6IHJlZmVyZW5jZVR5cGVcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWF0ZXJpYWxJbmRleEJ1ZmZlciA9IE1hdGVyaWFsTm9kZS5NYXRlcmlhbHMuYTtcblxuXHRcdFx0Ly8gU2luY2UgbWF0ZXJpYWxzIGFyZSBzdG9yZWQgYXMgaW5kaWNlcywgdGhlcmUncyBhIGJpdCBvZiBhIG1pc21hdGNoIGJldHdlZW4gRkJYIGFuZCB3aGF0XG5cdFx0XHQvLyB3ZSBleHBlY3QuU28gd2UgY3JlYXRlIGFuIGludGVybWVkaWF0ZSBidWZmZXIgdGhhdCBwb2ludHMgdG8gdGhlIGluZGV4IGluIHRoZSBidWZmZXIsXG5cdFx0XHQvLyBmb3IgY29uZm9ybWluZyB3aXRoIHRoZSBvdGhlciBmdW5jdGlvbnMgd2UndmUgd3JpdHRlbiBmb3Igb3RoZXIgZGF0YS5cblx0XHRcdHZhciBtYXRlcmlhbEluZGljZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxJbmRleEJ1ZmZlci5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxJbmRpY2VzLnB1c2goIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhU2l6ZTogMSxcblx0XHRcdFx0YnVmZmVyOiBtYXRlcmlhbEluZGV4QnVmZmVyLFxuXHRcdFx0XHRpbmRpY2VzOiBtYXRlcmlhbEluZGljZXMsXG5cdFx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBHZW5lcmF0ZSBhIE51cmJHZW9tZXRyeSBmcm9tIGEgbm9kZSBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0XHRwYXJzZU51cmJzR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvTm9kZSApIHtcblxuXHRcdFx0aWYgKCBOVVJCU0N1cnZlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkZCWExvYWRlcjogVGhlIGxvYWRlciByZWxpZXMgb24gTlVSQlNDdXJ2ZSBmb3IgYW55IG51cmJzIHByZXNlbnQgaW4gdGhlIG1vZGVsLiBOdXJicyB3aWxsIHNob3cgdXAgYXMgZW1wdHkgZ2VvbWV0cnkuJyApO1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG9yZGVyID0gcGFyc2VJbnQoIGdlb05vZGUuT3JkZXIgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggb3JkZXIgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBJbnZhbGlkIE9yZGVyICVzIGdpdmVuIGZvciBnZW9tZXRyeSBJRDogJXMnLCBnZW9Ob2RlLk9yZGVyLCBnZW9Ob2RlLmlkICk7XG5cdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVncmVlID0gb3JkZXIgLSAxO1xuXG5cdFx0XHR2YXIga25vdHMgPSBnZW9Ob2RlLktub3RWZWN0b3IuYTtcblx0XHRcdHZhciBjb250cm9sUG9pbnRzID0gW107XG5cdFx0XHR2YXIgcG9pbnRzVmFsdWVzID0gZ2VvTm9kZS5Qb2ludHMuYTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzVmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkgKz0gNCApIHtcblxuXHRcdFx0XHRjb250cm9sUG9pbnRzLnB1c2goIG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KCBwb2ludHNWYWx1ZXMsIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydEtub3QsIGVuZEtub3Q7XG5cblx0XHRcdGlmICggZ2VvTm9kZS5Gb3JtID09PSAnQ2xvc2VkJyApIHtcblxuXHRcdFx0XHRjb250cm9sUG9pbnRzLnB1c2goIGNvbnRyb2xQb2ludHNbIDAgXSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBnZW9Ob2RlLkZvcm0gPT09ICdQZXJpb2RpYycgKSB7XG5cblx0XHRcdFx0c3RhcnRLbm90ID0gZGVncmVlO1xuXHRcdFx0XHRlbmRLbm90ID0ga25vdHMubGVuZ3RoIC0gMSAtIHN0YXJ0S25vdDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZWdyZWU7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb250cm9sUG9pbnRzLnB1c2goIGNvbnRyb2xQb2ludHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3VydmUgPSBuZXcgTlVSQlNDdXJ2ZSggZGVncmVlLCBrbm90cywgY29udHJvbFBvaW50cywgc3RhcnRLbm90LCBlbmRLbm90ICk7XG5cdFx0XHR2YXIgdmVydGljZXMgPSBjdXJ2ZS5nZXRQb2ludHMoIGNvbnRyb2xQb2ludHMubGVuZ3RoICogNyApO1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMubGVuZ3RoICogMyApO1xuXG5cdFx0XHR2ZXJ0aWNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHZlcnRleCwgaSApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgudG9BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9LFxuXG5cdH07XG5cblx0Ly8gcGFyc2UgYW5pbWF0aW9uIGRhdGEgZnJvbSBGQlhUcmVlXG5cdGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlcigpIHt9XG5cblx0QW5pbWF0aW9uUGFyc2VyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBBbmltYXRpb25QYXJzZXIsXG5cblx0XHQvLyB0YWtlIHJhdyBhbmltYXRpb24gY2xpcHMgYW5kIHR1cm4gdGhlbSBpbnRvIHRocmVlLmpzIGFuaW1hdGlvbiBjbGlwc1xuXHRcdHBhcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBhbmltYXRpb25DbGlwcyA9IFtdO1xuXG5cdFx0XHR2YXIgcmF3Q2xpcHMgPSB0aGlzLnBhcnNlQ2xpcHMoKTtcblxuXHRcdFx0aWYgKCByYXdDbGlwcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gcmF3Q2xpcHMgKSB7XG5cblx0XHRcdFx0XHR2YXIgcmF3Q2xpcCA9IHJhd0NsaXBzWyBrZXkgXTtcblxuXHRcdFx0XHRcdHZhciBjbGlwID0gdGhpcy5hZGRDbGlwKCByYXdDbGlwICk7XG5cblx0XHRcdFx0XHRhbmltYXRpb25DbGlwcy5wdXNoKCBjbGlwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbmltYXRpb25DbGlwcztcblxuXHRcdH0sXG5cblx0XHRwYXJzZUNsaXBzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdC8vIHNpbmNlIHRoZSBhY3R1YWwgdHJhbnNmb3JtYXRpb24gZGF0YSBpcyBzdG9yZWQgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlLFxuXHRcdFx0Ly8gaWYgdGhpcyBpcyB1bmRlZmluZWQgd2UgY2FuIHNhZmVseSBhc3N1bWUgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnNcblx0XHRcdGlmICggZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR2YXIgY3VydmVOb2Rlc01hcCA9IHRoaXMucGFyc2VBbmltYXRpb25DdXJ2ZU5vZGVzKCk7XG5cblx0XHRcdHRoaXMucGFyc2VBbmltYXRpb25DdXJ2ZXMoIGN1cnZlTm9kZXNNYXAgKTtcblxuXHRcdFx0dmFyIGxheWVyc01hcCA9IHRoaXMucGFyc2VBbmltYXRpb25MYXllcnMoIGN1cnZlTm9kZXNNYXAgKTtcblx0XHRcdHZhciByYXdDbGlwcyA9IHRoaXMucGFyc2VBbmltU3RhY2tzKCBsYXllcnNNYXAgKTtcblxuXHRcdFx0cmV0dXJuIHJhd0NsaXBzO1xuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZU5vZGVcblx0XHQvLyBlYWNoIEFuaW1hdGlvbkN1cnZlTm9kZSBob2xkcyBkYXRhIGZvciBhbiBhbmltYXRpb24gdHJhbnNmb3JtIGZvciBhIG1vZGVsIChlLmcuIGxlZnQgYXJtIHJvdGF0aW9uIClcblx0XHQvLyBhbmQgaXMgcmVmZXJlbmNlZCBieSBhbiBBbmltYXRpb25MYXllclxuXHRcdHBhcnNlQW5pbWF0aW9uQ3VydmVOb2RlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgcmF3Q3VydmVOb2RlcyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZU5vZGU7XG5cblx0XHRcdHZhciBjdXJ2ZU5vZGVzTWFwID0gbmV3IE1hcCgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHJhd0N1cnZlTm9kZXMgKSB7XG5cblx0XHRcdFx0dmFyIHJhd0N1cnZlTm9kZSA9IHJhd0N1cnZlTm9kZXNbIG5vZGVJRCBdO1xuXG5cdFx0XHRcdGlmICggcmF3Q3VydmVOb2RlLmF0dHJOYW1lLm1hdGNoKCAvU3xSfFR8RGVmb3JtUGVyY2VudC8gKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciBjdXJ2ZU5vZGUgPSB7XG5cblx0XHRcdFx0XHRcdGlkOiByYXdDdXJ2ZU5vZGUuaWQsXG5cdFx0XHRcdFx0XHRhdHRyOiByYXdDdXJ2ZU5vZGUuYXR0ck5hbWUsXG5cdFx0XHRcdFx0XHRjdXJ2ZXM6IHt9LFxuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGN1cnZlTm9kZXNNYXAuc2V0KCBjdXJ2ZU5vZGUuaWQsIGN1cnZlTm9kZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY3VydmVOb2Rlc01hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmUgYW5kIGNvbm5lY3QgdGhlbSB1cCB0b1xuXHRcdC8vIHByZXZpb3VzbHkgcGFyc2VkIEFuaW1hdGlvbkN1cnZlTm9kZXMuIEVhY2ggQW5pbWF0aW9uQ3VydmUgaG9sZHMgZGF0YSBmb3IgYSBzaW5nbGUgYW5pbWF0ZWRcblx0XHQvLyBheGlzICggZS5nLiB0aW1lcyBhbmQgdmFsdWVzIG9mIHggcm90YXRpb24pXG5cdFx0cGFyc2VBbmltYXRpb25DdXJ2ZXM6IGZ1bmN0aW9uICggY3VydmVOb2Rlc01hcCApIHtcblxuXHRcdFx0dmFyIHJhd0N1cnZlcyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0Ly8gVE9ETzogTWFueSB2YWx1ZXMgYXJlIGlkZW50aWNhbCB1cCB0byByb3VuZG9mZiBlcnJvciwgYnV0IHdvbid0IGJlIG9wdGltaXNlZFxuXHRcdFx0Ly8gZS5nLiBwb3NpdGlvbiB0aW1lczogWzAsIDAuNCwgMC4gOF1cblx0XHRcdC8vIHBvc2l0aW9uIHZhbHVlczogWzcuMjM1MzgzMzUwMjM0NzdlLTcsIDkzLjY3NTE4NjE1NzIyNjU2LCAtMC45OTgyNjk1NTc5NTI4ODA5LCA3LjIzNTM4MzM1MDIzNDc3ZS03LCA5My42NzUxODYxNTcyMjY1NiwgLTAuOTk4MjY5NTU3OTUyODgwOSwgNy4yMzUzODQ0ODcxMDMxNDdlLTcsIDkzLjY3NTIwOTA0NTQxMDE2LCAtMC45OTgyNjk1NTc5NTI4ODA5XVxuXHRcdFx0Ly8gY2xlYXJseSwgdGhpcyBzaG91bGQgYmUgb3B0aW1pc2VkIHRvXG5cdFx0XHQvLyB0aW1lczogWzBdLCBwb3NpdGlvbnMgWzcuMjM1MzgzMzUwMjM0NzdlLTcsIDkzLjY3NTE4NjE1NzIyNjU2LCAtMC45OTgyNjk1NTc5NTI4ODA5XVxuXHRcdFx0Ly8gdGhpcyBzaG93cyB1cCBpbiBuZWFybHkgZXZlcnkgRkJYIGZpbGUsIGFuZCBnZW5lcmFsbHkgdGltZSBhcnJheSBpcyBsZW5ndGggPiAxMDBcblxuXHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiByYXdDdXJ2ZXMgKSB7XG5cblx0XHRcdFx0dmFyIGFuaW1hdGlvbkN1cnZlID0ge1xuXG5cdFx0XHRcdFx0aWQ6IHJhd0N1cnZlc1sgbm9kZUlEIF0uaWQsXG5cdFx0XHRcdFx0dGltZXM6IHJhd0N1cnZlc1sgbm9kZUlEIF0uS2V5VGltZS5hLm1hcCggY29udmVydEZCWFRpbWVUb1NlY29uZHMgKSxcblx0XHRcdFx0XHR2YWx1ZXM6IHJhd0N1cnZlc1sgbm9kZUlEIF0uS2V5VmFsdWVGbG9hdC5hLFxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dmFyIHJlbGF0aW9uc2hpcHMgPSBjb25uZWN0aW9ucy5nZXQoIGFuaW1hdGlvbkN1cnZlLmlkICk7XG5cblx0XHRcdFx0aWYgKCByZWxhdGlvbnNoaXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uQ3VydmVJRCA9IHJlbGF0aW9uc2hpcHMucGFyZW50c1sgMCBdLklEO1xuXHRcdFx0XHRcdHZhciBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcHMucGFyZW50c1sgMCBdLnJlbGF0aW9uc2hpcDtcblxuXHRcdFx0XHRcdGlmICggYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAubWF0Y2goIC9YLyApICkge1xuXG5cdFx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3gnIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFuaW1hdGlvbkN1cnZlUmVsYXRpb25zaGlwLm1hdGNoKCAvWS8gKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5nZXQoIGFuaW1hdGlvbkN1cnZlSUQgKS5jdXJ2ZXNbICd5JyBdID0gYW5pbWF0aW9uQ3VydmU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1ovICkgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnZlTm9kZXNNYXAuZ2V0KCBhbmltYXRpb25DdXJ2ZUlEICkuY3VydmVzWyAneicgXSA9IGFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAubWF0Y2goIC9kfERlZm9ybVBlcmNlbnQvICkgJiYgY3VydmVOb2Rlc01hcC5oYXMoIGFuaW1hdGlvbkN1cnZlSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5nZXQoIGFuaW1hdGlvbkN1cnZlSUQgKS5jdXJ2ZXNbICdtb3JwaCcgXSA9IGFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5BbmltYXRpb25MYXllci4gRWFjaCBsYXllcnMgaG9sZHMgcmVmZXJlbmNlc1xuXHRcdC8vIHRvIHZhcmlvdXMgQW5pbWF0aW9uQ3VydmVOb2RlcyBhbmQgaXMgcmVmZXJlbmNlZCBieSBhbiBBbmltYXRpb25TdGFjayBub2RlXG5cdFx0Ly8gbm90ZTogdGhlb3JldGljYWxseSBhIHN0YWNrIGNhbiBoYXZlIG11bHRpcGxlIGxheWVycywgaG93ZXZlciBpbiBwcmFjdGljZSB0aGVyZSBhbHdheXMgc2VlbXMgdG8gYmUgb25lIHBlciBzdGFja1xuXHRcdHBhcnNlQW5pbWF0aW9uTGF5ZXJzOiBmdW5jdGlvbiAoIGN1cnZlTm9kZXNNYXAgKSB7XG5cblx0XHRcdHZhciByYXdMYXllcnMgPSBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uTGF5ZXI7XG5cblx0XHRcdHZhciBsYXllcnNNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gcmF3TGF5ZXJzICkge1xuXG5cdFx0XHRcdHZhciBsYXllckN1cnZlTm9kZXMgPSBbXTtcblxuXHRcdFx0XHR2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zLmdldCggcGFyc2VJbnQoIG5vZGVJRCApICk7XG5cblx0XHRcdFx0aWYgKCBjb25uZWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBhbGwgdGhlIGFuaW1hdGlvbkN1cnZlTm9kZXMgdXNlZCBpbiB0aGUgbGF5ZXJcblx0XHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBjb25uZWN0aW9uLmNoaWxkcmVuO1xuXG5cdFx0XHRcdFx0Y2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCwgaSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjdXJ2ZU5vZGVzTWFwLmhhcyggY2hpbGQuSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY3VydmVOb2RlID0gY3VydmVOb2Rlc01hcC5nZXQoIGNoaWxkLklEICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gY2hlY2sgdGhhdCB0aGUgY3VydmVzIGFyZSBkZWZpbmVkIGZvciBhdCBsZWFzdCBvbmUgYXhpcywgb3RoZXJ3aXNlIGlnbm9yZSB0aGUgY3VydmVOb2RlXG5cdFx0XHRcdFx0XHRcdGlmICggY3VydmVOb2RlLmN1cnZlcy54ICE9PSB1bmRlZmluZWQgfHwgY3VydmVOb2RlLmN1cnZlcy55ICE9PSB1bmRlZmluZWQgfHwgY3VydmVOb2RlLmN1cnZlcy56ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtb2RlbElEID0gY29ubmVjdGlvbnMuZ2V0KCBjaGlsZC5JRCApLnBhcmVudHMuZmlsdGVyKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LnJlbGF0aW9uc2hpcCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IClbIDAgXS5JRDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBtb2RlbElEICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJhd01vZGVsID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBtb2RlbElELnRvU3RyaW5nKCkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJhd01vZGVsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IEVuY291bnRlcmVkIGEgdW51c2VkIGN1cnZlLicsIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZGVsTmFtZTogcmF3TW9kZWwuYXR0ck5hbWUgPyBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggcmF3TW9kZWwuYXR0ck5hbWUgKSA6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdElEOiByYXdNb2RlbC5pZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbml0aWFsUG9zaXRpb246IFsgMCwgMCwgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluaXRpYWxSb3RhdGlvbjogWyAwLCAwLCAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFNjYWxlOiBbIDEsIDEsIDEgXSxcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNjZW5lR3JhcGgudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNoaWxkLklEID09PSByYXdNb2RlbC5pZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS50cmFuc2Zvcm0gPSBjaGlsZC5tYXRyaXg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2hpbGQudXNlckRhdGEudHJhbnNmb3JtRGF0YSApIG5vZGUuZXVsZXJPcmRlciA9IGNoaWxkLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEuZXVsZXJPcmRlcjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAhIG5vZGUudHJhbnNmb3JtICkgbm9kZS50cmFuc2Zvcm0gPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBhbmltYXRlZCBtb2RlbCBpcyBwcmUgcm90YXRlZCwgd2UnbGwgaGF2ZSB0byBhcHBseSB0aGUgcHJlIHJvdGF0aW9ucyB0byBldmVyeVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmltYXRpb24gdmFsdWUgYXMgd2VsbFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoICdQcmVSb3RhdGlvbicgaW4gcmF3TW9kZWwgKSBub2RlLnByZVJvdGF0aW9uID0gcmF3TW9kZWwuUHJlUm90YXRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggJ1Bvc3RSb3RhdGlvbicgaW4gcmF3TW9kZWwgKSBub2RlLnBvc3RSb3RhdGlvbiA9IHJhd01vZGVsLlBvc3RSb3RhdGlvbi52YWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsYXllckN1cnZlTm9kZXNbIGkgXSA9IG5vZGU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gKSBsYXllckN1cnZlTm9kZXNbIGkgXVsgY3VydmVOb2RlLmF0dHIgXSA9IGN1cnZlTm9kZTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZU5vZGUuY3VydmVzLm1vcnBoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGxheWVyQ3VydmVOb2Rlc1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBkZWZvcm1lcklEID0gY29ubmVjdGlvbnMuZ2V0KCBjaGlsZC5JRCApLnBhcmVudHMuZmlsdGVyKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LnJlbGF0aW9uc2hpcCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IClbIDAgXS5JRDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1vcnBoZXJJRCA9IGNvbm5lY3Rpb25zLmdldCggZGVmb3JtZXJJRCApLnBhcmVudHNbIDAgXS5JRDtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBnZW9JRCA9IGNvbm5lY3Rpb25zLmdldCggbW9ycGhlcklEICkucGFyZW50c1sgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhc3N1bWluZyBnZW9tZXRyeSBpcyBub3QgdXNlZCBpbiBtb3JlIHRoYW4gb25lIG1vZGVsXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbW9kZWxJRCA9IGNvbm5lY3Rpb25zLmdldCggZ2VvSUQgKS5wYXJlbnRzWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciByYXdNb2RlbCA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgbW9kZWxJRCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtb2RlbE5hbWU6IHJhd01vZGVsLmF0dHJOYW1lID8gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUoIHJhd01vZGVsLmF0dHJOYW1lICkgOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bW9ycGhOYW1lOiBmYnhUcmVlLk9iamVjdHMuRGVmb3JtZXJbIGRlZm9ybWVySUQgXS5hdHRyTmFtZSxcblxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gPSBub2RlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0bGF5ZXJDdXJ2ZU5vZGVzWyBpIF1bIGN1cnZlTm9kZS5hdHRyIF0gPSBjdXJ2ZU5vZGU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRsYXllcnNNYXAuc2V0KCBwYXJzZUludCggbm9kZUlEICksIGxheWVyQ3VydmVOb2RlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGF5ZXJzTWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5BbmltYXRpb25TdGFjay4gVGhlc2UgYXJlIHRoZSB0b3AgbGV2ZWwgbm9kZSBpbiB0aGUgYW5pbWF0aW9uXG5cdFx0Ly8gaGllcmFyY2h5LiBFYWNoIFN0YWNrIG5vZGUgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIEFuaW1hdGlvbkNsaXBcblx0XHRwYXJzZUFuaW1TdGFja3M6IGZ1bmN0aW9uICggbGF5ZXJzTWFwICkge1xuXG5cdFx0XHR2YXIgcmF3U3RhY2tzID0gZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvblN0YWNrO1xuXG5cdFx0XHQvLyBjb25uZWN0IHRoZSBzdGFja3MgKGNsaXBzKSB1cCB0byB0aGUgbGF5ZXJzXG5cdFx0XHR2YXIgcmF3Q2xpcHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiByYXdTdGFja3MgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKS5jaGlsZHJlbjtcblxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0XHQvLyBpdCBzZWVtcyBsaWtlIHN0YWNrcyB3aWxsIGFsd2F5cyBiZSBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgbGF5ZXIuIEJ1dCBqdXN0IGluIGNhc2UgdGhlcmUgYXJlIGZpbGVzXG5cdFx0XHRcdFx0Ly8gd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIGxheWVycyBwZXIgc3RhY2ssIHdlJ2xsIGRpc3BsYXkgYSB3YXJuaW5nXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBFbmNvdW50ZXJlZCBhbiBhbmltYXRpb24gc3RhY2sgd2l0aCBtdWx0aXBsZSBsYXllcnMsIHRoaXMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuIElnbm9yaW5nIHN1YnNlcXVlbnQgbGF5ZXJzLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGxheWVyID0gbGF5ZXJzTWFwLmdldCggY2hpbGRyZW5bIDAgXS5JRCApO1xuXG5cdFx0XHRcdHJhd0NsaXBzWyBub2RlSUQgXSA9IHtcblxuXHRcdFx0XHRcdG5hbWU6IHJhd1N0YWNrc1sgbm9kZUlEIF0uYXR0ck5hbWUsXG5cdFx0XHRcdFx0bGF5ZXI6IGxheWVyLFxuXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJhd0NsaXBzO1xuXG5cdFx0fSxcblxuXHRcdGFkZENsaXA6IGZ1bmN0aW9uICggcmF3Q2xpcCApIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0cmF3Q2xpcC5sYXllci5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd1RyYWNrcyApIHtcblxuXHRcdFx0XHR0cmFja3MgPSB0cmFja3MuY29uY2F0KCBzY29wZS5nZW5lcmF0ZVRyYWNrcyggcmF3VHJhY2tzICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIHJhd0NsaXAubmFtZSwgLSAxLCB0cmFja3MgKTtcblxuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZVRyYWNrczogZnVuY3Rpb24gKCByYXdUcmFja3MgKSB7XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0dmFyIGluaXRpYWxQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgaW5pdGlhbFJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblx0XHRcdHZhciBpbml0aWFsU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRpZiAoIHJhd1RyYWNrcy50cmFuc2Zvcm0gKSByYXdUcmFja3MudHJhbnNmb3JtLmRlY29tcG9zZSggaW5pdGlhbFBvc2l0aW9uLCBpbml0aWFsUm90YXRpb24sIGluaXRpYWxTY2FsZSApO1xuXG5cdFx0XHRpbml0aWFsUG9zaXRpb24gPSBpbml0aWFsUG9zaXRpb24udG9BcnJheSgpO1xuXHRcdFx0aW5pdGlhbFJvdGF0aW9uID0gbmV3IEV1bGVyKCkuc2V0RnJvbVF1YXRlcm5pb24oIGluaXRpYWxSb3RhdGlvbiwgcmF3VHJhY2tzLmV1bGVyT3JkZXIgKS50b0FycmF5KCk7XG5cdFx0XHRpbml0aWFsU2NhbGUgPSBpbml0aWFsU2NhbGUudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHJhd1RyYWNrcy5UICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoIHJhd1RyYWNrcy5ULmN1cnZlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uVHJhY2sgPSB0aGlzLmdlbmVyYXRlVmVjdG9yVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUsIHJhd1RyYWNrcy5ULmN1cnZlcywgaW5pdGlhbFBvc2l0aW9uLCAncG9zaXRpb24nICk7XG5cdFx0XHRcdGlmICggcG9zaXRpb25UcmFjayAhPT0gdW5kZWZpbmVkICkgdHJhY2tzLnB1c2goIHBvc2l0aW9uVHJhY2sgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHJhd1RyYWNrcy5SICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0LmtleXMoIHJhd1RyYWNrcy5SLmN1cnZlcyApLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0dmFyIHJvdGF0aW9uVHJhY2sgPSB0aGlzLmdlbmVyYXRlUm90YXRpb25UcmFjayggcmF3VHJhY2tzLm1vZGVsTmFtZSwgcmF3VHJhY2tzLlIuY3VydmVzLCBpbml0aWFsUm90YXRpb24sIHJhd1RyYWNrcy5wcmVSb3RhdGlvbiwgcmF3VHJhY2tzLnBvc3RSb3RhdGlvbiwgcmF3VHJhY2tzLmV1bGVyT3JkZXIgKTtcblx0XHRcdFx0aWYgKCByb3RhdGlvblRyYWNrICE9PSB1bmRlZmluZWQgKSB0cmFja3MucHVzaCggcm90YXRpb25UcmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmF3VHJhY2tzLlMgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyggcmF3VHJhY2tzLlMuY3VydmVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgc2NhbGVUcmFjayA9IHRoaXMuZ2VuZXJhdGVWZWN0b3JUcmFjayggcmF3VHJhY2tzLm1vZGVsTmFtZSwgcmF3VHJhY2tzLlMuY3VydmVzLCBpbml0aWFsU2NhbGUsICdzY2FsZScgKTtcblx0XHRcdFx0aWYgKCBzY2FsZVRyYWNrICE9PSB1bmRlZmluZWQgKSB0cmFja3MucHVzaCggc2NhbGVUcmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmF3VHJhY2tzLkRlZm9ybVBlcmNlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhUcmFjayA9IHRoaXMuZ2VuZXJhdGVNb3JwaFRyYWNrKCByYXdUcmFja3MgKTtcblx0XHRcdFx0aWYgKCBtb3JwaFRyYWNrICE9PSB1bmRlZmluZWQgKSB0cmFja3MucHVzaCggbW9ycGhUcmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cmFja3M7XG5cblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVWZWN0b3JUcmFjazogZnVuY3Rpb24gKCBtb2RlbE5hbWUsIGN1cnZlcywgaW5pdGlhbFZhbHVlLCB0eXBlICkge1xuXG5cdFx0XHR2YXIgdGltZXMgPSB0aGlzLmdldFRpbWVzRm9yQWxsQXhlcyggY3VydmVzICk7XG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXRLZXlmcmFtZVRyYWNrVmFsdWVzKCB0aW1lcywgY3VydmVzLCBpbml0aWFsVmFsdWUgKTtcblxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3JLZXlmcmFtZVRyYWNrKCBtb2RlbE5hbWUgKyAnLicgKyB0eXBlLCB0aW1lcywgdmFsdWVzICk7XG5cblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVSb3RhdGlvblRyYWNrOiBmdW5jdGlvbiAoIG1vZGVsTmFtZSwgY3VydmVzLCBpbml0aWFsVmFsdWUsIHByZVJvdGF0aW9uLCBwb3N0Um90YXRpb24sIGV1bGVyT3JkZXIgKSB7XG5cblx0XHRcdGlmICggY3VydmVzLnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlUm90YXRpb25zKCBjdXJ2ZXMueCApO1xuXHRcdFx0XHRjdXJ2ZXMueC52YWx1ZXMgPSBjdXJ2ZXMueC52YWx1ZXMubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1cnZlcy55ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVJvdGF0aW9ucyggY3VydmVzLnkgKTtcblx0XHRcdFx0Y3VydmVzLnkudmFsdWVzID0gY3VydmVzLnkudmFsdWVzLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdXJ2ZXMueiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGVSb3RhdGlvbnMoIGN1cnZlcy56ICk7XG5cdFx0XHRcdGN1cnZlcy56LnZhbHVlcyA9IGN1cnZlcy56LnZhbHVlcy5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0aW1lcyA9IHRoaXMuZ2V0VGltZXNGb3JBbGxBeGVzKCBjdXJ2ZXMgKTtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldEtleWZyYW1lVHJhY2tWYWx1ZXMoIHRpbWVzLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSApO1xuXG5cdFx0XHRpZiAoIHByZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cHJlUm90YXRpb24gPSBwcmVSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0XHRwcmVSb3RhdGlvbi5wdXNoKCBldWxlck9yZGVyICk7XG5cblx0XHRcdFx0cHJlUm90YXRpb24gPSBuZXcgRXVsZXIoKS5mcm9tQXJyYXkoIHByZVJvdGF0aW9uICk7XG5cdFx0XHRcdHByZVJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIoIHByZVJvdGF0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwb3N0Um90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwb3N0Um90YXRpb24gPSBwb3N0Um90YXRpb24ubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblx0XHRcdFx0cG9zdFJvdGF0aW9uLnB1c2goIGV1bGVyT3JkZXIgKTtcblxuXHRcdFx0XHRwb3N0Um90YXRpb24gPSBuZXcgRXVsZXIoKS5mcm9tQXJyYXkoIHBvc3RSb3RhdGlvbiApO1xuXHRcdFx0XHRwb3N0Um90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21FdWxlciggcG9zdFJvdGF0aW9uICkuaW52ZXJ0KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdFx0dmFyIGV1bGVyID0gbmV3IEV1bGVyKCk7XG5cblx0XHRcdHZhciBxdWF0ZXJuaW9uVmFsdWVzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRldWxlci5zZXQoIHZhbHVlc1sgaSBdLCB2YWx1ZXNbIGkgKyAxIF0sIHZhbHVlc1sgaSArIDIgXSwgZXVsZXJPcmRlciApO1xuXG5cdFx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApO1xuXG5cdFx0XHRcdGlmICggcHJlUm90YXRpb24gIT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHByZVJvdGF0aW9uICk7XG5cdFx0XHRcdGlmICggcG9zdFJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uLm11bHRpcGx5KCBwb3N0Um90YXRpb24gKTtcblxuXHRcdFx0XHRxdWF0ZXJuaW9uLnRvQXJyYXkoIHF1YXRlcm5pb25WYWx1ZXMsICggaSAvIDMgKSAqIDQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBtb2RlbE5hbWUgKyAnLnF1YXRlcm5pb24nLCB0aW1lcywgcXVhdGVybmlvblZhbHVlcyApO1xuXG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlTW9ycGhUcmFjazogZnVuY3Rpb24gKCByYXdUcmFja3MgKSB7XG5cblx0XHRcdHZhciBjdXJ2ZXMgPSByYXdUcmFja3MuRGVmb3JtUGVyY2VudC5jdXJ2ZXMubW9ycGg7XG5cdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzLnZhbHVlcy5tYXAoIGZ1bmN0aW9uICggdmFsICkge1xuXG5cdFx0XHRcdHJldHVybiB2YWwgLyAxMDA7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dmFyIG1vcnBoTnVtID0gc2NlbmVHcmFwaC5nZXRPYmplY3RCeU5hbWUoIHJhd1RyYWNrcy5tb2RlbE5hbWUgKS5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHJhd1RyYWNrcy5tb3JwaE5hbWUgXTtcblxuXHRcdFx0cmV0dXJuIG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCByYXdUcmFja3MubW9kZWxOYW1lICsgJy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoTnVtICsgJ10nLCBjdXJ2ZXMudGltZXMsIHZhbHVlcyApO1xuXG5cdFx0fSxcblxuXHRcdC8vIEZvciBhbGwgYW5pbWF0ZWQgb2JqZWN0cywgdGltZXMgYXJlIGRlZmluZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBheGlzXG5cdFx0Ly8gSGVyZSB3ZSdsbCBjb21iaW5lIHRoZSB0aW1lcyBpbnRvIG9uZSBzb3J0ZWQgYXJyYXkgd2l0aG91dCBkdXBsaWNhdGVzXG5cdFx0Z2V0VGltZXNGb3JBbGxBeGVzOiBmdW5jdGlvbiAoIGN1cnZlcyApIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gW107XG5cblx0XHRcdC8vIGZpcnN0IGpvaW4gdG9nZXRoZXIgdGhlIHRpbWVzIGZvciBlYWNoIGF4aXMsIGlmIGRlZmluZWRcblx0XHRcdGlmICggY3VydmVzLnggIT09IHVuZGVmaW5lZCApIHRpbWVzID0gdGltZXMuY29uY2F0KCBjdXJ2ZXMueC50aW1lcyApO1xuXHRcdFx0aWYgKCBjdXJ2ZXMueSAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy55LnRpbWVzICk7XG5cdFx0XHRpZiAoIGN1cnZlcy56ICE9PSB1bmRlZmluZWQgKSB0aW1lcyA9IHRpbWVzLmNvbmNhdCggY3VydmVzLnoudGltZXMgKTtcblxuXHRcdFx0Ly8gdGhlbiBzb3J0IHRoZW1cblx0XHRcdHRpbWVzID0gdGltZXMuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0XHRcdHJldHVybiBhIC0gYjtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBhbmQgcmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggdGltZXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHR2YXIgdGFyZ2V0SW5kZXggPSAxO1xuXHRcdFx0XHR2YXIgbGFzdFZhbHVlID0gdGltZXNbIDAgXTtcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgdGltZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRpbWVzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50VmFsdWUgIT09IGxhc3RWYWx1ZSApIHtcblxuXHRcdFx0XHRcdFx0dGltZXNbIHRhcmdldEluZGV4IF0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHRsYXN0VmFsdWUgPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHR0YXJnZXRJbmRleCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGltZXMgPSB0aW1lcy5zbGljZSggMCwgdGFyZ2V0SW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGltZXM7XG5cblx0XHR9LFxuXG5cdFx0Z2V0S2V5ZnJhbWVUcmFja1ZhbHVlczogZnVuY3Rpb24gKCB0aW1lcywgY3VydmVzLCBpbml0aWFsVmFsdWUgKSB7XG5cblx0XHRcdHZhciBwcmV2VmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0dmFyIHhJbmRleCA9IC0gMTtcblx0XHRcdHZhciB5SW5kZXggPSAtIDE7XG5cdFx0XHR2YXIgekluZGV4ID0gLSAxO1xuXG5cdFx0XHR0aW1lcy5mb3JFYWNoKCBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHRcdFx0aWYgKCBjdXJ2ZXMueCApIHhJbmRleCA9IGN1cnZlcy54LnRpbWVzLmluZGV4T2YoIHRpbWUgKTtcblx0XHRcdFx0aWYgKCBjdXJ2ZXMueSApIHlJbmRleCA9IGN1cnZlcy55LnRpbWVzLmluZGV4T2YoIHRpbWUgKTtcblx0XHRcdFx0aWYgKCBjdXJ2ZXMueiApIHpJbmRleCA9IGN1cnZlcy56LnRpbWVzLmluZGV4T2YoIHRpbWUgKTtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhbiB4IHZhbHVlIGRlZmluZWQgZm9yIHRoaXMgZnJhbWUsIHVzZSB0aGF0XG5cdFx0XHRcdGlmICggeEluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHR2YXIgeFZhbHVlID0gY3VydmVzLngudmFsdWVzWyB4SW5kZXggXTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggeFZhbHVlICk7XG5cdFx0XHRcdFx0cHJldlZhbHVlWyAwIF0gPSB4VmFsdWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIHggdmFsdWUgZnJvbSB0aGUgcHJldmlvdXMgZnJhbWVcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggcHJldlZhbHVlWyAwIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB5SW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdHZhciB5VmFsdWUgPSBjdXJ2ZXMueS52YWx1ZXNbIHlJbmRleCBdO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB5VmFsdWUgKTtcblx0XHRcdFx0XHRwcmV2VmFsdWVbIDEgXSA9IHlWYWx1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHByZXZWYWx1ZVsgMSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggekluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHR2YXIgelZhbHVlID0gY3VydmVzLnoudmFsdWVzWyB6SW5kZXggXTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggelZhbHVlICk7XG5cdFx0XHRcdFx0cHJldlZhbHVlWyAyIF0gPSB6VmFsdWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCBwcmV2VmFsdWVbIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fSxcblxuXHRcdC8vIFJvdGF0aW9ucyBhcmUgZGVmaW5lZCBhcyBFdWxlciBhbmdsZXMgd2hpY2ggY2FuIGhhdmUgdmFsdWVzICBvZiBhbnkgc2l6ZVxuXHRcdC8vIFRoZXNlIHdpbGwgYmUgY29udmVydGVkIHRvIHF1YXRlcm5pb25zIHdoaWNoIGRvbid0IHN1cHBvcnQgdmFsdWVzIGdyZWF0ZXIgdGhhblxuXHRcdC8vIFBJLCBzbyB3ZSdsbCBpbnRlcnBvbGF0ZSBsYXJnZSByb3RhdGlvbnNcblx0XHRpbnRlcnBvbGF0ZVJvdGF0aW9uczogZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgY3VydmUudmFsdWVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5pdGlhbFZhbHVlID0gY3VydmUudmFsdWVzWyBpIC0gMSBdO1xuXHRcdFx0XHR2YXIgdmFsdWVzU3BhbiA9IGN1cnZlLnZhbHVlc1sgaSBdIC0gaW5pdGlhbFZhbHVlO1xuXG5cdFx0XHRcdHZhciBhYnNvbHV0ZVNwYW4gPSBNYXRoLmFicyggdmFsdWVzU3BhbiApO1xuXG5cdFx0XHRcdGlmICggYWJzb2x1dGVTcGFuID49IDE4MCApIHtcblxuXHRcdFx0XHRcdHZhciBudW1TdWJJbnRlcnZhbHMgPSBhYnNvbHV0ZVNwYW4gLyAxODA7XG5cblx0XHRcdFx0XHR2YXIgc3RlcCA9IHZhbHVlc1NwYW4gLyBudW1TdWJJbnRlcnZhbHM7XG5cdFx0XHRcdFx0dmFyIG5leHRWYWx1ZSA9IGluaXRpYWxWYWx1ZSArIHN0ZXA7XG5cblx0XHRcdFx0XHR2YXIgaW5pdGlhbFRpbWUgPSBjdXJ2ZS50aW1lc1sgaSAtIDEgXTtcblx0XHRcdFx0XHR2YXIgdGltZVNwYW4gPSBjdXJ2ZS50aW1lc1sgaSBdIC0gaW5pdGlhbFRpbWU7XG5cdFx0XHRcdFx0dmFyIGludGVydmFsID0gdGltZVNwYW4gLyBudW1TdWJJbnRlcnZhbHM7XG5cdFx0XHRcdFx0dmFyIG5leHRUaW1lID0gaW5pdGlhbFRpbWUgKyBpbnRlcnZhbDtcblxuXHRcdFx0XHRcdHZhciBpbnRlcnBvbGF0ZWRUaW1lcyA9IFtdO1xuXHRcdFx0XHRcdHZhciBpbnRlcnBvbGF0ZWRWYWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRcdHdoaWxlICggbmV4dFRpbWUgPCBjdXJ2ZS50aW1lc1sgaSBdICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnBvbGF0ZWRUaW1lcy5wdXNoKCBuZXh0VGltZSApO1xuXHRcdFx0XHRcdFx0bmV4dFRpbWUgKz0gaW50ZXJ2YWw7XG5cblx0XHRcdFx0XHRcdGludGVycG9sYXRlZFZhbHVlcy5wdXNoKCBuZXh0VmFsdWUgKTtcblx0XHRcdFx0XHRcdG5leHRWYWx1ZSArPSBzdGVwO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VydmUudGltZXMgPSBpbmplY3QoIGN1cnZlLnRpbWVzLCBpLCBpbnRlcnBvbGF0ZWRUaW1lcyApO1xuXHRcdFx0XHRcdGN1cnZlLnZhbHVlcyA9IGluamVjdCggY3VydmUudmFsdWVzLCBpLCBpbnRlcnBvbGF0ZWRWYWx1ZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0fTtcblxuXHQvLyBwYXJzZSBhbiBGQlggZmlsZSBpbiBBU0NJSSBmb3JtYXRcblx0ZnVuY3Rpb24gVGV4dFBhcnNlcigpIHt9XG5cblx0VGV4dFBhcnNlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVGV4dFBhcnNlcixcblxuXHRcdGdldFByZXZOb2RlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vZGVTdGFja1sgdGhpcy5jdXJyZW50SW5kZW50IC0gMiBdO1xuXG5cdFx0fSxcblxuXHRcdGdldEN1cnJlbnROb2RlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm5vZGVTdGFja1sgdGhpcy5jdXJyZW50SW5kZW50IC0gMSBdO1xuXG5cdFx0fSxcblxuXHRcdGdldEN1cnJlbnRQcm9wOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnRQcm9wO1xuXG5cdFx0fSxcblxuXHRcdHB1c2hTdGFjazogZnVuY3Rpb24gKCBub2RlICkge1xuXG5cdFx0XHR0aGlzLm5vZGVTdGFjay5wdXNoKCBub2RlICk7XG5cdFx0XHR0aGlzLmN1cnJlbnRJbmRlbnQgKz0gMTtcblxuXHRcdH0sXG5cblx0XHRwb3BTdGFjazogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aGlzLm5vZGVTdGFjay5wb3AoKTtcblx0XHRcdHRoaXMuY3VycmVudEluZGVudCAtPSAxO1xuXG5cdFx0fSxcblxuXHRcdHNldEN1cnJlbnRQcm9wOiBmdW5jdGlvbiAoIHZhbCwgbmFtZSApIHtcblxuXHRcdFx0dGhpcy5jdXJyZW50UHJvcCA9IHZhbDtcblx0XHRcdHRoaXMuY3VycmVudFByb3BOYW1lID0gbmFtZTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRJbmRlbnQgPSAwO1xuXG5cdFx0XHR0aGlzLmFsbE5vZGVzID0gbmV3IEZCWFRyZWUoKTtcblx0XHRcdHRoaXMubm9kZVN0YWNrID0gW107XG5cdFx0XHR0aGlzLmN1cnJlbnRQcm9wID0gW107XG5cdFx0XHR0aGlzLmN1cnJlbnRQcm9wTmFtZSA9ICcnO1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgc3BsaXQgPSB0ZXh0LnNwbGl0KCAvW1xcclxcbl0rLyApO1xuXG5cdFx0XHRzcGxpdC5mb3JFYWNoKCBmdW5jdGlvbiAoIGxpbmUsIGkgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGNoQ29tbWVudCA9IGxpbmUubWF0Y2goIC9eW1xcc1xcdF0qOy8gKTtcblx0XHRcdFx0dmFyIG1hdGNoRW1wdHkgPSBsaW5lLm1hdGNoKCAvXltcXHNcXHRdKiQvICk7XG5cblx0XHRcdFx0aWYgKCBtYXRjaENvbW1lbnQgfHwgbWF0Y2hFbXB0eSApIHJldHVybjtcblxuXHRcdFx0XHR2YXIgbWF0Y2hCZWdpbm5pbmcgPSBsaW5lLm1hdGNoKCAnXlxcXFx0eycgKyBzY29wZS5jdXJyZW50SW5kZW50ICsgJ30oXFxcXHcrKTooLiopeycsICcnICk7XG5cdFx0XHRcdHZhciBtYXRjaFByb3BlcnR5ID0gbGluZS5tYXRjaCggJ15cXFxcdHsnICsgKCBzY29wZS5jdXJyZW50SW5kZW50ICkgKyAnfShcXFxcdyspOltcXFxcc1xcXFx0XFxcXHJcXFxcbl0oLiopJyApO1xuXHRcdFx0XHR2YXIgbWF0Y2hFbmQgPSBsaW5lLm1hdGNoKCAnXlxcXFx0eycgKyAoIHNjb3BlLmN1cnJlbnRJbmRlbnQgLSAxICkgKyAnfX0nICk7XG5cblx0XHRcdFx0aWYgKCBtYXRjaEJlZ2lubmluZyApIHtcblxuXHRcdFx0XHRcdHNjb3BlLnBhcnNlTm9kZUJlZ2luKCBsaW5lLCBtYXRjaEJlZ2lubmluZyApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoUHJvcGVydHkgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5wYXJzZU5vZGVQcm9wZXJ0eSggbGluZSwgbWF0Y2hQcm9wZXJ0eSwgc3BsaXRbICsrIGkgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoRW5kICkge1xuXG5cdFx0XHRcdFx0c2NvcGUucG9wU3RhY2soKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lLm1hdGNoKCAvXlteXFxzXFx0fV0vICkgKSB7XG5cblx0XHRcdFx0XHQvLyBsYXJnZSBhcnJheXMgYXJlIHNwbGl0IG92ZXIgbXVsdGlwbGUgbGluZXMgdGVybWluYXRlZCB3aXRoIGEgJywnIGNoYXJhY3RlclxuXHRcdFx0XHRcdC8vIGlmIHRoaXMgaXMgZW5jb3VudGVyZWQgdGhlIGxpbmUgbmVlZHMgdG8gYmUgam9pbmVkIHRvIHRoZSBwcmV2aW91cyBsaW5lXG5cdFx0XHRcdFx0c2NvcGUucGFyc2VOb2RlUHJvcGVydHlDb250aW51ZWQoIGxpbmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuYWxsTm9kZXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VOb2RlQmVnaW46IGZ1bmN0aW9uICggbGluZSwgcHJvcGVydHkgKSB7XG5cblx0XHRcdHZhciBub2RlTmFtZSA9IHByb3BlcnR5WyAxIF0udHJpbSgpLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApO1xuXG5cdFx0XHR2YXIgbm9kZUF0dHJzID0gcHJvcGVydHlbIDIgXS5zcGxpdCggJywnICkubWFwKCBmdW5jdGlvbiAoIGF0dHIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGF0dHIudHJpbSgpLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciBub2RlID0geyBuYW1lOiBub2RlTmFtZSB9O1xuXHRcdFx0dmFyIGF0dHJzID0gdGhpcy5wYXJzZU5vZGVBdHRyKCBub2RlQXR0cnMgKTtcblxuXHRcdFx0dmFyIGN1cnJlbnROb2RlID0gdGhpcy5nZXRDdXJyZW50Tm9kZSgpO1xuXG5cdFx0XHQvLyBhIHRvcCBub2RlXG5cdFx0XHRpZiAoIHRoaXMuY3VycmVudEluZGVudCA9PT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLmFsbE5vZGVzLmFkZCggbm9kZU5hbWUsIG5vZGUgKTtcblxuXHRcdFx0fSBlbHNlIHsgLy8gYSBzdWJub2RlXG5cblx0XHRcdFx0Ly8gaWYgdGhlIHN1Ym5vZGUgYWxyZWFkeSBleGlzdHMsIGFwcGVuZCBpdFxuXHRcdFx0XHRpZiAoIG5vZGVOYW1lIGluIGN1cnJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIFBvc2UgbmVlZHMgUG9zZU5vZGVzIGFzIGFuIGFycmF5XG5cdFx0XHRcdFx0aWYgKCBub2RlTmFtZSA9PT0gJ1Bvc2VOb2RlJyApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudE5vZGUuUG9zZU5vZGUucHVzaCggbm9kZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VycmVudE5vZGVbIG5vZGVOYW1lIF0uaWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF0gPSB7fTtcblx0XHRcdFx0XHRcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdWyBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXS5pZCBdID0gY3VycmVudE5vZGVbIG5vZGVOYW1lIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJzLmlkICE9PSAnJyApIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdWyBhdHRycy5pZCBdID0gbm9kZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgYXR0cnMuaWQgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF0gPSB7fTtcblx0XHRcdFx0XHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXVsgYXR0cnMuaWQgXSA9IG5vZGU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZU5hbWUgIT09ICdQcm9wZXJ0aWVzNzAnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBub2RlTmFtZSA9PT0gJ1Bvc2VOb2RlJyApXHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXSA9IFsgbm9kZSBdO1xuXHRcdFx0XHRcdGVsc2UgY3VycmVudE5vZGVbIG5vZGVOYW1lIF0gPSBub2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGVvZiBhdHRycy5pZCA9PT0gJ251bWJlcicgKSBub2RlLmlkID0gYXR0cnMuaWQ7XG5cdFx0XHRpZiAoIGF0dHJzLm5hbWUgIT09ICcnICkgbm9kZS5hdHRyTmFtZSA9IGF0dHJzLm5hbWU7XG5cdFx0XHRpZiAoIGF0dHJzLnR5cGUgIT09ICcnICkgbm9kZS5hdHRyVHlwZSA9IGF0dHJzLnR5cGU7XG5cblx0XHRcdHRoaXMucHVzaFN0YWNrKCBub2RlICk7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VOb2RlQXR0cjogZnVuY3Rpb24gKCBhdHRycyApIHtcblxuXHRcdFx0dmFyIGlkID0gYXR0cnNbIDAgXTtcblxuXHRcdFx0aWYgKCBhdHRyc1sgMCBdICE9PSAnJyApIHtcblxuXHRcdFx0XHRpZCA9IHBhcnNlSW50KCBhdHRyc1sgMCBdICk7XG5cblx0XHRcdFx0aWYgKCBpc05hTiggaWQgKSApIHtcblxuXHRcdFx0XHRcdGlkID0gYXR0cnNbIDAgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5hbWUgPSAnJywgdHlwZSA9ICcnO1xuXG5cdFx0XHRpZiAoIGF0dHJzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdFx0bmFtZSA9IGF0dHJzWyAxIF0ucmVwbGFjZSggL14oXFx3Kyk6Oi8sICcnICk7XG5cdFx0XHRcdHR5cGUgPSBhdHRyc1sgMiBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IGlkOiBpZCwgbmFtZTogbmFtZSwgdHlwZTogdHlwZSB9O1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlTm9kZVByb3BlcnR5OiBmdW5jdGlvbiAoIGxpbmUsIHByb3BlcnR5LCBjb250ZW50TGluZSApIHtcblxuXHRcdFx0dmFyIHByb3BOYW1lID0gcHJvcGVydHlbIDEgXS5yZXBsYWNlKCAvXlwiLywgJycgKS5yZXBsYWNlKCAvXCIkLywgJycgKS50cmltKCk7XG5cdFx0XHR2YXIgcHJvcFZhbHVlID0gcHJvcGVydHlbIDIgXS5yZXBsYWNlKCAvXlwiLywgJycgKS5yZXBsYWNlKCAvXCIkLywgJycgKS50cmltKCk7XG5cblx0XHRcdC8vIGZvciBzcGVjaWFsIGNhc2U6IGJhc2U2NCBpbWFnZSBkYXRhIGZvbGxvd3MgXCJDb250ZW50OiAsXCIgbGluZVxuXHRcdFx0Ly9cdENvbnRlbnQ6ICxcblx0XHRcdC8vXHQgXCIvOWovNFJEYVJYaHBaZ0FBVFUwQS4uLlwiXG5cdFx0XHRpZiAoIHByb3BOYW1lID09PSAnQ29udGVudCcgJiYgcHJvcFZhbHVlID09PSAnLCcgKSB7XG5cblx0XHRcdFx0cHJvcFZhbHVlID0gY29udGVudExpbmUucmVwbGFjZSggL1wiL2csICcnICkucmVwbGFjZSggLywkLywgJycgKS50cmltKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnROb2RlID0gdGhpcy5nZXRDdXJyZW50Tm9kZSgpO1xuXHRcdFx0dmFyIHBhcmVudE5hbWUgPSBjdXJyZW50Tm9kZS5uYW1lO1xuXG5cdFx0XHRpZiAoIHBhcmVudE5hbWUgPT09ICdQcm9wZXJ0aWVzNzAnICkge1xuXG5cdFx0XHRcdHRoaXMucGFyc2VOb2RlU3BlY2lhbFByb3BlcnR5KCBsaW5lLCBwcm9wTmFtZSwgcHJvcFZhbHVlICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb25uZWN0aW9uc1xuXHRcdFx0aWYgKCBwcm9wTmFtZSA9PT0gJ0MnICkge1xuXG5cdFx0XHRcdHZhciBjb25uUHJvcHMgPSBwcm9wVmFsdWUuc3BsaXQoICcsJyApLnNsaWNlKCAxICk7XG5cdFx0XHRcdHZhciBmcm9tID0gcGFyc2VJbnQoIGNvbm5Qcm9wc1sgMCBdICk7XG5cdFx0XHRcdHZhciB0byA9IHBhcnNlSW50KCBjb25uUHJvcHNbIDEgXSApO1xuXG5cdFx0XHRcdHZhciByZXN0ID0gcHJvcFZhbHVlLnNwbGl0KCAnLCcgKS5zbGljZSggMyApO1xuXG5cdFx0XHRcdHJlc3QgPSByZXN0Lm1hcCggZnVuY3Rpb24gKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0udHJpbSgpLnJlcGxhY2UoIC9eXCIvLCAnJyApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRwcm9wTmFtZSA9ICdjb25uZWN0aW9ucyc7XG5cdFx0XHRcdHByb3BWYWx1ZSA9IFsgZnJvbSwgdG8gXTtcblx0XHRcdFx0YXBwZW5kKCBwcm9wVmFsdWUsIHJlc3QgKTtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb2RlXG5cdFx0XHRpZiAoIHByb3BOYW1lID09PSAnTm9kZScgKSBjdXJyZW50Tm9kZS5pZCA9IHByb3BWYWx1ZTtcblxuXHRcdFx0Ly8gY29ubmVjdGlvbnNcblx0XHRcdGlmICggcHJvcE5hbWUgaW4gY3VycmVudE5vZGUgJiYgQXJyYXkuaXNBcnJheSggY3VycmVudE5vZGVbIHByb3BOYW1lIF0gKSApIHtcblxuXHRcdFx0XHRjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXS5wdXNoKCBwcm9wVmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHByb3BOYW1lICE9PSAnYScgKSBjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSA9IHByb3BWYWx1ZTtcblx0XHRcdFx0ZWxzZSBjdXJyZW50Tm9kZS5hID0gcHJvcFZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0Q3VycmVudFByb3AoIGN1cnJlbnROb2RlLCBwcm9wTmFtZSApO1xuXG5cdFx0XHQvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSwgdW5sZXNzIGl0IGVuZHMgaW4gJywnIGluIHdoaWNoIGNhc2UgbW9yZSB3aWxsIGJlIGFkZGVkIHRvIGl0XG5cdFx0XHRpZiAoIHByb3BOYW1lID09PSAnYScgJiYgcHJvcFZhbHVlLnNsaWNlKCAtIDEgKSAhPT0gJywnICkge1xuXG5cdFx0XHRcdGN1cnJlbnROb2RlLmEgPSBwYXJzZU51bWJlckFycmF5KCBwcm9wVmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHBhcnNlTm9kZVByb3BlcnR5Q29udGludWVkOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRcdHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZ2V0Q3VycmVudE5vZGUoKTtcblxuXHRcdFx0Y3VycmVudE5vZGUuYSArPSBsaW5lO1xuXG5cdFx0XHQvLyBpZiB0aGUgbGluZSBkb2Vzbid0IGVuZCBpbiAnLCcgd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHByb3BlcnR5IHZhbHVlXG5cdFx0XHQvLyBzbyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYW4gYXJyYXlcblx0XHRcdGlmICggbGluZS5zbGljZSggLSAxICkgIT09ICcsJyApIHtcblxuXHRcdFx0XHRjdXJyZW50Tm9kZS5hID0gcGFyc2VOdW1iZXJBcnJheSggY3VycmVudE5vZGUuYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2UgXCJQcm9wZXJ0eTcwXCJcblx0XHRwYXJzZU5vZGVTcGVjaWFsUHJvcGVydHk6IGZ1bmN0aW9uICggbGluZSwgcHJvcE5hbWUsIHByb3BWYWx1ZSApIHtcblxuXHRcdFx0Ly8gc3BsaXQgdGhpc1xuXHRcdFx0Ly8gUDogXCJMY2wgU2NhbGluZ1wiLCBcIkxjbCBTY2FsaW5nXCIsIFwiXCIsIFwiQVwiLDEsMSwxXG5cdFx0XHQvLyBpbnRvIGFycmF5IGxpa2UgYmVsb3dcblx0XHRcdC8vIFtcIkxjbCBTY2FsaW5nXCIsIFwiTGNsIFNjYWxpbmdcIiwgXCJcIiwgXCJBXCIsIFwiMSwxLDFcIiBdXG5cdFx0XHR2YXIgcHJvcHMgPSBwcm9wVmFsdWUuc3BsaXQoICdcIiwnICkubWFwKCBmdW5jdGlvbiAoIHByb3AgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHByb3AudHJpbSgpLnJlcGxhY2UoIC9eXFxcIi8sICcnICkucmVwbGFjZSggL1xccy8sICdfJyApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHZhciBpbm5lclByb3BOYW1lID0gcHJvcHNbIDAgXTtcblx0XHRcdHZhciBpbm5lclByb3BUeXBlMSA9IHByb3BzWyAxIF07XG5cdFx0XHR2YXIgaW5uZXJQcm9wVHlwZTIgPSBwcm9wc1sgMiBdO1xuXHRcdFx0dmFyIGlubmVyUHJvcEZsYWcgPSBwcm9wc1sgMyBdO1xuXHRcdFx0dmFyIGlubmVyUHJvcFZhbHVlID0gcHJvcHNbIDQgXTtcblxuXHRcdFx0Ly8gY2FzdCB2YWx1ZXMgd2hlcmUgbmVlZGVkLCBvdGhlcndpc2UgbGVhdmUgYXMgc3RyaW5nc1xuXHRcdFx0c3dpdGNoICggaW5uZXJQcm9wVHlwZTEgKSB7XG5cblx0XHRcdFx0Y2FzZSAnaW50Jzpcblx0XHRcdFx0Y2FzZSAnZW51bSc6XG5cdFx0XHRcdGNhc2UgJ2Jvb2wnOlxuXHRcdFx0XHRjYXNlICdVTG9uZ0xvbmcnOlxuXHRcdFx0XHRjYXNlICdkb3VibGUnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRjYXNlICdGaWVsZE9mVmlldyc6XG5cdFx0XHRcdFx0aW5uZXJQcm9wVmFsdWUgPSBwYXJzZUZsb2F0KCBpbm5lclByb3BWYWx1ZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0NvbG9yJzpcblx0XHRcdFx0Y2FzZSAnQ29sb3JSR0InOlxuXHRcdFx0XHRjYXNlICdWZWN0b3IzRCc6XG5cdFx0XHRcdGNhc2UgJ0xjbF9UcmFuc2xhdGlvbic6XG5cdFx0XHRcdGNhc2UgJ0xjbF9Sb3RhdGlvbic6XG5cdFx0XHRcdGNhc2UgJ0xjbF9TY2FsaW5nJzpcblx0XHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IHBhcnNlTnVtYmVyQXJyYXkoIGlubmVyUHJvcFZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ0FVVElPTjogdGhlc2UgcHJvcHMgbXVzdCBhcHBlbmQgdG8gcGFyZW50J3MgcGFyZW50XG5cdFx0XHR0aGlzLmdldFByZXZOb2RlKClbIGlubmVyUHJvcE5hbWUgXSA9IHtcblxuXHRcdFx0XHQndHlwZSc6IGlubmVyUHJvcFR5cGUxLFxuXHRcdFx0XHQndHlwZTInOiBpbm5lclByb3BUeXBlMixcblx0XHRcdFx0J2ZsYWcnOiBpbm5lclByb3BGbGFnLFxuXHRcdFx0XHQndmFsdWUnOiBpbm5lclByb3BWYWx1ZVxuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLnNldEN1cnJlbnRQcm9wKCB0aGlzLmdldFByZXZOb2RlKCksIGlubmVyUHJvcE5hbWUgKTtcblxuXHRcdH0sXG5cblx0fTtcblxuXHQvLyBQYXJzZSBhbiBGQlggZmlsZSBpbiBCaW5hcnkgZm9ybWF0XG5cdGZ1bmN0aW9uIEJpbmFyeVBhcnNlcigpIHt9XG5cblx0QmluYXJ5UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBCaW5hcnlQYXJzZXIsXG5cblx0XHRwYXJzZTogZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHZhciByZWFkZXIgPSBuZXcgQmluYXJ5UmVhZGVyKCBidWZmZXIgKTtcblx0XHRcdHJlYWRlci5za2lwKCAyMyApOyAvLyBza2lwIG1hZ2ljIDIzIGJ5dGVzXG5cblx0XHRcdHZhciB2ZXJzaW9uID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXG5cdFx0XHRpZiAoIHZlcnNpb24gPCA2NDAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogRkJYIHZlcnNpb24gbm90IHN1cHBvcnRlZCwgRmlsZVZlcnNpb246ICcgKyB2ZXJzaW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGFsbE5vZGVzID0gbmV3IEZCWFRyZWUoKTtcblxuXHRcdFx0d2hpbGUgKCAhIHRoaXMuZW5kT2ZDb250ZW50KCByZWFkZXIgKSApIHtcblxuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMucGFyc2VOb2RlKCByZWFkZXIsIHZlcnNpb24gKTtcblx0XHRcdFx0aWYgKCBub2RlICE9PSBudWxsICkgYWxsTm9kZXMuYWRkKCBub2RlLm5hbWUsIG5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWxsTm9kZXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gQ2hlY2sgaWYgcmVhZGVyIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgY29udGVudC5cblx0XHRlbmRPZkNvbnRlbnQ6IGZ1bmN0aW9uICggcmVhZGVyICkge1xuXG5cdFx0XHQvLyBmb290ZXIgc2l6ZTogMTYwYnl0ZXMgKyAxNi1ieXRlIGFsaWdubWVudCBwYWRkaW5nXG5cdFx0XHQvLyAtIDE2Ynl0ZXM6IG1hZ2ljXG5cdFx0XHQvLyAtIHBhZGRpbmcgdGlsIDE2LWJ5dGUgYWxpZ25tZW50IChhdCBsZWFzdCAxYnl0ZT8pXG5cdFx0XHQvL1x0KHNlZW1zIGxpa2Ugc29tZSBleHBvcnRlcnMgZW1iZWQgZml4ZWQgMTUgb3IgMTZieXRlcz8pXG5cdFx0XHQvLyAtIDRieXRlczogbWFnaWNcblx0XHRcdC8vIC0gNGJ5dGVzOiB2ZXJzaW9uXG5cdFx0XHQvLyAtIDEyMGJ5dGVzOiB6ZXJvXG5cdFx0XHQvLyAtIDE2Ynl0ZXM6IG1hZ2ljXG5cdFx0XHRpZiAoIHJlYWRlci5zaXplKCkgJSAxNiA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gKCAoIHJlYWRlci5nZXRPZmZzZXQoKSArIDE2MCArIDE2ICkgJiB+IDB4ZiApID49IHJlYWRlci5zaXplKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRPZmZzZXQoKSArIDE2MCArIDE2ID49IHJlYWRlci5zaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyByZWN1cnNpdmVseSBwYXJzZSBub2RlcyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBmaWxlIGlzIHJlYWNoZWRcblx0XHRwYXJzZU5vZGU6IGZ1bmN0aW9uICggcmVhZGVyLCB2ZXJzaW9uICkge1xuXG5cdFx0XHR2YXIgbm9kZSA9IHt9O1xuXG5cdFx0XHQvLyBUaGUgZmlyc3QgdGhyZWUgZGF0YSBzaXplcyBkZXBlbmRzIG9uIHZlcnNpb24uXG5cdFx0XHR2YXIgZW5kT2Zmc2V0ID0gKCB2ZXJzaW9uID49IDc1MDAgKSA/IHJlYWRlci5nZXRVaW50NjQoKSA6IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRcdHZhciBudW1Qcm9wZXJ0aWVzID0gKCB2ZXJzaW9uID49IDc1MDAgKSA/IHJlYWRlci5nZXRVaW50NjQoKSA6IHJlYWRlci5nZXRVaW50MzIoKTtcblxuXHRcdFx0KCB2ZXJzaW9uID49IDc1MDAgKSA/IHJlYWRlci5nZXRVaW50NjQoKSA6IHJlYWRlci5nZXRVaW50MzIoKTsgLy8gdGhlIHJldHVybmVkIHByb3BlcnR5TGlzdExlbiBpcyBub3QgdXNlZFxuXG5cdFx0XHR2YXIgbmFtZUxlbiA9IHJlYWRlci5nZXRVaW50OCgpO1xuXHRcdFx0dmFyIG5hbWUgPSByZWFkZXIuZ2V0U3RyaW5nKCBuYW1lTGVuICk7XG5cblx0XHRcdC8vIFJlZ2FyZHMgdGhpcyBub2RlIGFzIE5VTEwtcmVjb3JkIGlmIGVuZE9mZnNldCBpcyB6ZXJvXG5cdFx0XHRpZiAoIGVuZE9mZnNldCA9PT0gMCApIHJldHVybiBudWxsO1xuXG5cdFx0XHR2YXIgcHJvcGVydHlMaXN0ID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bVByb3BlcnRpZXM7IGkgKysgKSB7XG5cblx0XHRcdFx0cHJvcGVydHlMaXN0LnB1c2goIHRoaXMucGFyc2VQcm9wZXJ0eSggcmVhZGVyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWdhcmRzIHRoZSBmaXJzdCB0aHJlZSBlbGVtZW50cyBpbiBwcm9wZXJ0eUxpc3QgYXMgaWQsIGF0dHJOYW1lLCBhbmQgYXR0clR5cGVcblx0XHRcdHZhciBpZCA9IHByb3BlcnR5TGlzdC5sZW5ndGggPiAwID8gcHJvcGVydHlMaXN0WyAwIF0gOiAnJztcblx0XHRcdHZhciBhdHRyTmFtZSA9IHByb3BlcnR5TGlzdC5sZW5ndGggPiAxID8gcHJvcGVydHlMaXN0WyAxIF0gOiAnJztcblx0XHRcdHZhciBhdHRyVHlwZSA9IHByb3BlcnR5TGlzdC5sZW5ndGggPiAyID8gcHJvcGVydHlMaXN0WyAyIF0gOiAnJztcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhpcyBub2RlIHJlcHJlc2VudHMganVzdCBhIHNpbmdsZSBwcm9wZXJ0eVxuXHRcdFx0Ly8gbGlrZSAobmFtZSwgMCkgc2V0IG9yIChuYW1lMiwgWzAsIDEsIDJdKSBzZXQgb2Yge25hbWU6IDAsIG5hbWUyOiBbMCwgMSwgMl19XG5cdFx0XHRub2RlLnNpbmdsZVByb3BlcnR5ID0gKCBudW1Qcm9wZXJ0aWVzID09PSAxICYmIHJlYWRlci5nZXRPZmZzZXQoKSA9PT0gZW5kT2Zmc2V0ICkgPyB0cnVlIDogZmFsc2U7XG5cblx0XHRcdHdoaWxlICggZW5kT2Zmc2V0ID4gcmVhZGVyLmdldE9mZnNldCgpICkge1xuXG5cdFx0XHRcdHZhciBzdWJOb2RlID0gdGhpcy5wYXJzZU5vZGUoIHJlYWRlciwgdmVyc2lvbiApO1xuXG5cdFx0XHRcdGlmICggc3ViTm9kZSAhPT0gbnVsbCApIHRoaXMucGFyc2VTdWJOb2RlKCBuYW1lLCBub2RlLCBzdWJOb2RlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bm9kZS5wcm9wZXJ0eUxpc3QgPSBwcm9wZXJ0eUxpc3Q7IC8vIHJhdyBwcm9wZXJ0eSBsaXN0IHVzZWQgYnkgcGFyZW50XG5cblx0XHRcdGlmICggdHlwZW9mIGlkID09PSAnbnVtYmVyJyApIG5vZGUuaWQgPSBpZDtcblx0XHRcdGlmICggYXR0ck5hbWUgIT09ICcnICkgbm9kZS5hdHRyTmFtZSA9IGF0dHJOYW1lO1xuXHRcdFx0aWYgKCBhdHRyVHlwZSAhPT0gJycgKSBub2RlLmF0dHJUeXBlID0gYXR0clR5cGU7XG5cdFx0XHRpZiAoIG5hbWUgIT09ICcnICkgbm9kZS5uYW1lID0gbmFtZTtcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VTdWJOb2RlOiBmdW5jdGlvbiAoIG5hbWUsIG5vZGUsIHN1Yk5vZGUgKSB7XG5cblx0XHRcdC8vIHNwZWNpYWwgY2FzZTogY2hpbGQgbm9kZSBpcyBzaW5nbGUgcHJvcGVydHlcblx0XHRcdGlmICggc3ViTm9kZS5zaW5nbGVQcm9wZXJ0eSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMCBdO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0gc3ViTm9kZTtcblxuXHRcdFx0XHRcdHN1Yk5vZGUuYSA9IHZhbHVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ0Nvbm5lY3Rpb25zJyAmJiBzdWJOb2RlLm5hbWUgPT09ICdDJyApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRzdWJOb2RlLnByb3BlcnR5TGlzdC5mb3JFYWNoKCBmdW5jdGlvbiAoIHByb3BlcnR5LCBpICkge1xuXG5cdFx0XHRcdFx0Ly8gZmlyc3QgQ29ubmVjdGlvbiBpcyBGQlggdHlwZSAoT08sIE9QLCBldGMuKS4gV2UnbGwgZGlzY2FyZCB0aGVzZVxuXHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGFycmF5LnB1c2goIHByb3BlcnR5ICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGlmICggbm9kZS5jb25uZWN0aW9ucyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9kZS5jb25uZWN0aW9ucyA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRub2RlLmNvbm5lY3Rpb25zLnB1c2goIGFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHN1Yk5vZGUubmFtZSA9PT0gJ1Byb3BlcnRpZXM3MCcgKSB7XG5cblx0XHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggc3ViTm9kZSApO1xuXG5cdFx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24gKCBrZXkgKSB7XG5cblx0XHRcdFx0XHRub2RlWyBrZXkgXSA9IHN1Yk5vZGVbIGtleSBdO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ1Byb3BlcnRpZXM3MCcgJiYgc3ViTm9kZS5uYW1lID09PSAnUCcgKSB7XG5cblx0XHRcdFx0dmFyIGlubmVyUHJvcE5hbWUgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMCBdO1xuXHRcdFx0XHR2YXIgaW5uZXJQcm9wVHlwZTEgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMSBdO1xuXHRcdFx0XHR2YXIgaW5uZXJQcm9wVHlwZTIgPSBzdWJOb2RlLnByb3BlcnR5TGlzdFsgMiBdO1xuXHRcdFx0XHR2YXIgaW5uZXJQcm9wRmxhZyA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAzIF07XG5cdFx0XHRcdHZhciBpbm5lclByb3BWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIGlubmVyUHJvcE5hbWUuaW5kZXhPZiggJ0xjbCAnICkgPT09IDAgKSBpbm5lclByb3BOYW1lID0gaW5uZXJQcm9wTmFtZS5yZXBsYWNlKCAnTGNsICcsICdMY2xfJyApO1xuXHRcdFx0XHRpZiAoIGlubmVyUHJvcFR5cGUxLmluZGV4T2YoICdMY2wgJyApID09PSAwICkgaW5uZXJQcm9wVHlwZTEgPSBpbm5lclByb3BUeXBlMS5yZXBsYWNlKCAnTGNsICcsICdMY2xfJyApO1xuXG5cdFx0XHRcdGlmICggaW5uZXJQcm9wVHlwZTEgPT09ICdDb2xvcicgfHwgaW5uZXJQcm9wVHlwZTEgPT09ICdDb2xvclJHQicgfHwgaW5uZXJQcm9wVHlwZTEgPT09ICdWZWN0b3InIHx8IGlubmVyUHJvcFR5cGUxID09PSAnVmVjdG9yM0QnIHx8IGlubmVyUHJvcFR5cGUxLmluZGV4T2YoICdMY2xfJyApID09PSAwICkge1xuXG5cdFx0XHRcdFx0aW5uZXJQcm9wVmFsdWUgPSBbXG5cdFx0XHRcdFx0XHRzdWJOb2RlLnByb3BlcnR5TGlzdFsgNCBdLFxuXHRcdFx0XHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDUgXSxcblx0XHRcdFx0XHRcdHN1Yk5vZGUucHJvcGVydHlMaXN0WyA2IF1cblx0XHRcdFx0XHRdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyA0IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRoaXMgd2lsbCBiZSBjb3BpZWQgdG8gcGFyZW50LCBzZWUgYWJvdmVcblx0XHRcdFx0bm9kZVsgaW5uZXJQcm9wTmFtZSBdID0ge1xuXG5cdFx0XHRcdFx0J3R5cGUnOiBpbm5lclByb3BUeXBlMSxcblx0XHRcdFx0XHQndHlwZTInOiBpbm5lclByb3BUeXBlMixcblx0XHRcdFx0XHQnZmxhZyc6IGlubmVyUHJvcEZsYWcsXG5cdFx0XHRcdFx0J3ZhbHVlJzogaW5uZXJQcm9wVmFsdWVcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBub2RlWyBzdWJOb2RlLm5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIHN1Yk5vZGUuaWQgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSB7fTtcblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXVsgc3ViTm9kZS5pZCBdID0gc3ViTm9kZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSBzdWJOb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIHN1Yk5vZGUubmFtZSA9PT0gJ1Bvc2VOb2RlJyApIHtcblxuXHRcdFx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBub2RlWyBzdWJOb2RlLm5hbWUgXSApICkge1xuXG5cdFx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IFsgbm9kZVsgc3ViTm9kZS5uYW1lIF0gXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdLnB1c2goIHN1Yk5vZGUgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlWyBzdWJOb2RlLm5hbWUgXVsgc3ViTm9kZS5pZCBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXVsgc3ViTm9kZS5pZCBdID0gc3ViTm9kZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRwYXJzZVByb3BlcnR5OiBmdW5jdGlvbiAoIHJlYWRlciApIHtcblxuXHRcdFx0dmFyIHR5cGUgPSByZWFkZXIuZ2V0U3RyaW5nKCAxICk7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRCb29sZWFuKCk7XG5cblx0XHRcdFx0Y2FzZSAnRCc6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRGbG9hdDY0KCk7XG5cblx0XHRcdFx0Y2FzZSAnRic6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRGbG9hdDMyKCk7XG5cblx0XHRcdFx0Y2FzZSAnSSc6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQzMigpO1xuXG5cdFx0XHRcdGNhc2UgJ0wnOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50NjQoKTtcblxuXHRcdFx0XHRjYXNlICdSJzpcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0QXJyYXlCdWZmZXIoIGxlbmd0aCApO1xuXG5cdFx0XHRcdGNhc2UgJ1MnOlxuXHRcdFx0XHRcdHZhciBsZW5ndGggPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRTdHJpbmcoIGxlbmd0aCApO1xuXG5cdFx0XHRcdGNhc2UgJ1knOlxuXHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50MTYoKTtcblxuXHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRjYXNlICdmJzpcblx0XHRcdFx0Y2FzZSAnaSc6XG5cdFx0XHRcdGNhc2UgJ2wnOlxuXG5cdFx0XHRcdFx0dmFyIGFycmF5TGVuZ3RoID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXHRcdFx0XHRcdHZhciBlbmNvZGluZyA9IHJlYWRlci5nZXRVaW50MzIoKTsgLy8gMDogbm9uLWNvbXByZXNzZWQsIDE6IGNvbXByZXNzZWRcblx0XHRcdFx0XHR2YXIgY29tcHJlc3NlZExlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblxuXHRcdFx0XHRcdGlmICggZW5jb2RpbmcgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0Qm9vbGVhbkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0RmxvYXQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0RmxvYXQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50MzJBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEludDY0QXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGZmbGF0ZSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IEV4dGVybmFsIGxpYnJhcnkgZmZsYXRlLm1pbi5qcyByZXF1aXJlZC4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IEpyKCBuZXcgVWludDhBcnJheSggcmVhZGVyLmdldEFycmF5QnVmZmVyKCBjb21wcmVzc2VkTGVuZ3RoICkgKSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cdFx0XHRcdFx0dmFyIHJlYWRlcjIgPSBuZXcgQmluYXJ5UmVhZGVyKCBkYXRhLmJ1ZmZlciApO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYic6XG5cdFx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0Qm9vbGVhbkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0RmxvYXQ2NEFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdmJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0RmxvYXQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0SW50MzJBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIyLmdldEludDY0QXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IFVua25vd24gcHJvcGVydHkgdHlwZSAnICsgdHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBCaW5hcnlSZWFkZXIoIGJ1ZmZlciwgbGl0dGxlRW5kaWFuICkge1xuXG5cdFx0dGhpcy5kdiA9IG5ldyBEYXRhVmlldyggYnVmZmVyICk7XG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xuXHRcdHRoaXMubGl0dGxlRW5kaWFuID0gKCBsaXR0bGVFbmRpYW4gIT09IHVuZGVmaW5lZCApID8gbGl0dGxlRW5kaWFuIDogdHJ1ZTtcblxuXHR9XG5cblx0QmluYXJ5UmVhZGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBCaW5hcnlSZWFkZXIsXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMub2Zmc2V0O1xuXG5cdFx0fSxcblxuXHRcdHNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZHYuYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0XHR9LFxuXG5cdFx0c2tpcDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblxuXHRcdH0sXG5cblx0XHQvLyBzZWVtcyBsaWtlIHRydWUvZmFsc2UgcmVwcmVzZW50YXRpb24gZGVwZW5kcyBvbiBleHBvcnRlci5cblx0XHQvLyB0cnVlOiAxIG9yICdZJyg9MHg1OSksIGZhbHNlOiAwIG9yICdUJyg9MHg1NClcblx0XHQvLyB0aGVuIHNlZXMgTFNCLlxuXHRcdGdldEJvb2xlYW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXRVaW50OCgpICYgMSApID09PSAxO1xuXG5cdFx0fSxcblxuXHRcdGdldEJvb2xlYW5BcnJheTogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGEucHVzaCggdGhpcy5nZXRCb29sZWFuKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblxuXHRcdH0sXG5cblx0XHRnZXRVaW50ODogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldFVpbnQ4KCB0aGlzLm9mZnNldCApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gMTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRJbnQxNjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldEludDE2KCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0SW50MzI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRJbnQzMiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldEludDMyQXJyYXk6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhLnB1c2goIHRoaXMuZ2V0SW50MzIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXG5cdFx0fSxcblxuXHRcdGdldFVpbnQzMjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldFVpbnQzMiggdGhpcy5vZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSA0O1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdC8vIEphdmFTY3JpcHQgZG9lc24ndCBzdXBwb3J0IDY0LWJpdCBpbnRlZ2VyIHNvIGNhbGN1bGF0ZSB0aGlzIGhlcmVcblx0XHQvLyAxIDw8IDMyIHdpbGwgcmV0dXJuIDEgc28gdXNpbmcgbXVsdGlwbHkgb3BlcmF0aW9uIGluc3RlYWQgaGVyZS5cblx0XHQvLyBUaGVyZSdzIGEgcG9zc2liaWxpdHkgdGhhdCB0aGlzIG1ldGhvZCByZXR1cm5zIHdyb25nIHZhbHVlIGlmIHRoZSB2YWx1ZVxuXHRcdC8vIGlzIG91dCBvZiB0aGUgcmFuZ2UgYmV0d2VlbiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiBhbmQgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIuXG5cdFx0Ly8gVE9ETzogc2FmZWx5IGhhbmRsZSA2NC1iaXQgaW50ZWdlclxuXHRcdGdldEludDY0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciBsb3csIGhpZ2g7XG5cblx0XHRcdGlmICggdGhpcy5saXR0bGVFbmRpYW4gKSB7XG5cblx0XHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblx0XHRcdFx0aGlnaCA9IHRoaXMuZ2V0VWludDMyKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGlnaCA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRcdGxvdyA9IHRoaXMuZ2V0VWludDMyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5lZ2F0aXZlIHZhbHVlXG5cdFx0XHRpZiAoIGhpZ2ggJiAweDgwMDAwMDAwICkge1xuXG5cdFx0XHRcdGhpZ2ggPSB+IGhpZ2ggJiAweEZGRkZGRkZGO1xuXHRcdFx0XHRsb3cgPSB+IGxvdyAmIDB4RkZGRkZGRkY7XG5cblx0XHRcdFx0aWYgKCBsb3cgPT09IDB4RkZGRkZGRkYgKSBoaWdoID0gKCBoaWdoICsgMSApICYgMHhGRkZGRkZGRjtcblxuXHRcdFx0XHRsb3cgPSAoIGxvdyArIDEgKSAmIDB4RkZGRkZGRkY7XG5cblx0XHRcdFx0cmV0dXJuIC0gKCBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGlnaCAqIDB4MTAwMDAwMDAwICsgbG93O1xuXG5cdFx0fSxcblxuXHRcdGdldEludDY0QXJyYXk6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhLnB1c2goIHRoaXMuZ2V0SW50NjQoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXG5cdFx0fSxcblxuXHRcdC8vIE5vdGU6IHNlZSBnZXRJbnQ2NCgpIGNvbW1lbnRcblx0XHRnZXRVaW50NjQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGxvdywgaGlnaDtcblxuXHRcdFx0aWYgKCB0aGlzLmxpdHRsZUVuZGlhbiApIHtcblxuXHRcdFx0XHRsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuXHRcdFx0XHRoaWdoID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRoaWdoID0gdGhpcy5nZXRVaW50MzIoKTtcblx0XHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGlnaCAqIDB4MTAwMDAwMDAwICsgbG93O1xuXG5cdFx0fSxcblxuXHRcdGdldEZsb2F0MzI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRGbG9hdDMyKCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RmxvYXQzMkFycmF5OiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YS5wdXNoKCB0aGlzLmdldEZsb2F0MzIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXG5cdFx0fSxcblxuXHRcdGdldEZsb2F0NjQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5nZXRGbG9hdDY0KCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDg7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RmxvYXQ2NEFycmF5OiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YS5wdXNoKCB0aGlzLmdldEZsb2F0NjQoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXG5cdFx0fSxcblxuXHRcdGdldEFycmF5QnVmZmVyOiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuYnVmZmVyLnNsaWNlKCB0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBzaXplICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSBzaXplO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldFN0cmluZzogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHQvLyBub3RlOiBzYWZhcmkgOSBkb2Vzbid0IHN1cHBvcnQgVWludDhBcnJheS5pbmRleE9mOyBjcmVhdGUgaW50ZXJtZWRpYXRlIGFycmF5IGluc3RlYWRcblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YVsgaSBdID0gdGhpcy5nZXRVaW50OCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBudWxsQnl0ZSA9IGEuaW5kZXhPZiggMCApO1xuXHRcdFx0aWYgKCBudWxsQnl0ZSA+PSAwICkgYSA9IGEuc2xpY2UoIDAsIG51bGxCeXRlICk7XG5cblx0XHRcdHJldHVybiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggYSApICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBGQlhUcmVlIGhvbGRzIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIEZCWCBkYXRhLCByZXR1cm5lZCBieSB0aGUgVGV4dFBhcnNlciAoIEZCWCBBU0NJSSBmb3JtYXQpXG5cdC8vIGFuZCBCaW5hcnlQYXJzZXIoIEZCWCBCaW5hcnkgZm9ybWF0KVxuXHRmdW5jdGlvbiBGQlhUcmVlKCkge31cblxuXHRGQlhUcmVlLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBGQlhUcmVlLFxuXG5cdFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgdmFsICkge1xuXG5cdFx0XHR0aGlzWyBrZXkgXSA9IHZhbDtcblxuXHRcdH0sXG5cblx0fTtcblxuXHQvLyAqKioqKioqKioqKioqKiBVVElMSVRZIEZVTkNUSU9OUyAqKioqKioqKioqKioqKlxuXG5cdGZ1bmN0aW9uIGlzRmJ4Rm9ybWF0QmluYXJ5KCBidWZmZXIgKSB7XG5cblx0XHR2YXIgQ09SUkVDVCA9ICdLYXlkYXJhIEZCWCBCaW5hcnkgIFxcMCc7XG5cblx0XHRyZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGggPj0gQ09SUkVDVC5sZW5ndGggJiYgQ09SUkVDVCA9PT0gY29udmVydEFycmF5QnVmZmVyVG9TdHJpbmcoIGJ1ZmZlciwgMCwgQ09SUkVDVC5sZW5ndGggKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNGYnhGb3JtYXRBU0NJSSggdGV4dCApIHtcblxuXHRcdHZhciBDT1JSRUNUID0gWyAnSycsICdhJywgJ3knLCAnZCcsICdhJywgJ3InLCAnYScsICdcXFxcJywgJ0YnLCAnQicsICdYJywgJ1xcXFwnLCAnQicsICdpJywgJ24nLCAnYScsICdyJywgJ3knLCAnXFxcXCcsICdcXFxcJyBdO1xuXG5cdFx0dmFyIGN1cnNvciA9IDA7XG5cblx0XHRmdW5jdGlvbiByZWFkKCBvZmZzZXQgKSB7XG5cblx0XHRcdHZhciByZXN1bHQgPSB0ZXh0WyBvZmZzZXQgLSAxIF07XG5cdFx0XHR0ZXh0ID0gdGV4dC5zbGljZSggY3Vyc29yICsgb2Zmc2V0ICk7XG5cdFx0XHRjdXJzb3IgKys7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgQ09SUkVDVC5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBudW0gPSByZWFkKCAxICk7XG5cdFx0XHRpZiAoIG51bSA9PT0gQ09SUkVDVFsgaSBdICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEZieFZlcnNpb24oIHRleHQgKSB7XG5cblx0XHR2YXIgdmVyc2lvblJlZ0V4cCA9IC9GQlhWZXJzaW9uOiAoXFxkKykvO1xuXHRcdHZhciBtYXRjaCA9IHRleHQubWF0Y2goIHZlcnNpb25SZWdFeHAgKTtcblxuXHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdHZhciB2ZXJzaW9uID0gcGFyc2VJbnQoIG1hdGNoWyAxIF0gKTtcblx0XHRcdHJldHVybiB2ZXJzaW9uO1xuXG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBDYW5ub3QgZmluZCB0aGUgdmVyc2lvbiBudW1iZXIgZm9yIHRoZSBmaWxlIGdpdmVuLicgKTtcblxuXHR9XG5cblx0Ly8gQ29udmVydHMgRkJYIHRpY2tzIGludG8gcmVhbCB0aW1lIHNlY29uZHMuXG5cdGZ1bmN0aW9uIGNvbnZlcnRGQlhUaW1lVG9TZWNvbmRzKCB0aW1lICkge1xuXG5cdFx0cmV0dXJuIHRpbWUgLyA0NjE4NjE1ODAwMDtcblxuXHR9XG5cblx0dmFyIGRhdGFBcnJheSA9IFtdO1xuXG5cdC8vIGV4dHJhY3RzIHRoZSBkYXRhIGZyb20gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIEZCWCBhcnJheSBiYXNlZCBvbiBpbmRleGluZyB0eXBlXG5cdGZ1bmN0aW9uIGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgaW5mb09iamVjdCApIHtcblxuXHRcdHZhciBpbmRleDtcblxuXHRcdHN3aXRjaCAoIGluZm9PYmplY3QubWFwcGluZ1R5cGUgKSB7XG5cblx0XHRcdGNhc2UgJ0J5UG9seWdvblZlcnRleCcgOlxuXHRcdFx0XHRpbmRleCA9IHBvbHlnb25WZXJ0ZXhJbmRleDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCeVBvbHlnb24nIDpcblx0XHRcdFx0aW5kZXggPSBwb2x5Z29uSW5kZXg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQnlWZXJ0aWNlJyA6XG5cdFx0XHRcdGluZGV4ID0gdmVydGV4SW5kZXg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQWxsU2FtZScgOlxuXHRcdFx0XHRpbmRleCA9IGluZm9PYmplY3QuaW5kaWNlc1sgMCBdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQgOlxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IHVua25vd24gYXR0cmlidXRlIG1hcHBpbmcgdHlwZSAnICsgaW5mb09iamVjdC5tYXBwaW5nVHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmZvT2JqZWN0LnJlZmVyZW5jZVR5cGUgPT09ICdJbmRleFRvRGlyZWN0JyApIGluZGV4ID0gaW5mb09iamVjdC5pbmRpY2VzWyBpbmRleCBdO1xuXG5cdFx0dmFyIGZyb20gPSBpbmRleCAqIGluZm9PYmplY3QuZGF0YVNpemU7XG5cdFx0dmFyIHRvID0gZnJvbSArIGluZm9PYmplY3QuZGF0YVNpemU7XG5cblx0XHRyZXR1cm4gc2xpY2UoIGRhdGFBcnJheSwgaW5mb09iamVjdC5idWZmZXIsIGZyb20sIHRvICk7XG5cblx0fVxuXG5cdHZhciB0ZW1wRXVsZXIgPSBuZXcgRXVsZXIoKTtcblx0dmFyIHRlbXBWZWMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdC8vIGdlbmVyYXRlIHRyYW5zZm9ybWF0aW9uIGZyb20gRkJYIHRyYW5zZm9ybSBkYXRhXG5cdC8vIHJlZjogaHR0cHM6Ly9oZWxwLmF1dG9kZXNrLmNvbS92aWV3L0ZCWC8yMDE3L0VOVS8/Z3VpZD1fX2ZpbGVzX0dVSURfMTBDREQ2M0NfNzlDMV80RjJEX0JCMjhfQUQyQkU2NUEwMkVEX2h0bVxuXHQvLyByZWY6IGh0dHA6Ly9kb2NzLmF1dG9kZXNrLmNvbS9GQlgvMjAxNC9FTlUvRkJYLVNESy1Eb2N1bWVudGF0aW9uL2luZGV4Lmh0bWw/dXJsPWNwcF9yZWYvX3RyYW5zZm9ybWF0aW9uc18ybWFpbl84Y3h4LWV4YW1wbGUuaHRtbCx0b3BpY051bWJlcj1jcHBfcmVmX190cmFuc2Zvcm1hdGlvbnNfMm1haW5fOGN4eF9leGFtcGxlX2h0bWxmYzEwYTFlMS1iMThkLTRlNzItOWRjMC03MGQwZjE5NTlmNWVcblx0ZnVuY3Rpb24gZ2VuZXJhdGVUcmFuc2Zvcm0oIHRyYW5zZm9ybURhdGEgKSB7XG5cblx0XHR2YXIgbFRyYW5zbGF0aW9uTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxQcmVSb3RhdGlvbk0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUm90YXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFBvc3RSb3RhdGlvbk0gPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dmFyIGxTY2FsaW5nTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxTY2FsaW5nUGl2b3RNID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFNjYWxpbmdPZmZzZXRNID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFJvdGF0aW9uT2Zmc2V0TSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxSb3RhdGlvblBpdm90TSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHR2YXIgbFBhcmVudEdYID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFBhcmVudExYID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbEdsb2JhbFQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0dmFyIGluaGVyaXRUeXBlID0gKCB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlICkgPyB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlIDogMDtcblxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiApIGxUcmFuc2xhdGlvbk0uc2V0UG9zaXRpb24oIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uICkgKTtcblxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5wcmVSb3RhdGlvbiApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gdHJhbnNmb3JtRGF0YS5wcmVSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0YXJyYXkucHVzaCggdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyICk7XG5cdFx0XHRsUHJlUm90YXRpb25NLm1ha2VSb3RhdGlvbkZyb21FdWxlciggdGVtcEV1bGVyLmZyb21BcnJheSggYXJyYXkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRhcnJheS5wdXNoKCB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgKTtcblx0XHRcdGxSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucG9zdFJvdGF0aW9uICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSB0cmFuc2Zvcm1EYXRhLnBvc3RSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0YXJyYXkucHVzaCggdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyICk7XG5cdFx0XHRsUG9zdFJvdGF0aW9uTS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoIHRlbXBFdWxlci5mcm9tQXJyYXkoIGFycmF5ICkgKTtcblx0XHRcdGxQb3N0Um90YXRpb25NLmludmVydCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnNjYWxlICkgbFNjYWxpbmdNLnNjYWxlKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS5zY2FsZSApICk7XG5cblx0XHQvLyBQaXZvdHMgYW5kIG9mZnNldHNcblx0XHRpZiAoIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCApIGxTY2FsaW5nT2Zmc2V0TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEuc2NhbGluZ09mZnNldCApICk7XG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdQaXZvdCApIGxTY2FsaW5nUGl2b3RNLnNldFBvc2l0aW9uKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS5zY2FsaW5nUGl2b3QgKSApO1xuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5yb3RhdGlvbk9mZnNldCApIGxSb3RhdGlvbk9mZnNldE0uc2V0UG9zaXRpb24oIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uT2Zmc2V0ICkgKTtcblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucm90YXRpb25QaXZvdCApIGxSb3RhdGlvblBpdm90TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEucm90YXRpb25QaXZvdCApICk7XG5cblx0XHQvLyBwYXJlbnQgdHJhbnNmb3JtXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeFdvcmxkICkge1xuXG5cdFx0XHRsUGFyZW50TFguY29weSggdHJhbnNmb3JtRGF0YS5wYXJlbnRNYXRyaXggKTtcblx0XHRcdGxQYXJlbnRHWC5jb3B5KCB0cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeFdvcmxkICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbExSTSA9IG5ldyBNYXRyaXg0KCkuY29weSggbFByZVJvdGF0aW9uTSApLm11bHRpcGx5KCBsUm90YXRpb25NICkubXVsdGlwbHkoIGxQb3N0Um90YXRpb25NICk7XG5cdFx0Ly8gR2xvYmFsIFJvdGF0aW9uXG5cdFx0dmFyIGxQYXJlbnRHUk0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdGxQYXJlbnRHUk0uZXh0cmFjdFJvdGF0aW9uKCBsUGFyZW50R1ggKTtcblxuXHRcdC8vIEdsb2JhbCBTaGVhcipTY2FsaW5nXG5cdFx0dmFyIGxQYXJlbnRUTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0bFBhcmVudFRNLmNvcHlQb3NpdGlvbiggbFBhcmVudEdYICk7XG5cblx0XHR2YXIgbFBhcmVudEdTTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxQYXJlbnRHUlNNID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUGFyZW50VE0gKS5pbnZlcnQoKS5tdWx0aXBseSggbFBhcmVudEdYICk7XG5cdFx0bFBhcmVudEdTTS5jb3B5KCBsUGFyZW50R1JNICkuaW52ZXJ0KCkubXVsdGlwbHkoIGxQYXJlbnRHUlNNICk7XG5cdFx0dmFyIGxMU00gPSBsU2NhbGluZ007XG5cblx0XHR2YXIgbEdsb2JhbFJTID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdGlmICggaW5oZXJpdFR5cGUgPT09IDAgKSB7XG5cblx0XHRcdGxHbG9iYWxSUy5jb3B5KCBsUGFyZW50R1JNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbFBhcmVudEdTTSApLm11bHRpcGx5KCBsTFNNICk7XG5cblx0XHR9IGVsc2UgaWYgKCBpbmhlcml0VHlwZSA9PT0gMSApIHtcblxuXHRcdFx0bEdsb2JhbFJTLmNvcHkoIGxQYXJlbnRHUk0gKS5tdWx0aXBseSggbFBhcmVudEdTTSApLm11bHRpcGx5KCBsTFJNICkubXVsdGlwbHkoIGxMU00gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBsUGFyZW50TFNNID0gbmV3IE1hdHJpeDQoKS5zY2FsZSggbmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4U2NhbGUoIGxQYXJlbnRMWCApICk7XG5cdFx0XHR2YXIgbFBhcmVudExTTV9pbnYgPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRMU00gKS5pbnZlcnQoKTtcblx0XHRcdHZhciBsUGFyZW50R1NNX25vTG9jYWwgPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRHU00gKS5tdWx0aXBseSggbFBhcmVudExTTV9pbnYgKTtcblxuXHRcdFx0bEdsb2JhbFJTLmNvcHkoIGxQYXJlbnRHUk0gKS5tdWx0aXBseSggbExSTSApLm11bHRpcGx5KCBsUGFyZW50R1NNX25vTG9jYWwgKS5tdWx0aXBseSggbExTTSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGxSb3RhdGlvblBpdm90TV9pbnYgPSBuZXcgTWF0cml4NCgpO1xuXHRcdGxSb3RhdGlvblBpdm90TV9pbnYuY29weSggbFJvdGF0aW9uUGl2b3RNICkuaW52ZXJ0KCk7XG5cdFx0dmFyIGxTY2FsaW5nUGl2b3RNX2ludiA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0bFNjYWxpbmdQaXZvdE1faW52LmNvcHkoIGxTY2FsaW5nUGl2b3RNICkuaW52ZXJ0KCk7XG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBsb2NhbCB0cmFuc2Zvcm0gbWF0cml4XG5cdFx0dmFyIGxUcmFuc2Zvcm0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdGxUcmFuc2Zvcm0uY29weSggbFRyYW5zbGF0aW9uTSApLm11bHRpcGx5KCBsUm90YXRpb25PZmZzZXRNICkubXVsdGlwbHkoIGxSb3RhdGlvblBpdm90TSApLm11bHRpcGx5KCBsUHJlUm90YXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvbk0gKS5tdWx0aXBseSggbFBvc3RSb3RhdGlvbk0gKS5tdWx0aXBseSggbFJvdGF0aW9uUGl2b3RNX2ludiApLm11bHRpcGx5KCBsU2NhbGluZ09mZnNldE0gKS5tdWx0aXBseSggbFNjYWxpbmdQaXZvdE0gKS5tdWx0aXBseSggbFNjYWxpbmdNICkubXVsdGlwbHkoIGxTY2FsaW5nUGl2b3RNX2ludiApO1xuXG5cdFx0dmFyIGxMb2NhbFRXaXRoQWxsUGl2b3RBbmRPZmZzZXRJbmZvID0gbmV3IE1hdHJpeDQoKS5jb3B5UG9zaXRpb24oIGxUcmFuc2Zvcm0gKTtcblxuXHRcdHZhciBsR2xvYmFsVHJhbnNsYXRpb24gPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRHWCApLm11bHRpcGx5KCBsTG9jYWxUV2l0aEFsbFBpdm90QW5kT2Zmc2V0SW5mbyApO1xuXHRcdGxHbG9iYWxULmNvcHlQb3NpdGlvbiggbEdsb2JhbFRyYW5zbGF0aW9uICk7XG5cblx0XHRsVHJhbnNmb3JtID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsR2xvYmFsVCApLm11bHRpcGx5KCBsR2xvYmFsUlMgKTtcblxuXHRcdC8vIGZyb20gZ2xvYmFsIHRvIGxvY2FsXG5cdFx0bFRyYW5zZm9ybS5wcmVtdWx0aXBseSggbFBhcmVudEdYLmludmVydCgpICk7XG5cblx0XHRyZXR1cm4gbFRyYW5zZm9ybTtcblxuXHR9XG5cblx0Ly8gUmV0dXJucyB0aGUgdGhyZWUuanMgaW50cmluc2ljIEV1bGVyIG9yZGVyIGNvcnJlc3BvbmRpbmcgdG8gRkJYIGV4dHJpbnNpYyBFdWxlciBvcmRlclxuXHQvLyByZWY6IGh0dHA6Ly9oZWxwLmF1dG9kZXNrLmNvbS92aWV3L0ZCWC8yMDE3L0VOVS8/Z3VpZD1fX2NwcF9yZWZfY2xhc3NfZmJ4X2V1bGVyX2h0bWxcblx0ZnVuY3Rpb24gZ2V0RXVsZXJPcmRlciggb3JkZXIgKSB7XG5cblx0XHRvcmRlciA9IG9yZGVyIHx8IDA7XG5cblx0XHR2YXIgZW51bXMgPSBbXG5cdFx0XHQnWllYJywgLy8gLT4gWFlaIGV4dHJpbnNpY1xuXHRcdFx0J1laWCcsIC8vIC0+IFhaWSBleHRyaW5zaWNcblx0XHRcdCdYWlknLCAvLyAtPiBZWlggZXh0cmluc2ljXG5cdFx0XHQnWlhZJywgLy8gLT4gWVhaIGV4dHJpbnNpY1xuXHRcdFx0J1lYWicsIC8vIC0+IFpYWSBleHRyaW5zaWNcblx0XHRcdCdYWVonLCAvLyAtPiBaWVggZXh0cmluc2ljXG5cdFx0XHQvLydTcGhlcmljWFlaJywgLy8gbm90IHBvc3NpYmxlIHRvIHN1cHBvcnRcblx0XHRdO1xuXG5cdFx0aWYgKCBvcmRlciA9PT0gNiApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiB1bnN1cHBvcnRlZCBFdWxlciBPcmRlcjogU3BoZXJpY2FsIFhZWi4gQW5pbWF0aW9ucyBhbmQgcm90YXRpb25zIG1heSBiZSBpbmNvcnJlY3QuJyApO1xuXHRcdFx0cmV0dXJuIGVudW1zWyAwIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZW51bXNbIG9yZGVyIF07XG5cblx0fVxuXG5cdC8vIFBhcnNlcyBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBudW1iZXJzIGFuZCByZXR1cm5zIHRoZW0gYW4gYXJyYXkuXG5cdC8vIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgVGV4dFBhcnNlclxuXHRmdW5jdGlvbiBwYXJzZU51bWJlckFycmF5KCB2YWx1ZSApIHtcblxuXHRcdHZhciBhcnJheSA9IHZhbHVlLnNwbGl0KCAnLCcgKS5tYXAoIGZ1bmN0aW9uICggdmFsICkge1xuXG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCggdmFsICk7XG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRBcnJheUJ1ZmZlclRvU3RyaW5nKCBidWZmZXIsIGZyb20sIHRvICkge1xuXG5cdFx0aWYgKCBmcm9tID09PSB1bmRlZmluZWQgKSBmcm9tID0gMDtcblx0XHRpZiAoIHRvID09PSB1bmRlZmluZWQgKSB0byA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIsIGZyb20sIHRvICkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwZW5kKCBhLCBiICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYS5sZW5ndGgsIGwgPSBiLmxlbmd0aDsgaSA8IGw7IGkgKyssIGogKysgKSB7XG5cblx0XHRcdGFbIGogXSA9IGJbIGkgXTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2xpY2UoIGEsIGIsIGZyb20sIHRvICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSBmcm9tLCBqID0gMDsgaSA8IHRvOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRhWyBqIF0gPSBiWyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYTtcblxuXHR9XG5cblx0Ly8gaW5qZWN0IGFycmF5IGEyIGludG8gYXJyYXkgYTEgYXQgaW5kZXhcblx0ZnVuY3Rpb24gaW5qZWN0KCBhMSwgaW5kZXgsIGEyICkge1xuXG5cdFx0cmV0dXJuIGExLnNsaWNlKCAwLCBpbmRleCApLmNvbmNhdCggYTIgKS5jb25jYXQoIGExLnNsaWNlKCBpbmRleCApICk7XG5cblx0fVxuXG5cdHJldHVybiBGQlhMb2FkZXI7XG5cbn0gKSgpO1xuXG52YXIgU1ZHTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHQvLyBEZWZhdWx0IGRvdHMgcGVyIGluY2hcblx0dGhpcy5kZWZhdWx0RFBJID0gOTA7XG5cblx0Ly8gQWNjZXB0ZWQgdW5pdHM6ICdtbScsICdjbScsICdpbicsICdwdCcsICdwYycsICdweCdcblx0dGhpcy5kZWZhdWx0VW5pdCA9ICdweCc7XG5cbn07XG5cblNWR0xvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTVkdMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZSggbm9kZSwgc3R5bGUgKSB7XG5cblx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSAhPT0gMSApIHJldHVybjtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IGdldE5vZGVUcmFuc2Zvcm0oIG5vZGUgKTtcblxuXHRcdFx0dmFyIHRyYXZlcnNlQ2hpbGROb2RlcyA9IHRydWU7XG5cblx0XHRcdHZhciBwYXRoID0gbnVsbDtcblxuXHRcdFx0c3dpdGNoICggbm9kZS5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdzdmcnOlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3N0eWxlJzpcblx0XHRcdFx0XHRwYXJzZUNTU1N0eWxlc2hlZXQoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdnJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncGF0aCc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICdkJyApICkgcGF0aCA9IHBhcnNlUGF0aE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlUmVjdE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwb2x5Z29uJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlUG9seWdvbk5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwb2x5bGluZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZVBvbHlsaW5lTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NpcmNsZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHBhdGggPSBwYXJzZUNpcmNsZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdlbGxpcHNlJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlRWxsaXBzZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdsaW5lJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlTGluZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdkZWZzJzpcblx0XHRcdFx0XHR0cmF2ZXJzZUNoaWxkTm9kZXMgPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd1c2UnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHR2YXIgdXNlZE5vZGVJZCA9IG5vZGUuaHJlZi5iYXNlVmFsLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdHZhciB1c2VkTm9kZSA9IG5vZGUudmlld3BvcnRFbGVtZW50LmdldEVsZW1lbnRCeUlkKCB1c2VkTm9kZUlkICk7XG5cdFx0XHRcdFx0aWYgKCB1c2VkTm9kZSApIHtcblxuXHRcdFx0XHRcdFx0cGFyc2VOb2RlKCB1c2VkTm9kZSwgc3R5bGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1NWR0xvYWRlcjogXFwndXNlIG5vZGVcXCcgcmVmZXJlbmNlcyBub24tZXhpc3RlbnQgbm9kZSBpZDogJyArIHVzZWROb2RlSWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBub2RlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXRoICkge1xuXG5cdFx0XHRcdGlmICggc3R5bGUuZmlsbCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlLmZpbGwgIT09ICdub25lJyApIHtcblxuXHRcdFx0XHRcdHBhdGguY29sb3Iuc2V0U3R5bGUoIHN0eWxlLmZpbGwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJhbnNmb3JtUGF0aCggcGF0aCwgY3VycmVudFRyYW5zZm9ybSApO1xuXG5cdFx0XHRcdHBhdGhzLnB1c2goIHBhdGggKTtcblxuXHRcdFx0XHRwYXRoLnVzZXJEYXRhID0geyBub2RlOiBub2RlLCBzdHlsZTogc3R5bGUgfTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRyYXZlcnNlQ2hpbGROb2RlcyApIHtcblxuXHRcdFx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cGFyc2VOb2RlKCBub2Rlc1sgaSBdLCBzdHlsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHR0cmFuc2Zvcm1TdGFjay5wb3AoKTtcblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLmNvcHkoIHRyYW5zZm9ybVN0YWNrWyB0cmFuc2Zvcm1TdGFjay5sZW5ndGggLSAxIF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQYXRoTm9kZSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cblx0XHRcdHZhciBwb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHR2YXIgY29udHJvbCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdHZhciBmaXJzdFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciBpc0ZpcnN0UG9pbnQgPSB0cnVlO1xuXHRcdFx0dmFyIGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnZCcgKTtcblxuXHRcdFx0Ly8gY29uc29sZS5sb2coIGQgKTtcblxuXHRcdFx0dmFyIGNvbW1hbmRzID0gZC5tYXRjaCggL1thLWRmLXpdW15hLWRmLXpdKi9pZyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb21tYW5kcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjb21tYW5kID0gY29tbWFuZHNbIGkgXTtcblxuXHRcdFx0XHR2YXIgdHlwZSA9IGNvbW1hbmQuY2hhckF0KCAwICk7XG5cdFx0XHRcdHZhciBkYXRhID0gY29tbWFuZC5zdWJzdHIoIDEgKS50cmltKCk7XG5cblx0XHRcdFx0aWYgKCBpc0ZpcnN0UG9pbnQgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRkb1NldEZpcnN0UG9pbnQgPSB0cnVlO1xuXHRcdFx0XHRcdGlzRmlyc3RQb2ludCA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXRoLm1vdmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1YnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0MnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA2ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyA0IF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDUgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBudW1iZXJzWyBqICsgMyBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDQgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyA1IF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1MnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKSxcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMyBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdUJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcnggPSBnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHJ5ID0gZ2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICk7XG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRyeCxcblx0XHRcdFx0XHRcdFx0XHRyeSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAxIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHJ5O1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA3ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHNraXAgY29tbWFuZCBpZiBzdGFydCBwb2ludCA9PSBlbmQgcG9pbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBudW1iZXJzWyBqICsgNSBdID09IHBvaW50LnggJiYgbnVtYmVyc1sgaiArIDYgXSA9PSBwb2ludC55ICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyA1IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgNiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXJzZUFyY0NvbW1hbmQoXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCwgbnVtYmVyc1sgaiBdLCBudW1iZXJzWyBqICsgMSBdLCBudW1iZXJzWyBqICsgMiBdLCBudW1iZXJzWyBqICsgMyBdLCBudW1iZXJzWyBqICsgNCBdLCBzdGFydCwgcG9pbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDYgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgNCBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgNSBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDMgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgNCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyA1IF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3MnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKSxcblx0XHRcdFx0XHRcdFx0XHRnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDMgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDMgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHJ4ID0gZ2V0UmVmbGVjdGlvbiggcG9pbnQueCwgY29udHJvbC54ICk7XG5cdFx0XHRcdFx0XHRcdHZhciByeSA9IGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApO1xuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cngsXG5cdFx0XHRcdFx0XHRcdFx0cnksXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHJ5O1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBjb21tYW5kIGlmIG5vIGRpc3BsYWNlbWVudFxuXHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlcnNbIGogKyA1IF0gPT0gMCAmJiBudW1iZXJzWyBqICsgNiBdID09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyA1IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDYgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGFyc2VBcmNDb21tYW5kKFxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsIG51bWJlcnNbIGogXSwgbnVtYmVyc1sgaiArIDEgXSwgbnVtYmVyc1sgaiArIDIgXSwgbnVtYmVyc1sgaiArIDMgXSwgbnVtYmVyc1sgaiArIDQgXSwgc3RhcnQsIHBvaW50XG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHBhdGguY3VycmVudFBhdGguY3VydmVzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQgcG9pbnQgdG8gYmVnaW5uaW5nIG9mIFBhdGhcblx0XHRcdFx0XHRcdFx0cG9pbnQuY29weSggZmlyc3RQb2ludCApO1xuXHRcdFx0XHRcdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmN1cnJlbnRQb2ludC5jb3B5KCBwb2ludCApO1xuXHRcdFx0XHRcdFx0XHRpc0ZpcnN0UG9pbnQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggY29tbWFuZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggdHlwZSwgcGFyc2VGbG9hdHMoIGRhdGEgKSwgcGFyc2VGbG9hdHMoIGRhdGEgKS5sZW5ndGggIClcblxuXHRcdFx0XHRkb1NldEZpcnN0UG9pbnQgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ1NTU3R5bGVzaGVldCggbm9kZSApIHtcblxuXHRcdFx0aWYgKCAhIG5vZGUuc2hlZXQgfHwgISBub2RlLnNoZWV0LmNzc1J1bGVzIHx8ICEgbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGggKSByZXR1cm47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGUuc2hlZXQuY3NzUnVsZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzdHlsZXNoZWV0ID0gbm9kZS5zaGVldC5jc3NSdWxlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggc3R5bGVzaGVldC50eXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIHNlbGVjdG9yTGlzdCA9IHN0eWxlc2hlZXQuc2VsZWN0b3JUZXh0XG5cdFx0XHRcdFx0LnNwbGl0KCAvLC9nbSApXG5cdFx0XHRcdFx0LmZpbHRlciggQm9vbGVhbiApXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHNlbGVjdG9yTGlzdC5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRzdHlsZXNoZWV0c1sgc2VsZWN0b3JMaXN0WyBqIF0gXSA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHRcdFx0XHRzdHlsZXNoZWV0c1sgc2VsZWN0b3JMaXN0WyBqIF0gXSB8fCB7fSxcblx0XHRcdFx0XHRcdHN0eWxlc2hlZXQuc3R5bGVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcblx0XHQgKiBodHRwczovL21vcnRvcmF5LmNvbS8yMDE3LzAyLzE2L3JlbmRlcmluZy1hbi1zdmctZWxsaXB0aWNhbC1hcmMtYXMtYmV6aWVyLWN1cnZlcy8gQXBwZW5kaXg6IEVuZHBvaW50IHRvIGNlbnRlciBhcmMgY29udmVyc2lvblxuXHRcdCAqIEZyb21cblx0XHQgKiByeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHlcblx0XHQgKiBUb1xuXHRcdCAqIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uXG5cdFx0ICovXG5cblx0XHRmdW5jdGlvbiBwYXJzZUFyY0NvbW1hbmQoIHBhdGgsIHJ4LCByeSwgeF9heGlzX3JvdGF0aW9uLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgc3RhcnQsIGVuZCApIHtcblxuXHRcdFx0aWYgKCByeCA9PSAwIHx8IHJ5ID09IDAgKSB7XG5cblx0XHRcdFx0Ly8gZHJhdyBhIGxpbmUgaWYgZWl0aGVyIG9mIHRoZSByYWRpaSA9PSAwXG5cdFx0XHRcdHBhdGgubGluZVRvKCBlbmQueCwgZW5kLnkgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdHhfYXhpc19yb3RhdGlvbiA9IHhfYXhpc19yb3RhdGlvbiAqIE1hdGguUEkgLyAxODA7XG5cblx0XHRcdC8vIEVuc3VyZSByYWRpaSBhcmUgcG9zaXRpdmVcblx0XHRcdHJ4ID0gTWF0aC5hYnMoIHJ4ICk7XG5cdFx0XHRyeSA9IE1hdGguYWJzKCByeSApO1xuXG5cdFx0XHQvLyBDb21wdXRlICh4MScsIHkxJylcblx0XHRcdHZhciBkeDIgPSAoIHN0YXJ0LnggLSBlbmQueCApIC8gMi4wO1xuXHRcdFx0dmFyIGR5MiA9ICggc3RhcnQueSAtIGVuZC55ICkgLyAyLjA7XG5cdFx0XHR2YXIgeDFwID0gTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogZHgyICsgTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogZHkyO1xuXHRcdFx0dmFyIHkxcCA9IC0gTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogZHgyICsgTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogZHkyO1xuXG5cdFx0XHQvLyBDb21wdXRlIChjeCcsIGN5Jylcblx0XHRcdHZhciByeHMgPSByeCAqIHJ4O1xuXHRcdFx0dmFyIHJ5cyA9IHJ5ICogcnk7XG5cdFx0XHR2YXIgeDFwcyA9IHgxcCAqIHgxcDtcblx0XHRcdHZhciB5MXBzID0geTFwICogeTFwO1xuXG5cdFx0XHQvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaFxuXHRcdFx0dmFyIGNyID0geDFwcyAvIHJ4cyArIHkxcHMgLyByeXM7XG5cblx0XHRcdGlmICggY3IgPiAxICkge1xuXG5cdFx0XHRcdC8vIHNjYWxlIHVwIHJ4LHJ5IGVxdWFsbHkgc28gY3IgPT0gMVxuXHRcdFx0XHR2YXIgcyA9IE1hdGguc3FydCggY3IgKTtcblx0XHRcdFx0cnggPSBzICogcng7XG5cdFx0XHRcdHJ5ID0gcyAqIHJ5O1xuXHRcdFx0XHRyeHMgPSByeCAqIHJ4O1xuXHRcdFx0XHRyeXMgPSByeSAqIHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBkcSA9ICggcnhzICogeTFwcyArIHJ5cyAqIHgxcHMgKTtcblx0XHRcdHZhciBwcSA9ICggcnhzICogcnlzIC0gZHEgKSAvIGRxO1xuXHRcdFx0dmFyIHEgPSBNYXRoLnNxcnQoIE1hdGgubWF4KCAwLCBwcSApICk7XG5cdFx0XHRpZiAoIGxhcmdlX2FyY19mbGFnID09PSBzd2VlcF9mbGFnICkgcSA9IC0gcTtcblx0XHRcdHZhciBjeHAgPSBxICogcnggKiB5MXAgLyByeTtcblx0XHRcdHZhciBjeXAgPSAtIHEgKiByeSAqIHgxcCAvIHJ4O1xuXG5cdFx0XHQvLyBTdGVwIDM6IENvbXB1dGUgKGN4LCBjeSkgZnJvbSAoY3gnLCBjeScpXG5cdFx0XHR2YXIgY3ggPSBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBjeHAgLSBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBjeXAgKyAoIHN0YXJ0LnggKyBlbmQueCApIC8gMjtcblx0XHRcdHZhciBjeSA9IE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGN4cCArIE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGN5cCArICggc3RhcnQueSArIGVuZC55ICkgLyAyO1xuXG5cdFx0XHQvLyBTdGVwIDQ6IENvbXB1dGUgzrgxIGFuZCDOlM64XG5cdFx0XHR2YXIgdGhldGEgPSBzdmdBbmdsZSggMSwgMCwgKCB4MXAgLSBjeHAgKSAvIHJ4LCAoIHkxcCAtIGN5cCApIC8gcnkgKTtcblx0XHRcdHZhciBkZWx0YSA9IHN2Z0FuZ2xlKCAoIHgxcCAtIGN4cCApIC8gcngsICggeTFwIC0gY3lwICkgLyByeSwgKCAtIHgxcCAtIGN4cCApIC8gcngsICggLSB5MXAgLSBjeXAgKSAvIHJ5ICkgJSAoIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHBhdGguY3VycmVudFBhdGguYWJzZWxsaXBzZSggY3gsIGN5LCByeCwgcnksIHRoZXRhLCB0aGV0YSArIGRlbHRhLCBzd2VlcF9mbGFnID09PSAwLCB4X2F4aXNfcm90YXRpb24gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN2Z0FuZ2xlKCB1eCwgdXksIHZ4LCB2eSApIHtcblxuXHRcdFx0dmFyIGRvdCA9IHV4ICogdnggKyB1eSAqIHZ5O1xuXHRcdFx0dmFyIGxlbiA9IE1hdGguc3FydCggdXggKiB1eCArIHV5ICogdXkgKSAqIE1hdGguc3FydCggdnggKiB2eCArIHZ5ICogdnkgKTtcblx0XHRcdHZhciBhbmcgPSBNYXRoLmFjb3MoIE1hdGgubWF4KCAtIDEsIE1hdGgubWluKCAxLCBkb3QgLyBsZW4gKSApICk7IC8vIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiwgc2xpZ2h0bHkgb3ZlciB2YWx1ZXMgYXBwZWFyXG5cdFx0XHRpZiAoICggdXggKiB2eSAtIHV5ICogdnggKSA8IDAgKSBhbmcgPSAtIGFuZztcblx0XHRcdHJldHVybiBhbmc7XG5cblx0XHR9XG5cblx0XHQvKlxuXHRcdCogQWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRSWEF0dHJpYnV0ZVxuXHRcdCogcm91bmRlZCBjb3JuZXIgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIGVsbGlwdGljYWwgYXJjLCBidXQgYmV6aWVyIGN1cnZlIGRvZXMgdGhlIGpvYiB3ZWxsIGVub3VnaFxuXHRcdCovXG5cdFx0ZnVuY3Rpb24gcGFyc2VSZWN0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gnICkgfHwgMCApO1xuXHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3knICkgfHwgMCApO1xuXHRcdFx0dmFyIHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSB8fCAwICk7XG5cdFx0XHR2YXIgcnkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3J5JyApIHx8IDAgKTtcblx0XHRcdHZhciB3ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd3aWR0aCcgKSApO1xuXHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2hlaWdodCcgKSApO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGgubW92ZVRvKCB4ICsgMiAqIHJ4LCB5ICk7XG5cdFx0XHRwYXRoLmxpbmVUbyggeCArIHcgLSAyICogcngsIHkgKTtcblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSBwYXRoLmJlemllckN1cnZlVG8oIHggKyB3LCB5LCB4ICsgdywgeSwgeCArIHcsIHkgKyAyICogcnkgKTtcblx0XHRcdHBhdGgubGluZVRvKCB4ICsgdywgeSArIGggLSAyICogcnkgKTtcblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSBwYXRoLmJlemllckN1cnZlVG8oIHggKyB3LCB5ICsgaCwgeCArIHcsIHkgKyBoLCB4ICsgdyAtIDIgKiByeCwgeSArIGggKTtcblx0XHRcdHBhdGgubGluZVRvKCB4ICsgMiAqIHJ4LCB5ICsgaCApO1xuXG5cdFx0XHRpZiAoIHJ4ICE9PSAwIHx8IHJ5ICE9PSAwICkge1xuXG5cdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggeCwgeSArIGgsIHgsIHkgKyBoLCB4LCB5ICsgaCAtIDIgKiByeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICsgMiAqIHJ5ICk7XG5cblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XG5cblx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCB4LCB5LCB4LCB5LCB4ICsgMiAqIHJ4LCB5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBvbHlnb25Ob2RlKCBub2RlICkge1xuXG5cdFx0XHRmdW5jdGlvbiBpdGVyYXRvciggbWF0Y2gsIGEsIGIgKSB7XG5cblx0XHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBhICk7XG5cdFx0XHRcdHZhciB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYiApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPT09IDAgKSB7XG5cblx0XHRcdFx0XHRwYXRoLm1vdmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXRoLmxpbmVUbyggeCwgeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVnZXggPSAvKC0/W1xcZFxcLj9dKylbLHxcXHNdKC0/W1xcZFxcLj9dKykvZztcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cblx0XHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAncG9pbnRzJyApLnJlcGxhY2UoIHJlZ2V4LCBpdGVyYXRvciApO1xuXG5cdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IHRydWU7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQb2x5bGluZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGl0ZXJhdG9yKCBtYXRjaCwgYSwgYiApIHtcblxuXHRcdFx0XHR2YXIgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGEgKTtcblx0XHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBiICk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWdleCA9IC8oLT9bXFxkXFwuP10rKVssfFxcc10oLT9bXFxkXFwuP10rKS9nO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdwb2ludHMnICkucmVwbGFjZSggcmVnZXgsIGl0ZXJhdG9yICk7XG5cblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDaXJjbGVOb2RlKCBub2RlICkge1xuXG5cdFx0XHR2YXIgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnY3gnICkgKTtcblx0XHRcdHZhciB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeScgKSApO1xuXHRcdFx0dmFyIHIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3InICkgKTtcblxuXHRcdFx0dmFyIHN1YnBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdFx0c3VicGF0aC5hYnNhcmMoIHgsIHksIHIsIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5zdWJQYXRocy5wdXNoKCBzdWJwYXRoICk7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFbGxpcHNlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N4JyApICk7XG5cdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnY3knICkgKTtcblx0XHRcdHZhciByeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncngnICkgKTtcblx0XHRcdHZhciByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncnknICkgKTtcblxuXHRcdFx0dmFyIHN1YnBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdFx0c3VicGF0aC5hYnNlbGxpcHNlKCB4LCB5LCByeCwgcnksIDAsIE1hdGguUEkgKiAyICk7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5zdWJQYXRocy5wdXNoKCBzdWJwYXRoICk7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaW5lTm9kZSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHgxID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4MScgKSApO1xuXHRcdFx0dmFyIHkxID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5MScgKSApO1xuXHRcdFx0dmFyIHgyID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd4MicgKSApO1xuXHRcdFx0dmFyIHkyID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5MicgKSApO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblx0XHRcdHBhdGgubW92ZVRvKCB4MSwgeTEgKTtcblx0XHRcdHBhdGgubGluZVRvKCB4MiwgeTIgKTtcblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gZmFsc2U7XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICkge1xuXG5cdFx0XHRzdHlsZSA9IE9iamVjdC5hc3NpZ24oIHt9LCBzdHlsZSApOyAvLyBjbG9uZSBzdHlsZVxuXG5cdFx0XHR2YXIgc3R5bGVzaGVldFN0eWxlcyA9IHt9O1xuXG5cdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnY2xhc3MnICkgKSB7XG5cblx0XHRcdFx0dmFyIGNsYXNzU2VsZWN0b3JzID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdjbGFzcycgKVxuXHRcdFx0XHRcdC5zcGxpdCggL1xccy8gKVxuXHRcdFx0XHRcdC5maWx0ZXIoIEJvb2xlYW4gKVxuXHRcdFx0XHRcdC5tYXAoIGkgPT4gaS50cmltKCkgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGFzc1NlbGVjdG9ycy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbiggc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbICcuJyArIGNsYXNzU2VsZWN0b3JzWyBpIF0gXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAnaWQnICkgKSB7XG5cblx0XHRcdFx0c3R5bGVzaGVldFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oIHN0eWxlc2hlZXRTdHlsZXMsIHN0eWxlc2hlZXRzWyAnIycgKyBub2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRTdHlsZSggc3ZnTmFtZSwganNOYW1lLCBhZGp1c3RGdW5jdGlvbiApIHtcblxuXHRcdFx0XHRpZiAoIGFkanVzdEZ1bmN0aW9uID09PSB1bmRlZmluZWQgKSBhZGp1c3RGdW5jdGlvbiA9IGZ1bmN0aW9uIGNvcHkoIHYgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHYuc3RhcnRzV2l0aCggJ3VybCcgKSApIGNvbnNvbGUud2FybiggJ1NWR0xvYWRlcjogdXJsIGFjY2VzcyBpbiBhdHRyaWJ1dGVzIGlzIG5vdCBpbXBsZW1lbnRlZC4nICk7XG5cblx0XHRcdFx0XHRyZXR1cm4gdjtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoIHN2Z05hbWUgKSApIHN0eWxlWyBqc05hbWUgXSA9IGFkanVzdEZ1bmN0aW9uKCBub2RlLmdldEF0dHJpYnV0ZSggc3ZnTmFtZSApICk7XG5cdFx0XHRcdGlmICggc3R5bGVzaGVldFN0eWxlc1sgc3ZnTmFtZSBdICkgc3R5bGVbIGpzTmFtZSBdID0gYWRqdXN0RnVuY3Rpb24oIHN0eWxlc2hlZXRTdHlsZXNbIHN2Z05hbWUgXSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuc3R5bGUgJiYgbm9kZS5zdHlsZVsgc3ZnTmFtZSBdICE9PSAnJyApIHN0eWxlWyBqc05hbWUgXSA9IGFkanVzdEZ1bmN0aW9uKCBub2RlLnN0eWxlWyBzdmdOYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjbGFtcCggdiApIHtcblxuXHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoIDAsIE1hdGgubWluKCAxLCBwYXJzZUZsb2F0V2l0aFVuaXRzKCB2ICkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHBvc2l0aXZlKCB2ICkge1xuXG5cdFx0XHRcdHJldHVybiBNYXRoLm1heCggMCwgcGFyc2VGbG9hdFdpdGhVbml0cyggdiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YWRkU3R5bGUoICdmaWxsJywgJ2ZpbGwnICk7XG5cdFx0XHRhZGRTdHlsZSggJ2ZpbGwtb3BhY2l0eScsICdmaWxsT3BhY2l0eScsIGNsYW1wICk7XG5cdFx0XHRhZGRTdHlsZSggJ29wYWNpdHknLCAnb3BhY2l0eScsIGNsYW1wICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZScsICdzdHJva2UnICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZU9wYWNpdHknLCBjbGFtcCApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2Utd2lkdGgnLCAnc3Ryb2tlV2lkdGgnLCBwb3NpdGl2ZSApO1xuXHRcdFx0YWRkU3R5bGUoICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlTGluZUpvaW4nICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZUxpbmVDYXAnICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZU1pdGVyTGltaXQnLCBwb3NpdGl2ZSApO1xuXHRcdFx0YWRkU3R5bGUoICd2aXNpYmlsaXR5JywgJ3Zpc2liaWxpdHknICk7XG5cblx0XHRcdHJldHVybiBzdHlsZTtcblxuXHRcdH1cblxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjUGF0aEVsZW1lbnRJbXBsZW1lbnRhdGlvbk5vdGVzXG5cblx0XHRmdW5jdGlvbiBnZXRSZWZsZWN0aW9uKCBhLCBiICkge1xuXG5cdFx0XHRyZXR1cm4gYSAtICggYiAtIGEgKTtcblxuXHRcdH1cblxuXHRcdC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bwdmcvc3ZnLW51bWJlcnMgKE1JVCBMaWNlbnNlKVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VGbG9hdHMoIGlucHV0ICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0ludmFsaWQgaW5wdXQ6ICcgKyB0eXBlb2YgaW5wdXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGFyYWN0ZXIgZ3JvdXBzXG5cdFx0XHR2YXIgUkUgPSB7XG5cdFx0XHRcdFNFUEFSQVRPUjogL1sgXFx0XFxyXFxuXFwsLlxcLStdLyxcblx0XHRcdFx0V0hJVEVTUEFDRTogL1sgXFx0XFxyXFxuXS8sXG5cdFx0XHRcdERJR0lUOiAvW1xcZF0vLFxuXHRcdFx0XHRTSUdOOiAvWy0rXS8sXG5cdFx0XHRcdFBPSU5UOiAvXFwuLyxcblx0XHRcdFx0Q09NTUE6IC8sLyxcblx0XHRcdFx0RVhQOiAvZS9pXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTdGF0ZXNcblx0XHRcdHZhciBTRVAgPSAwO1xuXHRcdFx0dmFyIElOVCA9IDE7XG5cdFx0XHR2YXIgRkxPQVQgPSAyO1xuXHRcdFx0dmFyIEVYUCA9IDM7XG5cblx0XHRcdHZhciBzdGF0ZSA9IFNFUDtcblx0XHRcdHZhciBzZWVuQ29tbWEgPSB0cnVlO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLCBudW1iZXIgPSAnJywgZXhwb25lbnQgPSAnJztcblxuXHRcdFx0ZnVuY3Rpb24gdGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcGFydGlhbCApIHtcblxuXHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoICdVbmV4cGVjdGVkIGNoYXJhY3RlciBcIicgKyBjdXJyZW50ICsgJ1wiIGF0IGluZGV4ICcgKyBpICsgJy4nICk7XG5cdFx0XHRcdGVycm9yLnBhcnRpYWwgPSBwYXJ0aWFsO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBuZXdOdW1iZXIoKSB7XG5cblx0XHRcdFx0aWYgKCBudW1iZXIgIT09ICcnICkge1xuXG5cdFx0XHRcdFx0aWYgKCBleHBvbmVudCA9PT0gJycgKSByZXN1bHQucHVzaCggTnVtYmVyKCBudW1iZXIgKSApO1xuXHRcdFx0XHRcdGVsc2UgcmVzdWx0LnB1c2goIE51bWJlciggbnVtYmVyICkgKiBNYXRoLnBvdyggMTAsIE51bWJlciggZXhwb25lbnQgKSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG51bWJlciA9ICcnO1xuXHRcdFx0XHRleHBvbmVudCA9ICcnO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJyZW50LCBpID0gMCwgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IGlucHV0WyBpIF07XG5cblx0XHRcdFx0Ly8gcGFyc2UgdW50aWwgbmV4dCBudW1iZXJcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gU0VQICkge1xuXG5cdFx0XHRcdFx0Ly8gZWF0IHdoaXRlc3BhY2Vcblx0XHRcdFx0XHRpZiAoIFJFLldISVRFU1BBQ0UudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHN0YXJ0IG5ldyBudW1iZXJcblx0XHRcdFx0XHRpZiAoIFJFLkRJR0lULnRlc3QoIGN1cnJlbnQgKSB8fCBSRS5TSUdOLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBJTlQ7XG5cdFx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0c3RhdGUgPSBGTE9BVDtcblx0XHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRocm93IG9uIGRvdWJsZSBjb21tYXMgKGUuZy4gXCIxLCAsIDJcIilcblx0XHRcdFx0XHRpZiAoIFJFLkNPTU1BLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzZWVuQ29tbWEgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c2VlbkNvbW1hID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcGFyc2UgaW50ZWdlciBwYXJ0XG5cdFx0XHRcdGlmICggc3RhdGUgPT09IElOVCApIHtcblxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdG51bWJlciArPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBGTE9BVDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5FWFAudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IEVYUDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhyb3cgb24gZG91YmxlIHNpZ25zIChcIi0rMVwiKSwgYnV0IG5vdCBvbiBzaWduIGFzIHNlcGFyYXRvciAoXCItMS0yXCIpXG5cdFx0XHRcdFx0aWYgKCBSRS5TSUdOLnRlc3QoIGN1cnJlbnQgKVxuXHRcdFx0XHRcdFx0XHQmJiBudW1iZXIubGVuZ3RoID09PSAxXG5cdFx0XHRcdFx0XHRcdCYmIFJFLlNJR04udGVzdCggbnVtYmVyWyAwIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHBhcnNlIGRlY2ltYWwgcGFydFxuXHRcdFx0XHRpZiAoIHN0YXRlID09PSBGTE9BVCApIHtcblxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRudW1iZXIgKz0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBSRS5FWFAudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IEVYUDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhyb3cgb24gZG91YmxlIGRlY2ltYWwgcG9pbnRzIChlLmcuIFwiMS4uMlwiKVxuXHRcdFx0XHRcdGlmICggUkUuUE9JTlQudGVzdCggY3VycmVudCApICYmIG51bWJlclsgbnVtYmVyLmxlbmd0aCAtIDEgXSA9PT0gJy4nICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcGFyc2UgZXhwb25lbnQgcGFydFxuXHRcdFx0XHRpZiAoIHN0YXRlID09IEVYUCApIHtcblxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRleHBvbmVudCArPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIFJFLlNJR04udGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGV4cG9uZW50ID09PSAnJyApIHtcblxuXHRcdFx0XHRcdFx0XHRleHBvbmVudCArPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGV4cG9uZW50Lmxlbmd0aCA9PT0gMSAmJiBSRS5TSUdOLnRlc3QoIGV4cG9uZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBlbmQgb2YgbnVtYmVyXG5cdFx0XHRcdGlmICggUkUuV0hJVEVTUEFDRS50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcblx0XHRcdFx0XHRzdGF0ZSA9IFNFUDtcblx0XHRcdFx0XHRzZWVuQ29tbWEgPSBmYWxzZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBSRS5DT01NQS50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcblx0XHRcdFx0XHRzdGF0ZSA9IFNFUDtcblx0XHRcdFx0XHRzZWVuQ29tbWEgPSB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLlNJR04udGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0bmV3TnVtYmVyKCk7XG5cdFx0XHRcdFx0c3RhdGUgPSBJTlQ7XG5cdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcblx0XHRcdFx0XHRzdGF0ZSA9IEZMT0FUO1xuXHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhZGQgdGhlIGxhc3QgbnVtYmVyIGZvdW5kIChpZiBhbnkpXG5cdFx0XHRuZXdOdW1iZXIoKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdC8vIFVuaXRzXG5cblx0XHR2YXIgdW5pdHMgPSBbICdtbScsICdjbScsICdpbicsICdwdCcsICdwYycsICdweCcgXTtcblxuXHRcdC8vIENvbnZlcnNpb246IFsgZnJvbVVuaXQgXVsgdG9Vbml0IF0gKC0xIG1lYW5zIGRwaSBkZXBlbmRlbnQpXG5cdFx0dmFyIHVuaXRDb252ZXJzaW9uID0ge1xuXG5cdFx0XHQnbW0nOiB7XG5cdFx0XHRcdCdtbSc6IDEsXG5cdFx0XHRcdCdjbSc6IDAuMSxcblx0XHRcdFx0J2luJzogMSAvIDI1LjQsXG5cdFx0XHRcdCdwdCc6IDcyIC8gMjUuNCxcblx0XHRcdFx0J3BjJzogNiAvIDI1LjQsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdjbSc6IHtcblx0XHRcdFx0J21tJzogMTAsXG5cdFx0XHRcdCdjbSc6IDEsXG5cdFx0XHRcdCdpbic6IDEgLyAyLjU0LFxuXHRcdFx0XHQncHQnOiA3MiAvIDIuNTQsXG5cdFx0XHRcdCdwYyc6IDYgLyAyLjU0LFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQnaW4nOiB7XG5cdFx0XHRcdCdtbSc6IDI1LjQsXG5cdFx0XHRcdCdjbSc6IDIuNTQsXG5cdFx0XHRcdCdpbic6IDEsXG5cdFx0XHRcdCdwdCc6IDcyLFxuXHRcdFx0XHQncGMnOiA2LFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQncHQnOiB7XG5cdFx0XHRcdCdtbSc6IDI1LjQgLyA3Mixcblx0XHRcdFx0J2NtJzogMi41NCAvIDcyLFxuXHRcdFx0XHQnaW4nOiAxIC8gNzIsXG5cdFx0XHRcdCdwdCc6IDEsXG5cdFx0XHRcdCdwYyc6IDYgLyA3Mixcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J3BjJzoge1xuXHRcdFx0XHQnbW0nOiAyNS40IC8gNixcblx0XHRcdFx0J2NtJzogMi41NCAvIDYsXG5cdFx0XHRcdCdpbic6IDEgLyA2LFxuXHRcdFx0XHQncHQnOiA3MiAvIDYsXG5cdFx0XHRcdCdwYyc6IDEsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdweCc6IHtcblx0XHRcdFx0J3B4JzogMVxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHN0cmluZyApIHtcblxuXHRcdFx0dmFyIHRoZVVuaXQgPSAncHgnO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnIHx8IHN0cmluZyBpbnN0YW5jZW9mIFN0cmluZyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB1bml0cy5sZW5ndGg7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHUgPSB1bml0c1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBzdHJpbmcuZW5kc1dpdGgoIHUgKSApIHtcblxuXHRcdFx0XHRcdFx0dGhlVW5pdCA9IHU7XG5cdFx0XHRcdFx0XHRzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKCAwLCBzdHJpbmcubGVuZ3RoIC0gdS5sZW5ndGggKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2NhbGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggdGhlVW5pdCA9PT0gJ3B4JyAmJiBzY29wZS5kZWZhdWx0VW5pdCAhPT0gJ3B4JyApIHtcblxuXHRcdFx0XHQvLyBDb252ZXJzaW9uIHNjYWxlIGZyb20gIHBpeGVscyB0byBpbmNoZXMsIHRoZW4gdG8gZGVmYXVsdCB1bml0c1xuXG5cdFx0XHRcdHNjYWxlID0gdW5pdENvbnZlcnNpb25bICdpbicgXVsgc2NvcGUuZGVmYXVsdFVuaXQgXSAvIHNjb3BlLmRlZmF1bHREUEk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgdGhlVW5pdCBdWyBzY29wZS5kZWZhdWx0VW5pdCBdO1xuXG5cdFx0XHRcdGlmICggc2NhbGUgPCAwICkge1xuXG5cdFx0XHRcdFx0Ly8gQ29udmVyc2lvbiBzY2FsZSB0byBwaXhlbHNcblxuXHRcdFx0XHRcdHNjYWxlID0gdW5pdENvbnZlcnNpb25bIHRoZVVuaXQgXVsgJ2luJyBdICogc2NvcGUuZGVmYXVsdERQSTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNjYWxlICogcGFyc2VGbG9hdCggc3RyaW5nICk7XG5cblx0XHR9XG5cblx0XHQvLyBUcmFuc2Zvcm1zXG5cblx0XHRmdW5jdGlvbiBnZXROb2RlVHJhbnNmb3JtKCBub2RlICkge1xuXG5cdFx0XHRpZiAoICEgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3RyYW5zZm9ybScgKSB8fCAoIG5vZGUubm9kZU5hbWUgPT09ICd1c2UnICYmICggbm9kZS5oYXNBdHRyaWJ1dGUoICd4JyApIHx8IG5vZGUuaGFzQXR0cmlidXRlKCAneScgKSApICkgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gcGFyc2VOb2RlVHJhbnNmb3JtKCBub2RlICk7XG5cblx0XHRcdGlmICggdHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR0cmFuc2Zvcm0ucHJlbXVsdGlwbHkoIHRyYW5zZm9ybVN0YWNrWyB0cmFuc2Zvcm1TdGFjay5sZW5ndGggLSAxIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50VHJhbnNmb3JtLmNvcHkoIHRyYW5zZm9ybSApO1xuXHRcdFx0dHJhbnNmb3JtU3RhY2sucHVzaCggdHJhbnNmb3JtICk7XG5cblx0XHRcdHJldHVybiB0cmFuc2Zvcm07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vZGVUcmFuc2Zvcm0oIG5vZGUgKSB7XG5cblx0XHRcdHZhciB0cmFuc2Zvcm0gPSBuZXcgTWF0cml4MygpO1xuXHRcdFx0dmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSB0ZW1wVHJhbnNmb3JtMDtcblxuXHRcdFx0aWYgKCBub2RlLm5vZGVOYW1lID09PSAndXNlJyAmJiAoIG5vZGUuaGFzQXR0cmlidXRlKCAneCcgKSB8fCBub2RlLmhhc0F0dHJpYnV0ZSggJ3knICkgKSApIHtcblxuXHRcdFx0XHR2YXIgdHggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gnICkgKTtcblx0XHRcdFx0dmFyIHR5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICd5JyApICk7XG5cblx0XHRcdFx0dHJhbnNmb3JtLnRyYW5zbGF0ZSggdHgsIHR5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3RyYW5zZm9ybScgKSApIHtcblxuXHRcdFx0XHR2YXIgdHJhbnNmb3Jtc1RleHRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoICd0cmFuc2Zvcm0nICkuc3BsaXQoICcpJyApO1xuXG5cdFx0XHRcdGZvciAoIHZhciB0SW5kZXggPSB0cmFuc2Zvcm1zVGV4dHMubGVuZ3RoIC0gMTsgdEluZGV4ID49IDA7IHRJbmRleCAtLSApIHtcblxuXHRcdFx0XHRcdHZhciB0cmFuc2Zvcm1UZXh0ID0gdHJhbnNmb3Jtc1RleHRzWyB0SW5kZXggXS50cmltKCk7XG5cblx0XHRcdFx0XHRpZiAoIHRyYW5zZm9ybVRleHQgPT09ICcnICkgY29udGludWU7XG5cblx0XHRcdFx0XHR2YXIgb3BlblBhclBvcyA9IHRyYW5zZm9ybVRleHQuaW5kZXhPZiggJygnICk7XG5cdFx0XHRcdFx0dmFyIGNsb3NlUGFyUG9zID0gdHJhbnNmb3JtVGV4dC5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIG9wZW5QYXJQb3MgPiAwICYmIG9wZW5QYXJQb3MgPCBjbG9zZVBhclBvcyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybVR5cGUgPSB0cmFuc2Zvcm1UZXh0LnN1YnN0ciggMCwgb3BlblBhclBvcyApO1xuXG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggdHJhbnNmb3JtVGV4dC5zdWJzdHIoIG9wZW5QYXJQb3MgKyAxLCBjbG9zZVBhclBvcyAtIG9wZW5QYXJQb3MgLSAxICkgKTtcblxuXHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5pZGVudGl0eSgpO1xuXG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCB0cmFuc2Zvcm1UeXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdHggPSBhcnJheVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gdHg7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dHkgPSBhcnJheVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0udHJhbnNsYXRlKCB0eCwgdHkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYW5nbGUgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGN4ID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjeSA9IDA7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFuZ2xlXG5cdFx0XHRcdFx0XHRcdFx0XHRhbmdsZSA9IC0gYXJyYXlbIDAgXSAqIE1hdGguUEkgLyAxODA7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2VudGVyIHgsIHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3ggPSBhcnJheVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjeSA9IGFycmF5WyAyIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUm90YXRlIGFyb3VuZCBjZW50ZXIgKGN4LCBjeSlcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0xLmlkZW50aXR5KCkudHJhbnNsYXRlKCAtIGN4LCAtIGN5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVHJhbnNmb3JtMi5pZGVudGl0eSgpLnJvdGF0ZSggYW5nbGUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0zLm11bHRpcGx5TWF0cmljZXMoIHRlbXBUcmFuc2Zvcm0yLCB0ZW1wVHJhbnNmb3JtMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTEuaWRlbnRpdHkoKS50cmFuc2xhdGUoIGN4LCBjeSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5tdWx0aXBseU1hdHJpY2VzKCB0ZW1wVHJhbnNmb3JtMSwgdGVtcFRyYW5zZm9ybTMgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzY2FsZVggPSBhcnJheVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHNjYWxlWSA9IHNjYWxlWDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzY2FsZVkgPSBhcnJheVsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2NhbGUoIHNjYWxlWCwgc2NhbGVZICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdza2V3WCc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDEsIE1hdGgudGFuKCBhcnJheVsgMCBdICogTWF0aC5QSSAvIDE4MCApLCAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAxLCAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAwLCAxXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2tld1knOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uc2V0KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQxLCAwLCAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLnRhbiggYXJyYXlbIDAgXSAqIE1hdGguUEkgLyAxODAgKSwgMSwgMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMCwgMVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFycmF5WyAwIF0sIGFycmF5WyAyIF0sIGFycmF5WyA0IF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFycmF5WyAxIF0sIGFycmF5WyAzIF0sIGFycmF5WyA1IF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDAsIDFcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJhbnNmb3JtLnByZW11bHRpcGx5KCBjdXJyZW50VHJhbnNmb3JtICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cmFuc2Zvcm07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKCBwYXRoLCBtICkge1xuXG5cdFx0XHRmdW5jdGlvbiB0cmFuc2ZWZWMyKCB2MiApIHtcblxuXHRcdFx0XHR0ZW1wVjMuc2V0KCB2Mi54LCB2Mi55LCAxICkuYXBwbHlNYXRyaXgzKCBtICk7XG5cblx0XHRcdFx0djIuc2V0KCB0ZW1wVjMueCwgdGVtcFYzLnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNSb3RhdGVkID0gaXNUcmFuc2Zvcm1Sb3RhdGVkKCBtICk7XG5cblx0XHRcdHZhciBzdWJQYXRocyA9IHBhdGguc3ViUGF0aHM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHN1YlBhdGggPSBzdWJQYXRoc1sgaSBdO1xuXHRcdFx0XHR2YXIgY3VydmVzID0gc3ViUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgY3VydmVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBjdXJ2ZS5pc0xpbmVDdXJ2ZSApIHtcblxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjEgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYyICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZS5pc0N1YmljQmV6aWVyQ3VydmUgKSB7XG5cblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYwICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYzICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZS5pc1F1YWRyYXRpY0JlemllckN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MCApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjEgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYyICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1JvdGF0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiBFbGxpcHRpYyBhcmMgb3IgZWxsaXBzZSByb3RhdGlvbiBvciBza2V3aW5nIGlzIG5vdCBpbXBsZW1lbnRlZC4nICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGVtcFYyLnNldCggY3VydmUuYVgsIGN1cnZlLmFZICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCB0ZW1wVjIgKTtcblx0XHRcdFx0XHRcdGN1cnZlLmFYID0gdGVtcFYyLng7XG5cdFx0XHRcdFx0XHRjdXJ2ZS5hWSA9IHRlbXBWMi55O1xuXG5cdFx0XHRcdFx0XHRjdXJ2ZS54UmFkaXVzICo9IGdldFRyYW5zZm9ybVNjYWxlWCggbSApO1xuXHRcdFx0XHRcdFx0Y3VydmUueVJhZGl1cyAqPSBnZXRUcmFuc2Zvcm1TY2FsZVkoIG0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzVHJhbnNmb3JtUm90YXRlZCggbSApIHtcblxuXHRcdFx0cmV0dXJuIG0uZWxlbWVudHNbIDEgXSAhPT0gMCB8fCBtLmVsZW1lbnRzWyAzIF0gIT09IDA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TY2FsZVgoIG0gKSB7XG5cblx0XHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TY2FsZVkoIG0gKSB7XG5cblx0XHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0ZVsgMyBdICogdGVbIDMgXSArIHRlWyA0IF0gKiB0ZVsgNCBdICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIHBhdGhzID0gW107XG5cdFx0dmFyIHN0eWxlc2hlZXRzID0ge307XG5cblx0XHR2YXIgdHJhbnNmb3JtU3RhY2sgPSBbXTtcblxuXHRcdHZhciB0ZW1wVHJhbnNmb3JtMCA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0dmFyIHRlbXBUcmFuc2Zvcm0xID0gbmV3IE1hdHJpeDMoKTtcblx0XHR2YXIgdGVtcFRyYW5zZm9ybTIgPSBuZXcgTWF0cml4MygpO1xuXHRcdHZhciB0ZW1wVHJhbnNmb3JtMyA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0dmFyIHRlbXBWMiA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0dmFyIHRlbXBWMyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHR2YXIgY3VycmVudFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgzKCk7XG5cblx0XHR2YXIgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgJ2ltYWdlL3N2Zyt4bWwnICk7IC8vIGFwcGxpY2F0aW9uL3htbFxuXG5cdFx0cGFyc2VOb2RlKCB4bWwuZG9jdW1lbnRFbGVtZW50LCB7XG5cdFx0XHRmaWxsOiAnIzAwMCcsXG5cdFx0XHRmaWxsT3BhY2l0eTogMSxcblx0XHRcdHN0cm9rZU9wYWNpdHk6IDEsXG5cdFx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRcdHN0cm9rZUxpbmVKb2luOiAnbWl0ZXInLFxuXHRcdFx0c3Ryb2tlTGluZUNhcDogJ2J1dHQnLFxuXHRcdFx0c3Ryb2tlTWl0ZXJMaW1pdDogNFxuXHRcdH0gKTtcblxuXHRcdHZhciBkYXRhID0geyBwYXRoczogcGF0aHMsIHhtbDogeG1sLmRvY3VtZW50RWxlbWVudCB9O1xuXG5cdFx0Ly8gY29uc29sZS5sb2coIHBhdGhzICk7XG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59ICk7XG5cblNWR0xvYWRlci5nZXRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uICggd2lkdGgsIGNvbG9yLCBsaW5lSm9pbiwgbGluZUNhcCwgbWl0ZXJMaW1pdCApIHtcblxuXHQvLyBQYXJhbSB3aWR0aDogU3Ryb2tlIHdpZHRoXG5cdC8vIFBhcmFtIGNvbG9yOiBBcyByZXR1cm5lZCBieSBUSFJFRS5Db2xvci5nZXRTdHlsZSgpXG5cdC8vIFBhcmFtIGxpbmVKb2luOiBPbmUgb2YgXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIiBvciBcIm1pdGVyLWxpbWl0XCJcblx0Ly8gUGFyYW0gbGluZUNhcDogT25lIG9mIFwicm91bmRcIiwgXCJzcXVhcmVcIiBvciBcImJ1dHRcIlxuXHQvLyBQYXJhbSBtaXRlckxpbWl0OiBNYXhpbXVtIGpvaW4gbGVuZ3RoLCBpbiBtdWx0aXBsZXMgb2YgdGhlIFwid2lkdGhcIiBwYXJhbWV0ZXIgKGpvaW4gaXMgdHJ1bmNhdGVkIGlmIGl0IGV4Y2VlZHMgdGhhdCBkaXN0YW5jZSlcblx0Ly8gUmV0dXJucyBzdHlsZSBvYmplY3RcblxuXHR3aWR0aCA9IHdpZHRoICE9PSB1bmRlZmluZWQgPyB3aWR0aCA6IDE7XG5cdGNvbG9yID0gY29sb3IgIT09IHVuZGVmaW5lZCA/IGNvbG9yIDogJyMwMDAnO1xuXHRsaW5lSm9pbiA9IGxpbmVKb2luICE9PSB1bmRlZmluZWQgPyBsaW5lSm9pbiA6ICdtaXRlcic7XG5cdGxpbmVDYXAgPSBsaW5lQ2FwICE9PSB1bmRlZmluZWQgPyBsaW5lQ2FwIDogJ2J1dHQnO1xuXHRtaXRlckxpbWl0ID0gbWl0ZXJMaW1pdCAhPT0gdW5kZWZpbmVkID8gbWl0ZXJMaW1pdCA6IDQ7XG5cblx0cmV0dXJuIHtcblx0XHRzdHJva2VDb2xvcjogY29sb3IsXG5cdFx0c3Ryb2tlV2lkdGg6IHdpZHRoLFxuXHRcdHN0cm9rZUxpbmVKb2luOiBsaW5lSm9pbixcblx0XHRzdHJva2VMaW5lQ2FwOiBsaW5lQ2FwLFxuXHRcdHN0cm9rZU1pdGVyTGltaXQ6IG1pdGVyTGltaXRcblx0fTtcblxufTtcblxuU1ZHTG9hZGVyLnBvaW50c1RvU3Ryb2tlID0gZnVuY3Rpb24gKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlICkge1xuXG5cdC8vIEdlbmVyYXRlcyBhIHN0cm9rZSB3aXRoIHNvbWUgd2l0ZGggYXJvdW5kIHRoZSBnaXZlbiBwYXRoLlxuXHQvLyBUaGUgcGF0aCBjYW4gYmUgb3BlbiBvciBjbG9zZWQgKGxhc3QgcG9pbnQgZXF1YWxzIHRvIGZpcnN0IHBvaW50KVxuXHQvLyBQYXJhbSBwb2ludHM6IEFycmF5IG9mIFZlY3RvcjJEICh0aGUgcGF0aCkuIE1pbmltdW0gMiBwb2ludHMuXG5cdC8vIFBhcmFtIHN0eWxlOiBPYmplY3Qgd2l0aCBTVkcgcHJvcGVydGllcyBhcyByZXR1cm5lZCBieSBTVkdMb2FkZXIuZ2V0U3Ryb2tlU3R5bGUoKSwgb3IgU1ZHTG9hZGVyLnBhcnNlKCkgaW4gdGhlIHBhdGgudXNlckRhdGEuc3R5bGUgb2JqZWN0XG5cdC8vIFBhcmFtcyBhcmNEaXZpc2lvbnM6IEFyYyBkaXZpc2lvbnMgZm9yIHJvdW5kIGpvaW5zIGFuZCBlbmRjYXBzLiAoT3B0aW9uYWwpXG5cdC8vIFBhcmFtIG1pbkRpc3RhbmNlOiBQb2ludHMgY2xvc2VyIHRvIHRoaXMgZGlzdGFuY2Ugd2lsbCBiZSBtZXJnZWQuIChPcHRpb25hbClcblx0Ly8gUmV0dXJucyBCdWZmZXJHZW9tZXRyeSB3aXRoIHN0cm9rZSB0cmlhbmdsZXMgKEluIHBsYW5lIHogPSAwKS4gVVYgY29vcmRpbmF0ZXMgYXJlIGdlbmVyYXRlZCAoJ3UnIGFsb25nIHBhdGguICd2JyBhY3Jvc3MgaXQsIGZyb20gbGVmdCB0byByaWdodClcblxuXHR2YXIgdmVydGljZXMgPSBbXTtcblx0dmFyIG5vcm1hbHMgPSBbXTtcblx0dmFyIHV2cyA9IFtdO1xuXG5cdGlmICggU1ZHTG9hZGVyLnBvaW50c1RvU3Ryb2tlV2l0aEJ1ZmZlcnMoIHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UsIHZlcnRpY2VzLCBub3JtYWxzLCB1dnMgKSA9PT0gMCApIHtcblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0cmV0dXJuIGdlb21ldHJ5O1xuXG59O1xuXG5TVkdMb2FkZXIucG9pbnRzVG9TdHJva2VXaXRoQnVmZmVycyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdGVtcFYyXzEgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzIgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzMgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzQgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzUgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzYgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgdGVtcFYyXzcgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgbGFzdFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBsYXN0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIHBvaW50MEwgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgcG9pbnQwUiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBjdXJyZW50UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGN1cnJlbnRQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgbmV4dFBvaW50TCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBuZXh0UG9pbnRSID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGlubmVyUG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgb3V0ZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSwgdmVydGljZXMsIG5vcm1hbHMsIHV2cywgdmVydGV4T2Zmc2V0ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIHVwZGF0ZSBleGlzdGluZyBhcnJheXMgb3IgYnVmZmVycy5cblx0XHQvLyBBY2NlcHRzIHNhbWUgcGFyYW1ldGVycyBhcyBwb2ludHNUb1N0cm9rZSwgcGx1cyB0aGUgYnVmZmVycyBhbmQgb3B0aW9uYWwgb2Zmc2V0LlxuXHRcdC8vIFBhcmFtIHZlcnRleE9mZnNldDogT2Zmc2V0IHZlcnRpY2VzIHRvIHN0YXJ0IHdyaXRpbmcgaW4gdGhlIGJ1ZmZlcnMgKDMgZWxlbWVudHMvdmVydGV4IGZvciB2ZXJ0aWNlcyBhbmQgbm9ybWFscywgYW5kIDIgZWxlbWVudHMvdmVydGV4IGZvciB1dnMpXG5cdFx0Ly8gUmV0dXJucyBudW1iZXIgb2Ygd3JpdHRlbiB2ZXJ0aWNlcyAvIG5vcm1hbHMgLyB1dnMgcGFpcnNcblx0XHQvLyBpZiAndmVydGljZXMnIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgbm8gdHJpYW5nbGVzIHdpbGwgYmUgZ2VuZXJhdGVkLCBidXQgdGhlIHJldHVybmVkIHZlcnRpY2VzIGNvdW50IHdpbGwgc3RpbGwgYmUgdmFsaWQgKHVzZWZ1bCB0byBwcmVhbGxvY2F0ZSB0aGUgYnVmZmVycylcblx0XHQvLyAnbm9ybWFscycgYW5kICd1dnMnIGJ1ZmZlcnMgYXJlIG9wdGlvbmFsXG5cblx0XHRhcmNEaXZpc2lvbnMgPSBhcmNEaXZpc2lvbnMgIT09IHVuZGVmaW5lZCA/IGFyY0RpdmlzaW9ucyA6IDEyO1xuXHRcdG1pbkRpc3RhbmNlID0gbWluRGlzdGFuY2UgIT09IHVuZGVmaW5lZCA/IG1pbkRpc3RhbmNlIDogMC4wMDE7XG5cdFx0dmVydGV4T2Zmc2V0ID0gdmVydGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgPyB2ZXJ0ZXhPZmZzZXQgOiAwO1xuXG5cdFx0Ly8gRmlyc3QgZW5zdXJlIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVkIHBvaW50c1xuXHRcdHBvaW50cyA9IHJlbW92ZUR1cGxpY2F0ZWRQb2ludHMoIHBvaW50cyApO1xuXG5cdFx0dmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cblx0XHRpZiAoIG51bVBvaW50cyA8IDIgKSByZXR1cm4gMDtcblxuXHRcdHZhciBpc0Nsb3NlZCA9IHBvaW50c1sgMCBdLmVxdWFscyggcG9pbnRzWyBudW1Qb2ludHMgLSAxIF0gKTtcblxuXHRcdHZhciBjdXJyZW50UG9pbnQ7XG5cdFx0dmFyIHByZXZpb3VzUG9pbnQgPSBwb2ludHNbIDAgXTtcblx0XHR2YXIgbmV4dFBvaW50O1xuXG5cdFx0dmFyIHN0cm9rZVdpZHRoMiA9IHN0eWxlLnN0cm9rZVdpZHRoIC8gMjtcblxuXHRcdHZhciBkZWx0YVUgPSAxIC8gKCBudW1Qb2ludHMgLSAxICk7XG5cdFx0dmFyIHUwID0gMDtcblxuXHRcdHZhciBpbm5lclNpZGVNb2RpZmllZDtcblx0XHR2YXIgam9pbklzT25MZWZ0U2lkZTtcblx0XHR2YXIgaXNNaXRlcjtcblx0XHR2YXIgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcblxuXHRcdHZhciBudW1WZXJ0aWNlcyA9IDA7XG5cdFx0dmFyIGN1cnJlbnRDb29yZGluYXRlID0gdmVydGV4T2Zmc2V0ICogMztcblx0XHR2YXIgY3VycmVudENvb3JkaW5hdGVVViA9IHZlcnRleE9mZnNldCAqIDI7XG5cblx0XHQvLyBHZXQgaW5pdGlhbCBsZWZ0IGFuZCByaWdodCBzdHJva2UgcG9pbnRzXG5cdFx0Z2V0Tm9ybWFsKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0sIHRlbXBWMl8xICkubXVsdGlwbHlTY2FsYXIoIHN0cm9rZVdpZHRoMiApO1xuXHRcdGxhc3RQb2ludEwuY29weSggcG9pbnRzWyAwIF0gKS5zdWIoIHRlbXBWMl8xICk7XG5cdFx0bGFzdFBvaW50Ui5jb3B5KCBwb2ludHNbIDAgXSApLmFkZCggdGVtcFYyXzEgKTtcblx0XHRwb2ludDBMLmNvcHkoIGxhc3RQb2ludEwgKTtcblx0XHRwb2ludDBSLmNvcHkoIGxhc3RQb2ludFIgKTtcblxuXHRcdGZvciAoIHZhciBpUG9pbnQgPSAxOyBpUG9pbnQgPCBudW1Qb2ludHM7IGlQb2ludCArKyApIHtcblxuXHRcdFx0Y3VycmVudFBvaW50ID0gcG9pbnRzWyBpUG9pbnQgXTtcblxuXHRcdFx0Ly8gR2V0IG5leHQgcG9pbnRcblx0XHRcdGlmICggaVBvaW50ID09PSBudW1Qb2ludHMgLSAxICkge1xuXG5cdFx0XHRcdGlmICggaXNDbG9zZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBTa2lwIGR1cGxpY2F0ZWQgaW5pdGlhbCBwb2ludFxuXHRcdFx0XHRcdG5leHRQb2ludCA9IHBvaW50c1sgMSBdO1xuXG5cdFx0XHRcdH0gZWxzZSBuZXh0UG9pbnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bmV4dFBvaW50ID0gcG9pbnRzWyBpUG9pbnQgKyAxIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gTm9ybWFsIG9mIHByZXZpb3VzIHNlZ21lbnQgaW4gdGVtcFYyXzFcblx0XHRcdHZhciBub3JtYWwxID0gdGVtcFYyXzE7XG5cdFx0XHRnZXROb3JtYWwoIHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbm9ybWFsMSApO1xuXG5cdFx0XHR0ZW1wVjJfMy5jb3B5KCBub3JtYWwxICkubXVsdGlwbHlTY2FsYXIoIHN0cm9rZVdpZHRoMiApO1xuXHRcdFx0Y3VycmVudFBvaW50TC5jb3B5KCBjdXJyZW50UG9pbnQgKS5zdWIoIHRlbXBWMl8zICk7XG5cdFx0XHRjdXJyZW50UG9pbnRSLmNvcHkoIGN1cnJlbnRQb2ludCApLmFkZCggdGVtcFYyXzMgKTtcblxuXHRcdFx0dmFyIHUxID0gdTAgKyBkZWx0YVU7XG5cblx0XHRcdGlubmVyU2lkZU1vZGlmaWVkID0gZmFsc2U7XG5cblx0XHRcdGlmICggbmV4dFBvaW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gTm9ybWFsIG9mIG5leHQgc2VnbWVudCBpbiB0ZW1wVjJfMlxuXHRcdFx0XHRnZXROb3JtYWwoIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCB0ZW1wVjJfMiApO1xuXG5cdFx0XHRcdHRlbXBWMl8zLmNvcHkoIHRlbXBWMl8yICkubXVsdGlwbHlTY2FsYXIoIHN0cm9rZVdpZHRoMiApO1xuXHRcdFx0XHRuZXh0UG9pbnRMLmNvcHkoIGN1cnJlbnRQb2ludCApLnN1YiggdGVtcFYyXzMgKTtcblx0XHRcdFx0bmV4dFBvaW50Ui5jb3B5KCBjdXJyZW50UG9pbnQgKS5hZGQoIHRlbXBWMl8zICk7XG5cblx0XHRcdFx0am9pbklzT25MZWZ0U2lkZSA9IHRydWU7XG5cdFx0XHRcdHRlbXBWMl8zLnN1YlZlY3RvcnMoIG5leHRQb2ludCwgcHJldmlvdXNQb2ludCApO1xuXHRcdFx0XHRpZiAoIG5vcm1hbDEuZG90KCB0ZW1wVjJfMyApIDwgMCApIHtcblxuXHRcdFx0XHRcdGpvaW5Jc09uTGVmdFNpZGUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpUG9pbnQgPT09IDEgKSBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGpvaW5Jc09uTGVmdFNpZGU7XG5cblx0XHRcdFx0dGVtcFYyXzMuc3ViVmVjdG9ycyggbmV4dFBvaW50LCBjdXJyZW50UG9pbnQgKTtcblx0XHRcdFx0dGVtcFYyXzMubm9ybWFsaXplKCk7XG5cdFx0XHRcdHZhciBkb3QgPSBNYXRoLmFicyggbm9ybWFsMS5kb3QoIHRlbXBWMl8zICkgKTtcblxuXHRcdFx0XHQvLyBJZiBwYXRoIGlzIHN0cmFpZ2h0LCBkb24ndCBjcmVhdGUgam9pblxuXHRcdFx0XHRpZiAoIGRvdCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdC8vIENvbXB1dGUgaW5uZXIgYW5kIG91dGVyIHNlZ21lbnQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdHZhciBtaXRlclNpZGUgPSBzdHJva2VXaWR0aDIgLyBkb3Q7XG5cdFx0XHRcdFx0dGVtcFYyXzMubXVsdGlwbHlTY2FsYXIoIC0gbWl0ZXJTaWRlICk7XG5cdFx0XHRcdFx0dGVtcFYyXzQuc3ViVmVjdG9ycyggY3VycmVudFBvaW50LCBwcmV2aW91c1BvaW50ICk7XG5cdFx0XHRcdFx0dGVtcFYyXzUuY29weSggdGVtcFYyXzQgKS5zZXRMZW5ndGgoIG1pdGVyU2lkZSApLmFkZCggdGVtcFYyXzMgKTtcblx0XHRcdFx0XHRpbm5lclBvaW50LmNvcHkoIHRlbXBWMl81ICkubmVnYXRlKCk7XG5cdFx0XHRcdFx0dmFyIG1pdGVyTGVuZ3RoMiA9IHRlbXBWMl81Lmxlbmd0aCgpO1xuXHRcdFx0XHRcdHZhciBzZWdtZW50TGVuZ3RoUHJldiA9IHRlbXBWMl80Lmxlbmd0aCgpO1xuXHRcdFx0XHRcdHRlbXBWMl80LmRpdmlkZVNjYWxhciggc2VnbWVudExlbmd0aFByZXYgKTtcblx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCApO1xuXHRcdFx0XHRcdHZhciBzZWdtZW50TGVuZ3RoTmV4dCA9IHRlbXBWMl82Lmxlbmd0aCgpO1xuXHRcdFx0XHRcdHRlbXBWMl82LmRpdmlkZVNjYWxhciggc2VnbWVudExlbmd0aE5leHQgKTtcblx0XHRcdFx0XHQvLyBDaGVjayB0aGF0IHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnRzIGRvZXNuJ3Qgb3ZlcmxhcCB3aXRoIHRoZSBpbm5lclBvaW50IG9mIGludGVyc2VjdGlvblxuXHRcdFx0XHRcdGlmICggdGVtcFYyXzQuZG90KCBpbm5lclBvaW50ICkgPCBzZWdtZW50TGVuZ3RoUHJldiAmJiB0ZW1wVjJfNi5kb3QoIGlubmVyUG9pbnQgKSA8IHNlZ21lbnRMZW5ndGhOZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRpbm5lclNpZGVNb2RpZmllZCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRlclBvaW50LmNvcHkoIHRlbXBWMl81ICkuYWRkKCBjdXJyZW50UG9pbnQgKTtcblx0XHRcdFx0XHRpbm5lclBvaW50LmFkZCggY3VycmVudFBvaW50ICk7XG5cblx0XHRcdFx0XHRpc01pdGVyID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0bmV4dFBvaW50Ui5jb3B5KCBpbm5lclBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRQb2ludFIuY29weSggaW5uZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdG5leHRQb2ludEwuY29weSggaW5uZXJQb2ludCApO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50UG9pbnRMLmNvcHkoIGlubmVyUG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSBpZiB0aGVyZSB3YXMgb3ZlcmxhcHBpbmdcblxuXHRcdFx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHN3aXRjaCAoIHN0eWxlLnN0cm9rZUxpbmVKb2luICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiZXZlbCc6XG5cblx0XHRcdFx0XHRcdFx0bWFrZVNlZ21lbnRXaXRoQmV2ZWxKb2luKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCwgdTEgKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncm91bmQnOlxuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZ21lbnQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0Y3JlYXRlU2VnbWVudFRyaWFuZ2xlc1dpdGhNaWRkbGVTZWN0aW9uKCBqb2luSXNPbkxlZnRTaWRlLCBpbm5lclNpZGVNb2RpZmllZCApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEpvaW4gdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWFrZUNpcmN1bGFyU2VjdG9yKCBjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIG5leHRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY3VycmVudFBvaW50LCBuZXh0UG9pbnRSLCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbWl0ZXInOlxuXHRcdFx0XHRcdFx0Y2FzZSAnbWl0ZXItY2xpcCc6XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdHZhciBtaXRlckZyYWN0aW9uID0gKCBzdHJva2VXaWR0aDIgKiBzdHlsZS5zdHJva2VNaXRlckxpbWl0ICkgLyBtaXRlckxlbmd0aDI7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtaXRlckZyYWN0aW9uIDwgMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBqb2luIG1pdGVyIGxlbmd0aCBleGNlZWRzIHRoZSBtaXRlciBsaW1pdFxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzdHlsZS5zdHJva2VMaW5lSm9pbiAhPT0gJ21pdGVyLWNsaXAnICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRtYWtlU2VnbWVudFdpdGhCZXZlbEpvaW4oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1MSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTZWdtZW50IHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIE1pdGVyLWNsaXAgam9pbiB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl82LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIGN1cnJlbnRQb2ludEwgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggY3VycmVudFBvaW50TCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNy5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBuZXh0UG9pbnRMICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIG5leHRQb2ludEwgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFYyXzYuc3ViVmVjdG9ycyggb3V0ZXJQb2ludCwgY3VycmVudFBvaW50UiApLm11bHRpcGx5U2NhbGFyKCBtaXRlckZyYWN0aW9uICkuYWRkKCBjdXJyZW50UG9pbnRSICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl83LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIG5leHRQb2ludFIgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggbmV4dFBvaW50UiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBNaXRlciBqb2luIHNlZ21lbnQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpbWl6ZWQgc2VnbWVudCArIGpvaW4gdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRQb2ludEwuY29weSggb3V0ZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5leHRQb2ludFIuY29weSggb3V0ZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFkZCBleHRyYSBtaXRlciBqb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGlzTWl0ZXIgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSB3aGVuIHR3byBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuXG5cdFx0XHRcdFx0bWFrZVNlZ21lbnRUcmlhbmdsZXMoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBnZW5lcmF0ZWQgaGVyZSBpZiBpdCBpcyB0aGUgZW5kaW5nIHNlZ21lbnRcblxuXHRcdFx0XHRtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBpc0Nsb3NlZCAmJiBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEgKSB7XG5cblx0XHRcdFx0Ly8gU3RhcnQgbGluZSBlbmRjYXBcblx0XHRcdFx0YWRkQ2FwR2VvbWV0cnkoIHBvaW50c1sgMCBdLCBwb2ludDBMLCBwb2ludDBSLCBqb2luSXNPbkxlZnRTaWRlLCB0cnVlLCB1MCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlbWVudCBsb29wIHZhcmlhYmxlc1xuXG5cdFx0XHR1MCA9IHUxO1xuXG5cdFx0XHRwcmV2aW91c1BvaW50ID0gY3VycmVudFBvaW50O1xuXG5cdFx0XHRsYXN0UG9pbnRMLmNvcHkoIG5leHRQb2ludEwgKTtcblx0XHRcdGxhc3RQb2ludFIuY29weSggbmV4dFBvaW50UiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGlzQ2xvc2VkICkge1xuXG5cdFx0XHQvLyBFbmRpbmcgbGluZSBlbmRjYXBcblx0XHRcdGFkZENhcEdlb21ldHJ5KCBjdXJyZW50UG9pbnQsIGN1cnJlbnRQb2ludEwsIGN1cnJlbnRQb2ludFIsIGpvaW5Jc09uTGVmdFNpZGUsIGZhbHNlLCB1MSApO1xuXG5cdFx0fSBlbHNlIGlmICggaW5uZXJTaWRlTW9kaWZpZWQgJiYgdmVydGljZXMgKSB7XG5cblx0XHRcdC8vIE1vZGlmeSBwYXRoIGZpcnN0IHNlZ21lbnQgdmVydGljZXMgdG8gYWRqdXN0IHRvIHRoZSBzZWdtZW50cyBpbm5lciBhbmQgb3V0ZXIgaW50ZXJzZWN0aW9uc1xuXG5cdFx0XHR2YXIgbGFzdE91dGVyID0gb3V0ZXJQb2ludDtcblx0XHRcdHZhciBsYXN0SW5uZXIgPSBpbm5lclBvaW50O1xuXG5cdFx0XHRpZiAoIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlICE9PSBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdGxhc3RPdXRlciA9IGlubmVyUG9pbnQ7XG5cdFx0XHRcdGxhc3RJbm5lciA9IG91dGVyUG9pbnQ7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdGlmICggaXNNaXRlciB8fCBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdGxhc3RJbm5lci50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cblx0XHRcdFx0XHRpZiAoIGlzTWl0ZXIgKSB7XG5cblx0XHRcdFx0XHRcdGxhc3RPdXRlci50b0FycmF5KCB2ZXJ0aWNlcywgMSAqIDMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBpc01pdGVyIHx8ICEgaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpc01pdGVyICkge1xuXG5cdFx0XHRcdFx0XHRsYXN0T3V0ZXIudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVtVmVydGljZXM7XG5cblx0XHQvLyAtLSBFbmQgb2YgYWxnb3JpdGhtXG5cblx0XHQvLyAtLSBGdW5jdGlvbnNcblxuXHRcdGZ1bmN0aW9uIGdldE5vcm1hbCggcDEsIHAyLCByZXN1bHQgKSB7XG5cblx0XHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAtIHJlc3VsdC55LCByZXN1bHQueCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBwb3NpdGlvbiwgdSwgdiApIHtcblxuXHRcdFx0aWYgKCB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0XHR2ZXJ0aWNlc1sgY3VycmVudENvb3JkaW5hdGUgXSA9IHBvc2l0aW9uLng7XG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDEgXSA9IHBvc2l0aW9uLnk7XG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDIgXSA9IDA7XG5cblx0XHRcdFx0aWYgKCBub3JtYWxzICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsc1sgY3VycmVudENvb3JkaW5hdGUgXSA9IDA7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY3VycmVudENvb3JkaW5hdGUgKyAxIF0gPSAwO1xuXHRcdFx0XHRcdG5vcm1hbHNbIGN1cnJlbnRDb29yZGluYXRlICsgMiBdID0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3VycmVudENvb3JkaW5hdGUgKz0gMztcblxuXHRcdFx0XHRpZiAoIHV2cyApIHtcblxuXHRcdFx0XHRcdHV2c1sgY3VycmVudENvb3JkaW5hdGVVViBdID0gdTtcblx0XHRcdFx0XHR1dnNbIGN1cnJlbnRDb29yZGluYXRlVVYgKyAxIF0gPSB2O1xuXG5cdFx0XHRcdFx0Y3VycmVudENvb3JkaW5hdGVVViArPSAyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRudW1WZXJ0aWNlcyArPSAzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZUNpcmN1bGFyU2VjdG9yKCBjZW50ZXIsIHAxLCBwMiwgdSwgdiApIHtcblxuXHRcdFx0Ly8gcGFyYW0gcDEsIHAyOiBQb2ludHMgaW4gdGhlIGNpcmNsZSBhcmMuXG5cdFx0XHQvLyBwMSBhbmQgcDIgYXJlIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG5cblx0XHRcdHRlbXBWMl8xLmNvcHkoIHAxICkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHRlbXBWMl8yLmNvcHkoIHAyICkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0dmFyIGFuZ2xlID0gTWF0aC5QSTtcblx0XHRcdHZhciBkb3QgPSB0ZW1wVjJfMS5kb3QoIHRlbXBWMl8yICk7XG5cdFx0XHRpZiAoIE1hdGguYWJzKCBkb3QgKSA8IDEgKSBhbmdsZSA9IE1hdGguYWJzKCBNYXRoLmFjb3MoIGRvdCApICk7XG5cblx0XHRcdGFuZ2xlIC89IGFyY0RpdmlzaW9ucztcblxuXHRcdFx0dGVtcFYyXzMuY29weSggcDEgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFyY0RpdmlzaW9ucyAtIDE7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR0ZW1wVjJfNC5jb3B5KCB0ZW1wVjJfMyApLnJvdGF0ZUFyb3VuZCggY2VudGVyLCBhbmdsZSApO1xuXG5cdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzMsIHUsIHYgKTtcblx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNCwgdSwgdiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGNlbnRlciwgdSwgMC41ICk7XG5cblx0XHRcdFx0dGVtcFYyXzMuY29weSggdGVtcFYyXzQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl80LCB1LCB2ICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIHAyLCB1LCB2ICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGNlbnRlciwgdSwgMC41ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYWtlU2VnbWVudFRyaWFuZ2xlcygpIHtcblxuXHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAxICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAwICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYWtlU2VnbWVudFdpdGhCZXZlbEpvaW4oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1ICkge1xuXG5cdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRcdC8vIE9wdGltaXplZCBzZWdtZW50ICsgYmV2ZWwgdHJpYW5nbGVzXG5cblx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0Ly8gUGF0aCBzZWdtZW50cyB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHQvLyBCZXZlbCBqb2luIHRyaWFuZ2xlXG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUsIDAuNSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBQYXRoIHNlZ21lbnRzIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdC8vIEJldmVsIGpvaW4gdHJpYW5nbGVcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdSwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEJldmVsIGpvaW4gdHJpYW5nbGUuIFRoZSBzZWdtZW50IHRyaWFuZ2xlcyBhcmUgZG9uZSBpbiB0aGUgbWFpbiBsb29wXG5cblx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUsIDAuNSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRpZiAoIGlubmVyU2lkZU1vZGlmaWVkICkge1xuXG5cdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludFIsIHUwLCAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXBHZW9tZXRyeSggY2VudGVyLCBwMSwgcDIsIGpvaW5Jc09uTGVmdFNpZGUsIHN0YXJ0LCB1ICkge1xuXG5cdFx0XHQvLyBwYXJhbSBjZW50ZXI6IEVuZCBwb2ludCBvZiB0aGUgcGF0aFxuXHRcdFx0Ly8gcGFyYW0gcDEsIHAyOiBMZWZ0IGFuZCByaWdodCBjYXAgcG9pbnRzXG5cblx0XHRcdHN3aXRjaCAoIHN0eWxlLnN0cm9rZUxpbmVDYXAgKSB7XG5cblx0XHRcdFx0Y2FzZSAncm91bmQnOlxuXG5cdFx0XHRcdFx0aWYgKCBzdGFydCApIHtcblxuXHRcdFx0XHRcdFx0bWFrZUNpcmN1bGFyU2VjdG9yKCBjZW50ZXIsIHAyLCBwMSwgdSwgMC41ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGNlbnRlciwgcDEsIHAyLCB1LCAwLjUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3NxdWFyZSc6XG5cblx0XHRcdFx0XHRpZiAoIHN0YXJ0ICkge1xuXG5cdFx0XHRcdFx0XHR0ZW1wVjJfMS5zdWJWZWN0b3JzKCBwMSwgY2VudGVyICk7XG5cdFx0XHRcdFx0XHR0ZW1wVjJfMi5zZXQoIHRlbXBWMl8xLnksIC0gdGVtcFYyXzEueCApO1xuXG5cdFx0XHRcdFx0XHR0ZW1wVjJfMy5hZGRWZWN0b3JzKCB0ZW1wVjJfMSwgdGVtcFYyXzIgKS5hZGQoIGNlbnRlciApO1xuXHRcdFx0XHRcdFx0dGVtcFYyXzQuc3ViVmVjdG9ycyggdGVtcFYyXzIsIHRlbXBWMl8xICkuYWRkKCBjZW50ZXIgKTtcblxuXHRcdFx0XHRcdFx0Ly8gTW9kaWZ5IGFscmVhZHkgZXhpc3RpbmcgdmVydGljZXNcblx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgMSAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgMyAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIDAgKiAzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8xLnN1YlZlY3RvcnMoIHAyLCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl8yLnNldCggdGVtcFYyXzEueSwgLSB0ZW1wVjJfMS54ICk7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8zLmFkZFZlY3RvcnMoIHRlbXBWMl8xLCB0ZW1wVjJfMiApLmFkZCggY2VudGVyICk7XG5cdFx0XHRcdFx0XHR0ZW1wVjJfNC5zdWJWZWN0b3JzKCB0ZW1wVjJfMiwgdGVtcFYyXzEgKS5hZGQoIGNlbnRlciApO1xuXG5cdFx0XHRcdFx0XHR2YXIgdmwgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdC8vIE1vZGlmeSBhbHJlYWR5IGV4aXN0aW5nIHZlcnRpY2VzXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIHZsIC0gMSAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gMiAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIHZsIC0gNCAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAyICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAxICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSA0ICogMyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICkge1xuXG5cdFx0XHQvLyBDcmVhdGVzIGEgbmV3IGFycmF5IGlmIG5lY2Vzc2FyeSB3aXRoIGR1cGxpY2F0ZWQgcG9pbnRzIHJlbW92ZWQuXG5cdFx0XHQvLyBUaGlzIGRvZXMgbm90IHJlbW92ZSBkdXBsaWNhdGVkIGluaXRpYWwgYW5kIGVuZGluZyBwb2ludHMgb2YgYSBjbG9zZWQgcGF0aC5cblxuXHRcdFx0dmFyIGR1cFBvaW50cyA9IGZhbHNlO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcG9pbnRzWyBpIF0uZGlzdGFuY2VUbyggcG9pbnRzWyBpICsgMSBdICkgPCBtaW5EaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGR1cFBvaW50cyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBkdXBQb2ludHMgKSByZXR1cm4gcG9pbnRzO1xuXG5cdFx0XHR2YXIgbmV3UG9pbnRzID0gW107XG5cdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggcG9pbnRzWyBpIF0uZGlzdGFuY2VUbyggcG9pbnRzWyBpICsgMSBdICkgPj0gbWluRGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0bmV3UG9pbnRzLnB1c2goIHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHRyZXR1cm4gbmV3UG9pbnRzO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0oKTtcblxuT2JqZWN0M0QuRGVmYXVsdFVwLnNldCgwLCAwLCAxKTtcbnZhciBkZWZhdWx0Q29sb3IgPSAnaG90cGluayc7XG52YXIgdHJhdmVyc2VDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZCwgb3BhY2l0eSwgc2hhZG93KSB7XG4gICAgaWYgKGNoaWxkLmlzTWVzaCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZC5tYXRlcmlhbCkpIHtcbiAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLmZvckVhY2goZnVuY3Rpb24gKG1hdCkge1xuICAgICAgICAgICAgICAgIG1hdCA9IG1hdC5jbG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5tYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gMS4wKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwuaXNNYXRlcmlhbCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQubWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuZm9yRWFjaChmdW5jdGlvbiAobWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1hdC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAnUG9pbnRMaWdodCcpIHtcbiAgICAgICAgY2hpbGQudmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEIHx8IGNoaWxkLmlzR3JvdXApIHtcbiAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQyKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKGNoaWxkMiwgb3BhY2l0eSwgc2hhZG93KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbnZhciBTVExBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihTVExMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdmFyIHNjZW5lID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbC5jbG9uZSgpOyB9LCBbbW9kZWxdKTtcbiAgICAvLyBjb25zb2xlLmxvZygnTG9hZGluZzogJylcbiAgICAvLyBjb25zb2xlLmxvZyhwcm9wcylcbiAgICAvLyB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vICAgICAvLyBzY2VuZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIC8vICAgICAvLyAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSlcbiAgICAvLyAgICAgLy8gfSlcbiAgICAvLyAgICAgc2NlbmUubmFtZSA9ICdsb2FkZWQnXG4gICAgLy8gfSlcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlLCBuYW1lOiAnbG9hZGVkJyB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBzY2VuZSwgYXR0YWNoOiBcImdlb21ldHJ5XCIgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoU3RhbmRhcmRNYXRlcmlhbFwiLCB7IGNvbG9yOiBwcm9wcy5jb2xvciA/IHByb3BzLmNvbG9yIDogZGVmYXVsdENvbG9yLCB0cmFuc3BhcmVudDogcHJvcHMub3BhY2l0eSAhPT0gMS4wID8gdHJ1ZSA6IGZhbHNlLCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5ID8gcHJvcHMub3BhY2l0eSA6IDEuMCB9KSkpO1xufTtcbnZhciBHTFRGQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoR0xURkxvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5zY2VuZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwuc2NlbmUsIG9wYWNpdHk6IHByb3BzLm9wYWNpdHksIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSkpKTtcbn07XG52YXIgQ29sbGFkYUFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKENvbGxhZGFMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdmFyIHNjZW5lID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBtb2RlbC5zY2VuZS5jbG9uZSh0cnVlKTsgfSwgW21vZGVsLnNjZW5lXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NlbmUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQ2hpbGRyZW4oY2hpbGQsIHByb3BzLm9wYWNpdHksIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2NlbmUubmFtZSA9ICdsb2FkZWQnO1xuICAgIH0sIFtzY2VuZV0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogc2NlbmUsIHBvc2l0aW9uOiBwcm9wcy50LCBzY2FsZTogcHJvcHMuc2NhbGUsIHF1YXRlcm5pb246IHByb3BzLnEgfSkpO1xufTtcbnZhciBPQkpBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtdGx1cmwgPSBwcm9wcy51cmwuc2xpY2UoMCwgcHJvcHMudXJsLmxlbmd0aCAtIDMpICsgJ210bCc7XG4gICAgdmFyIG1hdGVyaWFscyA9IHVzZUxvYWRlcihNVExMb2FkZXIsIG10bHVybCk7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKE9CSkxvYWRlciwgcHJvcHMudXJsLCBmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAgIG1hdGVyaWFscy5wcmVsb2FkKCk7XG4gICAgICAgIC8vIGxvYWRlci5zZXRNYXRlcmlhbHMobWF0ZXJpYWxzKVxuICAgIH0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKGNoaWxkLCBwcm9wcy5vcGFjaXR5LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7IHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSwgc2NhbGU6IFtwcm9wcy5zY2FsZVswXSwgcHJvcHMuc2NhbGVbMV0sIHByb3BzLnNjYWxlWzJdXSwgY2FzdFNoYWRvdzogdHJ1ZSwgcmVjZWl2ZVNoYWRvdzogdHJ1ZSB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBtb2RlbCB9KSkpO1xufTtcbnZhciBWUk1MQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoVlJNTExvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwgfSkpKTtcbn07XG52YXIgUENEQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoUENETG9hZGVyLCBwcm9wcy51cmwpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG1vZGVsLm1hdGVyaWFsLmNvbG9yID0gcHJvcHMuY29sb3JcbiAgICAgICAgLy8gICAgID8gbmV3IFRIUkVFLkNvbG9yKHByb3BzLmNvbG9yKVxuICAgICAgICAvLyAgICAgOiBuZXcgVEhSRUUuQ29sb3IoZGVmYXVsdENvbG9yKVxuICAgICAgICAvLyBtb2RlbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHByb3BzLm9wYWNpdHkgIT09IDEuMCA/IHRydWUgOiBmYWxzZVxuICAgICAgICAvLyBtb2RlbC5tYXRlcmlhbC5vcGFjaXR5ID0gcHJvcHMub3BhY2l0eSA/IHByb3BzLm9wYWNpdHkgOiAxLjBcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsIH0pKSk7XG59O1xudmFyIFBMWUFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKFBMWUxvYWRlciwgcHJvcHMudXJsKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsLCBhdHRhY2g6IFwiZ2VvbWV0cnlcIiB9KSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hTdGFuZGFyZE1hdGVyaWFsXCIsIHsgY29sb3I6IHByb3BzLmNvbG9yID8gcHJvcHMuY29sb3IgOiBkZWZhdWx0Q29sb3IsIHRyYW5zcGFyZW50OiBwcm9wcy5vcGFjaXR5ICE9PSAxLjAgPyB0cnVlIDogZmFsc2UsIG9wYWNpdHk6IHByb3BzLm9wYWNpdHkgPyBwcm9wcy5vcGFjaXR5IDogMS4wIH0pKSk7XG59O1xudmFyIEZCWEFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKEZCWExvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwgfSkpKTtcbn07XG52YXIgU1ZHU2hhcGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc2hhcGUgPSBfYS5zaGFwZSwgY29sb3IgPSBfYS5jb2xvciwgaW5kZXggPSBfYS5pbmRleCwgb3BhY2l0eSA9IF9hLm9wYWNpdHk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCBudWxsLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaExhbWJlcnRNYXRlcmlhbFwiLCB7IGF0dGFjaDogXCJtYXRlcmlhbFwiLCBjb2xvcjogY29sb3IsIHBvbHlnb25PZmZzZXQ6IHRydWUsIHBvbHlnb25PZmZzZXRGYWN0b3I6IGluZGV4ICogLTAuMSwgdHJhbnNwYXJlbnQ6IG9wYWNpdHkgIT09IDEuMCA/IHRydWUgOiBmYWxzZSwgb3BhY2l0eTogb3BhY2l0eSA/IG9wYWNpdHkgOiAxLjAgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzaGFwZUJ1ZmZlckdlb21ldHJ5XCIsIHsgYXR0YWNoOiBcImdlb21ldHJ5XCIsIGFyZ3M6IFtzaGFwZV0gfSkpKTtcbn07XG52YXIgU1ZHQXNzZXQgPSBSZWFjdF9fZGVmYXVsdC5tZW1vKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBwYXRocyA9IHVzZUxvYWRlcihTVkdMb2FkZXIsIHByb3BzLnVybCkucGF0aHM7XG4gICAgdmFyIHNoYXBlcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGF0aHMuZmxhdE1hcChmdW5jdGlvbiAocGF0aCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoXG4gICAgICAgICAgICAgICAgLnRvU2hhcGVzKHRydWUpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2hhcGUpIHsgcmV0dXJuICh7IGluZGV4OiBpbmRleCwgc2hhcGU6IHNoYXBlLCBjb2xvcjogcGF0aC5jb2xvciB9KTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtwYXRoc10pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHsgY2hpbGRyZW46IHNoYXBlcy5tYXAoZnVuY3Rpb24gKG5ld1Byb3BzLCBrZXkpIHsgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNWR1NoYXBlLCBfX2Fzc2lnbih7IGtleToga2V5LCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5IH0sIG5ld1Byb3BzKSkpOyB9KSwgc2NhbGU6IFtcbiAgICAgICAgICAgIC0wLjAxICogcHJvcHMuc2NhbGVbMF0sXG4gICAgICAgICAgICAwLjAxICogcHJvcHMuc2NhbGVbMV0sXG4gICAgICAgICAgICAwLjAxICogcHJvcHMuc2NhbGVbMl0sXG4gICAgICAgIF0sIHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSB9KSk7XG59KTtcbnZhciBMb2FkZXIgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgZXh0ID0gcHJvcHMuZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciB1cmwgPSBwcm9wcy5maWxlbmFtZTtcbiAgICB1cmwgPSBcInJldHJpZXZlL1wiICsgdXJsO1xuICAgIHN3aXRjaCAoZXh0KSB7XG4gICAgICAgIGNhc2UgJ3N0bCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTVExBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdnbHRmJzpcbiAgICAgICAgY2FzZSAnZ2xiJzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEdMVEZBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdkYWUnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sbGFkYUFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ29iaic6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChPQkpBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICd3cmwnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoVlJNTEFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ3BjZCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChQQ0RBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdwbHknOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUExZQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAnZmJ4JzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEZCWEFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ3N2Zyc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTVkdBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29sbGFkYUFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyLTIxNzNiMGM1LmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../react-swift/dist/Loader-2173b0c5.js\n");

/***/ })

}]);