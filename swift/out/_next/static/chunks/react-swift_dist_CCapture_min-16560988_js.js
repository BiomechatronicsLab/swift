/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_CCapture_min-16560988_js"],{

/***/ "../../react-swift/dist/CCapture.min-16560988.js":
/*!*******************************************************!*\
  !*** ../../react-swift/dist/CCapture.min-16560988.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": function() { return /* binding */ CCapture_min$1; }\n/* harmony export */ });\n/* harmony import */ var _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_commonjsHelpers-1c8beb5f.js */ \"../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../react-swift/node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nvar CCapture_min$2 = {exports: {}};\n\nvar tar = {exports: {}};\n\n(function (module) {\n\n  (function () {\n\n    var lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];\n\n    function clean(length) {\n      var i,\n          buffer = new Uint8Array(length);\n\n      for (i = 0; i < length; i += 1) {\n        buffer[i] = 0;\n      }\n\n      return buffer;\n    }\n\n    function extend(orig, length, addLength, multipleOf) {\n      var newSize = length + addLength,\n          buffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);\n      buffer.set(orig);\n      return buffer;\n    }\n\n    function pad(num, bytes, base) {\n      num = num.toString(base || 8);\n      return '000000000000'.substr(num.length + 12 - bytes) + num;\n    }\n\n    function stringToUint8(input, out, offset) {\n      var i, length;\n      out = out || clean(input.length);\n      offset = offset || 0;\n\n      for (i = 0, length = input.length; i < length; i += 1) {\n        out[offset] = input.charCodeAt(i);\n        offset += 1;\n      }\n\n      return out;\n    }\n\n    function uint8ToBase64(uint8) {\n      var i,\n          extraBytes = uint8.length % 3,\n          // if we have 1 byte left, pad 2 bytes\n      output = '',\n          temp,\n          length;\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n      } // go through the array every three bytes, we'll deal with trailing stuff later\n\n\n      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output += tripletToBase64(temp);\n      } // this prevents an ERR_INVALID_URL in Chrome (Firefox okay)\n\n\n      switch (output.length % 4) {\n        case 1:\n          output += '=';\n          break;\n\n        case 2:\n          output += '==';\n          break;\n      }\n\n      return output;\n    }\n\n    window.utils = {};\n    window.utils.clean = clean;\n    window.utils.pad = pad;\n    window.utils.extend = extend;\n    window.utils.stringToUint8 = stringToUint8;\n    window.utils.uint8ToBase64 = uint8ToBase64;\n  })();\n\n  (function () {\n    /*\n    struct posix_header {             // byte offset\n    char name[100];               //   0\n    char mode[8];                 // 100\n    char uid[8];                  // 108\n    char gid[8];                  // 116\n    char size[12];                // 124\n    char mtime[12];               // 136\n    char chksum[8];               // 148\n    char typeflag;                // 156\n    char linkname[100];           // 157\n    char magic[6];                // 257\n    char version[2];              // 263\n    char uname[32];               // 265\n    char gname[32];               // 297\n    char devmajor[8];             // 329\n    char devminor[8];             // 337\n    char prefix[155];             // 345\n                                    // 500\n    };\n    */\n\n    var utils = window.utils,\n        headerFormat;\n    headerFormat = [{\n      field: 'fileName',\n      length: 100\n    }, {\n      field: 'fileMode',\n      length: 8\n    }, {\n      field: 'uid',\n      length: 8\n    }, {\n      field: 'gid',\n      length: 8\n    }, {\n      field: 'fileSize',\n      length: 12\n    }, {\n      field: 'mtime',\n      length: 12\n    }, {\n      field: 'checksum',\n      length: 8\n    }, {\n      field: 'type',\n      length: 1\n    }, {\n      field: 'linkName',\n      length: 100\n    }, {\n      field: 'ustar',\n      length: 8\n    }, {\n      field: 'owner',\n      length: 32\n    }, {\n      field: 'group',\n      length: 32\n    }, {\n      field: 'majorNumber',\n      length: 8\n    }, {\n      field: 'minorNumber',\n      length: 8\n    }, {\n      field: 'filenamePrefix',\n      length: 155\n    }, {\n      field: 'padding',\n      length: 12\n    }];\n\n    function formatHeader(data, cb) {\n      var buffer = utils.clean(512),\n          offset = 0;\n      headerFormat.forEach(function (value) {\n        var str = data[value.field] || '',\n            i,\n            length;\n\n        for (i = 0, length = str.length; i < length; i += 1) {\n          buffer[offset] = str.charCodeAt(i);\n          offset += 1;\n        }\n\n        offset += value.length - i; // space it out with nulls\n      });\n\n      if (typeof cb === 'function') {\n        return cb(buffer, offset);\n      }\n\n      return buffer;\n    }\n\n    window.header = {};\n    window.header.structure = headerFormat;\n    window.header.format = formatHeader;\n  })();\n\n  (function () {\n\n    var header = window.header,\n        utils = window.utils,\n        recordSize = 512,\n        blockSize;\n\n    function Tar(recordsPerBlock) {\n      this.written = 0;\n      blockSize = (recordsPerBlock || 20) * recordSize;\n      this.out = utils.clean(blockSize);\n      this.blocks = [];\n      this.length = 0;\n    }\n\n    Tar.prototype.append = function (filepath, input, opts, callback) {\n      var data, checksum, mode, mtime, uid, gid, headerArr;\n\n      if (typeof input === 'string') {\n        input = utils.stringToUint8(input);\n      } else if (input.constructor !== Uint8Array.prototype.constructor) {\n        throw 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/)[1];\n      }\n\n      if (typeof opts === 'function') {\n        opts = {};\n      }\n\n      opts = opts || {};\n      mode = opts.mode || parseInt('777', 8) & 0xfff;\n      mtime = opts.mtime || Math.floor(+new Date() / 1000);\n      uid = opts.uid || 0;\n      gid = opts.gid || 0;\n      data = {\n        fileName: filepath,\n        fileMode: utils.pad(mode, 7),\n        uid: utils.pad(uid, 7),\n        gid: utils.pad(gid, 7),\n        fileSize: utils.pad(input.length, 11),\n        mtime: utils.pad(mtime, 11),\n        checksum: '        ',\n        type: '0',\n        // just a file\n        ustar: 'ustar  ',\n        owner: opts.owner || '',\n        group: opts.group || ''\n      }; // calculate the checksum\n\n      checksum = 0;\n      Object.keys(data).forEach(function (key) {\n        var i,\n            value = data[key],\n            length;\n\n        for (i = 0, length = value.length; i < length; i += 1) {\n          checksum += value.charCodeAt(i);\n        }\n      });\n      data.checksum = utils.pad(checksum, 6) + '\\u0000 ';\n      headerArr = header.format(data);\n      var headerLength = Math.ceil(headerArr.length / recordSize) * recordSize;\n      var inputLength = Math.ceil(input.length / recordSize) * recordSize;\n      this.blocks.push({\n        header: headerArr,\n        input: input,\n        headerLength: headerLength,\n        inputLength: inputLength\n      });\n    };\n\n    Tar.prototype.save = function () {\n      var buffers = [];\n      var chunks = [];\n      var length = 0;\n      var max = Math.pow(2, 20);\n      var chunk = [];\n      this.blocks.forEach(function (b) {\n        if (length + b.headerLength + b.inputLength > max) {\n          chunks.push({\n            blocks: chunk,\n            length: length\n          });\n          chunk = [];\n          length = 0;\n        }\n\n        chunk.push(b);\n        length += b.headerLength + b.inputLength;\n      });\n      chunks.push({\n        blocks: chunk,\n        length: length\n      });\n      chunks.forEach(function (c) {\n        var buffer = new Uint8Array(c.length);\n        var written = 0;\n        c.blocks.forEach(function (b) {\n          buffer.set(b.header, written);\n          written += b.headerLength;\n          buffer.set(b.input, written);\n          written += b.inputLength;\n        });\n        buffers.push(buffer);\n      });\n      buffers.push(new Uint8Array(2 * recordSize));\n      return new Blob(buffers, {\n        type: 'octet/stream'\n      });\n    };\n\n    Tar.prototype.clear = function () {\n      this.written = 0;\n      this.out = utils.clean(blockSize);\n    };\n\n    {\n      module.exports = Tar;\n    }\n  })();\n})(tar);\n\nvar download = {exports: {}};\n\n(function (module, exports) {\n\n  (function (root, factory) {\n    {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    }\n  })(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, function () {\n    return function download(data, strFileName, strMimeType) {\n      var self = window,\n          // this script is only for browsers anyway...\n      defaultMime = 'application/octet-stream',\n          // this default mime also triggers iframe downloads\n      mimeType = strMimeType || defaultMime,\n          payload = data,\n          url = !strFileName && !strMimeType && payload,\n          anchor = document.createElement('a'),\n          toString = function (a) {\n        return String(a);\n      },\n          myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString,\n          fileName = strFileName || 'download',\n          blob,\n          reader;\n\n      myBlob = myBlob.call ? myBlob.bind(self) : Blob;\n\n      if (String(this) === 'true') {\n        //reverse arguments, allowing download.bind(true, \"text/xml\", \"export.xml\") to act as a callback\n        payload = [payload, mimeType];\n        mimeType = payload[0];\n        payload = payload[1];\n      }\n\n      if (url && url.length < 2048) {\n        // if no filename and no mime, assume a url was passed as the only argument\n        fileName = url.split('/').pop().split('?')[0];\n        anchor.href = url; // assign href prop to temp anchor\n\n        if (anchor.href.indexOf(url) !== -1) {\n          // if the browser determines that it's a potentially valid url path:\n          var ajax = new XMLHttpRequest();\n          ajax.open('GET', url, true);\n          ajax.responseType = 'blob';\n\n          ajax.onload = function (e) {\n            download(e.target.response, fileName, defaultMime);\n          };\n\n          setTimeout(function () {\n            ajax.send();\n          }, 0); // allows setting custom ajax headers using the return:\n\n          return ajax;\n        } // end if valid url?\n\n      } // end if url?\n      //go ahead and download dataURLs right away\n\n\n      if (/^data:([\\w+-]+\\/[\\w+.-]+)?[,;]/.test(payload)) {\n        if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {\n          payload = dataUrlToBlob(payload);\n          mimeType = payload.type || defaultMime;\n        } else {\n          return navigator.msSaveBlob // IE10 can't do a[download], only Blobs:\n          ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed\n        }\n      } else {\n        //not data url, is it a string with special needs?\n        if (/([\\x80-\\xff])/.test(payload)) {\n          var i = 0,\n              tempUiArr = new Uint8Array(payload.length),\n              mx = tempUiArr.length;\n\n          for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);\n\n          payload = new myBlob([tempUiArr], {\n            type: mimeType\n          });\n        }\n      }\n\n      blob = payload instanceof myBlob ? payload : new myBlob([payload], {\n        type: mimeType\n      });\n\n      function dataUrlToBlob(strUrl) {\n        var parts = strUrl.split(/[:;,]/),\n            type = parts[1],\n            indexDecoder = strUrl.indexOf('charset') > 0 ? 3 : 2,\n            decoder = parts[indexDecoder] == 'base64' ? atob : decodeURIComponent,\n            binData = decoder(parts.pop()),\n            mx = binData.length,\n            i = 0,\n            uiArr = new Uint8Array(mx);\n\n        for (i; i < mx; ++i) uiArr[i] = binData.charCodeAt(i);\n\n        return new myBlob([uiArr], {\n          type: type\n        });\n      }\n\n      function saver(url, winMode) {\n        if ('download' in anchor) {\n          //html5 A[download]\n          anchor.href = url;\n          anchor.setAttribute('download', fileName);\n          anchor.className = 'download-js-link';\n          anchor.innerHTML = 'downloading...';\n          anchor.style.display = 'none';\n          anchor.addEventListener('click', function (e) {\n            e.stopPropagation();\n            this.removeEventListener('click', arguments.callee);\n          });\n          document.body.appendChild(anchor);\n          setTimeout(function () {\n            anchor.click();\n            document.body.removeChild(anchor);\n\n            if (winMode === true) {\n              setTimeout(function () {\n                self.URL.revokeObjectURL(anchor.href);\n              }, 250);\n            }\n          }, 66);\n          return true;\n        } // handle non-a[download] safari as best we can:\n\n\n        if (/(Version)\\/(\\d+)\\.(\\d+)(?:\\.(\\d+))?.*Safari\\//.test(navigator.userAgent)) {\n          if (/^data:/.test(url)) url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n\n          if (!window.open(url)) {\n            // popup blocked, offer direct download:\n            if (confirm('Displaying New Document\\n\\nUse Save As... to download, then click back to return to this page.')) {\n              location.href = url;\n            }\n          }\n\n          return true;\n        } //do iframe dataURL download (old ch+FF):\n\n\n        var f = document.createElement('iframe');\n        document.body.appendChild(f);\n\n        if (!winMode && /^data:/.test(url)) {\n          // force a mime that will download:\n          url = 'data:' + url.replace(/^data:([\\w\\/\\-\\+]+)/, defaultMime);\n        }\n\n        f.src = url;\n        setTimeout(function () {\n          document.body.removeChild(f);\n        }, 333);\n      } //end saver\n\n\n      if (navigator.msSaveBlob) {\n        // IE10+ : (has Blob, but not a[download] or URL)\n        return navigator.msSaveBlob(blob, fileName);\n      }\n\n      if (self.URL) {\n        // simple fast and modern way using Blob and URL:\n        saver(self.URL.createObjectURL(blob), true);\n      } else {\n        // handle non-Blob()+non-URL browsers:\n        if (typeof blob === 'string' || blob.constructor === toString) {\n          try {\n            return saver('data:' + mimeType + ';base64,' + self.btoa(blob));\n          } catch (y) {\n            return saver('data:' + mimeType + ',' + encodeURIComponent(blob));\n          }\n        } // Blob but not URL support:\n\n\n        reader = new FileReader();\n\n        reader.onload = function (e) {\n          saver(this.result);\n        };\n\n        reader.readAsDataURL(blob);\n      }\n\n      return true;\n    };\n    /* end download() */\n  });\n})(download);\n\nvar gif = {};\n\n(function (c) {\n  function a(b, d) {\n    if ({}.hasOwnProperty.call(a.cache, b)) return a.cache[b];\n    var e = a.resolve(b);\n    if (!e) throw new Error('Failed to resolve module ' + b);\n    var c = {\n      id: b,\n      require: a,\n      filename: b,\n      exports: {},\n      loaded: !1,\n      parent: d,\n      children: []\n    };\n    d && d.children.push(c);\n    var f = b.slice(0, b.lastIndexOf('/') + 1);\n    return a.cache[b] = c.exports, e.call(c.exports, c, c.exports, f, b), c.loaded = !0, a.cache[b] = c.exports;\n  }\n  a.modules = {}, a.cache = {}, a.resolve = function (b) {\n    return {}.hasOwnProperty.call(a.modules, b) ? a.modules[b] : void 0;\n  }, a.define = function (b, c) {\n    a.modules[b] = c;\n  };\n\n  var b = function (a) {\n    return a = '/', {\n      title: 'browser',\n      version: 'v0.10.26',\n      browser: !0,\n      env: {},\n      argv: [],\n      nextTick: c.setImmediate || function (a) {\n        setTimeout(a, 0);\n      },\n      cwd: function () {\n        return a;\n      },\n      chdir: function (b) {\n        a = b;\n      }\n    };\n  }();\n\n  a.define('/gif.coffee', function (d, m, l, k) {\n    function g(a, b) {\n      return {}.hasOwnProperty.call(a, b);\n    }\n\n    function j(d, b) {\n      for (var a = 0, c = b.length; a < c; ++a) if (a in b && b[a] === d) return !0;\n\n      return !1;\n    }\n\n    function i(a, b) {\n      function d() {\n        this.constructor = a;\n      }\n\n      for (var c in b) g(b, c) && (a[c] = b[c]);\n\n      return d.prototype = b.prototype, a.prototype = new d(), a.__super__ = b.prototype, a;\n    }\n\n    var h, c, f, b, e;\n    f = a('events', d).EventEmitter, h = a('/browser.coffee', d), e = function (d) {\n      function a(d) {\n        var a, b;\n        this.running = !1, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], this.setOptions(d);\n\n        for (a in c) b = c[a], null != this.options[a] ? this.options[a] : this.options[a] = b;\n      }\n\n      return i(a, d), c = {\n        workerScript: 'gif.worker.js',\n        workers: 2,\n        repeat: 0,\n        background: '#fff',\n        quality: 10,\n        width: null,\n        height: null,\n        transparent: null\n      }, b = {\n        delay: 500,\n        copy: !1\n      }, a.prototype.setOption = function (a, b) {\n        return this.options[a] = b, null != this._canvas && (a === 'width' || a === 'height') ? this._canvas[a] = b : void 0;\n      }, a.prototype.setOptions = function (b) {\n        var a, c;\n        return function (d) {\n          for (a in b) {\n            if (!g(b, a)) continue;\n            c = b[a], d.push(this.setOption(a, c));\n          }\n\n          return d;\n        }.call(this, []);\n      }, a.prototype.addFrame = function (a, d) {\n        var c, e;\n        null == d && (d = {}), c = {}, c.transparent = this.options.transparent;\n\n        for (e in b) c[e] = d[e] || b[e];\n\n        if (null != this.options.width || this.setOption('width', a.width), null != this.options.height || this.setOption('height', a.height), 'undefined' !== typeof ImageData && null != ImageData && a instanceof ImageData) c.data = a.data;else if ('undefined' !== typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && a instanceof CanvasRenderingContext2D || 'undefined' !== typeof WebGLRenderingContext && null != WebGLRenderingContext && a instanceof WebGLRenderingContext) d.copy ? c.data = this.getContextData(a) : c.context = a;else if (null != a.childNodes) d.copy ? c.data = this.getImageData(a) : c.image = a;else throw new Error('Invalid image');\n        return this.frames.push(c);\n      }, a.prototype.render = function () {\n        var a;\n        if (this.running) throw new Error('Already running');\n        if (!(null != this.options.width && null != this.options.height)) throw new Error('Width and height must be set prior to rendering');\n        this.running = !0, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = function (c) {\n          for (var b = function () {\n            var b;\n            b = [];\n\n            for (var a = 0; 0 <= this.frames.length ? a < this.frames.length : a > this.frames.length; 0 <= this.frames.length ? ++a : --a) b.push(a);\n\n            return b;\n          }.apply(this, arguments), a = 0, e = b.length; a < e; ++a) c.push(null);\n\n          return c;\n        }.call(this, []), a = this.spawnWorkers();\n\n        for (var c = function () {\n          var c;\n          c = [];\n\n          for (var b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments), b = 0, e = c.length; b < e; ++b) this.renderNextFrame();\n\n        return this.emit('start'), this.emit('progress', 0);\n      }, a.prototype.abort = function () {\n        var a;\n\n        while (!0) {\n          if (a = this.activeWorkers.shift(), !(null != a)) break;\n          console.log('killing active worker'), a.terminate();\n        }\n\n        return this.running = !1, this.emit('abort');\n      }, a.prototype.spawnWorkers = function () {\n        var a;\n        return a = Math.min(this.options.workers, this.frames.length), function () {\n          var c;\n          c = [];\n\n          for (var b = this.freeWorkers.length; this.freeWorkers.length <= a ? b < a : b > a; this.freeWorkers.length <= a ? ++b : --b) c.push(b);\n\n          return c;\n        }.apply(this, arguments).forEach(function (a) {\n          return function (c) {\n            var b;\n            return console.log('spawning worker ' + c), b = new Worker(a.options.workerScript), b.onmessage = function (a) {\n              return function (c) {\n                return a.activeWorkers.splice(a.activeWorkers.indexOf(b), 1), a.freeWorkers.push(b), a.frameFinished(c.data);\n              };\n            }(a), a.freeWorkers.push(b);\n          };\n        }(this)), a;\n      }, a.prototype.frameFinished = function (a) {\n        return console.log('frame ' + a.index + ' finished - ' + this.activeWorkers.length + ' active'), this.finishedFrames++, this.emit('progress', this.finishedFrames / this.frames.length), this.imageParts[a.index] = a, j(null, this.imageParts) ? this.renderNextFrame() : this.finishRendering();\n      }, a.prototype.finishRendering = function () {\n        var e, a, k, m, b, d, h;\n        b = 0;\n\n        for (var f = 0, j = this.imageParts.length; f < j; ++f) a = this.imageParts[f], b += (a.data.length - 1) * a.pageSize + a.cursor;\n\n        b += a.pageSize - a.cursor, console.log('rendering finished - filesize ' + Math.round(b / 1e3) + 'kb'), e = new Uint8Array(b), d = 0;\n\n        for (var g = 0, l = this.imageParts.length; g < l; ++g) {\n          a = this.imageParts[g];\n\n          for (var c = 0, i = a.data.length; c < i; ++c) h = a.data[c], k = c, e.set(h, d), k === a.data.length - 1 ? d += a.cursor : d += a.pageSize;\n        }\n\n        return m = new Blob([e], {\n          type: 'image/gif'\n        }), this.emit('finished', m, e);\n      }, a.prototype.renderNextFrame = function () {\n        var c, a, b;\n        if (this.freeWorkers.length === 0) throw new Error('No free workers');\n        return this.nextFrame >= this.frames.length ? void 0 : (c = this.frames[this.nextFrame++], b = this.freeWorkers.shift(), a = this.getTask(c), console.log('starting frame ' + (a.index + 1) + ' of ' + this.frames.length), this.activeWorkers.push(b), b.postMessage(a));\n      }, a.prototype.getContextData = function (a) {\n        return a.getImageData(0, 0, this.options.width, this.options.height).data;\n      }, a.prototype.getImageData = function (b) {\n        var a;\n        return null != this._canvas || (this._canvas = document.createElement('canvas'), this._canvas.width = this.options.width, this._canvas.height = this.options.height), a = this._canvas.getContext('2d'), a.setFill = this.options.background, a.fillRect(0, 0, this.options.width, this.options.height), a.drawImage(b, 0, 0), this.getContextData(a);\n      }, a.prototype.getTask = function (a) {\n        var c, b;\n        if (c = this.frames.indexOf(a), b = {\n          index: c,\n          last: c === this.frames.length - 1,\n          delay: a.delay,\n          transparent: a.transparent,\n          width: this.options.width,\n          height: this.options.height,\n          quality: this.options.quality,\n          repeat: this.options.repeat,\n          canTransfer: h.name === 'chrome'\n        }, null != a.data) b.data = a.data;else if (null != a.context) b.data = this.getContextData(a.context);else if (null != a.image) b.data = this.getImageData(a.image);else throw new Error('Invalid frame');\n        return b;\n      }, a;\n    }(f), d.exports = e;\n  }), a.define('/browser.coffee', function (f, g, h, i) {\n    var a, d, e, c, b;\n    c = navigator.userAgent.toLowerCase(), e = navigator.platform.toLowerCase(), b = c.match(/(opera|ie|firefox|chrome|version)[\\s\\/:]([\\w\\d\\.]+)?.*?(safari|version[\\s\\/:]([\\w\\d\\.]+)|$)/) || [null, 'unknown', 0], d = b[1] === 'ie' && document.documentMode, a = {\n      name: b[1] === 'version' ? b[3] : b[1],\n      version: d || parseFloat(b[1] === 'opera' && b[4] ? b[4] : b[2]),\n      platform: {\n        name: c.match(/ip(?:ad|od|hone)/) ? 'ios' : (c.match(/(?:webos|android)/) || e.match(/mac|win|linux/) || ['other'])[0]\n      }\n    }, a[a.name] = !0, a[a.name + parseInt(a.version, 10)] = !0, a.platform[a.platform.name] = !0, f.exports = a;\n  }), a.define('events', function (f, e, g, h) {\n    b.EventEmitter || (b.EventEmitter = function () {});\n    var a = e.EventEmitter = b.EventEmitter,\n        c = typeof Array.isArray === 'function' ? Array.isArray : function (a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n        d = 10;\n    a.prototype.setMaxListeners = function (a) {\n      this._events || (this._events = {}), this._events.maxListeners = a;\n    }, a.prototype.emit = function (f) {\n      if (f === 'error' && (!(this._events && this._events.error) || c(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error(\"Uncaught, unspecified 'error' event.\");\n      if (!this._events) return !1;\n      var a = this._events[f];\n      if (!a) return !1;\n      if (!(typeof a == 'function')) if (c(a)) {\n        var b = Array.prototype.slice.call(arguments, 1),\n            e = a.slice();\n\n        for (var d = 0, g = e.length; d < g; d++) e[d].apply(this, b);\n\n        return !0;\n      } else return !1;\n\n      switch (arguments.length) {\n        case 1:\n          a.call(this);\n          break;\n\n        case 2:\n          a.call(this, arguments[1]);\n          break;\n\n        case 3:\n          a.call(this, arguments[1], arguments[2]);\n          break;\n\n        default:\n          var b = Array.prototype.slice.call(arguments, 1);\n          a.apply(this, b);\n      }\n\n      return !0;\n    }, a.prototype.addListener = function (a, b) {\n      if ('function' !== typeof b) throw new Error('addListener only takes instances of Function');\n      if (this._events || (this._events = {}), this.emit('newListener', a, b), !this._events[a]) this._events[a] = b;else if (c(this._events[a])) {\n        if (!this._events[a].warned) {\n          var e;\n          this._events.maxListeners !== undefined ? e = this._events.maxListeners : e = d, e && e > 0 && this._events[a].length > e && (this._events[a].warned = !0, console.error('(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.', this._events[a].length), console.trace());\n        }\n\n        this._events[a].push(b);\n      } else this._events[a] = [this._events[a], b];\n      return this;\n    }, a.prototype.on = a.prototype.addListener, a.prototype.once = function (b, c) {\n      var a = this;\n      return a.on(b, function d() {\n        a.removeListener(b, d), c.apply(this, arguments);\n      }), this;\n    }, a.prototype.removeListener = function (a, d) {\n      if ('function' !== typeof d) throw new Error('removeListener only takes instances of Function');\n      if (!(this._events && this._events[a])) return this;\n      var b = this._events[a];\n\n      if (c(b)) {\n        var e = b.indexOf(d);\n        if (e < 0) return this;\n        b.splice(e, 1), b.length == 0 && delete this._events[a];\n      } else this._events[a] === d && delete this._events[a];\n\n      return this;\n    }, a.prototype.removeAllListeners = function (a) {\n      return a && this._events && this._events[a] && (this._events[a] = null), this;\n    }, a.prototype.listeners = function (a) {\n      return this._events || (this._events = {}), this._events[a] || (this._events[a] = []), c(this._events[a]) || (this._events[a] = [this._events[a]]), this._events[a];\n    };\n  }), c.GIF = a('/gif.coffee');\n}).call(_commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c, _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c); // gif.js 0.1.6 - https://github.com/jnordberg/gif.js\n\nvar webmWriter0_2_0 = {exports: {}};\n\n/**\n * A tool for presenting an ArrayBuffer as a stream for writing some simple data types.\n *\n * By Nicholas Sherlock\n *\n * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n */\n\n(function (module) {\n\n  (function () {\n    var isNodeEnviroment = 'object' !== 'undefined';\n    var isNodeEnviroment = false;\n    /**\n     * Create an ArrayBuffer of the given length and present it as a writable stream with methods\n     * for writing data in different formats.\n     */\n\n    var ArrayBufferDataStream = function (length) {\n      this.data = new Uint8Array(length);\n      this.pos = 0;\n    };\n\n    ArrayBufferDataStream.prototype.seek = function (offset) {\n      this.pos = offset;\n    };\n\n    ArrayBufferDataStream.prototype.writeBytes = function (arr) {\n      for (var i = 0; i < arr.length; i++) {\n        this.data[this.pos++] = arr[i];\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeByte = function (b) {\n      this.data[this.pos++] = b;\n    }; //Synonym:\n\n\n    ArrayBufferDataStream.prototype.writeU8 = ArrayBufferDataStream.prototype.writeByte;\n\n    ArrayBufferDataStream.prototype.writeU16BE = function (u) {\n      this.data[this.pos++] = u >> 8;\n      this.data[this.pos++] = u;\n    };\n\n    ArrayBufferDataStream.prototype.writeDoubleBE = function (d) {\n      var bytes = new Uint8Array(new Float64Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeFloatBE = function (d) {\n      var bytes = new Uint8Array(new Float32Array([d]).buffer);\n\n      for (var i = bytes.length - 1; i >= 0; i--) {\n        this.writeByte(bytes[i]);\n      }\n    };\n    /**\n     * Write an ASCII string to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeString = function (s) {\n      for (var i = 0; i < s.length; i++) {\n        this.data[this.pos++] = s.charCodeAt(i);\n      }\n    };\n    /**\n     * Write the given 32-bit integer to the stream as an EBML variable-length integer using the given byte width\n     * (use measureEBMLVarInt).\n     *\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * @param i Integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeEBMLVarIntWidth = function (i, width) {\n      switch (width) {\n        case 1:\n          this.writeU8(1 << 7 | i);\n          break;\n\n        case 2:\n          this.writeU8(1 << 6 | i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 3:\n          this.writeU8(1 << 5 | i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 4:\n          this.writeU8(1 << 4 | i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        case 5:\n          /*\n           * JavaScript converts its doubles to 32-bit integers for bitwise operations, so we need to do a\n           * division by 2^32 instead of a right-shift of 32 to retain those top 3 bits\n           */\n          this.writeU8(1 << 3 | i / 4294967296 & 0x7);\n          this.writeU8(i >> 24);\n          this.writeU8(i >> 16);\n          this.writeU8(i >> 8);\n          this.writeU8(i);\n          break;\n\n        default:\n          throw new RuntimeException('Bad EBML VINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to encode the given integer as an EBML VINT.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureEBMLVarInt = function (val) {\n      if (val < (1 << 7) - 1) {\n        /* Top bit is set, leaving 7 bits to hold the integer, but we can't store 127 because\n         * \"all bits set to one\" is a reserved value. Same thing for the other cases below:\n         */\n        return 1;\n      } else if (val < (1 << 14) - 1) {\n        return 2;\n      } else if (val < (1 << 21) - 1) {\n        return 3;\n      } else if (val < (1 << 28) - 1) {\n        return 4;\n      } else if (val < 34359738367) {\n        // 2 ^ 35 - 1 (can address 32GB)\n        return 5;\n      } else {\n        throw new RuntimeException('EBML VINT size not supported ' + val);\n      }\n    };\n\n    ArrayBufferDataStream.prototype.writeEBMLVarInt = function (i) {\n      this.writeEBMLVarIntWidth(i, this.measureEBMLVarInt(i));\n    };\n    /**\n     * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.\n     * No error checking is performed to ensure that the supplied width is correct for the integer.\n     *\n     * Omit the width parameter to have it determined automatically for you.\n     *\n     * @param u Unsigned integer to be written\n     * @param width Number of bytes to write to the stream\n     */\n\n\n    ArrayBufferDataStream.prototype.writeUnsignedIntBE = function (u, width) {\n      if (width === undefined) {\n        width = this.measureUnsignedInt(u);\n      } // Each case falls through:\n\n\n      switch (width) {\n        case 5:\n          this.writeU8(Math.floor(u / 4294967296));\n        // Need to use division to access >32 bits of floating point var\n\n        case 4:\n          this.writeU8(u >> 24);\n\n        case 3:\n          this.writeU8(u >> 16);\n\n        case 2:\n          this.writeU8(u >> 8);\n\n        case 1:\n          this.writeU8(u);\n          break;\n\n        default:\n          throw new RuntimeException('Bad UINT size ' + width);\n      }\n    };\n    /**\n     * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.\n     */\n\n\n    ArrayBufferDataStream.prototype.measureUnsignedInt = function (val) {\n      // Force to 32-bit unsigned integer\n      if (val < 1 << 8) {\n        return 1;\n      } else if (val < 1 << 16) {\n        return 2;\n      } else if (val < 1 << 24) {\n        return 3;\n      } else if (val < 4294967296) {\n        return 4;\n      } else {\n        return 5;\n      }\n    };\n    /**\n     * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.\n     */\n\n\n    ArrayBufferDataStream.prototype.getAsDataArray = function () {\n      if (this.pos < this.data.byteLength) {\n        return this.data.subarray(0, this.pos);\n      } else if (this.pos == this.data.byteLength) {\n        return this.data;\n      } else {\n        throw \"ArrayBufferDataStream's pos lies beyond end of buffer\";\n      }\n    };\n\n    window.ArrayBufferDataStream = ArrayBufferDataStream;\n    /**\n     * Allows a series of Blob-convertible objects (ArrayBuffer, Blob, String, etc) to be added to a buffer. Seeking and\n     * overwriting of blobs is allowed.\n     *\n     * You can supply a FileWriter, in which case the BlobBuffer is just used as temporary storage before it writes it\n     * through to the disk.\n     *\n     * By Nicholas Sherlock\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var BlobBuffer = function (fs) {\n      return function (destination) {\n        var buffer = [],\n            writePromise = Promise.resolve(),\n            fileWriter = null,\n            fd = null;\n\n        if (typeof FileWriter !== 'undefined' && destination instanceof FileWriter) {\n          fileWriter = destination;\n        } else if (fs && destination) {\n          fd = destination;\n        } // Current seek offset\n\n\n        this.pos = 0; // One more than the index of the highest byte ever written\n\n        this.length = 0; // Returns a promise that converts the blob to an ArrayBuffer\n\n        function readBlobAsBuffer(blob) {\n          return new Promise(function (resolve, reject) {\n            var reader = new FileReader();\n            reader.addEventListener('loadend', function () {\n              resolve(reader.result);\n            });\n            reader.readAsArrayBuffer(blob);\n          });\n        }\n\n        function convertToUint8Array(thing) {\n          return new Promise(function (resolve, reject) {\n            if (thing instanceof Uint8Array) {\n              resolve(thing);\n            } else if (thing instanceof ArrayBuffer || ArrayBuffer.isView(thing)) {\n              resolve(new Uint8Array(thing));\n            } else if (thing instanceof Blob) {\n              resolve(readBlobAsBuffer(thing).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            } else {\n              //Assume that Blob will know how to read this thing\n              resolve(readBlobAsBuffer(new Blob([thing])).then(function (buffer) {\n                return new Uint8Array(buffer);\n              }));\n            }\n          });\n        }\n\n        function measureData(data) {\n          var result = data.byteLength || data.length || data.size;\n\n          if (!Number.isInteger(result)) {\n            throw 'Failed to determine size of element';\n          }\n\n          return result;\n        }\n        /**\n         * Seek to the given absolute offset.\n         *\n         * You may not seek beyond the end of the file (this would create a hole and/or allow blocks to be written in non-\n         * sequential order, which isn't currently supported by the memory buffer backend).\n         */\n\n\n        this.seek = function (offset) {\n          if (offset < 0) {\n            throw 'Offset may not be negative';\n          }\n\n          if (isNaN(offset)) {\n            throw 'Offset may not be NaN';\n          }\n\n          if (offset > this.length) {\n            throw 'Seeking beyond the end of file is not allowed';\n          }\n\n          this.pos = offset;\n        };\n        /**\n         * Write the Blob-convertible data to the buffer at the current seek position.\n         *\n         * Note: If overwriting existing data, the write must not cross preexisting block boundaries (written data must\n         * be fully contained by the extent of a previous write).\n         */\n\n\n        this.write = function (data) {\n          var newEntry = {\n            offset: this.pos,\n            data: data,\n            length: measureData(data)\n          },\n              isAppend = newEntry.offset >= this.length;\n          this.pos += newEntry.length;\n          this.length = Math.max(this.length, this.pos); // After previous writes complete, perform our write\n\n          writePromise = writePromise.then(function () {\n            if (fd) {\n              return new Promise(function (resolve, reject) {\n                convertToUint8Array(newEntry.data).then(function (dataArray) {\n                  var totalWritten = 0,\n                      buffer = Buffer.from(dataArray.buffer),\n                      handleWriteComplete = function (err, written, buffer) {\n                    totalWritten += written;\n\n                    if (totalWritten >= buffer.length) {\n                      resolve();\n                    } else {\n                      // We still have more to write...\n                      fs.write(fd, buffer, totalWritten, buffer.length - totalWritten, newEntry.offset + totalWritten, handleWriteComplete);\n                    }\n                  };\n\n                  fs.write(fd, buffer, 0, buffer.length, newEntry.offset, handleWriteComplete);\n                });\n              });\n            } else if (fileWriter) {\n              return new Promise(function (resolve, reject) {\n                fileWriter.onwriteend = resolve;\n                fileWriter.seek(newEntry.offset);\n                fileWriter.write(new Blob([newEntry.data]));\n              });\n            } else if (!isAppend) {\n              // We might be modifying a write that was already buffered in memory.\n              // Slow linear search to find a block we might be overwriting\n              for (var i = 0; i < buffer.length; i++) {\n                var entry = buffer[i]; // If our new entry overlaps the old one in any way...\n\n                if (!(newEntry.offset + newEntry.length <= entry.offset || newEntry.offset >= entry.offset + entry.length)) {\n                  if (newEntry.offset < entry.offset || newEntry.offset + newEntry.length > entry.offset + entry.length) {\n                    throw new Error('Overwrite crosses blob boundaries');\n                  }\n\n                  if (newEntry.offset == entry.offset && newEntry.length == entry.length) {\n                    // We overwrote the entire block\n                    entry.data = newEntry.data; // We're done\n\n                    return;\n                  } else {\n                    return convertToUint8Array(entry.data).then(function (entryArray) {\n                      entry.data = entryArray;\n                      return convertToUint8Array(newEntry.data);\n                    }).then(function (newEntryArray) {\n                      newEntry.data = newEntryArray;\n                      entry.data.set(newEntry.data, newEntry.offset - entry.offset);\n                    });\n                  }\n                }\n              } // Else fall through to do a simple append, as we didn't overwrite any pre-existing blocks\n\n            }\n\n            buffer.push(newEntry);\n          });\n        };\n        /**\n         * Finish all writes to the buffer, returning a promise that signals when that is complete.\n         *\n         * If a FileWriter was not provided, the promise is resolved with a Blob that represents the completed BlobBuffer\n         * contents. You can optionally pass in a mimeType to be used for this blob.\n         *\n         * If a FileWriter was provided, the promise is resolved with null as the first argument.\n         */\n\n\n        this.complete = function (mimeType) {\n          if (fd || fileWriter) {\n            writePromise = writePromise.then(function () {\n              return null;\n            });\n          } else {\n            // After writes complete we need to merge the buffer to give to the caller\n            writePromise = writePromise.then(function () {\n              var result = [];\n\n              for (var i = 0; i < buffer.length; i++) {\n                result.push(buffer[i].data);\n              }\n\n              return new Blob(result, {\n                mimeType: mimeType\n              });\n            });\n          }\n\n          return writePromise;\n        };\n      };\n    }(isNodeEnviroment ? null : null);\n\n    window.BlobBuffer = BlobBuffer;\n    /**\n     * WebM video encoder for Google Chrome. This implementation is suitable for creating very large video files, because\n     * it can stream Blobs directly to a FileWriter without buffering the entire video in memory.\n     *\n     * When FileWriter is not available or not desired, it can buffer the video in memory as a series of Blobs which are\n     * eventually returned as one composite Blob.\n     *\n     * By Nicholas Sherlock.\n     *\n     * Based on the ideas from Whammy: https://github.com/antimatter15/whammy\n     *\n     * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL\n     */\n\n    var WebMWriter = function (ArrayBufferDataStream, BlobBuffer) {\n      function extend(base, top) {\n        var target = {};\n        [base, top].forEach(function (obj) {\n          for (var prop in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n              target[prop] = obj[prop];\n            }\n          }\n        });\n        return target;\n      }\n      /**\n       * Decode a Base64 data URL into a binary string.\n       *\n       * Returns the binary string, or false if the URL could not be decoded.\n       */\n\n\n      function decodeBase64WebPDataURL(url) {\n        if (typeof url !== 'string' || !url.match(/^data:image\\/webp;base64,/i)) {\n          return false;\n        }\n\n        return window.atob(url.substring('data:image/webp;base64,'.length));\n      }\n      /**\n       * Convert the given canvas to a WebP encoded image and return the image data as a string.\n       */\n\n\n      function renderAsWebP(canvas, quality) {\n        var frame = canvas.toDataURL('image/webp', {\n          quality: quality\n        });\n        return decodeBase64WebPDataURL(frame);\n      }\n\n      function extractKeyframeFromWebP(webP) {\n        // Assume that Chrome will generate a Simple Lossy WebP which has this header:\n        var keyframeStartIndex = webP.indexOf('VP8 ');\n\n        if (keyframeStartIndex == -1) {\n          throw 'Failed to identify beginning of keyframe in WebP image';\n        } // Skip the header and the 4 bytes that encode the length of the VP8 chunk\n\n\n        keyframeStartIndex += 'VP8 '.length + 4;\n        return webP.substring(keyframeStartIndex);\n      } // Just a little utility so we can tag values as floats for the EBML encoder's benefit\n\n\n      function EBMLFloat32(value) {\n        this.value = value;\n      }\n\n      function EBMLFloat64(value) {\n        this.value = value;\n      }\n      /**\n       * Write the given EBML object to the provided ArrayBufferStream.\n       *\n       * The buffer's first byte is at bufferFileOffset inside the video file. This is used to complete offset and\n       * dataOffset fields in each EBML structure, indicating the file offset of the first byte of the EBML element and\n       * its data payload.\n       */\n\n\n      function writeEBML(buffer, bufferFileOffset, ebml) {\n        // Is the ebml an array of sibling elements?\n        if (Array.isArray(ebml)) {\n          for (var i = 0; i < ebml.length; i++) {\n            writeEBML(buffer, bufferFileOffset, ebml[i]);\n          } // Is this some sort of raw data that we want to write directly?\n\n        } else if (typeof ebml === 'string') {\n          buffer.writeString(ebml);\n        } else if (ebml instanceof Uint8Array) {\n          buffer.writeBytes(ebml);\n        } else if (ebml.id) {\n          // We're writing an EBML element\n          ebml.offset = buffer.pos + bufferFileOffset;\n          buffer.writeUnsignedIntBE(ebml.id); // ID field\n          // Now we need to write the size field, so we must know the payload size:\n\n          if (Array.isArray(ebml.data)) {\n            // Writing an array of child elements. We won't try to measure the size of the children up-front\n            var sizePos, dataBegin, dataEnd;\n\n            if (ebml.size === -1) {\n              // Write the reserved all-one-bits marker to note that the size of this element is unknown/unbounded\n              buffer.writeByte(0xff);\n            } else {\n              sizePos = buffer.pos;\n              /* Write a dummy size field to overwrite later. 4 bytes allows an element maximum size of 256MB,\n               * which should be plenty (we don't want to have to buffer that much data in memory at one time\n               * anyway!)\n               */\n\n              buffer.writeBytes([0, 0, 0, 0]);\n            }\n\n            dataBegin = buffer.pos;\n            ebml.dataOffset = dataBegin + bufferFileOffset;\n            writeEBML(buffer, bufferFileOffset, ebml.data);\n\n            if (ebml.size !== -1) {\n              dataEnd = buffer.pos;\n              ebml.size = dataEnd - dataBegin;\n              buffer.seek(sizePos);\n              buffer.writeEBMLVarIntWidth(ebml.size, 4); // Size field\n\n              buffer.seek(dataEnd);\n            }\n          } else if (typeof ebml.data === 'string') {\n            buffer.writeEBMLVarInt(ebml.data.length); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeString(ebml.data);\n          } else if (typeof ebml.data === 'number') {\n            // Allow the caller to explicitly choose the size if they wish by supplying a size field\n            if (!ebml.size) {\n              ebml.size = buffer.measureUnsignedInt(ebml.data);\n            }\n\n            buffer.writeEBMLVarInt(ebml.size); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeUnsignedIntBE(ebml.data, ebml.size);\n          } else if (ebml.data instanceof EBMLFloat64) {\n            buffer.writeEBMLVarInt(8); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeDoubleBE(ebml.data.value);\n          } else if (ebml.data instanceof EBMLFloat32) {\n            buffer.writeEBMLVarInt(4); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeFloatBE(ebml.data.value);\n          } else if (ebml.data instanceof Uint8Array) {\n            buffer.writeEBMLVarInt(ebml.data.byteLength); // Size field\n\n            ebml.dataOffset = buffer.pos + bufferFileOffset;\n            buffer.writeBytes(ebml.data);\n          } else {\n            throw 'Bad EBML datatype ' + typeof ebml.data;\n          }\n        } else {\n          throw 'Bad EBML datatype ' + typeof ebml.data;\n        }\n      }\n\n      return function (options) {\n        var MAX_CLUSTER_DURATION_MSEC = 5000,\n            DEFAULT_TRACK_NUMBER = 1,\n            writtenHeader = false,\n            videoWidth,\n            videoHeight,\n            clusterFrameBuffer = [],\n            clusterStartTime = 0,\n            clusterDuration = 0,\n            optionDefaults = {\n          quality: 0.95,\n          // WebM image quality from 0.0 (worst) to 1.0 (best)\n          fileWriter: null,\n          // Chrome FileWriter in order to stream to a file instead of buffering to memory (optional)\n          fd: null,\n          // Node.JS file descriptor to write to instead of buffering (optional)\n          // You must supply one of:\n          frameDuration: null,\n          // Duration of frames in milliseconds\n          frameRate: null // Number of frames per second\n\n        },\n            seekPoints = {\n          Cues: {\n            id: new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]),\n            positionEBML: null\n          },\n          SegmentInfo: {\n            id: new Uint8Array([0x15, 0x49, 0xa9, 0x66]),\n            positionEBML: null\n          },\n          Tracks: {\n            id: new Uint8Array([0x16, 0x54, 0xae, 0x6b]),\n            positionEBML: null\n          }\n        },\n            ebmlSegment,\n            segmentDuration = {\n          id: 0x4489,\n          // Duration\n          data: new EBMLFloat64(0)\n        },\n            seekHead,\n            cues = [],\n            blobBuffer = new BlobBuffer(options.fileWriter || options.fd);\n\n        function fileOffsetToSegmentRelative(fileOffset) {\n          return fileOffset - ebmlSegment.dataOffset;\n        }\n        /**\n         * Create a SeekHead element with descriptors for the points in the global seekPoints array.\n         *\n         * 5 bytes of position values are reserved for each node, which lie at the offset point.positionEBML.dataOffset,\n         * to be overwritten later.\n         */\n\n\n        function createSeekHead() {\n          var seekPositionEBMLTemplate = {\n            id: 0x53ac,\n            // SeekPosition\n            size: 5,\n            // Allows for 32GB video files\n            data: 0 // We'll overwrite this when the file is complete\n\n          },\n              result = {\n            id: 0x114d9b74,\n            // SeekHead\n            data: []\n          };\n\n          for (var name in seekPoints) {\n            var seekPoint = seekPoints[name];\n            seekPoint.positionEBML = Object.create(seekPositionEBMLTemplate);\n            result.data.push({\n              id: 0x4dbb,\n              // Seek\n              data: [{\n                id: 0x53ab,\n                // SeekID\n                data: seekPoint.id\n              }, seekPoint.positionEBML]\n            });\n          }\n\n          return result;\n        }\n        /**\n         * Write the WebM file header to the stream.\n         */\n\n\n        function writeHeader() {\n          seekHead = createSeekHead();\n          var ebmlHeader = {\n            id: 0x1a45dfa3,\n            // EBML\n            data: [{\n              id: 0x4286,\n              // EBMLVersion\n              data: 1\n            }, {\n              id: 0x42f7,\n              // EBMLReadVersion\n              data: 1\n            }, {\n              id: 0x42f2,\n              // EBMLMaxIDLength\n              data: 4\n            }, {\n              id: 0x42f3,\n              // EBMLMaxSizeLength\n              data: 8\n            }, {\n              id: 0x4282,\n              // DocType\n              data: 'webm'\n            }, {\n              id: 0x4287,\n              // DocTypeVersion\n              data: 2\n            }, {\n              id: 0x4285,\n              // DocTypeReadVersion\n              data: 2\n            }]\n          },\n              segmentInfo = {\n            id: 0x1549a966,\n            // Info\n            data: [{\n              id: 0x2ad7b1,\n              // TimecodeScale\n              data: 1e6 // Times will be in miliseconds (1e6 nanoseconds per step = 1ms)\n\n            }, {\n              id: 0x4d80,\n              // MuxingApp\n              data: 'webm-writer-js'\n            }, {\n              id: 0x5741,\n              // WritingApp\n              data: 'webm-writer-js'\n            }, segmentDuration // To be filled in later\n            ]\n          },\n              tracks = {\n            id: 0x1654ae6b,\n            // Tracks\n            data: [{\n              id: 0xae,\n              // TrackEntry\n              data: [{\n                id: 0xd7,\n                // TrackNumber\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x73c5,\n                // TrackUID\n                data: DEFAULT_TRACK_NUMBER\n              }, {\n                id: 0x9c,\n                // FlagLacing\n                data: 0\n              }, {\n                id: 0x22b59c,\n                // Language\n                data: 'und'\n              }, {\n                id: 0x86,\n                // CodecID\n                data: 'V_VP8'\n              }, {\n                id: 0x258688,\n                // CodecName\n                data: 'VP8'\n              }, {\n                id: 0x83,\n                // TrackType\n                data: 1\n              }, {\n                id: 0xe0,\n                // Video\n                data: [{\n                  id: 0xb0,\n                  // PixelWidth\n                  data: videoWidth\n                }, {\n                  id: 0xba,\n                  // PixelHeight\n                  data: videoHeight\n                }]\n              }]\n            }]\n          };\n          ebmlSegment = {\n            id: 0x18538067,\n            // Segment\n            size: -1,\n            // Unbounded size\n            data: [seekHead, segmentInfo, tracks]\n          };\n          var bufferStream = new ArrayBufferDataStream(256);\n          writeEBML(bufferStream, blobBuffer.pos, [ebmlHeader, ebmlSegment]);\n          blobBuffer.write(bufferStream.getAsDataArray()); // Now we know where these top-level elements lie in the file:\n\n          seekPoints.SegmentInfo.positionEBML.data = fileOffsetToSegmentRelative(segmentInfo.offset);\n          seekPoints.Tracks.positionEBML.data = fileOffsetToSegmentRelative(tracks.offset);\n        }\n        /**\n         * Create a SimpleBlock keyframe header using these fields:\n         *     timecode    - Time of this keyframe\n         *     trackNumber - Track number from 1 to 126 (inclusive)\n         *     frame       - Raw frame data payload string\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createKeyframeBlock(keyframe) {\n          var bufferStream = new ArrayBufferDataStream(1 + 2 + 1);\n\n          if (!(keyframe.trackNumber > 0 && keyframe.trackNumber < 127)) {\n            throw 'TrackNumber must be > 0 and < 127';\n          }\n\n          bufferStream.writeEBMLVarInt(keyframe.trackNumber); // Always 1 byte since we limit the range of trackNumber\n\n          bufferStream.writeU16BE(keyframe.timecode); // Flags byte\n\n          bufferStream.writeByte(1 << 7 // Keyframe\n          );\n          return {\n            id: 0xa3,\n            // SimpleBlock\n            data: [bufferStream.getAsDataArray(), keyframe.frame]\n          };\n        }\n        /**\n         * Create a Cluster node using these fields:\n         *\n         *    timecode    - Start time for the cluster\n         *\n         * Returns an EBML element.\n         */\n\n\n        function createCluster(cluster) {\n          return {\n            id: 0x1f43b675,\n            data: [{\n              id: 0xe7,\n              // Timecode\n              data: Math.round(cluster.timecode)\n            }]\n          };\n        }\n\n        function addCuePoint(trackIndex, clusterTime, clusterFileOffset) {\n          cues.push({\n            id: 0xbb,\n            // Cue\n            data: [{\n              id: 0xb3,\n              // CueTime\n              data: clusterTime\n            }, {\n              id: 0xb7,\n              // CueTrackPositions\n              data: [{\n                id: 0xf7,\n                // CueTrack\n                data: trackIndex\n              }, {\n                id: 0xf1,\n                // CueClusterPosition\n                data: fileOffsetToSegmentRelative(clusterFileOffset)\n              }]\n            }]\n          });\n        }\n        /**\n         * Write a Cues element to the blobStream using the global `cues` array of CuePoints (use addCuePoint()).\n         * The seek entry for the Cues in the SeekHead is updated.\n         */\n\n\n        function writeCues() {\n          var ebml = {\n            id: 0x1c53bb6b,\n            data: cues\n          },\n              cuesBuffer = new ArrayBufferDataStream(16 + cues.length * 32); // Pretty crude estimate of the buffer size we'll need\n\n          writeEBML(cuesBuffer, blobBuffer.pos, ebml);\n          blobBuffer.write(cuesBuffer.getAsDataArray()); // Now we know where the Cues element has ended up, we can update the SeekHead\n\n          seekPoints.Cues.positionEBML.data = fileOffsetToSegmentRelative(ebml.offset);\n        }\n        /**\n         * Flush the frames in the current clusterFrameBuffer out to the stream as a Cluster.\n         */\n\n\n        function flushClusterFrameBuffer() {\n          if (clusterFrameBuffer.length == 0) {\n            return;\n          } // First work out how large of a buffer we need to hold the cluster data\n\n\n          var rawImageSize = 0;\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            rawImageSize += clusterFrameBuffer[i].frame.length;\n          }\n\n          var buffer = new ArrayBufferDataStream(rawImageSize + clusterFrameBuffer.length * 32),\n              // Estimate 32 bytes per SimpleBlock header\n          cluster = createCluster({\n            timecode: Math.round(clusterStartTime)\n          });\n\n          for (var i = 0; i < clusterFrameBuffer.length; i++) {\n            cluster.data.push(createKeyframeBlock(clusterFrameBuffer[i]));\n          }\n\n          writeEBML(buffer, blobBuffer.pos, cluster);\n          blobBuffer.write(buffer.getAsDataArray());\n          addCuePoint(DEFAULT_TRACK_NUMBER, Math.round(clusterStartTime), cluster.offset);\n          clusterFrameBuffer = [];\n          clusterStartTime += clusterDuration;\n          clusterDuration = 0;\n        }\n\n        function validateOptions() {\n          // Derive frameDuration setting if not already supplied\n          if (!options.frameDuration) {\n            if (options.frameRate) {\n              options.frameDuration = 1000 / options.frameRate;\n            } else {\n              throw 'Missing required frameDuration or frameRate setting';\n            }\n          }\n        }\n\n        function addFrameToCluster(frame) {\n          frame.trackNumber = DEFAULT_TRACK_NUMBER; // Frame timecodes are relative to the start of their cluster:\n\n          frame.timecode = Math.round(clusterDuration);\n          clusterFrameBuffer.push(frame);\n          clusterDuration += frame.duration;\n\n          if (clusterDuration >= MAX_CLUSTER_DURATION_MSEC) {\n            flushClusterFrameBuffer();\n          }\n        }\n        /**\n         * Rewrites the SeekHead element that was initially written to the stream with the offsets of top level elements.\n         *\n         * Call once writing is complete (so the offset of all top level elements is known).\n         */\n\n\n        function rewriteSeekHead() {\n          var seekHeadBuffer = new ArrayBufferDataStream(seekHead.size),\n              oldPos = blobBuffer.pos; // Write the rewritten SeekHead element's data payload to the stream (don't need to update the id or size)\n\n          writeEBML(seekHeadBuffer, seekHead.dataOffset, seekHead.data); // And write that through to the file\n\n          blobBuffer.seek(seekHead.dataOffset);\n          blobBuffer.write(seekHeadBuffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Rewrite the Duration field of the Segment with the newly-discovered video duration.\n         */\n\n\n        function rewriteDuration() {\n          var buffer = new ArrayBufferDataStream(8),\n              oldPos = blobBuffer.pos; // Rewrite the data payload (don't need to update the id or size)\n\n          buffer.writeDoubleBE(clusterStartTime); // And write that through to the file\n\n          blobBuffer.seek(segmentDuration.dataOffset);\n          blobBuffer.write(buffer.getAsDataArray());\n          blobBuffer.seek(oldPos);\n        }\n        /**\n         * Add a frame to the video. Currently the frame must be a Canvas element.\n         */\n\n\n        this.addFrame = function (canvas) {\n          if (writtenHeader) {\n            if (canvas.width != videoWidth || canvas.height != videoHeight) {\n              throw 'Frame size differs from previous frames';\n            }\n          } else {\n            videoWidth = canvas.width;\n            videoHeight = canvas.height;\n            writeHeader();\n            writtenHeader = true;\n          }\n\n          var webP = renderAsWebP(canvas, {\n            quality: options.quality\n          });\n\n          if (!webP) {\n            throw \"Couldn't decode WebP frame, does the browser support WebP?\";\n          }\n\n          addFrameToCluster({\n            frame: extractKeyframeFromWebP(webP),\n            duration: options.frameDuration\n          });\n        };\n        /**\n         * Finish writing the video and return a Promise to signal completion.\n         *\n         * If the destination device was memory (i.e. options.fileWriter was not supplied), the Promise is resolved with\n         * a Blob with the contents of the entire video.\n         */\n\n\n        this.complete = function () {\n          flushClusterFrameBuffer();\n          writeCues();\n          rewriteSeekHead();\n          rewriteDuration();\n          return blobBuffer.complete('video/webm');\n        };\n\n        this.getWrittenSize = function () {\n          return blobBuffer.length;\n        };\n\n        options = extend(optionDefaults, options || {});\n        validateOptions();\n      };\n    };\n\n    if (isNodeEnviroment) {\n      module.exports = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    } else {\n      window.WebMWriter = WebMWriter(ArrayBufferDataStream, BlobBuffer);\n    }\n  })();\n})(webmWriter0_2_0);\n\n(function (module, exports) {\n  !function () {\n\n    var t = void 0 !== module.exports,\n        e = t ? tar.exports : window.Tar,\n        M = t ? download.exports : window.download,\n        i = t ? gif.GIF : window.GIF,\n        n = t ? webmWriter0_2_0.exports : window.WebMWriter,\n        o = {\n      function: !0,\n      object: !0\n    };\n\n    function r(t) {\n      return t && t.Object === Object ? t : null;\n    }\n    var a = exports && !exports.nodeType ? exports : void 0,\n        s = module && !module.nodeType ? module : void 0,\n        c = s && s.exports === a ? a : void 0,\n        h = r(a && s && 'object' == typeof _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c && _commonjsHelpers_1c8beb5f_js__WEBPACK_IMPORTED_MODULE_0__.c),\n        p = r(o[typeof self] && self),\n        m = r(o[typeof window] && window),\n        d = r(o[typeof this] && this),\n        u = h || m !== (d && d.window) && m || p || d || Function('return this')();\n\n    function l(t) {\n      return String('0000000' + t).slice(-7);\n    }\n\n    'gc' in window || (window.gc = function () {}), HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n      value: function (t, e, i) {\n        for (var n = atob(this.toDataURL(e, i).split(',')[1]), o = n.length, r = new Uint8Array(o), a = 0; a < o; a++) r[a] = n.charCodeAt(a);\n\n        t(new Blob([r], {\n          type: e || 'image/png'\n        }));\n      }\n    }), function () {\n      if ('performance' in window == 0 && (window.performance = {}), Date.now = Date.now || function () {\n        return new Date().getTime();\n      }, 'now' in window.performance == 0) {\n        var t = Date.now();\n        performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), window.performance.now = function () {\n          return Date.now() - t;\n        };\n      }\n    }();\n    var W = window.Date.now();\n\n    function f(t) {\n      var i = {};\n      this.settings = t, this.on = function (t, e) {\n        i[t] = e;\n      }, this.emit = function (t) {\n        var e = i[t];\n        e && e.apply(null, Array.prototype.slice.call(arguments, 1));\n      }, this.filename = t.name || function () {\n        function t() {\n          return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);\n        }\n\n        return t() + t() + '-' + t() + '-' + t() + '-' + t() + '-' + t() + t() + t();\n      }(), this.extension = '', this.mimeType = '';\n    }\n\n    function w(t) {\n      f.call(this, t), this.extension = '.tar', this.mimeType = 'application/x-tar', this.fileExtension = '', this.baseFilename = this.filename, this.tape = null, this.count = 0, this.part = 1, this.frames = 0;\n    }\n\n    function z(t) {\n      w.call(this, t), this.type = 'image/png', this.fileExtension = '.png';\n    }\n\n    function U(t) {\n      w.call(this, t), this.type = 'image/jpeg', this.fileExtension = '.jpg', this.quality = t.quality / 100 || 0.8;\n    }\n\n    function _(t) {\n      'image/webp' !== document.createElement('canvas').toDataURL('image/webp').substr(5, 10) && console.log('WebP not supported - try another export format'), f.call(this, t), this.quality = t.quality / 100 || 0.8, this.extension = '.webm', this.mimeType = 'video/webm', this.baseFilename = this.filename, this.framerate = t.framerate, this.frames = 0, this.part = 1, this.videoWriter = new n({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    }\n\n    function H(t) {\n      f.call(this, t), t.quality = t.quality / 100 || 0.8, this.encoder = new FFMpegServer.Video(t), this.encoder.on('process', function () {\n        this.emit('process');\n      }.bind(this)), this.encoder.on('finished', function (t, e) {\n        var i = this.callback;\n        i && (this.callback = void 0, i(t, e));\n      }.bind(this)), this.encoder.on('progress', function (t) {\n        this.settings.onProgress && this.settings.onProgress(t);\n      }.bind(this)), this.encoder.on('error', function (t) {\n        alert(JSON.stringify(t, null, 2));\n      }.bind(this));\n    }\n\n    function V(t) {\n      f.call(this, t), this.framerate = this.settings.framerate, this.type = 'video/webm', this.extension = '.webm', this.stream = null, this.mediaRecorder = null, this.chunks = [];\n    }\n\n    function G(t) {\n      f.call(this, t), t.quality = 31 - (30 * t.quality / 100 || 10), t.workers = t.workers || 4, this.extension = '.gif', this.mimeType = 'image/gif', this.canvas = document.createElement('canvas'), this.ctx = this.canvas.getContext('2d'), this.sizeSet = !1, this.encoder = new i({\n        workers: t.workers,\n        quality: t.quality,\n        workerScript: t.workersPath + 'gif.worker.js'\n      }), this.encoder.on('progress', function (t) {\n        this.settings.onProgress && this.settings.onProgress(t);\n      }.bind(this)), this.encoder.on('finished', function (t) {\n        var e = this.callback;\n        e && (this.callback = void 0, e(t));\n      }.bind(this));\n    }\n\n    function y(t) {\n      var e,\n          n,\n          o,\n          r,\n          a,\n          i,\n          s,\n          c = t || {},\n          h = ([]),\n          p = [],\n          m = 0,\n          d = 0,\n          u = [],\n          l = !1,\n          f = {};\n      c.framerate = c.framerate || 60, c.motionBlurFrames = 2 * (c.motionBlurFrames || 1), e = c.verbose || !1, c.display, c.step = 1e3 / c.framerate, c.timeLimit = c.timeLimit || 0, c.frameLimit = c.frameLimit || 0, c.startTime = c.startTime || 0;\n      var w = document.createElement('div');\n      w.style.position = 'absolute', w.style.left = w.style.top = 0, w.style.backgroundColor = 'black', w.style.fontFamily = 'monospace', w.style.fontSize = '11px', w.style.padding = '5px', w.style.color = 'red', w.style.zIndex = 1e5, c.display && document.body.appendChild(w);\n      var y,\n          g,\n          v = document.createElement('canvas'),\n          b = v.getContext('2d');\n      P('Step is set to ' + c.step + 'ms');\n      var T = {\n        gif: G,\n        webm: _,\n        ffmpegserver: H,\n        png: z,\n        jpg: U,\n        'webm-mediarecorder': V\n      },\n          F = T[c.format];\n      if (!F) throw 'Error: Incorrect or missing format: Valid formats are ' + Object.keys(T).join(', ');\n\n      if ((s = new F(c)).step = i, s.on('process', R), s.on('progress', function (t) {\n        !function (t) {\n          var e = f[t];\n          e && e.apply(null, Array.prototype.slice.call(arguments, 1));\n        }('progress', t);\n      }), 'performance' in window == 0 && (window.performance = {}), Date.now = Date.now || function () {\n        return new Date().getTime();\n      }, 'now' in window.performance == 0) {\n        var x = Date.now();\n        performance.timing && performance.timing.navigationStart && (x = performance.timing.navigationStart), window.performance.now = function () {\n          return Date.now() - x;\n        };\n      }\n\n      var k = window.setTimeout,\n          S = window.setInterval,\n          D = window.clearInterval,\n          C = window.clearTimeout,\n          q = window.requestAnimationFrame,\n          j = window.Date.now,\n          I = window.performance.now,\n          O = window.Date.prototype.getTime,\n          B = [];\n\n      function E() {\n        l = !1, s.stop(), P('Capturer stop'), window.setTimeout = k, window.setInterval = S, window.clearInterval = D, window.clearTimeout = C, window.requestAnimationFrame = q, window.Date.prototype.getTime = O, window.Date.now = j, window.performance.now = I;\n      }\n\n      function L(t, e) {\n        k(t, 0, e);\n      }\n\n      function i() {\n        L(R);\n      }\n\n      function R() {\n        var t = 1e3 / c.framerate,\n            e = (m + d / c.motionBlurFrames) * t;\n        n = o + e, r = a + e, B.forEach(function (t) {\n          t._hookedTime = e / 1e3;\n        }), function () {\n          var t = m / c.framerate;\n          (c.frameLimit && m >= c.frameLimit || c.timeLimit && t >= c.timeLimit) && (E(), A());\n          var e = new Date(null);\n          e.setSeconds(t), 2 < c.motionBlurFrames ? w.textContent = 'CCapture ' + c.format + ' | ' + m + ' frames (' + d + ' inter) | ' + e.toISOString().substr(11, 8) : w.textContent = 'CCapture ' + c.format + ' | ' + m + ' frames | ' + e.toISOString().substr(11, 8);\n        }(), P('Frame: ' + m + ' ' + d);\n\n        for (var i = 0; i < h.length; i++) n >= h[i].triggerTime && (L(h[i].callback), h.splice(i, 1));\n\n        for (i = 0; i < p.length; i++) n >= p[i].triggerTime && (L(p[i].callback), p[i].triggerTime += p[i].time);\n\n        u.forEach(function (t) {\n          L(t, n - W);\n        }), u = [];\n      }\n\n      function A(t) {\n        t || (t = function (t) {\n          return M(t, s.filename + s.extension, s.mimeType), !1;\n        }), s.save(t);\n      }\n\n      function P(t) {\n        e && console.log(t);\n      }\n\n      return {\n        start: function () {\n          !function () {\n            function t() {\n              return this._hooked || (this._hooked = !0, this._hookedTime = this.currentTime || 0, this.pause(), B.push(this)), this._hookedTime + c.startTime;\n            }\n\n            P('Capturer start'), o = window.Date.now(), n = o + c.startTime, a = window.performance.now(), r = a + c.startTime, window.Date.prototype.getTime = function () {\n              return n;\n            }, window.Date.now = function () {\n              return n;\n            }, window.setTimeout = function (t, e) {\n              var i = {\n                callback: t,\n                time: e,\n                triggerTime: n + e\n              };\n              return h.push(i), P('Timeout set to ' + i.time), i;\n            }, window.clearTimeout = function (t) {\n              for (var e = 0; e < h.length; e++) h[e] != t || (h.splice(e, 1), P('Timeout cleared'));\n            }, window.setInterval = function (t, e) {\n              var i = {\n                callback: t,\n                time: e,\n                triggerTime: n + e\n              };\n              return p.push(i), P('Interval set to ' + i.time), i;\n            }, window.clearInterval = function (t) {\n              return P('clear Interval'), null;\n            }, window.requestAnimationFrame = function (t) {\n              u.push(t);\n            }, window.performance.now = function () {\n              return r;\n            };\n\n            try {\n              Object.defineProperty(HTMLVideoElement.prototype, 'currentTime', {\n                get: t\n              }), Object.defineProperty(HTMLAudioElement.prototype, 'currentTime', {\n                get: t\n              });\n            } catch (t) {\n              P(t);\n            }\n          }(), s.start(), l = !0;\n        },\n        capture: function (t) {\n          var e;\n          l && (2 < c.motionBlurFrames ? (e = t, v.width === e.width && v.height === e.height || (v.width = e.width, v.height = e.height, y = new Uint16Array(v.height * v.width * 4), b.fillStyle = '#0', b.fillRect(0, 0, v.width, v.height)), function (t) {\n            b.drawImage(t, 0, 0), g = b.getImageData(0, 0, v.width, v.height);\n\n            for (var e = 0; e < y.length; e += 4) y[e] += g.data[e], y[e + 1] += g.data[e + 1], y[e + 2] += g.data[e + 2];\n\n            d++;\n          }(t), d >= 0.5 * c.motionBlurFrames ? function () {\n            for (var t = g.data, e = 0; e < y.length; e += 4) t[e] = 2 * y[e] / c.motionBlurFrames, t[e + 1] = 2 * y[e + 1] / c.motionBlurFrames, t[e + 2] = 2 * y[e + 2] / c.motionBlurFrames;\n\n            for (b.putImageData(g, 0, 0), s.add(v), d = 0, P('Full MB Frame! ' + ++m + ' ' + n), e = 0; e < y.length; e += 4) y[e] = 0, y[e + 1] = 0, y[e + 2] = 0;\n\n            gc();\n          }() : i()) : (s.add(t), P('Full Frame! ' + ++m)));\n        },\n        stop: E,\n        save: A,\n        on: function (t, e) {\n          f[t] = e;\n        }\n      };\n    }\n    f.prototype.start = function () {}, f.prototype.stop = function () {}, f.prototype.add = function () {}, f.prototype.save = function () {}, f.prototype.dispose = function () {}, f.prototype.safeToProceed = function () {\n      return !0;\n    }, f.prototype.step = function () {\n      console.log('Step not set!');\n    }, (w.prototype = Object.create(f.prototype)).start = function () {\n      this.dispose();\n    }, w.prototype.add = function (t) {\n      var e = new FileReader();\n      e.onload = function () {\n        this.tape.append(l(this.count) + this.fileExtension, new Uint8Array(e.result)), 0 < this.settings.autoSaveTime && this.frames / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function (t) {\n          this.filename = this.baseFilename + '-part-' + l(this.part), M(t, this.filename + this.extension, this.mimeType);\n          var e = this.count;\n          this.dispose(), this.count = e + 1, this.part++, this.filename = this.baseFilename + '-part-' + l(this.part), this.frames = 0, this.step();\n        }.bind(this)) : (this.count++, this.frames++, this.step());\n      }.bind(this), e.readAsArrayBuffer(t);\n    }, w.prototype.save = function (t) {\n      t(this.tape.save());\n    }, w.prototype.dispose = function () {\n      this.tape = new e(), this.count = 0;\n    }, (z.prototype = Object.create(w.prototype)).add = function (t) {\n      t.toBlob(function (t) {\n        w.prototype.add.call(this, t);\n      }.bind(this), this.type);\n    }, (U.prototype = Object.create(w.prototype)).add = function (t) {\n      t.toBlob(function (t) {\n        w.prototype.add.call(this, t);\n      }.bind(this), this.type, this.quality);\n    }, (_.prototype = Object.create(f.prototype)).start = function (t) {\n      this.dispose();\n    }, _.prototype.add = function (t) {\n      this.videoWriter.addFrame(t), 0 < this.settings.autoSaveTime && this.frames / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function (t) {\n        this.filename = this.baseFilename + '-part-' + l(this.part), M(t, this.filename + this.extension, this.mimeType), this.dispose(), this.part++, this.filename = this.baseFilename + '-part-' + l(this.part), this.step();\n      }.bind(this)) : (this.frames++, this.step());\n    }, _.prototype.save = function (t) {\n      this.videoWriter.complete().then(t);\n    }, _.prototype.dispose = function (t) {\n      this.frames = 0, this.videoWriter = new n({\n        quality: this.quality,\n        fileWriter: null,\n        fd: null,\n        frameRate: this.framerate\n      });\n    }, (H.prototype = Object.create(f.prototype)).start = function () {\n      this.encoder.start(this.settings);\n    }, H.prototype.add = function (t) {\n      this.encoder.add(t);\n    }, H.prototype.save = function (t) {\n      this.callback = t, this.encoder.end();\n    }, H.prototype.safeToProceed = function () {\n      return this.encoder.safeToProceed();\n    }, (V.prototype = Object.create(f.prototype)).add = function (t) {\n      this.stream || (this.stream = t.captureStream(this.framerate), this.mediaRecorder = new MediaRecorder(this.stream), this.mediaRecorder.start(), this.mediaRecorder.ondataavailable = function (t) {\n        this.chunks.push(t.data);\n      }.bind(this)), this.step();\n    }, V.prototype.save = function (i) {\n      this.mediaRecorder.onstop = function (t) {\n        var e = new Blob(this.chunks, {\n          type: 'video/webm'\n        });\n        this.chunks = [], i(e);\n      }.bind(this), this.mediaRecorder.stop();\n    }, (G.prototype = Object.create(f.prototype)).add = function (t) {\n      this.sizeSet || (this.encoder.setOption('width', t.width), this.encoder.setOption('height', t.height), this.sizeSet = !0), this.canvas.width = t.width, this.canvas.height = t.height, this.ctx.drawImage(t, 0, 0), this.encoder.addFrame(this.ctx, {\n        copy: !0,\n        delay: this.settings.step\n      }), this.step();\n    }, G.prototype.save = function (t) {\n      this.callback = t, this.encoder.render();\n    }, (m || p || {}).CCapture = y, a && s ? (c && ((s.exports = y).CCapture = y), a.CCapture = y) : u.CCapture = y;\n  }();\n})(CCapture_min$2, CCapture_min$2.exports);\n\nvar CCapture_min = CCapture_min$2.exports;\n\nvar CCapture_min$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), CCapture_min$2.exports, {\n  'default': CCapture_min\n}));\n\n\n//# sourceMappingURL=CCapture.min-16560988.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvQ0NhcHR1cmUubWluLTE2NTYwOTg4LmpzPzhiZTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFFOztBQUVyRSxzQkFBc0I7O0FBRXRCLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQLHFEQUFxRCxZQUFZO0FBQ2pFO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkMsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjOztBQUV6QztBQUNBLFdBQVc7QUFDWCx1Q0FBdUMsY0FBYzs7QUFFckQsdUdBQXVHLGNBQWM7O0FBRXJIO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUMsa0NBQWtDLG1DQUFtQyxzQ0FBc0M7QUFDcEw7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSyxlQUFlO0FBQ3BCLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUU4QjtBQUMvQiIsImZpbGUiOiIuLi8uLi9yZWFjdC1zd2lmdC9kaXN0L0NDYXB0dXJlLm1pbi0xNjU2MDk4OC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY29tbW9uanNHbG9iYWwgfSBmcm9tICcuL19jb21tb25qc0hlbHBlcnMtMWM4YmViNWYuanMnO1xuXG52YXIgQ0NhcHR1cmVfbWluJDIgPSB7ZXhwb3J0czoge319O1xuXG52YXIgdGFyID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvb2t1cCA9IFsnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJysnLCAnLyddO1xuXG4gICAgZnVuY3Rpb24gY2xlYW4obGVuZ3RoKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQob3JpZywgbGVuZ3RoLCBhZGRMZW5ndGgsIG11bHRpcGxlT2YpIHtcbiAgICAgIHZhciBuZXdTaXplID0gbGVuZ3RoICsgYWRkTGVuZ3RoLFxuICAgICAgICAgIGJ1ZmZlciA9IGNsZWFuKChwYXJzZUludChuZXdTaXplIC8gbXVsdGlwbGVPZikgKyAxKSAqIG11bHRpcGxlT2YpO1xuICAgICAgYnVmZmVyLnNldChvcmlnKTtcbiAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkKG51bSwgYnl0ZXMsIGJhc2UpIHtcbiAgICAgIG51bSA9IG51bS50b1N0cmluZyhiYXNlIHx8IDgpO1xuICAgICAgcmV0dXJuICcwMDAwMDAwMDAwMDAnLnN1YnN0cihudW0ubGVuZ3RoICsgMTIgLSBieXRlcykgKyBudW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9VaW50OChpbnB1dCwgb3V0LCBvZmZzZXQpIHtcbiAgICAgIHZhciBpLCBsZW5ndGg7XG4gICAgICBvdXQgPSBvdXQgfHwgY2xlYW4oaW5wdXQubGVuZ3RoKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvdXRbb2Zmc2V0XSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLFxuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gICAgICBvdXRwdXQgPSAnJyxcbiAgICAgICAgICB0ZW1wLFxuICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICAgICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M2ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M2ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzZl0gKyBsb29rdXBbbnVtICYgMHgzZl07XG4gICAgICB9IC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgdWludDhbaSArIDJdO1xuICAgICAgICBvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApO1xuICAgICAgfSAvLyB0aGlzIHByZXZlbnRzIGFuIEVSUl9JTlZBTElEX1VSTCBpbiBDaHJvbWUgKEZpcmVmb3ggb2theSlcblxuXG4gICAgICBzd2l0Y2ggKG91dHB1dC5sZW5ndGggJSA0KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvdXRwdXQgKz0gJz0nO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBvdXRwdXQgKz0gJz09JztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICB3aW5kb3cudXRpbHMgPSB7fTtcbiAgICB3aW5kb3cudXRpbHMuY2xlYW4gPSBjbGVhbjtcbiAgICB3aW5kb3cudXRpbHMucGFkID0gcGFkO1xuICAgIHdpbmRvdy51dGlscy5leHRlbmQgPSBleHRlbmQ7XG4gICAgd2luZG93LnV0aWxzLnN0cmluZ1RvVWludDggPSBzdHJpbmdUb1VpbnQ4O1xuICAgIHdpbmRvdy51dGlscy51aW50OFRvQmFzZTY0ID0gdWludDhUb0Jhc2U2NDtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8qXG4gICAgc3RydWN0IHBvc2l4X2hlYWRlciB7ICAgICAgICAgICAgIC8vIGJ5dGUgb2Zmc2V0XG4gICAgY2hhciBuYW1lWzEwMF07ICAgICAgICAgICAgICAgLy8gICAwXG4gICAgY2hhciBtb2RlWzhdOyAgICAgICAgICAgICAgICAgLy8gMTAwXG4gICAgY2hhciB1aWRbOF07ICAgICAgICAgICAgICAgICAgLy8gMTA4XG4gICAgY2hhciBnaWRbOF07ICAgICAgICAgICAgICAgICAgLy8gMTE2XG4gICAgY2hhciBzaXplWzEyXTsgICAgICAgICAgICAgICAgLy8gMTI0XG4gICAgY2hhciBtdGltZVsxMl07ICAgICAgICAgICAgICAgLy8gMTM2XG4gICAgY2hhciBjaGtzdW1bOF07ICAgICAgICAgICAgICAgLy8gMTQ4XG4gICAgY2hhciB0eXBlZmxhZzsgICAgICAgICAgICAgICAgLy8gMTU2XG4gICAgY2hhciBsaW5rbmFtZVsxMDBdOyAgICAgICAgICAgLy8gMTU3XG4gICAgY2hhciBtYWdpY1s2XTsgICAgICAgICAgICAgICAgLy8gMjU3XG4gICAgY2hhciB2ZXJzaW9uWzJdOyAgICAgICAgICAgICAgLy8gMjYzXG4gICAgY2hhciB1bmFtZVszMl07ICAgICAgICAgICAgICAgLy8gMjY1XG4gICAgY2hhciBnbmFtZVszMl07ICAgICAgICAgICAgICAgLy8gMjk3XG4gICAgY2hhciBkZXZtYWpvcls4XTsgICAgICAgICAgICAgLy8gMzI5XG4gICAgY2hhciBkZXZtaW5vcls4XTsgICAgICAgICAgICAgLy8gMzM3XG4gICAgY2hhciBwcmVmaXhbMTU1XTsgICAgICAgICAgICAgLy8gMzQ1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA1MDBcbiAgICB9O1xuICAgICovXG5cbiAgICB2YXIgdXRpbHMgPSB3aW5kb3cudXRpbHMsXG4gICAgICAgIGhlYWRlckZvcm1hdDtcbiAgICBoZWFkZXJGb3JtYXQgPSBbe1xuICAgICAgZmllbGQ6ICdmaWxlTmFtZScsXG4gICAgICBsZW5ndGg6IDEwMFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnZmlsZU1vZGUnLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICd1aWQnLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdnaWQnLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdmaWxlU2l6ZScsXG4gICAgICBsZW5ndGg6IDEyXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdtdGltZScsXG4gICAgICBsZW5ndGg6IDEyXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdjaGVja3N1bScsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ3R5cGUnLFxuICAgICAgbGVuZ3RoOiAxXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdsaW5rTmFtZScsXG4gICAgICBsZW5ndGg6IDEwMFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAndXN0YXInLFxuICAgICAgbGVuZ3RoOiA4XG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdvd25lcicsXG4gICAgICBsZW5ndGg6IDMyXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdncm91cCcsXG4gICAgICBsZW5ndGg6IDMyXG4gICAgfSwge1xuICAgICAgZmllbGQ6ICdtYWpvck51bWJlcicsXG4gICAgICBsZW5ndGg6IDhcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ21pbm9yTnVtYmVyJyxcbiAgICAgIGxlbmd0aDogOFxuICAgIH0sIHtcbiAgICAgIGZpZWxkOiAnZmlsZW5hbWVQcmVmaXgnLFxuICAgICAgbGVuZ3RoOiAxNTVcbiAgICB9LCB7XG4gICAgICBmaWVsZDogJ3BhZGRpbmcnLFxuICAgICAgbGVuZ3RoOiAxMlxuICAgIH1dO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGRhdGEsIGNiKSB7XG4gICAgICB2YXIgYnVmZmVyID0gdXRpbHMuY2xlYW4oNTEyKSxcbiAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgaGVhZGVyRm9ybWF0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHIgPSBkYXRhW3ZhbHVlLmZpZWxkXSB8fCAnJyxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldCArPSB2YWx1ZS5sZW5ndGggLSBpOyAvLyBzcGFjZSBpdCBvdXQgd2l0aCBudWxsc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNiKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICB3aW5kb3cuaGVhZGVyID0ge307XG4gICAgd2luZG93LmhlYWRlci5zdHJ1Y3R1cmUgPSBoZWFkZXJGb3JtYXQ7XG4gICAgd2luZG93LmhlYWRlci5mb3JtYXQgPSBmb3JtYXRIZWFkZXI7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBoZWFkZXIgPSB3aW5kb3cuaGVhZGVyLFxuICAgICAgICB1dGlscyA9IHdpbmRvdy51dGlscyxcbiAgICAgICAgcmVjb3JkU2l6ZSA9IDUxMixcbiAgICAgICAgYmxvY2tTaXplO1xuXG4gICAgZnVuY3Rpb24gVGFyKHJlY29yZHNQZXJCbG9jaykge1xuICAgICAgdGhpcy53cml0dGVuID0gMDtcbiAgICAgIGJsb2NrU2l6ZSA9IChyZWNvcmRzUGVyQmxvY2sgfHwgMjApICogcmVjb3JkU2l6ZTtcbiAgICAgIHRoaXMub3V0ID0gdXRpbHMuY2xlYW4oYmxvY2tTaXplKTtcbiAgICAgIHRoaXMuYmxvY2tzID0gW107XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgVGFyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZmlsZXBhdGgsIGlucHV0LCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGRhdGEsIGNoZWNrc3VtLCBtb2RlLCBtdGltZSwgdWlkLCBnaWQsIGhlYWRlckFycjtcblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5wdXQgPSB1dGlscy5zdHJpbmdUb1VpbnQ4KGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRocm93ICdJbnZhbGlkIGlucHV0IHR5cGUuIFlvdSBnYXZlIG1lOiAnICsgaW5wdXQuY29uc3RydWN0b3IudG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb25cXHMqKFskQS1aYS16X11bMC05QS1aYS16X10qKVxccypcXCgvKVsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICBtb2RlID0gb3B0cy5tb2RlIHx8IHBhcnNlSW50KCc3NzcnLCA4KSAmIDB4ZmZmO1xuICAgICAgbXRpbWUgPSBvcHRzLm10aW1lIHx8IE1hdGguZmxvb3IoK25ldyBEYXRlKCkgLyAxMDAwKTtcbiAgICAgIHVpZCA9IG9wdHMudWlkIHx8IDA7XG4gICAgICBnaWQgPSBvcHRzLmdpZCB8fCAwO1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgZmlsZU5hbWU6IGZpbGVwYXRoLFxuICAgICAgICBmaWxlTW9kZTogdXRpbHMucGFkKG1vZGUsIDcpLFxuICAgICAgICB1aWQ6IHV0aWxzLnBhZCh1aWQsIDcpLFxuICAgICAgICBnaWQ6IHV0aWxzLnBhZChnaWQsIDcpLFxuICAgICAgICBmaWxlU2l6ZTogdXRpbHMucGFkKGlucHV0Lmxlbmd0aCwgMTEpLFxuICAgICAgICBtdGltZTogdXRpbHMucGFkKG10aW1lLCAxMSksXG4gICAgICAgIGNoZWNrc3VtOiAnICAgICAgICAnLFxuICAgICAgICB0eXBlOiAnMCcsXG4gICAgICAgIC8vIGp1c3QgYSBmaWxlXG4gICAgICAgIHVzdGFyOiAndXN0YXIgICcsXG4gICAgICAgIG93bmVyOiBvcHRzLm93bmVyIHx8ICcnLFxuICAgICAgICBncm91cDogb3B0cy5ncm91cCB8fCAnJ1xuICAgICAgfTsgLy8gY2FsY3VsYXRlIHRoZSBjaGVja3N1bVxuXG4gICAgICBjaGVja3N1bSA9IDA7XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGFba2V5XSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNoZWNrc3VtICs9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZGF0YS5jaGVja3N1bSA9IHV0aWxzLnBhZChjaGVja3N1bSwgNikgKyAnXFx1MDAwMCAnO1xuICAgICAgaGVhZGVyQXJyID0gaGVhZGVyLmZvcm1hdChkYXRhKTtcbiAgICAgIHZhciBoZWFkZXJMZW5ndGggPSBNYXRoLmNlaWwoaGVhZGVyQXJyLmxlbmd0aCAvIHJlY29yZFNpemUpICogcmVjb3JkU2l6ZTtcbiAgICAgIHZhciBpbnB1dExlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyByZWNvcmRTaXplKSAqIHJlY29yZFNpemU7XG4gICAgICB0aGlzLmJsb2Nrcy5wdXNoKHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXJBcnIsXG4gICAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgICAgaGVhZGVyTGVuZ3RoOiBoZWFkZXJMZW5ndGgsXG4gICAgICAgIGlucHV0TGVuZ3RoOiBpbnB1dExlbmd0aFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRhci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBidWZmZXJzID0gW107XG4gICAgICB2YXIgY2h1bmtzID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIHZhciBtYXggPSBNYXRoLnBvdygyLCAyMCk7XG4gICAgICB2YXIgY2h1bmsgPSBbXTtcbiAgICAgIHRoaXMuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGIuaGVhZGVyTGVuZ3RoICsgYi5pbnB1dExlbmd0aCA+IG1heCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGJsb2NrczogY2h1bmssXG4gICAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rLnB1c2goYik7XG4gICAgICAgIGxlbmd0aCArPSBiLmhlYWRlckxlbmd0aCArIGIuaW5wdXRMZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgYmxvY2tzOiBjaHVuayxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHdyaXR0ZW4gPSAwO1xuICAgICAgICBjLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgYnVmZmVyLnNldChiLmhlYWRlciwgd3JpdHRlbik7XG4gICAgICAgICAgd3JpdHRlbiArPSBiLmhlYWRlckxlbmd0aDtcbiAgICAgICAgICBidWZmZXIuc2V0KGIuaW5wdXQsIHdyaXR0ZW4pO1xuICAgICAgICAgIHdyaXR0ZW4gKz0gYi5pbnB1dExlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgfSk7XG4gICAgICBidWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoMiAqIHJlY29yZFNpemUpKTtcbiAgICAgIHJldHVybiBuZXcgQmxvYihidWZmZXJzLCB7XG4gICAgICAgIHR5cGU6ICdvY3RldC9zdHJlYW0nXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVGFyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMud3JpdHRlbiA9IDA7XG4gICAgICB0aGlzLm91dCA9IHV0aWxzLmNsZWFuKGJsb2NrU2l6ZSk7XG4gICAgfTtcblxuICAgIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gVGFyO1xuICAgIH1cbiAgfSkoKTtcbn0pKHRhcik7XG5cbnZhciBkb3dubG9hZCA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAge1xuICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkoY29tbW9uanNHbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZG93bmxvYWQoZGF0YSwgc3RyRmlsZU5hbWUsIHN0ck1pbWVUeXBlKSB7XG4gICAgICB2YXIgc2VsZiA9IHdpbmRvdyxcbiAgICAgICAgICAvLyB0aGlzIHNjcmlwdCBpcyBvbmx5IGZvciBicm93c2VycyBhbnl3YXkuLi5cbiAgICAgIGRlZmF1bHRNaW1lID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgLy8gdGhpcyBkZWZhdWx0IG1pbWUgYWxzbyB0cmlnZ2VycyBpZnJhbWUgZG93bmxvYWRzXG4gICAgICBtaW1lVHlwZSA9IHN0ck1pbWVUeXBlIHx8IGRlZmF1bHRNaW1lLFxuICAgICAgICAgIHBheWxvYWQgPSBkYXRhLFxuICAgICAgICAgIHVybCA9ICFzdHJGaWxlTmFtZSAmJiAhc3RyTWltZVR5cGUgJiYgcGF5bG9hZCxcbiAgICAgICAgICBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyksXG4gICAgICAgICAgdG9TdHJpbmcgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgICAgfSxcbiAgICAgICAgICBteUJsb2IgPSBzZWxmLkJsb2IgfHwgc2VsZi5Nb3pCbG9iIHx8IHNlbGYuV2ViS2l0QmxvYiB8fCB0b1N0cmluZyxcbiAgICAgICAgICBmaWxlTmFtZSA9IHN0ckZpbGVOYW1lIHx8ICdkb3dubG9hZCcsXG4gICAgICAgICAgYmxvYixcbiAgICAgICAgICByZWFkZXI7XG5cbiAgICAgIG15QmxvYiA9IG15QmxvYi5jYWxsID8gbXlCbG9iLmJpbmQoc2VsZikgOiBCbG9iO1xuXG4gICAgICBpZiAoU3RyaW5nKHRoaXMpID09PSAndHJ1ZScpIHtcbiAgICAgICAgLy9yZXZlcnNlIGFyZ3VtZW50cywgYWxsb3dpbmcgZG93bmxvYWQuYmluZCh0cnVlLCBcInRleHQveG1sXCIsIFwiZXhwb3J0LnhtbFwiKSB0byBhY3QgYXMgYSBjYWxsYmFja1xuICAgICAgICBwYXlsb2FkID0gW3BheWxvYWQsIG1pbWVUeXBlXTtcbiAgICAgICAgbWltZVR5cGUgPSBwYXlsb2FkWzBdO1xuICAgICAgICBwYXlsb2FkID0gcGF5bG9hZFsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVybCAmJiB1cmwubGVuZ3RoIDwgMjA0OCkge1xuICAgICAgICAvLyBpZiBubyBmaWxlbmFtZSBhbmQgbm8gbWltZSwgYXNzdW1lIGEgdXJsIHdhcyBwYXNzZWQgYXMgdGhlIG9ubHkgYXJndW1lbnRcbiAgICAgICAgZmlsZU5hbWUgPSB1cmwuc3BsaXQoJy8nKS5wb3AoKS5zcGxpdCgnPycpWzBdO1xuICAgICAgICBhbmNob3IuaHJlZiA9IHVybDsgLy8gYXNzaWduIGhyZWYgcHJvcCB0byB0ZW1wIGFuY2hvclxuXG4gICAgICAgIGlmIChhbmNob3IuaHJlZi5pbmRleE9mKHVybCkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcyB0aGF0IGl0J3MgYSBwb3RlbnRpYWxseSB2YWxpZCB1cmwgcGF0aDpcbiAgICAgICAgICB2YXIgYWpheCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIGFqYXgub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICBhamF4LnJlc3BvbnNlVHlwZSA9ICdibG9iJztcblxuICAgICAgICAgIGFqYXgub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGRvd25sb2FkKGUudGFyZ2V0LnJlc3BvbnNlLCBmaWxlTmFtZSwgZGVmYXVsdE1pbWUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFqYXguc2VuZCgpO1xuICAgICAgICAgIH0sIDApOyAvLyBhbGxvd3Mgc2V0dGluZyBjdXN0b20gYWpheCBoZWFkZXJzIHVzaW5nIHRoZSByZXR1cm46XG5cbiAgICAgICAgICByZXR1cm4gYWpheDtcbiAgICAgICAgfSAvLyBlbmQgaWYgdmFsaWQgdXJsP1xuXG4gICAgICB9IC8vIGVuZCBpZiB1cmw/XG4gICAgICAvL2dvIGFoZWFkIGFuZCBkb3dubG9hZCBkYXRhVVJMcyByaWdodCBhd2F5XG5cblxuICAgICAgaWYgKC9eZGF0YTooW1xcdystXStcXC9bXFx3Ky4tXSspP1ssO10vLnRlc3QocGF5bG9hZCkpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoID4gMTAyNCAqIDEwMjQgKiAxLjk5OSAmJiBteUJsb2IgIT09IHRvU3RyaW5nKSB7XG4gICAgICAgICAgcGF5bG9hZCA9IGRhdGFVcmxUb0Jsb2IocGF5bG9hZCk7XG4gICAgICAgICAgbWltZVR5cGUgPSBwYXlsb2FkLnR5cGUgfHwgZGVmYXVsdE1pbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tc1NhdmVCbG9iIC8vIElFMTAgY2FuJ3QgZG8gYVtkb3dubG9hZF0sIG9ubHkgQmxvYnM6XG4gICAgICAgICAgPyBuYXZpZ2F0b3IubXNTYXZlQmxvYihkYXRhVXJsVG9CbG9iKHBheWxvYWQpLCBmaWxlTmFtZSkgOiBzYXZlcihwYXlsb2FkKTsgLy8gZXZlcnlvbmUgZWxzZSBjYW4gc2F2ZSBkYXRhVVJMcyB1bi1wcm9jZXNzZWRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ub3QgZGF0YSB1cmwsIGlzIGl0IGEgc3RyaW5nIHdpdGggc3BlY2lhbCBuZWVkcz9cbiAgICAgICAgaWYgKC8oW1xceDgwLVxceGZmXSkvLnRlc3QocGF5bG9hZCkpIHtcbiAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICAgIHRlbXBVaUFyciA9IG5ldyBVaW50OEFycmF5KHBheWxvYWQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgbXggPSB0ZW1wVWlBcnIubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpOyBpIDwgbXg7ICsraSkgdGVtcFVpQXJyW2ldID0gcGF5bG9hZC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgcGF5bG9hZCA9IG5ldyBteUJsb2IoW3RlbXBVaUFycl0sIHtcbiAgICAgICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYmxvYiA9IHBheWxvYWQgaW5zdGFuY2VvZiBteUJsb2IgPyBwYXlsb2FkIDogbmV3IG15QmxvYihbcGF5bG9hZF0sIHtcbiAgICAgICAgdHlwZTogbWltZVR5cGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBkYXRhVXJsVG9CbG9iKHN0clVybCkge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHJVcmwuc3BsaXQoL1s6OyxdLyksXG4gICAgICAgICAgICB0eXBlID0gcGFydHNbMV0sXG4gICAgICAgICAgICBpbmRleERlY29kZXIgPSBzdHJVcmwuaW5kZXhPZignY2hhcnNldCcpID4gMCA/IDMgOiAyLFxuICAgICAgICAgICAgZGVjb2RlciA9IHBhcnRzW2luZGV4RGVjb2Rlcl0gPT0gJ2Jhc2U2NCcgPyBhdG9iIDogZGVjb2RlVVJJQ29tcG9uZW50LFxuICAgICAgICAgICAgYmluRGF0YSA9IGRlY29kZXIocGFydHMucG9wKCkpLFxuICAgICAgICAgICAgbXggPSBiaW5EYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgdWlBcnIgPSBuZXcgVWludDhBcnJheShteCk7XG5cbiAgICAgICAgZm9yIChpOyBpIDwgbXg7ICsraSkgdWlBcnJbaV0gPSBiaW5EYXRhLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBteUJsb2IoW3VpQXJyXSwge1xuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNhdmVyKHVybCwgd2luTW9kZSkge1xuICAgICAgICBpZiAoJ2Rvd25sb2FkJyBpbiBhbmNob3IpIHtcbiAgICAgICAgICAvL2h0bWw1IEFbZG93bmxvYWRdXG4gICAgICAgICAgYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlTmFtZSk7XG4gICAgICAgICAgYW5jaG9yLmNsYXNzTmFtZSA9ICdkb3dubG9hZC1qcy1saW5rJztcbiAgICAgICAgICBhbmNob3IuaW5uZXJIVE1MID0gJ2Rvd25sb2FkaW5nLi4uJztcbiAgICAgICAgICBhbmNob3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBhbmNob3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFuY2hvcik7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhbmNob3IuY2xpY2soKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYW5jaG9yKTtcblxuICAgICAgICAgICAgaWYgKHdpbk1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKGFuY2hvci5ocmVmKTtcbiAgICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA2Nik7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gaGFuZGxlIG5vbi1hW2Rvd25sb2FkXSBzYWZhcmkgYXMgYmVzdCB3ZSBjYW46XG5cblxuICAgICAgICBpZiAoLyhWZXJzaW9uKVxcLyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/LipTYWZhcmlcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICBpZiAoL15kYXRhOi8udGVzdCh1cmwpKSB1cmwgPSAnZGF0YTonICsgdXJsLnJlcGxhY2UoL15kYXRhOihbXFx3XFwvXFwtXFwrXSspLywgZGVmYXVsdE1pbWUpO1xuXG4gICAgICAgICAgaWYgKCF3aW5kb3cub3Blbih1cmwpKSB7XG4gICAgICAgICAgICAvLyBwb3B1cCBibG9ja2VkLCBvZmZlciBkaXJlY3QgZG93bmxvYWQ6XG4gICAgICAgICAgICBpZiAoY29uZmlybSgnRGlzcGxheWluZyBOZXcgRG9jdW1lbnRcXG5cXG5Vc2UgU2F2ZSBBcy4uLiB0byBkb3dubG9hZCwgdGhlbiBjbGljayBiYWNrIHRvIHJldHVybiB0byB0aGlzIHBhZ2UuJykpIHtcbiAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvL2RvIGlmcmFtZSBkYXRhVVJMIGRvd25sb2FkIChvbGQgY2grRkYpOlxuXG5cbiAgICAgICAgdmFyIGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmKTtcblxuICAgICAgICBpZiAoIXdpbk1vZGUgJiYgL15kYXRhOi8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgLy8gZm9yY2UgYSBtaW1lIHRoYXQgd2lsbCBkb3dubG9hZDpcbiAgICAgICAgICB1cmwgPSAnZGF0YTonICsgdXJsLnJlcGxhY2UoL15kYXRhOihbXFx3XFwvXFwtXFwrXSspLywgZGVmYXVsdE1pbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZi5zcmMgPSB1cmw7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZik7XG4gICAgICAgIH0sIDMzMyk7XG4gICAgICB9IC8vZW5kIHNhdmVyXG5cblxuICAgICAgaWYgKG5hdmlnYXRvci5tc1NhdmVCbG9iKSB7XG4gICAgICAgIC8vIElFMTArIDogKGhhcyBCbG9iLCBidXQgbm90IGFbZG93bmxvYWRdIG9yIFVSTClcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuVVJMKSB7XG4gICAgICAgIC8vIHNpbXBsZSBmYXN0IGFuZCBtb2Rlcm4gd2F5IHVzaW5nIEJsb2IgYW5kIFVSTDpcbiAgICAgICAgc2F2ZXIoc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBub24tQmxvYigpK25vbi1VUkwgYnJvd3NlcnM6XG4gICAgICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycgfHwgYmxvYi5jb25zdHJ1Y3RvciA9PT0gdG9TdHJpbmcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNhdmVyKCdkYXRhOicgKyBtaW1lVHlwZSArICc7YmFzZTY0LCcgKyBzZWxmLmJ0b2EoYmxvYikpO1xuICAgICAgICAgIH0gY2F0Y2ggKHkpIHtcbiAgICAgICAgICAgIHJldHVybiBzYXZlcignZGF0YTonICsgbWltZVR5cGUgKyAnLCcgKyBlbmNvZGVVUklDb21wb25lbnQoYmxvYikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBCbG9iIGJ1dCBub3QgVVJMIHN1cHBvcnQ6XG5cblxuICAgICAgICByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHNhdmVyKHRoaXMucmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKiBlbmQgZG93bmxvYWQoKSAqL1xuICB9KTtcbn0pKGRvd25sb2FkKTtcblxudmFyIGdpZiA9IHt9O1xuXG4oZnVuY3Rpb24gKGMpIHtcbiAgZnVuY3Rpb24gYShiLCBkKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoYS5jYWNoZSwgYikpIHJldHVybiBhLmNhY2hlW2JdO1xuICAgIHZhciBlID0gYS5yZXNvbHZlKGIpO1xuICAgIGlmICghZSkgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBtb2R1bGUgJyArIGIpO1xuICAgIHZhciBjID0ge1xuICAgICAgaWQ6IGIsXG4gICAgICByZXF1aXJlOiBhLFxuICAgICAgZmlsZW5hbWU6IGIsXG4gICAgICBleHBvcnRzOiB7fSxcbiAgICAgIGxvYWRlZDogITEsXG4gICAgICBwYXJlbnQ6IGQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGQgJiYgZC5jaGlsZHJlbi5wdXNoKGMpO1xuICAgIHZhciBmID0gYi5zbGljZSgwLCBiLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICByZXR1cm4gYS5jYWNoZVtiXSA9IGMuZXhwb3J0cywgZS5jYWxsKGMuZXhwb3J0cywgYywgYy5leHBvcnRzLCBmLCBiKSwgYy5sb2FkZWQgPSAhMCwgYS5jYWNoZVtiXSA9IGMuZXhwb3J0cztcbiAgfVxuICBhLm1vZHVsZXMgPSB7fSwgYS5jYWNoZSA9IHt9LCBhLnJlc29sdmUgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEubW9kdWxlcywgYikgPyBhLm1vZHVsZXNbYl0gOiB2b2lkIDA7XG4gIH0sIGEuZGVmaW5lID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICBhLm1vZHVsZXNbYl0gPSBjO1xuICB9O1xuXG4gIHZhciBiID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYSA9ICcvJywge1xuICAgICAgdGl0bGU6ICdicm93c2VyJyxcbiAgICAgIHZlcnNpb246ICd2MC4xMC4yNicsXG4gICAgICBicm93c2VyOiAhMCxcbiAgICAgIGVudjoge30sXG4gICAgICBhcmd2OiBbXSxcbiAgICAgIG5leHRUaWNrOiBjLnNldEltbWVkaWF0ZSB8fCBmdW5jdGlvbiAoYSkge1xuICAgICAgICBzZXRUaW1lb3V0KGEsIDApO1xuICAgICAgfSxcbiAgICAgIGN3ZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0sXG4gICAgICBjaGRpcjogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIGEuZGVmaW5lKCcvZ2lmLmNvZmZlZScsIGZ1bmN0aW9uIChkLCBtLCBsLCBrKSB7XG4gICAgZnVuY3Rpb24gZyhhLCBiKSB7XG4gICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBqKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIGEgPSAwLCBjID0gYi5sZW5ndGg7IGEgPCBjOyArK2EpIGlmIChhIGluIGIgJiYgYlthXSA9PT0gZCkgcmV0dXJuICEwO1xuXG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaShhLCBiKSB7XG4gICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYyBpbiBiKSBnKGIsIGMpICYmIChhW2NdID0gYltjXSk7XG5cbiAgICAgIHJldHVybiBkLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBhLnByb3RvdHlwZSA9IG5ldyBkKCksIGEuX19zdXBlcl9fID0gYi5wcm90b3R5cGUsIGE7XG4gICAgfVxuXG4gICAgdmFyIGgsIGMsIGYsIGIsIGU7XG4gICAgZiA9IGEoJ2V2ZW50cycsIGQpLkV2ZW50RW1pdHRlciwgaCA9IGEoJy9icm93c2VyLmNvZmZlZScsIGQpLCBlID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgIGZ1bmN0aW9uIGEoZCkge1xuICAgICAgICB2YXIgYSwgYjtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gITEsIHRoaXMub3B0aW9ucyA9IHt9LCB0aGlzLmZyYW1lcyA9IFtdLCB0aGlzLmZyZWVXb3JrZXJzID0gW10sIHRoaXMuYWN0aXZlV29ya2VycyA9IFtdLCB0aGlzLnNldE9wdGlvbnMoZCk7XG5cbiAgICAgICAgZm9yIChhIGluIGMpIGIgPSBjW2FdLCBudWxsICE9IHRoaXMub3B0aW9uc1thXSA/IHRoaXMub3B0aW9uc1thXSA6IHRoaXMub3B0aW9uc1thXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpKGEsIGQpLCBjID0ge1xuICAgICAgICB3b3JrZXJTY3JpcHQ6ICdnaWYud29ya2VyLmpzJyxcbiAgICAgICAgd29ya2VyczogMixcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgIHF1YWxpdHk6IDEwLFxuICAgICAgICB3aWR0aDogbnVsbCxcbiAgICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgICB0cmFuc3BhcmVudDogbnVsbFxuICAgICAgfSwgYiA9IHtcbiAgICAgICAgZGVsYXk6IDUwMCxcbiAgICAgICAgY29weTogITFcbiAgICAgIH0sIGEucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbYV0gPSBiLCBudWxsICE9IHRoaXMuX2NhbnZhcyAmJiAoYSA9PT0gJ3dpZHRoJyB8fCBhID09PSAnaGVpZ2h0JykgPyB0aGlzLl9jYW52YXNbYV0gPSBiIDogdm9pZCAwO1xuICAgICAgfSwgYS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhLCBjO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBmb3IgKGEgaW4gYikge1xuICAgICAgICAgICAgaWYgKCFnKGIsIGEpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGMgPSBiW2FdLCBkLnB1c2godGhpcy5zZXRPcHRpb24oYSwgYykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9LmNhbGwodGhpcywgW10pO1xuICAgICAgfSwgYS5wcm90b3R5cGUuYWRkRnJhbWUgPSBmdW5jdGlvbiAoYSwgZCkge1xuICAgICAgICB2YXIgYywgZTtcbiAgICAgICAgbnVsbCA9PSBkICYmIChkID0ge30pLCBjID0ge30sIGMudHJhbnNwYXJlbnQgPSB0aGlzLm9wdGlvbnMudHJhbnNwYXJlbnQ7XG5cbiAgICAgICAgZm9yIChlIGluIGIpIGNbZV0gPSBkW2VdIHx8IGJbZV07XG5cbiAgICAgICAgaWYgKG51bGwgIT0gdGhpcy5vcHRpb25zLndpZHRoIHx8IHRoaXMuc2V0T3B0aW9uKCd3aWR0aCcsIGEud2lkdGgpLCBudWxsICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5zZXRPcHRpb24oJ2hlaWdodCcsIGEuaGVpZ2h0KSwgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBJbWFnZURhdGEgJiYgbnVsbCAhPSBJbWFnZURhdGEgJiYgYSBpbnN0YW5jZW9mIEltYWdlRGF0YSkgYy5kYXRhID0gYS5kYXRhO2Vsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmIG51bGwgIT0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICYmIGEgaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfHwgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgbnVsbCAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgYSBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkgZC5jb3B5ID8gYy5kYXRhID0gdGhpcy5nZXRDb250ZXh0RGF0YShhKSA6IGMuY29udGV4dCA9IGE7ZWxzZSBpZiAobnVsbCAhPSBhLmNoaWxkTm9kZXMpIGQuY29weSA/IGMuZGF0YSA9IHRoaXMuZ2V0SW1hZ2VEYXRhKGEpIDogYy5pbWFnZSA9IGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW1hZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhbWVzLnB1c2goYyk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcnVubmluZycpO1xuICAgICAgICBpZiAoIShudWxsICE9IHRoaXMub3B0aW9ucy53aWR0aCAmJiBudWxsICE9IHRoaXMub3B0aW9ucy5oZWlnaHQpKSB0aHJvdyBuZXcgRXJyb3IoJ1dpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBzZXQgcHJpb3IgdG8gcmVuZGVyaW5nJyk7XG4gICAgICAgIHRoaXMucnVubmluZyA9ICEwLCB0aGlzLm5leHRGcmFtZSA9IDAsIHRoaXMuZmluaXNoZWRGcmFtZXMgPSAwLCB0aGlzLmltYWdlUGFydHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGZvciAodmFyIGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIGIgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IDAgPD0gdGhpcy5mcmFtZXMubGVuZ3RoID8gYSA8IHRoaXMuZnJhbWVzLmxlbmd0aCA6IGEgPiB0aGlzLmZyYW1lcy5sZW5ndGg7IDAgPD0gdGhpcy5mcmFtZXMubGVuZ3RoID8gKythIDogLS1hKSBiLnB1c2goYSk7XG5cbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYSA9IDAsIGUgPSBiLmxlbmd0aDsgYSA8IGU7ICsrYSkgYy5wdXNoKG51bGwpO1xuXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0uY2FsbCh0aGlzLCBbXSksIGEgPSB0aGlzLnNwYXduV29ya2VycygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgYyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYiA9IDA7IDAgPD0gYSA/IGIgPCBhIDogYiA+IGE7IDAgPD0gYSA/ICsrYiA6IC0tYikgYy5wdXNoKGIpO1xuXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYiA9IDAsIGUgPSBjLmxlbmd0aDsgYiA8IGU7ICsrYikgdGhpcy5yZW5kZXJOZXh0RnJhbWUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdzdGFydCcpLCB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgMCk7XG4gICAgICB9LCBhLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG5cbiAgICAgICAgd2hpbGUgKCEwKSB7XG4gICAgICAgICAgaWYgKGEgPSB0aGlzLmFjdGl2ZVdvcmtlcnMuc2hpZnQoKSwgIShudWxsICE9IGEpKSBicmVhaztcbiAgICAgICAgICBjb25zb2xlLmxvZygna2lsbGluZyBhY3RpdmUgd29ya2VyJyksIGEudGVybWluYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ydW5uaW5nID0gITEsIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLnNwYXduV29ya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHJldHVybiBhID0gTWF0aC5taW4odGhpcy5vcHRpb25zLndvcmtlcnMsIHRoaXMuZnJhbWVzLmxlbmd0aCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBjID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBiID0gdGhpcy5mcmVlV29ya2Vycy5sZW5ndGg7IHRoaXMuZnJlZVdvcmtlcnMubGVuZ3RoIDw9IGEgPyBiIDwgYSA6IGIgPiBhOyB0aGlzLmZyZWVXb3JrZXJzLmxlbmd0aCA8PSBhID8gKytiIDogLS1iKSBjLnB1c2goYik7XG5cbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciBiO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdzcGF3bmluZyB3b3JrZXIgJyArIGMpLCBiID0gbmV3IFdvcmtlcihhLm9wdGlvbnMud29ya2VyU2NyaXB0KSwgYi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5hY3RpdmVXb3JrZXJzLnNwbGljZShhLmFjdGl2ZVdvcmtlcnMuaW5kZXhPZihiKSwgMSksIGEuZnJlZVdvcmtlcnMucHVzaChiKSwgYS5mcmFtZUZpbmlzaGVkKGMuZGF0YSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KGEpLCBhLmZyZWVXb3JrZXJzLnB1c2goYik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSh0aGlzKSksIGE7XG4gICAgICB9LCBhLnByb3RvdHlwZS5mcmFtZUZpbmlzaGVkID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCdmcmFtZSAnICsgYS5pbmRleCArICcgZmluaXNoZWQgLSAnICsgdGhpcy5hY3RpdmVXb3JrZXJzLmxlbmd0aCArICcgYWN0aXZlJyksIHRoaXMuZmluaXNoZWRGcmFtZXMrKywgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuZmluaXNoZWRGcmFtZXMgLyB0aGlzLmZyYW1lcy5sZW5ndGgpLCB0aGlzLmltYWdlUGFydHNbYS5pbmRleF0gPSBhLCBqKG51bGwsIHRoaXMuaW1hZ2VQYXJ0cykgPyB0aGlzLnJlbmRlck5leHRGcmFtZSgpIDogdGhpcy5maW5pc2hSZW5kZXJpbmcoKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmZpbmlzaFJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGUsIGEsIGssIG0sIGIsIGQsIGg7XG4gICAgICAgIGIgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGYgPSAwLCBqID0gdGhpcy5pbWFnZVBhcnRzLmxlbmd0aDsgZiA8IGo7ICsrZikgYSA9IHRoaXMuaW1hZ2VQYXJ0c1tmXSwgYiArPSAoYS5kYXRhLmxlbmd0aCAtIDEpICogYS5wYWdlU2l6ZSArIGEuY3Vyc29yO1xuXG4gICAgICAgIGIgKz0gYS5wYWdlU2l6ZSAtIGEuY3Vyc29yLCBjb25zb2xlLmxvZygncmVuZGVyaW5nIGZpbmlzaGVkIC0gZmlsZXNpemUgJyArIE1hdGgucm91bmQoYiAvIDFlMykgKyAna2InKSwgZSA9IG5ldyBVaW50OEFycmF5KGIpLCBkID0gMDtcblxuICAgICAgICBmb3IgKHZhciBnID0gMCwgbCA9IHRoaXMuaW1hZ2VQYXJ0cy5sZW5ndGg7IGcgPCBsOyArK2cpIHtcbiAgICAgICAgICBhID0gdGhpcy5pbWFnZVBhcnRzW2ddO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDAsIGkgPSBhLmRhdGEubGVuZ3RoOyBjIDwgaTsgKytjKSBoID0gYS5kYXRhW2NdLCBrID0gYywgZS5zZXQoaCwgZCksIGsgPT09IGEuZGF0YS5sZW5ndGggLSAxID8gZCArPSBhLmN1cnNvciA6IGQgKz0gYS5wYWdlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtID0gbmV3IEJsb2IoW2VdLCB7XG4gICAgICAgICAgdHlwZTogJ2ltYWdlL2dpZidcbiAgICAgICAgfSksIHRoaXMuZW1pdCgnZmluaXNoZWQnLCBtLCBlKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLnJlbmRlck5leHRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGMsIGEsIGI7XG4gICAgICAgIGlmICh0aGlzLmZyZWVXb3JrZXJzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdObyBmcmVlIHdvcmtlcnMnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEZyYW1lID49IHRoaXMuZnJhbWVzLmxlbmd0aCA/IHZvaWQgMCA6IChjID0gdGhpcy5mcmFtZXNbdGhpcy5uZXh0RnJhbWUrK10sIGIgPSB0aGlzLmZyZWVXb3JrZXJzLnNoaWZ0KCksIGEgPSB0aGlzLmdldFRhc2soYyksIGNvbnNvbGUubG9nKCdzdGFydGluZyBmcmFtZSAnICsgKGEuaW5kZXggKyAxKSArICcgb2YgJyArIHRoaXMuZnJhbWVzLmxlbmd0aCksIHRoaXMuYWN0aXZlV29ya2Vycy5wdXNoKGIpLCBiLnBvc3RNZXNzYWdlKGEpKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldENvbnRleHREYXRhID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCkuZGF0YTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICByZXR1cm4gbnVsbCAhPSB0aGlzLl9jYW52YXMgfHwgKHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLCB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0KSwgYSA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCBhLnNldEZpbGwgPSB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZCwgYS5maWxsUmVjdCgwLCAwLCB0aGlzLm9wdGlvbnMud2lkdGgsIHRoaXMub3B0aW9ucy5oZWlnaHQpLCBhLmRyYXdJbWFnZShiLCAwLCAwKSwgdGhpcy5nZXRDb250ZXh0RGF0YShhKTtcbiAgICAgIH0sIGEucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYywgYjtcbiAgICAgICAgaWYgKGMgPSB0aGlzLmZyYW1lcy5pbmRleE9mKGEpLCBiID0ge1xuICAgICAgICAgIGluZGV4OiBjLFxuICAgICAgICAgIGxhc3Q6IGMgPT09IHRoaXMuZnJhbWVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZGVsYXk6IGEuZGVsYXksXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IGEudHJhbnNwYXJlbnQsXG4gICAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgcXVhbGl0eTogdGhpcy5vcHRpb25zLnF1YWxpdHksXG4gICAgICAgICAgcmVwZWF0OiB0aGlzLm9wdGlvbnMucmVwZWF0LFxuICAgICAgICAgIGNhblRyYW5zZmVyOiBoLm5hbWUgPT09ICdjaHJvbWUnXG4gICAgICAgIH0sIG51bGwgIT0gYS5kYXRhKSBiLmRhdGEgPSBhLmRhdGE7ZWxzZSBpZiAobnVsbCAhPSBhLmNvbnRleHQpIGIuZGF0YSA9IHRoaXMuZ2V0Q29udGV4dERhdGEoYS5jb250ZXh0KTtlbHNlIGlmIChudWxsICE9IGEuaW1hZ2UpIGIuZGF0YSA9IHRoaXMuZ2V0SW1hZ2VEYXRhKGEuaW1hZ2UpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyYW1lJyk7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSwgYTtcbiAgICB9KGYpLCBkLmV4cG9ydHMgPSBlO1xuICB9KSwgYS5kZWZpbmUoJy9icm93c2VyLmNvZmZlZScsIGZ1bmN0aW9uIChmLCBnLCBoLCBpKSB7XG4gICAgdmFyIGEsIGQsIGUsIGMsIGI7XG4gICAgYyA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSwgZSA9IG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpLCBiID0gYy5tYXRjaCgvKG9wZXJhfGllfGZpcmVmb3h8Y2hyb21lfHZlcnNpb24pW1xcc1xcLzpdKFtcXHdcXGRcXC5dKyk/Lio/KHNhZmFyaXx2ZXJzaW9uW1xcc1xcLzpdKFtcXHdcXGRcXC5dKyl8JCkvKSB8fCBbbnVsbCwgJ3Vua25vd24nLCAwXSwgZCA9IGJbMV0gPT09ICdpZScgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlLCBhID0ge1xuICAgICAgbmFtZTogYlsxXSA9PT0gJ3ZlcnNpb24nID8gYlszXSA6IGJbMV0sXG4gICAgICB2ZXJzaW9uOiBkIHx8IHBhcnNlRmxvYXQoYlsxXSA9PT0gJ29wZXJhJyAmJiBiWzRdID8gYls0XSA6IGJbMl0pLFxuICAgICAgcGxhdGZvcm06IHtcbiAgICAgICAgbmFtZTogYy5tYXRjaCgvaXAoPzphZHxvZHxob25lKS8pID8gJ2lvcycgOiAoYy5tYXRjaCgvKD86d2Vib3N8YW5kcm9pZCkvKSB8fCBlLm1hdGNoKC9tYWN8d2lufGxpbnV4LykgfHwgWydvdGhlciddKVswXVxuICAgICAgfVxuICAgIH0sIGFbYS5uYW1lXSA9ICEwLCBhW2EubmFtZSArIHBhcnNlSW50KGEudmVyc2lvbiwgMTApXSA9ICEwLCBhLnBsYXRmb3JtW2EucGxhdGZvcm0ubmFtZV0gPSAhMCwgZi5leHBvcnRzID0gYTtcbiAgfSksIGEuZGVmaW5lKCdldmVudHMnLCBmdW5jdGlvbiAoZiwgZSwgZywgaCkge1xuICAgIGIuRXZlbnRFbWl0dGVyIHx8IChiLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9KTtcbiAgICB2YXIgYSA9IGUuRXZlbnRFbWl0dGVyID0gYi5FdmVudEVtaXR0ZXIsXG4gICAgICAgIGMgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuICAgICAgICBkID0gMTA7XG4gICAgYS5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pLCB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gYTtcbiAgICB9LCBhLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgIGlmIChmID09PSAnZXJyb3InICYmICghKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHMuZXJyb3IpIHx8IGModGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHRocm93IGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yID8gYXJndW1lbnRzWzFdIDogbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiAhMTtcbiAgICAgIHZhciBhID0gdGhpcy5fZXZlbnRzW2ZdO1xuICAgICAgaWYgKCFhKSByZXR1cm4gITE7XG4gICAgICBpZiAoISh0eXBlb2YgYSA9PSAnZnVuY3Rpb24nKSkgaWYgKGMoYSkpIHtcbiAgICAgICAgdmFyIGIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgZSA9IGEuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBkID0gMCwgZyA9IGUubGVuZ3RoOyBkIDwgZzsgZCsrKSBlW2RdLmFwcGx5KHRoaXMsIGIpO1xuXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0gZWxzZSByZXR1cm4gITE7XG5cbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBhLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBiID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICBhLmFwcGx5KHRoaXMsIGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgYS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBiKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgICBpZiAodGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSksIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCBhLCBiKSwgIXRoaXMuX2V2ZW50c1thXSkgdGhpcy5fZXZlbnRzW2FdID0gYjtlbHNlIGlmIChjKHRoaXMuX2V2ZW50c1thXSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbYV0ud2FybmVkKSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkID8gZSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgOiBlID0gZCwgZSAmJiBlID4gMCAmJiB0aGlzLl9ldmVudHNbYV0ubGVuZ3RoID4gZSAmJiAodGhpcy5fZXZlbnRzW2FdLndhcm5lZCA9ICEwLCBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsIHRoaXMuX2V2ZW50c1thXS5sZW5ndGgpLCBjb25zb2xlLnRyYWNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2FdLnB1c2goYik7XG4gICAgICB9IGVsc2UgdGhpcy5fZXZlbnRzW2FdID0gW3RoaXMuX2V2ZW50c1thXSwgYl07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBhLnByb3RvdHlwZS5vbiA9IGEucHJvdG90eXBlLmFkZExpc3RlbmVyLCBhLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgIHZhciBhID0gdGhpcztcbiAgICAgIHJldHVybiBhLm9uKGIsIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgIGEucmVtb3ZlTGlzdGVuZXIoYiwgZCksIGMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGEsIGQpIHtcbiAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgZCkgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgICAgaWYgKCEodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1thXSkpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGIgPSB0aGlzLl9ldmVudHNbYV07XG5cbiAgICAgIGlmIChjKGIpKSB7XG4gICAgICAgIHZhciBlID0gYi5pbmRleE9mKGQpO1xuICAgICAgICBpZiAoZSA8IDApIHJldHVybiB0aGlzO1xuICAgICAgICBiLnNwbGljZShlLCAxKSwgYi5sZW5ndGggPT0gMCAmJiBkZWxldGUgdGhpcy5fZXZlbnRzW2FdO1xuICAgICAgfSBlbHNlIHRoaXMuX2V2ZW50c1thXSA9PT0gZCAmJiBkZWxldGUgdGhpcy5fZXZlbnRzW2FdO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBhLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1thXSAmJiAodGhpcy5fZXZlbnRzW2FdID0gbnVsbCksIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KSwgdGhpcy5fZXZlbnRzW2FdIHx8ICh0aGlzLl9ldmVudHNbYV0gPSBbXSksIGModGhpcy5fZXZlbnRzW2FdKSB8fCAodGhpcy5fZXZlbnRzW2FdID0gW3RoaXMuX2V2ZW50c1thXV0pLCB0aGlzLl9ldmVudHNbYV07XG4gICAgfTtcbiAgfSksIGMuR0lGID0gYSgnL2dpZi5jb2ZmZWUnKTtcbn0pLmNhbGwoY29tbW9uanNHbG9iYWwsIGNvbW1vbmpzR2xvYmFsKTsgLy8gZ2lmLmpzIDAuMS42IC0gaHR0cHM6Ly9naXRodWIuY29tL2pub3JkYmVyZy9naWYuanNcblxudmFyIHdlYm1Xcml0ZXIwXzJfMCA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogQSB0b29sIGZvciBwcmVzZW50aW5nIGFuIEFycmF5QnVmZmVyIGFzIGEgc3RyZWFtIGZvciB3cml0aW5nIHNvbWUgc2ltcGxlIGRhdGEgdHlwZXMuXG4gKlxuICogQnkgTmljaG9sYXMgU2hlcmxvY2tcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNOb2RlRW52aXJvbWVudCA9ICdvYmplY3QnICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgaXNOb2RlRW52aXJvbWVudCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBBcnJheUJ1ZmZlciBvZiB0aGUgZ2l2ZW4gbGVuZ3RoIGFuZCBwcmVzZW50IGl0IGFzIGEgd3JpdGFibGUgc3RyZWFtIHdpdGggbWV0aG9kc1xuICAgICAqIGZvciB3cml0aW5nIGRhdGEgaW4gZGlmZmVyZW50IGZvcm1hdHMuXG4gICAgICovXG5cbiAgICB2YXIgQXJyYXlCdWZmZXJEYXRhU3RyZWFtID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgdGhpcy5wb3MgPSBvZmZzZXQ7XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IGFycltpXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gYjtcbiAgICB9OyAvL1N5bm9ueW06XG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVOCA9IEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlO1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVUxNkJFID0gZnVuY3Rpb24gKHUpIHtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHUgPj4gODtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHU7XG4gICAgfTtcblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShuZXcgRmxvYXQ2NEFycmF5KFtkXSkuYnVmZmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZsb2F0MzJBcnJheShbZF0pLmJ1ZmZlcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSBieXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndyaXRlQnl0ZShieXRlc1tpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhbiBBU0NJSSBzdHJpbmcgdG8gdGhlIHN0cmVhbVxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgZ2l2ZW4gMzItYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbSBhcyBhbiBFQk1MIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIHVzaW5nIHRoZSBnaXZlbiBieXRlIHdpZHRoXG4gICAgICogKHVzZSBtZWFzdXJlRUJNTFZhckludCkuXG4gICAgICpcbiAgICAgKiBObyBlcnJvciBjaGVja2luZyBpcyBwZXJmb3JtZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHN1cHBsaWVkIHdpZHRoIGlzIGNvcnJlY3QgZm9yIHRoZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGkgSW50ZWdlciB0byBiZSB3cml0dGVuXG4gICAgICogQHBhcmFtIHdpZHRoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVFQk1MVmFySW50V2lkdGggPSBmdW5jdGlvbiAoaSwgd2lkdGgpIHtcbiAgICAgIHN3aXRjaCAod2lkdGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMud3JpdGVVOCgxIDw8IDcgfCBpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KDEgPDwgNiB8IGkgPj4gOCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCA1IHwgaSA+PiAxNik7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gOCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoMSA8PCA0IHwgaSA+PiAyNCk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gMTYpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDgpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBKYXZhU2NyaXB0IGNvbnZlcnRzIGl0cyBkb3VibGVzIHRvIDMyLWJpdCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zLCBzbyB3ZSBuZWVkIHRvIGRvIGFcbiAgICAgICAgICAgKiBkaXZpc2lvbiBieSAyXjMyIGluc3RlYWQgb2YgYSByaWdodC1zaGlmdCBvZiAzMiB0byByZXRhaW4gdGhvc2UgdG9wIDMgYml0c1xuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMud3JpdGVVOCgxIDw8IDMgfCBpIC8gNDI5NDk2NzI5NiAmIDB4Nyk7XG4gICAgICAgICAgdGhpcy53cml0ZVU4KGkgPj4gMjQpO1xuICAgICAgICAgIHRoaXMud3JpdGVVOChpID4+IDE2KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSA+PiA4KTtcbiAgICAgICAgICB0aGlzLndyaXRlVTgoaSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignQmFkIEVCTUwgVklOVCBzaXplICcgKyB3aWR0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiBpbnRlZ2VyIGFzIGFuIEVCTUwgVklOVC5cbiAgICAgKi9cblxuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS5tZWFzdXJlRUJNTFZhckludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICh2YWwgPCAoMSA8PCA3KSAtIDEpIHtcbiAgICAgICAgLyogVG9wIGJpdCBpcyBzZXQsIGxlYXZpbmcgNyBiaXRzIHRvIGhvbGQgdGhlIGludGVnZXIsIGJ1dCB3ZSBjYW4ndCBzdG9yZSAxMjcgYmVjYXVzZVxuICAgICAgICAgKiBcImFsbCBiaXRzIHNldCB0byBvbmVcIiBpcyBhIHJlc2VydmVkIHZhbHVlLiBTYW1lIHRoaW5nIGZvciB0aGUgb3RoZXIgY2FzZXMgYmVsb3c6XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMTQpIC0gMSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMjEpIC0gMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgKDEgPDwgMjgpIC0gMSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMzQzNTk3MzgzNjcpIHtcbiAgICAgICAgLy8gMiBeIDM1IC0gMSAoY2FuIGFkZHJlc3MgMzJHQilcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignRUJNTCBWSU5UIHNpemUgbm90IHN1cHBvcnRlZCAnICsgdmFsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQXJyYXlCdWZmZXJEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUVCTUxWYXJJbnQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgdGhpcy53cml0ZUVCTUxWYXJJbnRXaWR0aChpLCB0aGlzLm1lYXN1cmVFQk1MVmFySW50KGkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIHRoZSBnaXZlbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtIGluIGJpZy1lbmRpYW4gb3JkZXIgdXNpbmcgdGhlIGdpdmVuIGJ5dGUgd2lkdGguXG4gICAgICogTm8gZXJyb3IgY2hlY2tpbmcgaXMgcGVyZm9ybWVkIHRvIGVuc3VyZSB0aGF0IHRoZSBzdXBwbGllZCB3aWR0aCBpcyBjb3JyZWN0IGZvciB0aGUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqIE9taXQgdGhlIHdpZHRoIHBhcmFtZXRlciB0byBoYXZlIGl0IGRldGVybWluZWQgYXV0b21hdGljYWxseSBmb3IgeW91LlxuICAgICAqXG4gICAgICogQHBhcmFtIHUgVW5zaWduZWQgaW50ZWdlciB0byBiZSB3cml0dGVuXG4gICAgICogQHBhcmFtIHdpZHRoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZSB0byB0aGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIEFycmF5QnVmZmVyRGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVbnNpZ25lZEludEJFID0gZnVuY3Rpb24gKHUsIHdpZHRoKSB7XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3aWR0aCA9IHRoaXMubWVhc3VyZVVuc2lnbmVkSW50KHUpO1xuICAgICAgfSAvLyBFYWNoIGNhc2UgZmFsbHMgdGhyb3VnaDpcblxuXG4gICAgICBzd2l0Y2ggKHdpZHRoKSB7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLndyaXRlVTgoTWF0aC5mbG9vcih1IC8gNDI5NDk2NzI5NikpO1xuICAgICAgICAvLyBOZWVkIHRvIHVzZSBkaXZpc2lvbiB0byBhY2Nlc3MgPjMyIGJpdHMgb2YgZmxvYXRpbmcgcG9pbnQgdmFyXG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRoaXMud3JpdGVVOCh1ID4+IDI0KTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KHUgPj4gMTYpO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLndyaXRlVTgodSA+PiA4KTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy53cml0ZVU4KHUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ0JhZCBVSU5UIHNpemUgJyArIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCB0byBob2xkIHRoZSBub24temVybyBiaXRzIG9mIHRoZSBnaXZlbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLm1lYXN1cmVVbnNpZ25lZEludCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIC8vIEZvcmNlIHRvIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyXG4gICAgICBpZiAodmFsIDwgMSA8PCA4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAxIDw8IDE2KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCAxIDw8IDI0KSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgICAgfSBlbHNlIGlmICh2YWwgPCA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2aWV3IG9uIHRoZSBwb3J0aW9uIG9mIHRoZSBidWZmZXIgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24gYXMgYSBVaW50OEFycmF5LlxuICAgICAqL1xuXG5cbiAgICBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ucHJvdG90eXBlLmdldEFzRGF0YUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJhcnJheSgwLCB0aGlzLnBvcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucG9zID09IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkFycmF5QnVmZmVyRGF0YVN0cmVhbSdzIHBvcyBsaWVzIGJleW9uZCBlbmQgb2YgYnVmZmVyXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5BcnJheUJ1ZmZlckRhdGFTdHJlYW0gPSBBcnJheUJ1ZmZlckRhdGFTdHJlYW07XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGEgc2VyaWVzIG9mIEJsb2ItY29udmVydGlibGUgb2JqZWN0cyAoQXJyYXlCdWZmZXIsIEJsb2IsIFN0cmluZywgZXRjKSB0byBiZSBhZGRlZCB0byBhIGJ1ZmZlci4gU2Vla2luZyBhbmRcbiAgICAgKiBvdmVyd3JpdGluZyBvZiBibG9icyBpcyBhbGxvd2VkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBzdXBwbHkgYSBGaWxlV3JpdGVyLCBpbiB3aGljaCBjYXNlIHRoZSBCbG9iQnVmZmVyIGlzIGp1c3QgdXNlZCBhcyB0ZW1wb3Jhcnkgc3RvcmFnZSBiZWZvcmUgaXQgd3JpdGVzIGl0XG4gICAgICogdGhyb3VnaCB0byB0aGUgZGlzay5cbiAgICAgKlxuICAgICAqIEJ5IE5pY2hvbGFzIFNoZXJsb2NrXG4gICAgICpcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICAgICAqL1xuXG4gICAgdmFyIEJsb2JCdWZmZXIgPSBmdW5jdGlvbiAoZnMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IFtdLFxuICAgICAgICAgICAgd3JpdGVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICAgICAgICBmaWxlV3JpdGVyID0gbnVsbCxcbiAgICAgICAgICAgIGZkID0gbnVsbDtcblxuICAgICAgICBpZiAodHlwZW9mIEZpbGVXcml0ZXIgIT09ICd1bmRlZmluZWQnICYmIGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgRmlsZVdyaXRlcikge1xuICAgICAgICAgIGZpbGVXcml0ZXIgPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChmcyAmJiBkZXN0aW5hdGlvbikge1xuICAgICAgICAgIGZkID0gZGVzdGluYXRpb247XG4gICAgICAgIH0gLy8gQ3VycmVudCBzZWVrIG9mZnNldFxuXG5cbiAgICAgICAgdGhpcy5wb3MgPSAwOyAvLyBPbmUgbW9yZSB0aGFuIHRoZSBpbmRleCBvZiB0aGUgaGlnaGVzdCBieXRlIGV2ZXIgd3JpdHRlblxuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDsgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBjb252ZXJ0cyB0aGUgYmxvYiB0byBhbiBBcnJheUJ1ZmZlclxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRCbG9iQXNCdWZmZXIoYmxvYikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb252ZXJ0VG9VaW50OEFycmF5KHRoaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGluZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHRoaW5nKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KHRoaW5nKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRCbG9iQXNCdWZmZXIodGhpbmcpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvL0Fzc3VtZSB0aGF0IEJsb2Igd2lsbCBrbm93IGhvdyB0byByZWFkIHRoaXMgdGhpbmdcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZWFkQmxvYkFzQnVmZmVyKG5ldyBCbG9iKFt0aGluZ10pKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWVhc3VyZURhdGEoZGF0YSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93ICdGYWlsZWQgdG8gZGV0ZXJtaW5lIHNpemUgb2YgZWxlbWVudCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2VlayB0byB0aGUgZ2l2ZW4gYWJzb2x1dGUgb2Zmc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgbWF5IG5vdCBzZWVrIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBmaWxlICh0aGlzIHdvdWxkIGNyZWF0ZSBhIGhvbGUgYW5kL29yIGFsbG93IGJsb2NrcyB0byBiZSB3cml0dGVuIGluIG5vbi1cbiAgICAgICAgICogc2VxdWVudGlhbCBvcmRlciwgd2hpY2ggaXNuJ3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgbWVtb3J5IGJ1ZmZlciBiYWNrZW5kKS5cbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHRocm93ICdPZmZzZXQgbWF5IG5vdCBiZSBuZWdhdGl2ZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93ICdPZmZzZXQgbWF5IG5vdCBiZSBOYU4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgJ1NlZWtpbmcgYmV5b25kIHRoZSBlbmQgb2YgZmlsZSBpcyBub3QgYWxsb3dlZCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wb3MgPSBvZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZSB0aGUgQmxvYi1jb252ZXJ0aWJsZSBkYXRhIHRvIHRoZSBidWZmZXIgYXQgdGhlIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogSWYgb3ZlcndyaXRpbmcgZXhpc3RpbmcgZGF0YSwgdGhlIHdyaXRlIG11c3Qgbm90IGNyb3NzIHByZWV4aXN0aW5nIGJsb2NrIGJvdW5kYXJpZXMgKHdyaXR0ZW4gZGF0YSBtdXN0XG4gICAgICAgICAqIGJlIGZ1bGx5IGNvbnRhaW5lZCBieSB0aGUgZXh0ZW50IG9mIGEgcHJldmlvdXMgd3JpdGUpLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHZhciBuZXdFbnRyeSA9IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5wb3MsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbGVuZ3RoOiBtZWFzdXJlRGF0YShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGlzQXBwZW5kID0gbmV3RW50cnkub2Zmc2V0ID49IHRoaXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMucG9zICs9IG5ld0VudHJ5Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCB0aGlzLnBvcyk7IC8vIEFmdGVyIHByZXZpb3VzIHdyaXRlcyBjb21wbGV0ZSwgcGVyZm9ybSBvdXIgd3JpdGVcblxuICAgICAgICAgIHdyaXRlUHJvbWlzZSA9IHdyaXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRUb1VpbnQ4QXJyYXkobmV3RW50cnkuZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdG90YWxXcml0dGVuID0gMCxcbiAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhQXJyYXkuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVXcml0ZUNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgd3JpdHRlbiwgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV3JpdHRlbiArPSB3cml0dGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbFdyaXR0ZW4gPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIG1vcmUgdG8gd3JpdGUuLi5cbiAgICAgICAgICAgICAgICAgICAgICBmcy53cml0ZShmZCwgYnVmZmVyLCB0b3RhbFdyaXR0ZW4sIGJ1ZmZlci5sZW5ndGggLSB0b3RhbFdyaXR0ZW4sIG5ld0VudHJ5Lm9mZnNldCArIHRvdGFsV3JpdHRlbiwgaGFuZGxlV3JpdGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIG5ld0VudHJ5Lm9mZnNldCwgaGFuZGxlV3JpdGVDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlV3JpdGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5vbndyaXRlZW5kID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLnNlZWsobmV3RW50cnkub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKG5ldyBCbG9iKFtuZXdFbnRyeS5kYXRhXSkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzQXBwZW5kKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIG1vZGlmeWluZyBhIHdyaXRlIHRoYXQgd2FzIGFscmVhZHkgYnVmZmVyZWQgaW4gbWVtb3J5LlxuICAgICAgICAgICAgICAvLyBTbG93IGxpbmVhciBzZWFyY2ggdG8gZmluZCBhIGJsb2NrIHdlIG1pZ2h0IGJlIG92ZXJ3cml0aW5nXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gYnVmZmVyW2ldOyAvLyBJZiBvdXIgbmV3IGVudHJ5IG92ZXJsYXBzIHRoZSBvbGQgb25lIGluIGFueSB3YXkuLi5cblxuICAgICAgICAgICAgICAgIGlmICghKG5ld0VudHJ5Lm9mZnNldCArIG5ld0VudHJ5Lmxlbmd0aCA8PSBlbnRyeS5vZmZzZXQgfHwgbmV3RW50cnkub2Zmc2V0ID49IGVudHJ5Lm9mZnNldCArIGVudHJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdFbnRyeS5vZmZzZXQgPCBlbnRyeS5vZmZzZXQgfHwgbmV3RW50cnkub2Zmc2V0ICsgbmV3RW50cnkubGVuZ3RoID4gZW50cnkub2Zmc2V0ICsgZW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcndyaXRlIGNyb3NzZXMgYmxvYiBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdFbnRyeS5vZmZzZXQgPT0gZW50cnkub2Zmc2V0ICYmIG5ld0VudHJ5Lmxlbmd0aCA9PSBlbnRyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb3Zlcndyb3RlIHRoZSBlbnRpcmUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgZW50cnkuZGF0YSA9IG5ld0VudHJ5LmRhdGE7IC8vIFdlJ3JlIGRvbmVcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRvVWludDhBcnJheShlbnRyeS5kYXRhKS50aGVuKGZ1bmN0aW9uIChlbnRyeUFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZW50cnkuZGF0YSA9IGVudHJ5QXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1VpbnQ4QXJyYXkobmV3RW50cnkuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG5ld0VudHJ5QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdFbnRyeS5kYXRhID0gbmV3RW50cnlBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5kYXRhLnNldChuZXdFbnRyeS5kYXRhLCBuZXdFbnRyeS5vZmZzZXQgLSBlbnRyeS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gRWxzZSBmYWxsIHRocm91Z2ggdG8gZG8gYSBzaW1wbGUgYXBwZW5kLCBhcyB3ZSBkaWRuJ3Qgb3ZlcndyaXRlIGFueSBwcmUtZXhpc3RpbmcgYmxvY2tzXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluaXNoIGFsbCB3cml0ZXMgdG8gdGhlIGJ1ZmZlciwgcmV0dXJuaW5nIGEgcHJvbWlzZSB0aGF0IHNpZ25hbHMgd2hlbiB0aGF0IGlzIGNvbXBsZXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIEZpbGVXcml0ZXIgd2FzIG5vdCBwcm92aWRlZCwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhIEJsb2IgdGhhdCByZXByZXNlbnRzIHRoZSBjb21wbGV0ZWQgQmxvYkJ1ZmZlclxuICAgICAgICAgKiBjb250ZW50cy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgaW4gYSBtaW1lVHlwZSB0byBiZSB1c2VkIGZvciB0aGlzIGJsb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgRmlsZVdyaXRlciB3YXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggbnVsbCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uIChtaW1lVHlwZSkge1xuICAgICAgICAgIGlmIChmZCB8fCBmaWxlV3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZVByb21pc2UgPSB3cml0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFmdGVyIHdyaXRlcyBjb21wbGV0ZSB3ZSBuZWVkIHRvIG1lcmdlIHRoZSBidWZmZXIgdG8gZ2l2ZSB0byB0aGUgY2FsbGVyXG4gICAgICAgICAgICB3cml0ZVByb21pc2UgPSB3cml0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ1ZmZlcltpXS5kYXRhKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihyZXN1bHQsIHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd3JpdGVQcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KGlzTm9kZUVudmlyb21lbnQgPyBudWxsIDogbnVsbCk7XG5cbiAgICB3aW5kb3cuQmxvYkJ1ZmZlciA9IEJsb2JCdWZmZXI7XG4gICAgLyoqXG4gICAgICogV2ViTSB2aWRlbyBlbmNvZGVyIGZvciBHb29nbGUgQ2hyb21lLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHN1aXRhYmxlIGZvciBjcmVhdGluZyB2ZXJ5IGxhcmdlIHZpZGVvIGZpbGVzLCBiZWNhdXNlXG4gICAgICogaXQgY2FuIHN0cmVhbSBCbG9icyBkaXJlY3RseSB0byBhIEZpbGVXcml0ZXIgd2l0aG91dCBidWZmZXJpbmcgdGhlIGVudGlyZSB2aWRlbyBpbiBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBXaGVuIEZpbGVXcml0ZXIgaXMgbm90IGF2YWlsYWJsZSBvciBub3QgZGVzaXJlZCwgaXQgY2FuIGJ1ZmZlciB0aGUgdmlkZW8gaW4gbWVtb3J5IGFzIGEgc2VyaWVzIG9mIEJsb2JzIHdoaWNoIGFyZVxuICAgICAqIGV2ZW50dWFsbHkgcmV0dXJuZWQgYXMgb25lIGNvbXBvc2l0ZSBCbG9iLlxuICAgICAqXG4gICAgICogQnkgTmljaG9sYXMgU2hlcmxvY2suXG4gICAgICpcbiAgICAgKiBCYXNlZCBvbiB0aGUgaWRlYXMgZnJvbSBXaGFtbXk6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRpbWF0dGVyMTUvd2hhbW15XG4gICAgICpcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgV1RGUEx2MiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XVEZQTFxuICAgICAqL1xuXG4gICAgdmFyIFdlYk1Xcml0ZXIgPSBmdW5jdGlvbiAoQXJyYXlCdWZmZXJEYXRhU3RyZWFtLCBCbG9iQnVmZmVyKSB7XG4gICAgICBmdW5jdGlvbiBleHRlbmQoYmFzZSwgdG9wKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgW2Jhc2UsIHRvcF0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRGVjb2RlIGEgQmFzZTY0IGRhdGEgVVJMIGludG8gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAgICpcbiAgICAgICAqIFJldHVybnMgdGhlIGJpbmFyeSBzdHJpbmcsIG9yIGZhbHNlIGlmIHRoZSBVUkwgY291bGQgbm90IGJlIGRlY29kZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBkZWNvZGVCYXNlNjRXZWJQRGF0YVVSTCh1cmwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8ICF1cmwubWF0Y2goL15kYXRhOmltYWdlXFwvd2VicDtiYXNlNjQsL2kpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKHVybC5zdWJzdHJpbmcoJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsJy5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydCB0aGUgZ2l2ZW4gY2FudmFzIHRvIGEgV2ViUCBlbmNvZGVkIGltYWdlIGFuZCByZXR1cm4gdGhlIGltYWdlIGRhdGEgYXMgYSBzdHJpbmcuXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiByZW5kZXJBc1dlYlAoY2FudmFzLCBxdWFsaXR5KSB7XG4gICAgICAgIHZhciBmcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnLCB7XG4gICAgICAgICAgcXVhbGl0eTogcXVhbGl0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFdlYlBEYXRhVVJMKGZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXh0cmFjdEtleWZyYW1lRnJvbVdlYlAod2ViUCkge1xuICAgICAgICAvLyBBc3N1bWUgdGhhdCBDaHJvbWUgd2lsbCBnZW5lcmF0ZSBhIFNpbXBsZSBMb3NzeSBXZWJQIHdoaWNoIGhhcyB0aGlzIGhlYWRlcjpcbiAgICAgICAgdmFyIGtleWZyYW1lU3RhcnRJbmRleCA9IHdlYlAuaW5kZXhPZignVlA4ICcpO1xuXG4gICAgICAgIGlmIChrZXlmcmFtZVN0YXJ0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyAnRmFpbGVkIHRvIGlkZW50aWZ5IGJlZ2lubmluZyBvZiBrZXlmcmFtZSBpbiBXZWJQIGltYWdlJztcbiAgICAgICAgfSAvLyBTa2lwIHRoZSBoZWFkZXIgYW5kIHRoZSA0IGJ5dGVzIHRoYXQgZW5jb2RlIHRoZSBsZW5ndGggb2YgdGhlIFZQOCBjaHVua1xuXG5cbiAgICAgICAga2V5ZnJhbWVTdGFydEluZGV4ICs9ICdWUDggJy5sZW5ndGggKyA0O1xuICAgICAgICByZXR1cm4gd2ViUC5zdWJzdHJpbmcoa2V5ZnJhbWVTdGFydEluZGV4KTtcbiAgICAgIH0gLy8gSnVzdCBhIGxpdHRsZSB1dGlsaXR5IHNvIHdlIGNhbiB0YWcgdmFsdWVzIGFzIGZsb2F0cyBmb3IgdGhlIEVCTUwgZW5jb2RlcidzIGJlbmVmaXRcblxuXG4gICAgICBmdW5jdGlvbiBFQk1MRmxvYXQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEVCTUxGbG9hdDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogV3JpdGUgdGhlIGdpdmVuIEVCTUwgb2JqZWN0IHRvIHRoZSBwcm92aWRlZCBBcnJheUJ1ZmZlclN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgYnVmZmVyJ3MgZmlyc3QgYnl0ZSBpcyBhdCBidWZmZXJGaWxlT2Zmc2V0IGluc2lkZSB0aGUgdmlkZW8gZmlsZS4gVGhpcyBpcyB1c2VkIHRvIGNvbXBsZXRlIG9mZnNldCBhbmRcbiAgICAgICAqIGRhdGFPZmZzZXQgZmllbGRzIGluIGVhY2ggRUJNTCBzdHJ1Y3R1cmUsIGluZGljYXRpbmcgdGhlIGZpbGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBFQk1MIGVsZW1lbnQgYW5kXG4gICAgICAgKiBpdHMgZGF0YSBwYXlsb2FkLlxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbCkge1xuICAgICAgICAvLyBJcyB0aGUgZWJtbCBhbiBhcnJheSBvZiBzaWJsaW5nIGVsZW1lbnRzP1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlYm1sKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWJtbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbFtpXSk7XG4gICAgICAgICAgfSAvLyBJcyB0aGlzIHNvbWUgc29ydCBvZiByYXcgZGF0YSB0aGF0IHdlIHdhbnQgdG8gd3JpdGUgZGlyZWN0bHk/XG5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZWJtbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBidWZmZXIud3JpdGVTdHJpbmcoZWJtbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWJtbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBidWZmZXIud3JpdGVCeXRlcyhlYm1sKTtcbiAgICAgICAgfSBlbHNlIGlmIChlYm1sLmlkKSB7XG4gICAgICAgICAgLy8gV2UncmUgd3JpdGluZyBhbiBFQk1MIGVsZW1lbnRcbiAgICAgICAgICBlYm1sLm9mZnNldCA9IGJ1ZmZlci5wb3MgKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgIGJ1ZmZlci53cml0ZVVuc2lnbmVkSW50QkUoZWJtbC5pZCk7IC8vIElEIGZpZWxkXG4gICAgICAgICAgLy8gTm93IHdlIG5lZWQgdG8gd3JpdGUgdGhlIHNpemUgZmllbGQsIHNvIHdlIG11c3Qga25vdyB0aGUgcGF5bG9hZCBzaXplOlxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWJtbC5kYXRhKSkge1xuICAgICAgICAgICAgLy8gV3JpdGluZyBhbiBhcnJheSBvZiBjaGlsZCBlbGVtZW50cy4gV2Ugd29uJ3QgdHJ5IHRvIG1lYXN1cmUgdGhlIHNpemUgb2YgdGhlIGNoaWxkcmVuIHVwLWZyb250XG4gICAgICAgICAgICB2YXIgc2l6ZVBvcywgZGF0YUJlZ2luLCBkYXRhRW5kO1xuXG4gICAgICAgICAgICBpZiAoZWJtbC5zaXplID09PSAtMSkge1xuICAgICAgICAgICAgICAvLyBXcml0ZSB0aGUgcmVzZXJ2ZWQgYWxsLW9uZS1iaXRzIG1hcmtlciB0byBub3RlIHRoYXQgdGhlIHNpemUgb2YgdGhpcyBlbGVtZW50IGlzIHVua25vd24vdW5ib3VuZGVkXG4gICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGUoMHhmZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaXplUG9zID0gYnVmZmVyLnBvcztcbiAgICAgICAgICAgICAgLyogV3JpdGUgYSBkdW1teSBzaXplIGZpZWxkIHRvIG92ZXJ3cml0ZSBsYXRlci4gNCBieXRlcyBhbGxvd3MgYW4gZWxlbWVudCBtYXhpbXVtIHNpemUgb2YgMjU2TUIsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHNob3VsZCBiZSBwbGVudHkgKHdlIGRvbid0IHdhbnQgdG8gaGF2ZSB0byBidWZmZXIgdGhhdCBtdWNoIGRhdGEgaW4gbWVtb3J5IGF0IG9uZSB0aW1lXG4gICAgICAgICAgICAgICAqIGFueXdheSEpXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGVzKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGFCZWdpbiA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBkYXRhQmVnaW4gKyBidWZmZXJGaWxlT2Zmc2V0O1xuICAgICAgICAgICAgd3JpdGVFQk1MKGJ1ZmZlciwgYnVmZmVyRmlsZU9mZnNldCwgZWJtbC5kYXRhKTtcblxuICAgICAgICAgICAgaWYgKGVibWwuc2l6ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZGF0YUVuZCA9IGJ1ZmZlci5wb3M7XG4gICAgICAgICAgICAgIGVibWwuc2l6ZSA9IGRhdGFFbmQgLSBkYXRhQmVnaW47XG4gICAgICAgICAgICAgIGJ1ZmZlci5zZWVrKHNpemVQb3MpO1xuICAgICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50V2lkdGgoZWJtbC5zaXplLCA0KTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICAgIGJ1ZmZlci5zZWVrKGRhdGFFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVibWwuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoZWJtbC5kYXRhLmxlbmd0aCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVTdHJpbmcoZWJtbC5kYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlYm1sLmRhdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgY2FsbGVyIHRvIGV4cGxpY2l0bHkgY2hvb3NlIHRoZSBzaXplIGlmIHRoZXkgd2lzaCBieSBzdXBwbHlpbmcgYSBzaXplIGZpZWxkXG4gICAgICAgICAgICBpZiAoIWVibWwuc2l6ZSkge1xuICAgICAgICAgICAgICBlYm1sLnNpemUgPSBidWZmZXIubWVhc3VyZVVuc2lnbmVkSW50KGVibWwuZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoZWJtbC5zaXplKTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBidWZmZXIucG9zICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVuc2lnbmVkSW50QkUoZWJtbC5kYXRhLCBlYm1sLnNpemUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWJtbC5kYXRhIGluc3RhbmNlb2YgRUJNTEZsb2F0NjQpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoOCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRShlYm1sLmRhdGEudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWJtbC5kYXRhIGluc3RhbmNlb2YgRUJNTEZsb2F0MzIpIHtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUVCTUxWYXJJbnQoNCk7IC8vIFNpemUgZmllbGRcblxuICAgICAgICAgICAgZWJtbC5kYXRhT2Zmc2V0ID0gYnVmZmVyLnBvcyArIGJ1ZmZlckZpbGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVGbG9hdEJFKGVibWwuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlYm1sLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVFQk1MVmFySW50KGVibWwuZGF0YS5ieXRlTGVuZ3RoKTsgLy8gU2l6ZSBmaWVsZFxuXG4gICAgICAgICAgICBlYm1sLmRhdGFPZmZzZXQgPSBidWZmZXIucG9zICsgYnVmZmVyRmlsZU9mZnNldDtcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZUJ5dGVzKGVibWwuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdCYWQgRUJNTCBkYXRhdHlwZSAnICsgdHlwZW9mIGVibWwuZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0JhZCBFQk1MIGRhdGF0eXBlICcgKyB0eXBlb2YgZWJtbC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgTUFYX0NMVVNURVJfRFVSQVRJT05fTVNFQyA9IDUwMDAsXG4gICAgICAgICAgICBERUZBVUxUX1RSQUNLX05VTUJFUiA9IDEsXG4gICAgICAgICAgICB3cml0dGVuSGVhZGVyID0gZmFsc2UsXG4gICAgICAgICAgICB2aWRlb1dpZHRoLFxuICAgICAgICAgICAgdmlkZW9IZWlnaHQsXG4gICAgICAgICAgICBjbHVzdGVyRnJhbWVCdWZmZXIgPSBbXSxcbiAgICAgICAgICAgIGNsdXN0ZXJTdGFydFRpbWUgPSAwLFxuICAgICAgICAgICAgY2x1c3RlckR1cmF0aW9uID0gMCxcbiAgICAgICAgICAgIG9wdGlvbkRlZmF1bHRzID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDAuOTUsXG4gICAgICAgICAgLy8gV2ViTSBpbWFnZSBxdWFsaXR5IGZyb20gMC4wICh3b3JzdCkgdG8gMS4wIChiZXN0KVxuICAgICAgICAgIGZpbGVXcml0ZXI6IG51bGwsXG4gICAgICAgICAgLy8gQ2hyb21lIEZpbGVXcml0ZXIgaW4gb3JkZXIgdG8gc3RyZWFtIHRvIGEgZmlsZSBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyB0byBtZW1vcnkgKG9wdGlvbmFsKVxuICAgICAgICAgIGZkOiBudWxsLFxuICAgICAgICAgIC8vIE5vZGUuSlMgZmlsZSBkZXNjcmlwdG9yIHRvIHdyaXRlIHRvIGluc3RlYWQgb2YgYnVmZmVyaW5nIChvcHRpb25hbClcbiAgICAgICAgICAvLyBZb3UgbXVzdCBzdXBwbHkgb25lIG9mOlxuICAgICAgICAgIGZyYW1lRHVyYXRpb246IG51bGwsXG4gICAgICAgICAgLy8gRHVyYXRpb24gb2YgZnJhbWVzIGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAgIGZyYW1lUmF0ZTogbnVsbCAvLyBOdW1iZXIgb2YgZnJhbWVzIHBlciBzZWNvbmRcblxuICAgICAgICB9LFxuICAgICAgICAgICAgc2Vla1BvaW50cyA9IHtcbiAgICAgICAgICBDdWVzOiB7XG4gICAgICAgICAgICBpZDogbmV3IFVpbnQ4QXJyYXkoWzB4MWMsIDB4NTMsIDB4YmIsIDB4NmJdKSxcbiAgICAgICAgICAgIHBvc2l0aW9uRUJNTDogbnVsbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgU2VnbWVudEluZm86IHtcbiAgICAgICAgICAgIGlkOiBuZXcgVWludDhBcnJheShbMHgxNSwgMHg0OSwgMHhhOSwgMHg2Nl0pLFxuICAgICAgICAgICAgcG9zaXRpb25FQk1MOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBUcmFja3M6IHtcbiAgICAgICAgICAgIGlkOiBuZXcgVWludDhBcnJheShbMHgxNiwgMHg1NCwgMHhhZSwgMHg2Yl0pLFxuICAgICAgICAgICAgcG9zaXRpb25FQk1MOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAgICAgZWJtbFNlZ21lbnQsXG4gICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB7XG4gICAgICAgICAgaWQ6IDB4NDQ4OSxcbiAgICAgICAgICAvLyBEdXJhdGlvblxuICAgICAgICAgIGRhdGE6IG5ldyBFQk1MRmxvYXQ2NCgwKVxuICAgICAgICB9LFxuICAgICAgICAgICAgc2Vla0hlYWQsXG4gICAgICAgICAgICBjdWVzID0gW10sXG4gICAgICAgICAgICBibG9iQnVmZmVyID0gbmV3IEJsb2JCdWZmZXIob3B0aW9ucy5maWxlV3JpdGVyIHx8IG9wdGlvbnMuZmQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZShmaWxlT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGVPZmZzZXQgLSBlYm1sU2VnbWVudC5kYXRhT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBTZWVrSGVhZCBlbGVtZW50IHdpdGggZGVzY3JpcHRvcnMgZm9yIHRoZSBwb2ludHMgaW4gdGhlIGdsb2JhbCBzZWVrUG9pbnRzIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiA1IGJ5dGVzIG9mIHBvc2l0aW9uIHZhbHVlcyBhcmUgcmVzZXJ2ZWQgZm9yIGVhY2ggbm9kZSwgd2hpY2ggbGllIGF0IHRoZSBvZmZzZXQgcG9pbnQucG9zaXRpb25FQk1MLmRhdGFPZmZzZXQsXG4gICAgICAgICAqIHRvIGJlIG92ZXJ3cml0dGVuIGxhdGVyLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlZWtIZWFkKCkge1xuICAgICAgICAgIHZhciBzZWVrUG9zaXRpb25FQk1MVGVtcGxhdGUgPSB7XG4gICAgICAgICAgICBpZDogMHg1M2FjLFxuICAgICAgICAgICAgLy8gU2Vla1Bvc2l0aW9uXG4gICAgICAgICAgICBzaXplOiA1LFxuICAgICAgICAgICAgLy8gQWxsb3dzIGZvciAzMkdCIHZpZGVvIGZpbGVzXG4gICAgICAgICAgICBkYXRhOiAwIC8vIFdlJ2xsIG92ZXJ3cml0ZSB0aGlzIHdoZW4gdGhlIGZpbGUgaXMgY29tcGxldGVcblxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGlkOiAweDExNGQ5Yjc0LFxuICAgICAgICAgICAgLy8gU2Vla0hlYWRcbiAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc2Vla1BvaW50cykge1xuICAgICAgICAgICAgdmFyIHNlZWtQb2ludCA9IHNlZWtQb2ludHNbbmFtZV07XG4gICAgICAgICAgICBzZWVrUG9pbnQucG9zaXRpb25FQk1MID0gT2JqZWN0LmNyZWF0ZShzZWVrUG9zaXRpb25FQk1MVGVtcGxhdGUpO1xuICAgICAgICAgICAgcmVzdWx0LmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiAweDRkYmIsXG4gICAgICAgICAgICAgIC8vIFNlZWtcbiAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICBpZDogMHg1M2FiLFxuICAgICAgICAgICAgICAgIC8vIFNlZWtJRFxuICAgICAgICAgICAgICAgIGRhdGE6IHNlZWtQb2ludC5pZFxuICAgICAgICAgICAgICB9LCBzZWVrUG9pbnQucG9zaXRpb25FQk1MXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgdGhlIFdlYk0gZmlsZSBoZWFkZXIgdG8gdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUhlYWRlcigpIHtcbiAgICAgICAgICBzZWVrSGVhZCA9IGNyZWF0ZVNlZWtIZWFkKCk7XG4gICAgICAgICAgdmFyIGVibWxIZWFkZXIgPSB7XG4gICAgICAgICAgICBpZDogMHgxYTQ1ZGZhMyxcbiAgICAgICAgICAgIC8vIEVCTUxcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweDQyODYsXG4gICAgICAgICAgICAgIC8vIEVCTUxWZXJzaW9uXG4gICAgICAgICAgICAgIGRhdGE6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmNyxcbiAgICAgICAgICAgICAgLy8gRUJNTFJlYWRWZXJzaW9uXG4gICAgICAgICAgICAgIGRhdGE6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmMixcbiAgICAgICAgICAgICAgLy8gRUJNTE1heElETGVuZ3RoXG4gICAgICAgICAgICAgIGRhdGE6IDRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgaWQ6IDB4NDJmMyxcbiAgICAgICAgICAgICAgLy8gRUJNTE1heFNpemVMZW5ndGhcbiAgICAgICAgICAgICAgZGF0YTogOFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0MjgyLFxuICAgICAgICAgICAgICAvLyBEb2NUeXBlXG4gICAgICAgICAgICAgIGRhdGE6ICd3ZWJtJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0Mjg3LFxuICAgICAgICAgICAgICAvLyBEb2NUeXBlVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAyXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweDQyODUsXG4gICAgICAgICAgICAgIC8vIERvY1R5cGVSZWFkVmVyc2lvblxuICAgICAgICAgICAgICBkYXRhOiAyXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNlZ21lbnRJbmZvID0ge1xuICAgICAgICAgICAgaWQ6IDB4MTU0OWE5NjYsXG4gICAgICAgICAgICAvLyBJbmZvXG4gICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICBpZDogMHgyYWQ3YjEsXG4gICAgICAgICAgICAgIC8vIFRpbWVjb2RlU2NhbGVcbiAgICAgICAgICAgICAgZGF0YTogMWU2IC8vIFRpbWVzIHdpbGwgYmUgaW4gbWlsaXNlY29uZHMgKDFlNiBuYW5vc2Vjb25kcyBwZXIgc3RlcCA9IDFtcylcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg0ZDgwLFxuICAgICAgICAgICAgICAvLyBNdXhpbmdBcHBcbiAgICAgICAgICAgICAgZGF0YTogJ3dlYm0td3JpdGVyLWpzJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBpZDogMHg1NzQxLFxuICAgICAgICAgICAgICAvLyBXcml0aW5nQXBwXG4gICAgICAgICAgICAgIGRhdGE6ICd3ZWJtLXdyaXRlci1qcydcbiAgICAgICAgICAgIH0sIHNlZ21lbnREdXJhdGlvbiAvLyBUbyBiZSBmaWxsZWQgaW4gbGF0ZXJcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0cmFja3MgPSB7XG4gICAgICAgICAgICBpZDogMHgxNjU0YWU2YixcbiAgICAgICAgICAgIC8vIFRyYWNrc1xuICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgaWQ6IDB4YWUsXG4gICAgICAgICAgICAgIC8vIFRyYWNrRW50cnlcbiAgICAgICAgICAgICAgZGF0YTogW3tcbiAgICAgICAgICAgICAgICBpZDogMHhkNyxcbiAgICAgICAgICAgICAgICAvLyBUcmFja051bWJlclxuICAgICAgICAgICAgICAgIGRhdGE6IERFRkFVTFRfVFJBQ0tfTlVNQkVSXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHg3M2M1LFxuICAgICAgICAgICAgICAgIC8vIFRyYWNrVUlEXG4gICAgICAgICAgICAgICAgZGF0YTogREVGQVVMVF9UUkFDS19OVU1CRVJcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDljLFxuICAgICAgICAgICAgICAgIC8vIEZsYWdMYWNpbmdcbiAgICAgICAgICAgICAgICBkYXRhOiAwXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMHgyMmI1OWMsXG4gICAgICAgICAgICAgICAgLy8gTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICBkYXRhOiAndW5kJ1xuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ODYsXG4gICAgICAgICAgICAgICAgLy8gQ29kZWNJRFxuICAgICAgICAgICAgICAgIGRhdGE6ICdWX1ZQOCdcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiAweDI1ODY4OCxcbiAgICAgICAgICAgICAgICAvLyBDb2RlY05hbWVcbiAgICAgICAgICAgICAgICBkYXRhOiAnVlA4J1xuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ODMsXG4gICAgICAgICAgICAgICAgLy8gVHJhY2tUeXBlXG4gICAgICAgICAgICAgICAgZGF0YTogMVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ZTAsXG4gICAgICAgICAgICAgICAgLy8gVmlkZW9cbiAgICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgICAgaWQ6IDB4YjAsXG4gICAgICAgICAgICAgICAgICAvLyBQaXhlbFdpZHRoXG4gICAgICAgICAgICAgICAgICBkYXRhOiB2aWRlb1dpZHRoXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgaWQ6IDB4YmEsXG4gICAgICAgICAgICAgICAgICAvLyBQaXhlbEhlaWdodFxuICAgICAgICAgICAgICAgICAgZGF0YTogdmlkZW9IZWlnaHRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVibWxTZWdtZW50ID0ge1xuICAgICAgICAgICAgaWQ6IDB4MTg1MzgwNjcsXG4gICAgICAgICAgICAvLyBTZWdtZW50XG4gICAgICAgICAgICBzaXplOiAtMSxcbiAgICAgICAgICAgIC8vIFVuYm91bmRlZCBzaXplXG4gICAgICAgICAgICBkYXRhOiBbc2Vla0hlYWQsIHNlZ21lbnRJbmZvLCB0cmFja3NdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYnVmZmVyU3RyZWFtID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgyNTYpO1xuICAgICAgICAgIHdyaXRlRUJNTChidWZmZXJTdHJlYW0sIGJsb2JCdWZmZXIucG9zLCBbZWJtbEhlYWRlciwgZWJtbFNlZ21lbnRdKTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKGJ1ZmZlclN0cmVhbS5nZXRBc0RhdGFBcnJheSgpKTsgLy8gTm93IHdlIGtub3cgd2hlcmUgdGhlc2UgdG9wLWxldmVsIGVsZW1lbnRzIGxpZSBpbiB0aGUgZmlsZTpcblxuICAgICAgICAgIHNlZWtQb2ludHMuU2VnbWVudEluZm8ucG9zaXRpb25FQk1MLmRhdGEgPSBmaWxlT2Zmc2V0VG9TZWdtZW50UmVsYXRpdmUoc2VnbWVudEluZm8ub2Zmc2V0KTtcbiAgICAgICAgICBzZWVrUG9pbnRzLlRyYWNrcy5wb3NpdGlvbkVCTUwuZGF0YSA9IGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZSh0cmFja3Mub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgU2ltcGxlQmxvY2sga2V5ZnJhbWUgaGVhZGVyIHVzaW5nIHRoZXNlIGZpZWxkczpcbiAgICAgICAgICogICAgIHRpbWVjb2RlICAgIC0gVGltZSBvZiB0aGlzIGtleWZyYW1lXG4gICAgICAgICAqICAgICB0cmFja051bWJlciAtIFRyYWNrIG51bWJlciBmcm9tIDEgdG8gMTI2IChpbmNsdXNpdmUpXG4gICAgICAgICAqICAgICBmcmFtZSAgICAgICAtIFJhdyBmcmFtZSBkYXRhIHBheWxvYWQgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYW4gRUJNTCBlbGVtZW50LlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUtleWZyYW1lQmxvY2soa2V5ZnJhbWUpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyU3RyZWFtID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgxICsgMiArIDEpO1xuXG4gICAgICAgICAgaWYgKCEoa2V5ZnJhbWUudHJhY2tOdW1iZXIgPiAwICYmIGtleWZyYW1lLnRyYWNrTnVtYmVyIDwgMTI3KSkge1xuICAgICAgICAgICAgdGhyb3cgJ1RyYWNrTnVtYmVyIG11c3QgYmUgPiAwIGFuZCA8IDEyNyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnVmZmVyU3RyZWFtLndyaXRlRUJNTFZhckludChrZXlmcmFtZS50cmFja051bWJlcik7IC8vIEFsd2F5cyAxIGJ5dGUgc2luY2Ugd2UgbGltaXQgdGhlIHJhbmdlIG9mIHRyYWNrTnVtYmVyXG5cbiAgICAgICAgICBidWZmZXJTdHJlYW0ud3JpdGVVMTZCRShrZXlmcmFtZS50aW1lY29kZSk7IC8vIEZsYWdzIGJ5dGVcblxuICAgICAgICAgIGJ1ZmZlclN0cmVhbS53cml0ZUJ5dGUoMSA8PCA3IC8vIEtleWZyYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IDB4YTMsXG4gICAgICAgICAgICAvLyBTaW1wbGVCbG9ja1xuICAgICAgICAgICAgZGF0YTogW2J1ZmZlclN0cmVhbS5nZXRBc0RhdGFBcnJheSgpLCBrZXlmcmFtZS5mcmFtZV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBDbHVzdGVyIG5vZGUgdXNpbmcgdGhlc2UgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICB0aW1lY29kZSAgICAtIFN0YXJ0IHRpbWUgZm9yIHRoZSBjbHVzdGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgYW4gRUJNTCBlbGVtZW50LlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNsdXN0ZXIoY2x1c3Rlcikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogMHgxZjQzYjY3NSxcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweGU3LFxuICAgICAgICAgICAgICAvLyBUaW1lY29kZVxuICAgICAgICAgICAgICBkYXRhOiBNYXRoLnJvdW5kKGNsdXN0ZXIudGltZWNvZGUpXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDdWVQb2ludCh0cmFja0luZGV4LCBjbHVzdGVyVGltZSwgY2x1c3RlckZpbGVPZmZzZXQpIHtcbiAgICAgICAgICBjdWVzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IDB4YmIsXG4gICAgICAgICAgICAvLyBDdWVcbiAgICAgICAgICAgIGRhdGE6IFt7XG4gICAgICAgICAgICAgIGlkOiAweGIzLFxuICAgICAgICAgICAgICAvLyBDdWVUaW1lXG4gICAgICAgICAgICAgIGRhdGE6IGNsdXN0ZXJUaW1lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlkOiAweGI3LFxuICAgICAgICAgICAgICAvLyBDdWVUcmFja1Bvc2l0aW9uc1xuICAgICAgICAgICAgICBkYXRhOiBbe1xuICAgICAgICAgICAgICAgIGlkOiAweGY3LFxuICAgICAgICAgICAgICAgIC8vIEN1ZVRyYWNrXG4gICAgICAgICAgICAgICAgZGF0YTogdHJhY2tJbmRleFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgaWQ6IDB4ZjEsXG4gICAgICAgICAgICAgICAgLy8gQ3VlQ2x1c3RlclBvc2l0aW9uXG4gICAgICAgICAgICAgICAgZGF0YTogZmlsZU9mZnNldFRvU2VnbWVudFJlbGF0aXZlKGNsdXN0ZXJGaWxlT2Zmc2V0KVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgYSBDdWVzIGVsZW1lbnQgdG8gdGhlIGJsb2JTdHJlYW0gdXNpbmcgdGhlIGdsb2JhbCBgY3Vlc2AgYXJyYXkgb2YgQ3VlUG9pbnRzICh1c2UgYWRkQ3VlUG9pbnQoKSkuXG4gICAgICAgICAqIFRoZSBzZWVrIGVudHJ5IGZvciB0aGUgQ3VlcyBpbiB0aGUgU2Vla0hlYWQgaXMgdXBkYXRlZC5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUN1ZXMoKSB7XG4gICAgICAgICAgdmFyIGVibWwgPSB7XG4gICAgICAgICAgICBpZDogMHgxYzUzYmI2YixcbiAgICAgICAgICAgIGRhdGE6IGN1ZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjdWVzQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSgxNiArIGN1ZXMubGVuZ3RoICogMzIpOyAvLyBQcmV0dHkgY3J1ZGUgZXN0aW1hdGUgb2YgdGhlIGJ1ZmZlciBzaXplIHdlJ2xsIG5lZWRcblxuICAgICAgICAgIHdyaXRlRUJNTChjdWVzQnVmZmVyLCBibG9iQnVmZmVyLnBvcywgZWJtbCk7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShjdWVzQnVmZmVyLmdldEFzRGF0YUFycmF5KCkpOyAvLyBOb3cgd2Uga25vdyB3aGVyZSB0aGUgQ3VlcyBlbGVtZW50IGhhcyBlbmRlZCB1cCwgd2UgY2FuIHVwZGF0ZSB0aGUgU2Vla0hlYWRcblxuICAgICAgICAgIHNlZWtQb2ludHMuQ3Vlcy5wb3NpdGlvbkVCTUwuZGF0YSA9IGZpbGVPZmZzZXRUb1NlZ21lbnRSZWxhdGl2ZShlYm1sLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsdXNoIHRoZSBmcmFtZXMgaW4gdGhlIGN1cnJlbnQgY2x1c3RlckZyYW1lQnVmZmVyIG91dCB0byB0aGUgc3RyZWFtIGFzIGEgQ2x1c3Rlci5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiBmbHVzaENsdXN0ZXJGcmFtZUJ1ZmZlcigpIHtcbiAgICAgICAgICBpZiAoY2x1c3RlckZyYW1lQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBGaXJzdCB3b3JrIG91dCBob3cgbGFyZ2Ugb2YgYSBidWZmZXIgd2UgbmVlZCB0byBob2xkIHRoZSBjbHVzdGVyIGRhdGFcblxuXG4gICAgICAgICAgdmFyIHJhd0ltYWdlU2l6ZSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmF3SW1hZ2VTaXplICs9IGNsdXN0ZXJGcmFtZUJ1ZmZlcltpXS5mcmFtZS5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlckRhdGFTdHJlYW0ocmF3SW1hZ2VTaXplICsgY2x1c3RlckZyYW1lQnVmZmVyLmxlbmd0aCAqIDMyKSxcbiAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgMzIgYnl0ZXMgcGVyIFNpbXBsZUJsb2NrIGhlYWRlclxuICAgICAgICAgIGNsdXN0ZXIgPSBjcmVhdGVDbHVzdGVyKHtcbiAgICAgICAgICAgIHRpbWVjb2RlOiBNYXRoLnJvdW5kKGNsdXN0ZXJTdGFydFRpbWUpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJGcmFtZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2x1c3Rlci5kYXRhLnB1c2goY3JlYXRlS2V5ZnJhbWVCbG9jayhjbHVzdGVyRnJhbWVCdWZmZXJbaV0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cml0ZUVCTUwoYnVmZmVyLCBibG9iQnVmZmVyLnBvcywgY2x1c3Rlcik7XG4gICAgICAgICAgYmxvYkJ1ZmZlci53cml0ZShidWZmZXIuZ2V0QXNEYXRhQXJyYXkoKSk7XG4gICAgICAgICAgYWRkQ3VlUG9pbnQoREVGQVVMVF9UUkFDS19OVU1CRVIsIE1hdGgucm91bmQoY2x1c3RlclN0YXJ0VGltZSksIGNsdXN0ZXIub2Zmc2V0KTtcbiAgICAgICAgICBjbHVzdGVyRnJhbWVCdWZmZXIgPSBbXTtcbiAgICAgICAgICBjbHVzdGVyU3RhcnRUaW1lICs9IGNsdXN0ZXJEdXJhdGlvbjtcbiAgICAgICAgICBjbHVzdGVyRHVyYXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKCkge1xuICAgICAgICAgIC8vIERlcml2ZSBmcmFtZUR1cmF0aW9uIHNldHRpbmcgaWYgbm90IGFscmVhZHkgc3VwcGxpZWRcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuZnJhbWVEdXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnJhbWVSYXRlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBvcHRpb25zLmZyYW1lUmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93ICdNaXNzaW5nIHJlcXVpcmVkIGZyYW1lRHVyYXRpb24gb3IgZnJhbWVSYXRlIHNldHRpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEZyYW1lVG9DbHVzdGVyKGZyYW1lKSB7XG4gICAgICAgICAgZnJhbWUudHJhY2tOdW1iZXIgPSBERUZBVUxUX1RSQUNLX05VTUJFUjsgLy8gRnJhbWUgdGltZWNvZGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlaXIgY2x1c3RlcjpcblxuICAgICAgICAgIGZyYW1lLnRpbWVjb2RlID0gTWF0aC5yb3VuZChjbHVzdGVyRHVyYXRpb24pO1xuICAgICAgICAgIGNsdXN0ZXJGcmFtZUJ1ZmZlci5wdXNoKGZyYW1lKTtcbiAgICAgICAgICBjbHVzdGVyRHVyYXRpb24gKz0gZnJhbWUuZHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoY2x1c3RlckR1cmF0aW9uID49IE1BWF9DTFVTVEVSX0RVUkFUSU9OX01TRUMpIHtcbiAgICAgICAgICAgIGZsdXNoQ2x1c3RlckZyYW1lQnVmZmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXdyaXRlcyB0aGUgU2Vla0hlYWQgZWxlbWVudCB0aGF0IHdhcyBpbml0aWFsbHkgd3JpdHRlbiB0byB0aGUgc3RyZWFtIHdpdGggdGhlIG9mZnNldHMgb2YgdG9wIGxldmVsIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsIG9uY2Ugd3JpdGluZyBpcyBjb21wbGV0ZSAoc28gdGhlIG9mZnNldCBvZiBhbGwgdG9wIGxldmVsIGVsZW1lbnRzIGlzIGtub3duKS5cbiAgICAgICAgICovXG5cblxuICAgICAgICBmdW5jdGlvbiByZXdyaXRlU2Vla0hlYWQoKSB7XG4gICAgICAgICAgdmFyIHNlZWtIZWFkQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbShzZWVrSGVhZC5zaXplKSxcbiAgICAgICAgICAgICAgb2xkUG9zID0gYmxvYkJ1ZmZlci5wb3M7IC8vIFdyaXRlIHRoZSByZXdyaXR0ZW4gU2Vla0hlYWQgZWxlbWVudCdzIGRhdGEgcGF5bG9hZCB0byB0aGUgc3RyZWFtIChkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgaWQgb3Igc2l6ZSlcblxuICAgICAgICAgIHdyaXRlRUJNTChzZWVrSGVhZEJ1ZmZlciwgc2Vla0hlYWQuZGF0YU9mZnNldCwgc2Vla0hlYWQuZGF0YSk7IC8vIEFuZCB3cml0ZSB0aGF0IHRocm91Z2ggdG8gdGhlIGZpbGVcblxuICAgICAgICAgIGJsb2JCdWZmZXIuc2VlayhzZWVrSGVhZC5kYXRhT2Zmc2V0KTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKHNlZWtIZWFkQnVmZmVyLmdldEFzRGF0YUFycmF5KCkpO1xuICAgICAgICAgIGJsb2JCdWZmZXIuc2VlayhvbGRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXdyaXRlIHRoZSBEdXJhdGlvbiBmaWVsZCBvZiB0aGUgU2VnbWVudCB3aXRoIHRoZSBuZXdseS1kaXNjb3ZlcmVkIHZpZGVvIGR1cmF0aW9uLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIGZ1bmN0aW9uIHJld3JpdGVEdXJhdGlvbigpIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyRGF0YVN0cmVhbSg4KSxcbiAgICAgICAgICAgICAgb2xkUG9zID0gYmxvYkJ1ZmZlci5wb3M7IC8vIFJld3JpdGUgdGhlIGRhdGEgcGF5bG9hZCAoZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGlkIG9yIHNpemUpXG5cbiAgICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRShjbHVzdGVyU3RhcnRUaW1lKTsgLy8gQW5kIHdyaXRlIHRoYXQgdGhyb3VnaCB0byB0aGUgZmlsZVxuXG4gICAgICAgICAgYmxvYkJ1ZmZlci5zZWVrKHNlZ21lbnREdXJhdGlvbi5kYXRhT2Zmc2V0KTtcbiAgICAgICAgICBibG9iQnVmZmVyLndyaXRlKGJ1ZmZlci5nZXRBc0RhdGFBcnJheSgpKTtcbiAgICAgICAgICBibG9iQnVmZmVyLnNlZWsob2xkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgZnJhbWUgdG8gdGhlIHZpZGVvLiBDdXJyZW50bHkgdGhlIGZyYW1lIG11c3QgYmUgYSBDYW52YXMgZWxlbWVudC5cbiAgICAgICAgICovXG5cblxuICAgICAgICB0aGlzLmFkZEZyYW1lID0gZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgICAgIGlmICh3cml0dGVuSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9IHZpZGVvV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPSB2aWRlb0hlaWdodCkge1xuICAgICAgICAgICAgICB0aHJvdyAnRnJhbWUgc2l6ZSBkaWZmZXJzIGZyb20gcHJldmlvdXMgZnJhbWVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9XaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIHZpZGVvSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHdyaXRlSGVhZGVyKCk7XG4gICAgICAgICAgICB3cml0dGVuSGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2ViUCA9IHJlbmRlckFzV2ViUChjYW52YXMsIHtcbiAgICAgICAgICAgIHF1YWxpdHk6IG9wdGlvbnMucXVhbGl0eVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCF3ZWJQKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkbid0IGRlY29kZSBXZWJQIGZyYW1lLCBkb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgV2ViUD9cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRGcmFtZVRvQ2x1c3Rlcih7XG4gICAgICAgICAgICBmcmFtZTogZXh0cmFjdEtleWZyYW1lRnJvbVdlYlAod2ViUCksXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5mcmFtZUR1cmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5pc2ggd3JpdGluZyB0aGUgdmlkZW8gYW5kIHJldHVybiBhIFByb21pc2UgdG8gc2lnbmFsIGNvbXBsZXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBkZXN0aW5hdGlvbiBkZXZpY2Ugd2FzIG1lbW9yeSAoaS5lLiBvcHRpb25zLmZpbGVXcml0ZXIgd2FzIG5vdCBzdXBwbGllZCksIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkIHdpdGhcbiAgICAgICAgICogYSBCbG9iIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBlbnRpcmUgdmlkZW8uXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaENsdXN0ZXJGcmFtZUJ1ZmZlcigpO1xuICAgICAgICAgIHdyaXRlQ3VlcygpO1xuICAgICAgICAgIHJld3JpdGVTZWVrSGVhZCgpO1xuICAgICAgICAgIHJld3JpdGVEdXJhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBibG9iQnVmZmVyLmNvbXBsZXRlKCd2aWRlby93ZWJtJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRXcml0dGVuU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gYmxvYkJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZChvcHRpb25EZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucygpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGlzTm9kZUVudmlyb21lbnQpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gV2ViTVdyaXRlcihBcnJheUJ1ZmZlckRhdGFTdHJlYW0sIEJsb2JCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuV2ViTVdyaXRlciA9IFdlYk1Xcml0ZXIoQXJyYXlCdWZmZXJEYXRhU3RyZWFtLCBCbG9iQnVmZmVyKTtcbiAgICB9XG4gIH0pKCk7XG59KSh3ZWJtV3JpdGVyMF8yXzApO1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAhZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHQgPSB2b2lkIDAgIT09IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICBlID0gdCA/IHRhci5leHBvcnRzIDogd2luZG93LlRhcixcbiAgICAgICAgTSA9IHQgPyBkb3dubG9hZC5leHBvcnRzIDogd2luZG93LmRvd25sb2FkLFxuICAgICAgICBpID0gdCA/IGdpZi5HSUYgOiB3aW5kb3cuR0lGLFxuICAgICAgICBuID0gdCA/IHdlYm1Xcml0ZXIwXzJfMC5leHBvcnRzIDogd2luZG93LldlYk1Xcml0ZXIsXG4gICAgICAgIG8gPSB7XG4gICAgICBmdW5jdGlvbjogITAsXG4gICAgICBvYmplY3Q6ICEwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHIodCkge1xuICAgICAgcmV0dXJuIHQgJiYgdC5PYmplY3QgPT09IE9iamVjdCA/IHQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgYSA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgPyBleHBvcnRzIDogdm9pZCAwLFxuICAgICAgICBzID0gbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgPyBtb2R1bGUgOiB2b2lkIDAsXG4gICAgICAgIGMgPSBzICYmIHMuZXhwb3J0cyA9PT0gYSA/IGEgOiB2b2lkIDAsXG4gICAgICAgIGggPSByKGEgJiYgcyAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwpLFxuICAgICAgICBwID0gcihvW3R5cGVvZiBzZWxmXSAmJiBzZWxmKSxcbiAgICAgICAgbSA9IHIob1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpLFxuICAgICAgICBkID0gcihvW3R5cGVvZiB0aGlzXSAmJiB0aGlzKSxcbiAgICAgICAgdSA9IGggfHwgbSAhPT0gKGQgJiYgZC53aW5kb3cpICYmIG0gfHwgcCB8fCBkIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgICBmdW5jdGlvbiBsKHQpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoJzAwMDAwMDAnICsgdCkuc2xpY2UoLTcpO1xuICAgIH1cblxuICAgICdnYycgaW4gd2luZG93IHx8ICh3aW5kb3cuZ2MgPSBmdW5jdGlvbiAoKSB7fSksIEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0Jsb2IgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSwgJ3RvQmxvYicsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAodCwgZSwgaSkge1xuICAgICAgICBmb3IgKHZhciBuID0gYXRvYih0aGlzLnRvRGF0YVVSTChlLCBpKS5zcGxpdCgnLCcpWzFdKSwgbyA9IG4ubGVuZ3RoLCByID0gbmV3IFVpbnQ4QXJyYXkobyksIGEgPSAwOyBhIDwgbzsgYSsrKSByW2FdID0gbi5jaGFyQ29kZUF0KGEpO1xuXG4gICAgICAgIHQobmV3IEJsb2IoW3JdLCB7XG4gICAgICAgICAgdHlwZTogZSB8fCAnaW1hZ2UvcG5nJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgncGVyZm9ybWFuY2UnIGluIHdpbmRvdyA9PSAwICYmICh3aW5kb3cucGVyZm9ybWFuY2UgPSB7fSksIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9LCAnbm93JyBpbiB3aW5kb3cucGVyZm9ybWFuY2UgPT0gMCkge1xuICAgICAgICB2YXIgdCA9IERhdGUubm93KCk7XG4gICAgICAgIHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ICYmICh0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCksIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgVyA9IHdpbmRvdy5EYXRlLm5vdygpO1xuXG4gICAgZnVuY3Rpb24gZih0KSB7XG4gICAgICB2YXIgaSA9IHt9O1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHQsIHRoaXMub24gPSBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICBpW3RdID0gZTtcbiAgICAgIH0sIHRoaXMuZW1pdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gaVt0XTtcbiAgICAgICAgZSAmJiBlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgfSwgdGhpcy5maWxlbmFtZSA9IHQubmFtZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHQoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoNjU1MzYgKiAoMSArIE1hdGgucmFuZG9tKCkpKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQoKSArIHQoKSArICctJyArIHQoKSArICctJyArIHQoKSArICctJyArIHQoKSArICctJyArIHQoKSArIHQoKSArIHQoKTtcbiAgICAgIH0oKSwgdGhpcy5leHRlbnNpb24gPSAnJywgdGhpcy5taW1lVHlwZSA9ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHcodCkge1xuICAgICAgZi5jYWxsKHRoaXMsIHQpLCB0aGlzLmV4dGVuc2lvbiA9ICcudGFyJywgdGhpcy5taW1lVHlwZSA9ICdhcHBsaWNhdGlvbi94LXRhcicsIHRoaXMuZmlsZUV4dGVuc2lvbiA9ICcnLCB0aGlzLmJhc2VGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWUsIHRoaXMudGFwZSA9IG51bGwsIHRoaXMuY291bnQgPSAwLCB0aGlzLnBhcnQgPSAxLCB0aGlzLmZyYW1lcyA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24geih0KSB7XG4gICAgICB3LmNhbGwodGhpcywgdCksIHRoaXMudHlwZSA9ICdpbWFnZS9wbmcnLCB0aGlzLmZpbGVFeHRlbnNpb24gPSAnLnBuZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVSh0KSB7XG4gICAgICB3LmNhbGwodGhpcywgdCksIHRoaXMudHlwZSA9ICdpbWFnZS9qcGVnJywgdGhpcy5maWxlRXh0ZW5zaW9uID0gJy5qcGcnLCB0aGlzLnF1YWxpdHkgPSB0LnF1YWxpdHkgLyAxMDAgfHwgMC44O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF8odCkge1xuICAgICAgJ2ltYWdlL3dlYnAnICE9PSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS50b0RhdGFVUkwoJ2ltYWdlL3dlYnAnKS5zdWJzdHIoNSwgMTApICYmIGNvbnNvbGUubG9nKCdXZWJQIG5vdCBzdXBwb3J0ZWQgLSB0cnkgYW5vdGhlciBleHBvcnQgZm9ybWF0JyksIGYuY2FsbCh0aGlzLCB0KSwgdGhpcy5xdWFsaXR5ID0gdC5xdWFsaXR5IC8gMTAwIHx8IDAuOCwgdGhpcy5leHRlbnNpb24gPSAnLndlYm0nLCB0aGlzLm1pbWVUeXBlID0gJ3ZpZGVvL3dlYm0nLCB0aGlzLmJhc2VGaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWUsIHRoaXMuZnJhbWVyYXRlID0gdC5mcmFtZXJhdGUsIHRoaXMuZnJhbWVzID0gMCwgdGhpcy5wYXJ0ID0gMSwgdGhpcy52aWRlb1dyaXRlciA9IG5ldyBuKHtcbiAgICAgICAgcXVhbGl0eTogdGhpcy5xdWFsaXR5LFxuICAgICAgICBmaWxlV3JpdGVyOiBudWxsLFxuICAgICAgICBmZDogbnVsbCxcbiAgICAgICAgZnJhbWVSYXRlOiB0aGlzLmZyYW1lcmF0ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSCh0KSB7XG4gICAgICBmLmNhbGwodGhpcywgdCksIHQucXVhbGl0eSA9IHQucXVhbGl0eSAvIDEwMCB8fCAwLjgsIHRoaXMuZW5jb2RlciA9IG5ldyBGRk1wZWdTZXJ2ZXIuVmlkZW8odCksIHRoaXMuZW5jb2Rlci5vbigncHJvY2VzcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9jZXNzJyk7XG4gICAgICB9LmJpbmQodGhpcykpLCB0aGlzLmVuY29kZXIub24oJ2ZpbmlzaGVkJywgZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmNhbGxiYWNrO1xuICAgICAgICBpICYmICh0aGlzLmNhbGxiYWNrID0gdm9pZCAwLCBpKHQsIGUpKTtcbiAgICAgIH0uYmluZCh0aGlzKSksIHRoaXMuZW5jb2Rlci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLm9uUHJvZ3Jlc3MgJiYgdGhpcy5zZXR0aW5ncy5vblByb2dyZXNzKHQpO1xuICAgICAgfS5iaW5kKHRoaXMpKSwgdGhpcy5lbmNvZGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGFsZXJ0KEpTT04uc3RyaW5naWZ5KHQsIG51bGwsIDIpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVih0KSB7XG4gICAgICBmLmNhbGwodGhpcywgdCksIHRoaXMuZnJhbWVyYXRlID0gdGhpcy5zZXR0aW5ncy5mcmFtZXJhdGUsIHRoaXMudHlwZSA9ICd2aWRlby93ZWJtJywgdGhpcy5leHRlbnNpb24gPSAnLndlYm0nLCB0aGlzLnN0cmVhbSA9IG51bGwsIHRoaXMubWVkaWFSZWNvcmRlciA9IG51bGwsIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRyh0KSB7XG4gICAgICBmLmNhbGwodGhpcywgdCksIHQucXVhbGl0eSA9IDMxIC0gKDMwICogdC5xdWFsaXR5IC8gMTAwIHx8IDEwKSwgdC53b3JrZXJzID0gdC53b3JrZXJzIHx8IDQsIHRoaXMuZXh0ZW5zaW9uID0gJy5naWYnLCB0aGlzLm1pbWVUeXBlID0gJ2ltYWdlL2dpZicsIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdGhpcy5zaXplU2V0ID0gITEsIHRoaXMuZW5jb2RlciA9IG5ldyBpKHtcbiAgICAgICAgd29ya2VyczogdC53b3JrZXJzLFxuICAgICAgICBxdWFsaXR5OiB0LnF1YWxpdHksXG4gICAgICAgIHdvcmtlclNjcmlwdDogdC53b3JrZXJzUGF0aCArICdnaWYud29ya2VyLmpzJ1xuICAgICAgfSksIHRoaXMuZW5jb2Rlci5vbigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLm9uUHJvZ3Jlc3MgJiYgdGhpcy5zZXR0aW5ncy5vblByb2dyZXNzKHQpO1xuICAgICAgfS5iaW5kKHRoaXMpKSwgdGhpcy5lbmNvZGVyLm9uKCdmaW5pc2hlZCcsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5jYWxsYmFjaztcbiAgICAgICAgZSAmJiAodGhpcy5jYWxsYmFjayA9IHZvaWQgMCwgZSh0KSk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHkodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgbixcbiAgICAgICAgICBvLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgYyA9IHQgfHwge30sXG4gICAgICAgICAgaCA9IChbXSksXG4gICAgICAgICAgcCA9IFtdLFxuICAgICAgICAgIG0gPSAwLFxuICAgICAgICAgIGQgPSAwLFxuICAgICAgICAgIHUgPSBbXSxcbiAgICAgICAgICBsID0gITEsXG4gICAgICAgICAgZiA9IHt9O1xuICAgICAgYy5mcmFtZXJhdGUgPSBjLmZyYW1lcmF0ZSB8fCA2MCwgYy5tb3Rpb25CbHVyRnJhbWVzID0gMiAqIChjLm1vdGlvbkJsdXJGcmFtZXMgfHwgMSksIGUgPSBjLnZlcmJvc2UgfHwgITEsIGMuZGlzcGxheSwgYy5zdGVwID0gMWUzIC8gYy5mcmFtZXJhdGUsIGMudGltZUxpbWl0ID0gYy50aW1lTGltaXQgfHwgMCwgYy5mcmFtZUxpbWl0ID0gYy5mcmFtZUxpbWl0IHx8IDAsIGMuc3RhcnRUaW1lID0gYy5zdGFydFRpbWUgfHwgMDtcbiAgICAgIHZhciB3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJywgdy5zdHlsZS5sZWZ0ID0gdy5zdHlsZS50b3AgPSAwLCB3LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdibGFjaycsIHcuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnLCB3LnN0eWxlLmZvbnRTaXplID0gJzExcHgnLCB3LnN0eWxlLnBhZGRpbmcgPSAnNXB4Jywgdy5zdHlsZS5jb2xvciA9ICdyZWQnLCB3LnN0eWxlLnpJbmRleCA9IDFlNSwgYy5kaXNwbGF5ICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodyk7XG4gICAgICB2YXIgeSxcbiAgICAgICAgICBnLFxuICAgICAgICAgIHYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgICAgICBiID0gdi5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgUCgnU3RlcCBpcyBzZXQgdG8gJyArIGMuc3RlcCArICdtcycpO1xuICAgICAgdmFyIFQgPSB7XG4gICAgICAgIGdpZjogRyxcbiAgICAgICAgd2VibTogXyxcbiAgICAgICAgZmZtcGVnc2VydmVyOiBILFxuICAgICAgICBwbmc6IHosXG4gICAgICAgIGpwZzogVSxcbiAgICAgICAgJ3dlYm0tbWVkaWFyZWNvcmRlcic6IFZcbiAgICAgIH0sXG4gICAgICAgICAgRiA9IFRbYy5mb3JtYXRdO1xuICAgICAgaWYgKCFGKSB0aHJvdyAnRXJyb3I6IEluY29ycmVjdCBvciBtaXNzaW5nIGZvcm1hdDogVmFsaWQgZm9ybWF0cyBhcmUgJyArIE9iamVjdC5rZXlzKFQpLmpvaW4oJywgJyk7XG5cbiAgICAgIGlmICgocyA9IG5ldyBGKGMpKS5zdGVwID0gaSwgcy5vbigncHJvY2VzcycsIFIpLCBzLm9uKCdwcm9ncmVzcycsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICFmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHZhciBlID0gZlt0XTtcbiAgICAgICAgICBlICYmIGUuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0oJ3Byb2dyZXNzJywgdCk7XG4gICAgICB9KSwgJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT0gMCAmJiAod2luZG93LnBlcmZvcm1hbmNlID0ge30pLCBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgfSwgJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09IDApIHtcbiAgICAgICAgdmFyIHggPSBEYXRlLm5vdygpO1xuICAgICAgICBwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCAmJiAoeCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpLCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0geDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGsgPSB3aW5kb3cuc2V0VGltZW91dCxcbiAgICAgICAgICBTID0gd2luZG93LnNldEludGVydmFsLFxuICAgICAgICAgIEQgPSB3aW5kb3cuY2xlYXJJbnRlcnZhbCxcbiAgICAgICAgICBDID0gd2luZG93LmNsZWFyVGltZW91dCxcbiAgICAgICAgICBxID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgICBqID0gd2luZG93LkRhdGUubm93LFxuICAgICAgICAgIEkgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93LFxuICAgICAgICAgIE8gPSB3aW5kb3cuRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSxcbiAgICAgICAgICBCID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIEUoKSB7XG4gICAgICAgIGwgPSAhMSwgcy5zdG9wKCksIFAoJ0NhcHR1cmVyIHN0b3AnKSwgd2luZG93LnNldFRpbWVvdXQgPSBrLCB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBTLCB3aW5kb3cuY2xlYXJJbnRlcnZhbCA9IEQsIHdpbmRvdy5jbGVhclRpbWVvdXQgPSBDLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcSwgd2luZG93LkRhdGUucHJvdG90eXBlLmdldFRpbWUgPSBPLCB3aW5kb3cuRGF0ZS5ub3cgPSBqLCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gSTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gTCh0LCBlKSB7XG4gICAgICAgIGsodCwgMCwgZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICAgIEwoUik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFIoKSB7XG4gICAgICAgIHZhciB0ID0gMWUzIC8gYy5mcmFtZXJhdGUsXG4gICAgICAgICAgICBlID0gKG0gKyBkIC8gYy5tb3Rpb25CbHVyRnJhbWVzKSAqIHQ7XG4gICAgICAgIG4gPSBvICsgZSwgciA9IGEgKyBlLCBCLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB0Ll9ob29rZWRUaW1lID0gZSAvIDFlMztcbiAgICAgICAgfSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdCA9IG0gLyBjLmZyYW1lcmF0ZTtcbiAgICAgICAgICAoYy5mcmFtZUxpbWl0ICYmIG0gPj0gYy5mcmFtZUxpbWl0IHx8IGMudGltZUxpbWl0ICYmIHQgPj0gYy50aW1lTGltaXQpICYmIChFKCksIEEoKSk7XG4gICAgICAgICAgdmFyIGUgPSBuZXcgRGF0ZShudWxsKTtcbiAgICAgICAgICBlLnNldFNlY29uZHModCksIDIgPCBjLm1vdGlvbkJsdXJGcmFtZXMgPyB3LnRleHRDb250ZW50ID0gJ0NDYXB0dXJlICcgKyBjLmZvcm1hdCArICcgfCAnICsgbSArICcgZnJhbWVzICgnICsgZCArICcgaW50ZXIpIHwgJyArIGUudG9JU09TdHJpbmcoKS5zdWJzdHIoMTEsIDgpIDogdy50ZXh0Q29udGVudCA9ICdDQ2FwdHVyZSAnICsgYy5mb3JtYXQgKyAnIHwgJyArIG0gKyAnIGZyYW1lcyB8ICcgKyBlLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDExLCA4KTtcbiAgICAgICAgfSgpLCBQKCdGcmFtZTogJyArIG0gKyAnICcgKyBkKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGgubGVuZ3RoOyBpKyspIG4gPj0gaFtpXS50cmlnZ2VyVGltZSAmJiAoTChoW2ldLmNhbGxiYWNrKSwgaC5zcGxpY2UoaSwgMSkpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSBuID49IHBbaV0udHJpZ2dlclRpbWUgJiYgKEwocFtpXS5jYWxsYmFjayksIHBbaV0udHJpZ2dlclRpbWUgKz0gcFtpXS50aW1lKTtcblxuICAgICAgICB1LmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBMKHQsIG4gLSBXKTtcbiAgICAgICAgfSksIHUgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gQSh0KSB7XG4gICAgICAgIHQgfHwgKHQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBNKHQsIHMuZmlsZW5hbWUgKyBzLmV4dGVuc2lvbiwgcy5taW1lVHlwZSksICExO1xuICAgICAgICB9KSwgcy5zYXZlKHQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBQKHQpIHtcbiAgICAgICAgZSAmJiBjb25zb2xlLmxvZyh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAhZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvb2tlZCB8fCAodGhpcy5faG9va2VkID0gITAsIHRoaXMuX2hvb2tlZFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lIHx8IDAsIHRoaXMucGF1c2UoKSwgQi5wdXNoKHRoaXMpKSwgdGhpcy5faG9va2VkVGltZSArIGMuc3RhcnRUaW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQKCdDYXB0dXJlciBzdGFydCcpLCBvID0gd2luZG93LkRhdGUubm93KCksIG4gPSBvICsgYy5zdGFydFRpbWUsIGEgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksIHIgPSBhICsgYy5zdGFydFRpbWUsIHdpbmRvdy5EYXRlLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH0sIHdpbmRvdy5EYXRlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9LCB3aW5kb3cuc2V0VGltZW91dCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgICAgIHZhciBpID0ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0LFxuICAgICAgICAgICAgICAgIHRpbWU6IGUsXG4gICAgICAgICAgICAgICAgdHJpZ2dlclRpbWU6IG4gKyBlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBoLnB1c2goaSksIFAoJ1RpbWVvdXQgc2V0IHRvICcgKyBpLnRpbWUpLCBpO1xuICAgICAgICAgICAgfSwgd2luZG93LmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgaC5sZW5ndGg7IGUrKykgaFtlXSAhPSB0IHx8IChoLnNwbGljZShlLCAxKSwgUCgnVGltZW91dCBjbGVhcmVkJykpO1xuICAgICAgICAgICAgfSwgd2luZG93LnNldEludGVydmFsID0gZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgICAgdmFyIGkgPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IHQsXG4gICAgICAgICAgICAgICAgdGltZTogZSxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVGltZTogbiArIGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHAucHVzaChpKSwgUCgnSW50ZXJ2YWwgc2V0IHRvICcgKyBpLnRpbWUpLCBpO1xuICAgICAgICAgICAgfSwgd2luZG93LmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gUCgnY2xlYXIgSW50ZXJ2YWwnKSwgbnVsbDtcbiAgICAgICAgICAgIH0sIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICB1LnB1c2godCk7XG4gICAgICAgICAgICB9LCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZSwgJ2N1cnJlbnRUaW1lJywge1xuICAgICAgICAgICAgICAgIGdldDogdFxuICAgICAgICAgICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxBdWRpb0VsZW1lbnQucHJvdG90eXBlLCAnY3VycmVudFRpbWUnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiB0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgICBQKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oKSwgcy5zdGFydCgpLCBsID0gITA7XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmU6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgbCAmJiAoMiA8IGMubW90aW9uQmx1ckZyYW1lcyA/IChlID0gdCwgdi53aWR0aCA9PT0gZS53aWR0aCAmJiB2LmhlaWdodCA9PT0gZS5oZWlnaHQgfHwgKHYud2lkdGggPSBlLndpZHRoLCB2LmhlaWdodCA9IGUuaGVpZ2h0LCB5ID0gbmV3IFVpbnQxNkFycmF5KHYuaGVpZ2h0ICogdi53aWR0aCAqIDQpLCBiLmZpbGxTdHlsZSA9ICcjMCcsIGIuZmlsbFJlY3QoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpKSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGIuZHJhd0ltYWdlKHQsIDAsIDApLCBnID0gYi5nZXRJbWFnZURhdGEoMCwgMCwgdi53aWR0aCwgdi5oZWlnaHQpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHkubGVuZ3RoOyBlICs9IDQpIHlbZV0gKz0gZy5kYXRhW2VdLCB5W2UgKyAxXSArPSBnLmRhdGFbZSArIDFdLCB5W2UgKyAyXSArPSBnLmRhdGFbZSArIDJdO1xuXG4gICAgICAgICAgICBkKys7XG4gICAgICAgICAgfSh0KSwgZCA+PSAwLjUgKiBjLm1vdGlvbkJsdXJGcmFtZXMgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gZy5kYXRhLCBlID0gMDsgZSA8IHkubGVuZ3RoOyBlICs9IDQpIHRbZV0gPSAyICogeVtlXSAvIGMubW90aW9uQmx1ckZyYW1lcywgdFtlICsgMV0gPSAyICogeVtlICsgMV0gLyBjLm1vdGlvbkJsdXJGcmFtZXMsIHRbZSArIDJdID0gMiAqIHlbZSArIDJdIC8gYy5tb3Rpb25CbHVyRnJhbWVzO1xuXG4gICAgICAgICAgICBmb3IgKGIucHV0SW1hZ2VEYXRhKGcsIDAsIDApLCBzLmFkZCh2KSwgZCA9IDAsIFAoJ0Z1bGwgTUIgRnJhbWUhICcgKyArK20gKyAnICcgKyBuKSwgZSA9IDA7IGUgPCB5Lmxlbmd0aDsgZSArPSA0KSB5W2VdID0gMCwgeVtlICsgMV0gPSAwLCB5W2UgKyAyXSA9IDA7XG5cbiAgICAgICAgICAgIGdjKCk7XG4gICAgICAgICAgfSgpIDogaSgpKSA6IChzLmFkZCh0KSwgUCgnRnVsbCBGcmFtZSEgJyArICsrbSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogRSxcbiAgICAgICAgc2F2ZTogQSxcbiAgICAgICAgb246IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgZlt0XSA9IGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGYucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge30sIGYucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7fSwgZi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge30sIGYucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7fSwgZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHt9LCBmLnByb3RvdHlwZS5zYWZlVG9Qcm9jZWVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGYucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCBub3Qgc2V0IScpO1xuICAgIH0sICh3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH0sIHcucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50YXBlLmFwcGVuZChsKHRoaXMuY291bnQpICsgdGhpcy5maWxlRXh0ZW5zaW9uLCBuZXcgVWludDhBcnJheShlLnJlc3VsdCkpLCAwIDwgdGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUgJiYgdGhpcy5mcmFtZXMgLyB0aGlzLnNldHRpbmdzLmZyYW1lcmF0ZSA+PSB0aGlzLnNldHRpbmdzLmF1dG9TYXZlVGltZSA/IHRoaXMuc2F2ZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0aGlzLmJhc2VGaWxlbmFtZSArICctcGFydC0nICsgbCh0aGlzLnBhcnQpLCBNKHQsIHRoaXMuZmlsZW5hbWUgKyB0aGlzLmV4dGVuc2lvbiwgdGhpcy5taW1lVHlwZSk7XG4gICAgICAgICAgdmFyIGUgPSB0aGlzLmNvdW50O1xuICAgICAgICAgIHRoaXMuZGlzcG9zZSgpLCB0aGlzLmNvdW50ID0gZSArIDEsIHRoaXMucGFydCsrLCB0aGlzLmZpbGVuYW1lID0gdGhpcy5iYXNlRmlsZW5hbWUgKyAnLXBhcnQtJyArIGwodGhpcy5wYXJ0KSwgdGhpcy5mcmFtZXMgPSAwLCB0aGlzLnN0ZXAoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKSA6ICh0aGlzLmNvdW50KyssIHRoaXMuZnJhbWVzKyssIHRoaXMuc3RlcCgpKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZS5yZWFkQXNBcnJheUJ1ZmZlcih0KTtcbiAgICB9LCB3LnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHQodGhpcy50YXBlLnNhdmUoKSk7XG4gICAgfSwgdy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudGFwZSA9IG5ldyBlKCksIHRoaXMuY291bnQgPSAwO1xuICAgIH0sICh6LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUody5wcm90b3R5cGUpKS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdC50b0Jsb2IoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdy5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMudHlwZSk7XG4gICAgfSwgKFUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh3LnByb3RvdHlwZSkpLmFkZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0LnRvQmxvYihmdW5jdGlvbiAodCkge1xuICAgICAgICB3LnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB0KTtcbiAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy50eXBlLCB0aGlzLnF1YWxpdHkpO1xuICAgIH0sIChfLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5zdGFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9LCBfLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy52aWRlb1dyaXRlci5hZGRGcmFtZSh0KSwgMCA8IHRoaXMuc2V0dGluZ3MuYXV0b1NhdmVUaW1lICYmIHRoaXMuZnJhbWVzIC8gdGhpcy5zZXR0aW5ncy5mcmFtZXJhdGUgPj0gdGhpcy5zZXR0aW5ncy5hdXRvU2F2ZVRpbWUgPyB0aGlzLnNhdmUoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IHRoaXMuYmFzZUZpbGVuYW1lICsgJy1wYXJ0LScgKyBsKHRoaXMucGFydCksIE0odCwgdGhpcy5maWxlbmFtZSArIHRoaXMuZXh0ZW5zaW9uLCB0aGlzLm1pbWVUeXBlKSwgdGhpcy5kaXNwb3NlKCksIHRoaXMucGFydCsrLCB0aGlzLmZpbGVuYW1lID0gdGhpcy5iYXNlRmlsZW5hbWUgKyAnLXBhcnQtJyArIGwodGhpcy5wYXJ0KSwgdGhpcy5zdGVwKCk7XG4gICAgICB9LmJpbmQodGhpcykpIDogKHRoaXMuZnJhbWVzKyssIHRoaXMuc3RlcCgpKTtcbiAgICB9LCBfLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMudmlkZW9Xcml0ZXIuY29tcGxldGUoKS50aGVuKHQpO1xuICAgIH0sIF8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5mcmFtZXMgPSAwLCB0aGlzLnZpZGVvV3JpdGVyID0gbmV3IG4oe1xuICAgICAgICBxdWFsaXR5OiB0aGlzLnF1YWxpdHksXG4gICAgICAgIGZpbGVXcml0ZXI6IG51bGwsXG4gICAgICAgIGZkOiBudWxsLFxuICAgICAgICBmcmFtZVJhdGU6IHRoaXMuZnJhbWVyYXRlXG4gICAgICB9KTtcbiAgICB9LCAoSC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSkuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVuY29kZXIuc3RhcnQodGhpcy5zZXR0aW5ncyk7XG4gICAgfSwgSC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuZW5jb2Rlci5hZGQodCk7XG4gICAgfSwgSC5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gdCwgdGhpcy5lbmNvZGVyLmVuZCgpO1xuICAgIH0sIEgucHJvdG90eXBlLnNhZmVUb1Byb2NlZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVyLnNhZmVUb1Byb2NlZWQoKTtcbiAgICB9LCAoVi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSkuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuc3RyZWFtIHx8ICh0aGlzLnN0cmVhbSA9IHQuY2FwdHVyZVN0cmVhbSh0aGlzLmZyYW1lcmF0ZSksIHRoaXMubWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtKSwgdGhpcy5tZWRpYVJlY29yZGVyLnN0YXJ0KCksIHRoaXMubWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHQuZGF0YSk7XG4gICAgICB9LmJpbmQodGhpcykpLCB0aGlzLnN0ZXAoKTtcbiAgICB9LCBWLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHRoaXMubWVkaWFSZWNvcmRlci5vbnN0b3AgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IG5ldyBCbG9iKHRoaXMuY2h1bmtzLCB7XG4gICAgICAgICAgdHlwZTogJ3ZpZGVvL3dlYm0nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdLCBpKGUpO1xuICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLm1lZGlhUmVjb3JkZXIuc3RvcCgpO1xuICAgIH0sIChHLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZi5wcm90b3R5cGUpKS5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgdGhpcy5zaXplU2V0IHx8ICh0aGlzLmVuY29kZXIuc2V0T3B0aW9uKCd3aWR0aCcsIHQud2lkdGgpLCB0aGlzLmVuY29kZXIuc2V0T3B0aW9uKCdoZWlnaHQnLCB0LmhlaWdodCksIHRoaXMuc2l6ZVNldCA9ICEwKSwgdGhpcy5jYW52YXMud2lkdGggPSB0LndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0LmhlaWdodCwgdGhpcy5jdHguZHJhd0ltYWdlKHQsIDAsIDApLCB0aGlzLmVuY29kZXIuYWRkRnJhbWUodGhpcy5jdHgsIHtcbiAgICAgICAgY29weTogITAsXG4gICAgICAgIGRlbGF5OiB0aGlzLnNldHRpbmdzLnN0ZXBcbiAgICAgIH0pLCB0aGlzLnN0ZXAoKTtcbiAgICB9LCBHLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSB0LCB0aGlzLmVuY29kZXIucmVuZGVyKCk7XG4gICAgfSwgKG0gfHwgcCB8fCB7fSkuQ0NhcHR1cmUgPSB5LCBhICYmIHMgPyAoYyAmJiAoKHMuZXhwb3J0cyA9IHkpLkNDYXB0dXJlID0geSksIGEuQ0NhcHR1cmUgPSB5KSA6IHUuQ0NhcHR1cmUgPSB5O1xuICB9KCk7XG59KShDQ2FwdHVyZV9taW4kMiwgQ0NhcHR1cmVfbWluJDIuZXhwb3J0cyk7XG5cbnZhciBDQ2FwdHVyZV9taW4gPSBDQ2FwdHVyZV9taW4kMi5leHBvcnRzO1xuXG52YXIgQ0NhcHR1cmVfbWluJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSgvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbigvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKSwgQ0NhcHR1cmVfbWluJDIuZXhwb3J0cywge1xuICAnZGVmYXVsdCc6IENDYXB0dXJlX21pblxufSkpO1xuXG5leHBvcnQgeyBDQ2FwdHVyZV9taW4kMSBhcyBDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DQ2FwdHVyZS5taW4tMTY1NjA5ODguanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../react-swift/dist/CCapture.min-16560988.js\n");

/***/ }),

/***/ "../../react-swift/dist/_commonjsHelpers-1c8beb5f.js":
/*!***********************************************************!*\
  !*** ../../react-swift/dist/_commonjsHelpers-1c8beb5f.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": function() { return /* binding */ commonjsGlobal; }\n/* harmony export */ });\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\n//# sourceMappingURL=_commonjsHelpers-1c8beb5f.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvX2NvbW1vbmpzSGVscGVycy0xYzhiZWI1Zi5qcz8yZDYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFK0I7QUFDL0IiLCJmaWxlIjoiLi4vLi4vcmVhY3Qtc3dpZnQvZGlzdC9fY29tbW9uanNIZWxwZXJzLTFjOGJlYjVmLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmV4cG9ydCB7IGNvbW1vbmpzR2xvYmFsIGFzIGMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9jb21tb25qc0hlbHBlcnMtMWM4YmViNWYuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../react-swift/dist/_commonjsHelpers-1c8beb5f.js\n");

/***/ })

}]);