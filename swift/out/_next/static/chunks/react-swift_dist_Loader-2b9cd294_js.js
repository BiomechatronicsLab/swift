/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["react-swift_dist_Loader-2b9cd294_js"],{

/***/ "../../react-swift/dist/Loader-2b9cd294.js":
/*!*************************************************!*\
  !*** ../../react-swift/dist/Loader-2b9cd294.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-33fa60bf.js */ \"../../react-swift/dist/index-33fa60bf.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"../../react-swift/node_modules/react-dom/index.js\");\n\n\n\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * var mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  var materials = [];\n *  var nGeometryGroups = geometry.groups.length;\n *\n *  var colorMap = ...; // Some logic to index colors.\n *\n *  for (var i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tvar material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  var mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nvar STLLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nSTLLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: STLLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView( data );\n\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tvar reader = new DataView( data );\n\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar dataOffset = 84;\n\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tvar faceCounter = 0;\n\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tvar normal = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar result;\n\n\t\t\tvar groupCount = 0;\n\t\t\tvar startVertex = 0;\n\t\t\tvar endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar start = startVertex;\n\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tvar binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n} );\n\nvar GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t}\n\n\tGLTFLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar resourcePath;\n\n\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\tresourcePath = this.path;\n\n\t\t\t} else {\n\n\t\t\t\tresourcePath = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url );\n\n\t\t\t}\n\n\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t};\n\n\t\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t}, _onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t_onError( e );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, _onError );\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDDSLoader: function () {\n\n\t\t\tthrow new Error(\n\n\t\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t\t);\n\n\t\t},\n\n\t\tsetKTX2Loader: function ( ktx2Loader ) {\n\n\t\t\tthis.ktx2Loader = ktx2Loader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetMeshoptDecoder: function ( meshoptDecoder ) {\n\n\t\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\t\t\tvar plugins = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser( json, {\n\n\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\trequestHeader: this.requestHeader,\n\t\t\t\tmanager: this.manager,\n\t\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t\t} );\n\n\t\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\t\tfor ( var i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\t\tvar plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t\t// Remove this workaround if we move all the existing\n\t\t\t\t// extension handlers to plugin system\n\t\t\t\textensions[ plugin.name ] = true;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.setExtensions( extensions );\n\t\t\tparser.setPlugins( plugins );\n\t\t\tparser.parse( onLoad, onError );\n\n\t\t}\n\n\t} );\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\t\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\t\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n\t};\n\n\t/**\n\t * Punctual Lights Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t */\n\tfunction GLTFLightsExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\tGLTFLightsExtension.prototype._markDefs = function () {\n\n\t\tvar parser = this.parser;\n\t\tvar nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tGLTFLightsExtension.prototype._loadLight = function ( lightIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar cacheKey = 'light:' + lightIndex;\n\t\tvar dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tvar json = parser.json;\n\t\tvar extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tvar lightDefs = extensions.lights || [];\n\t\tvar lightDef = lightDefs[ lightIndex ];\n\t\tvar lightNode;\n\n\t\tvar color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__._( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Z( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Y( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t};\n\n\tGLTFLightsExtension.prototype.createNodeAttachment = function ( nodeIndex ) {\n\n\t\tvar self = this;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\t\tvar lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tvar lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Unlit Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t */\n\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Clearcoat Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t */\n\tfunction GLTFMaterialsClearcoatExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tmaterialParams.clearcoatNormalScale = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a( scale, - scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Transmission Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n\t * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n\t */\n\tfunction GLTFMaterialsTransmissionExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tGLTFMaterialsTransmissionExtension.prototype.getMaterialType = function ( materialIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.$;\n\n\t};\n\n\tGLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function ( materialIndex, materialParams ) {\n\n\t\tvar parser = this.parser;\n\t\tvar materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * BasisU Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n\t */\n\tfunction GLTFTextureBasisUExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tGLTFTextureBasisUExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ this.name ];\n\t\tvar source = json.images[ extension.source ];\n\t\tvar loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\t/**\n\t * WebP Texture Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n\t */\n\tfunction GLTFTextureWebPExtension( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tGLTFTextureWebPExtension.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar name = this.name;\n\t\tvar parser = this.parser;\n\t\tvar json = parser.json;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar extension = textureDef.extensions[ name ];\n\t\tvar source = json.images[ extension.source ];\n\n\t\tvar loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t};\n\n\tGLTFTextureWebPExtension.prototype.detectSupport = function () {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tvar image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t};\n\n\t/**\n\t* meshopt BufferView Compression Extension\n\t*\n\t* Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n\t*/\n\tfunction GLTFMeshoptCompression( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tGLTFMeshoptCompression.prototype.loadBufferView = function ( index ) {\n\n\t\tvar json = this.parser.json;\n\t\tvar bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tvar extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tvar buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tvar decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {\n\n\t\t\t\tvar byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tvar byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tvar count = extensionDef.count;\n\t\t\t\tvar stride = extensionDef.byteStride;\n\n\t\t\t\tvar result = new ArrayBuffer( count * stride );\n\t\t\t\tvar source = new Uint8Array( res[ 0 ], byteOffset, byteLength );\n\n\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\treturn result;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\t/* BINARY EXTENSION */\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tvar chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t */\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar json = this.json;\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\t\tvar attributeNormalizedMap = {};\n\t\tvar attributeTypeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Texture Transform Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t */\n\tfunction GLTFTextureTransformExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\n\t/**\n\t * A sub class of StandardMaterial with some of the functionality\n\t * changed via the `onBeforeCompile` callback\n\t * @pailhead\n\t */\n\n\tfunction GLTFMeshStandardSGMaterial( params ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.h.call( this );\n\n\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t//various chunks that need replacing\n\t\tvar specularMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar specularMapFragmentChunk = [\n\t\t\t'vec3 specularFactor = specular;',\n\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar glossinessMapFragmentChunk = [\n\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t'#endif'\n\t\t].join( '\\n' );\n\n\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t'PhysicalMaterial material;',\n\t\t\t'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',\n\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t'material.specularColor = specularFactor;',\n\t\t].join( '\\n' );\n\n\t\tvar uniforms = {\n\t\t\tspecular: { value: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().setHex( 0xffffff ) },\n\t\t\tglossiness: { value: 1 },\n\t\t\tspecularMap: { value: null },\n\t\t\tglossinessMap: { value: null }\n\t\t};\n\n\t\tthis._extraUniforms = uniforms;\n\n\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\tfor ( var uniformName in uniforms ) {\n\n\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t}\n\n\t\t\tshader.fragmentShader = shader.fragmentShader\n\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t};\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tspecular: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specular.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specular.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tspecularMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.specularMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.specularMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_SPECULARMAP;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossiness: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossiness.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossiness.value = v;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tglossinessMap: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn uniforms.glossinessMap.value;\n\n\t\t\t\t},\n\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\tuniforms.glossinessMap.value = v;\n\n\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\tthis.defines.USE_UV = '';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\t\t\t\t\t\tdelete this.defines.USE_UV;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tGLTFMeshStandardSGMaterial.prototype = Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype );\n\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.h.prototype.copy.call( this, source );\n\t\tthis.specularMap = source.specularMap;\n\t\tthis.specular.copy( source.specular );\n\t\tthis.glossinessMap = source.glossinessMap;\n\t\tthis.glossiness = source.glossiness;\n\t\tdelete this.metalness;\n\t\tdelete this.roughness;\n\t\tdelete this.metalnessMap;\n\t\tdelete this.roughnessMap;\n\t\treturn this;\n\n\t};\n\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'normalMapType',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn GLTFMeshStandardSGMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\tmaterialParams.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.emissive = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 0.0, 0.0, 0.0 );\n\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tmaterialParams.specular = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( materialParams ) {\n\n\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\t\t\tmaterial.fog = true;\n\n\t\t\t\tmaterial.color = materialParams.color;\n\n\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = materialParams.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\t\t\tmaterial.normalMapType = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.i;\n\n\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\t\t\tmaterial.specular = materialParams.specular;\n\n\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\t\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Mesh Quantization Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t */\n\tfunction GLTFMeshQuantizationExtension() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a0.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a0.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\t\tvar s0 = 1 - s2;\n\t\tvar s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a1,\n\t\t9729: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.m,\n\t\t9984: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a2,\n\t\t9985: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a3,\n\t\t9986: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a4,\n\t\t9987: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.n\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5,\n\t\t33648: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a6,\n\t\t10497: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTANGENT: 'tangent',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tJOINTS_0: 'skinIndex',\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\tLINEAR: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.J,\n\t\tSTEP: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a7\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial( cache ) {\n\n\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\t\tcache[ 'DefaultMaterial' ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.h( {\n\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\temissive: 0x000000,\n\t\t\t\tmetalness: 1,\n\t\t\t\troughness: 1,\n\t\t\t\ttransparent: false,\n\t\t\t\tdepthTest: true,\n\t\t\t\tside: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a8\n\t\t\t} );\n\n\t\t}\n\n\t\treturn cache[ 'DefaultMaterial' ];\n\n\t}\n\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @param {Object3D|Material|BufferGeometry} object\n\t * @param {GLTF.definition} gltfDef\n\t */\n\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\tvar pendingPositionAccessors = [];\n\t\tvar pendingNormalAccessors = [];\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( [\n\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\tPromise.all( pendingNormalAccessors )\n\t\t] ).then( function ( accessors ) {\n\n\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t\treturn geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\n\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\tvar geometryKey;\n\n\t\tif ( dracoExtension ) {\n\n\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t} else {\n\n\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t}\n\n\t\treturn geometryKey;\n\n\t}\n\n\tfunction createAttributesKey( attributes ) {\n\n\t\tvar attributesKey = '';\n\n\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t}\n\n\t\treturn attributesKey;\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\t\tif ( typeof createImageBitmap !== 'undefined' && /Firefox/.test( navigator.userAgent ) === false ) {\n\n\t\t\tthis.textureLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.I( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.j( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tGLTFParser.prototype.setExtensions = function ( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t};\n\n\tGLTFParser.prototype.setPlugins = function ( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t};\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tvar result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype._markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\tGLTFParser.prototype._addNodeRef = function ( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t};\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\tGLTFParser.prototype._getNodeRef = function ( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tvar ref = object.clone();\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t};\n\n\tGLTFParser.prototype._invokeOne = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t};\n\n\tGLTFParser.prototype._invokeAll = function ( func ) {\n\n\t\tvar extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tvar result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn Promise.resolve( null );\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.k( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.l( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureDef = json.textures[ textureIndex ];\n\t\tvar source = json.images[ textureDef.source ];\n\n\t\tvar loader = this.textureLoader;\n\n\t\tif ( source.uri ) {\n\n\t\t\tvar handler = options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, source, loader );\n\n\t};\n\n\tGLTFParser.prototype.loadTextureImage = function ( textureIndex, source, loader ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar URL = self.URL || self.webkitURL;\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\t\tvar hasAlpha = true;\n\n\t\tif ( source.mimeType === 'image/jpeg' ) hasAlpha = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tif ( source.mimeType === 'image/png' ) {\n\n\t\t\t\t\t// Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n\t\t\t\t\t// alpha channel. This check is conservative — the image could have an alpha\n\t\t\t\t\t// channel with all values == 1, and the indexed type (colorType == 3) only\n\t\t\t\t\t// sometimes contains alpha.\n\t\t\t\t\t//\n\t\t\t\t\t// https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n\t\t\t\t\tvar colorType = new DataView( bufferView, 25, 1 ).getUint8( 0, false );\n\t\t\t\t\thasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n\n\t\t\t\t}\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( source.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tvar onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tresolve( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a9( imageBitmap ) );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t// When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\t\t\tif ( ! hasAlpha ) texture.format = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.R;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.m;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.n;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\tparser.associations.set( texture, {\n\t\t\t\ttype: 'textures',\n\t\t\t\tindex: textureIndex\n\t\t\t} );\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\tvar parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tvar gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar material = mesh.material;\n\n\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P();\n\t\t\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\tif ( useVertexTangents ) {\n\n\t\t\t\t\tcachedMaterial.vertexTangents = true;\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\t// workarounds for mesh and geometry\n\n\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\tgeometry.setAttribute( 'uv2', geometry.attributes.uv );\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t};\n\n\tGLTFParser.prototype.getMaterialType = function ( /* materialIndex */ ) {\n\n\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.h;\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tmaterialParams.normalScale = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, - 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, - materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tmaterialParams.emissive = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { type: 'materials', index: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tGLTFParser.prototype.createUniqueName = function ( originalName ) {\n\n\t\tvar sanitizedName = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( originalName || '' );\n\n\t\tvar name = sanitizedName;\n\n\t\tfor ( var i = 1; this.nodeNamesUsed[ name ]; ++ i ) {\n\n\t\t\tname = sanitizedName + '_' + i;\n\n\t\t}\n\n\t\tthis.nodeNamesUsed[ name ] = true;\n\n\t\treturn name;\n\n\t};\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t */\n\tfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar box = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.af();\n\n\t\tif ( attributes.POSITION !== undefined ) {\n\n\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\t\tvar min = accessor.min;\n\t\t\tvar max = accessor.max;\n\n\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\tbox.set(\n\t\t\t\t\tnew _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\t\tnew _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V( max[ 0 ], max[ 1 ], max[ 2 ] ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar targets = primitiveDef.targets;\n\n\t\tif ( targets !== undefined ) {\n\n\t\t\tvar maxDisplacement = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vector = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\t\tvar min = accessor.min;\n\t\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\t\tbox.expandByVector( maxDisplacement );\n\n\t\t}\n\n\t\tgeometry.boundingBox = box;\n\n\t\tvar sphere = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ag();\n\n\t\tbox.getCenter( sphere.center );\n\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\t\tgeometry.boundingSphere = sphere;\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {GLTF.Primitive} primitiveDef\n\t * @param {GLTFParser} parser\n\t * @return {Promise<BufferGeometry>}\n\t */\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tvar pending = [];\n\n\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t} );\n\n\t\t\tpending.push( accessor );\n\n\t\t}\n\n\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\tcomputeBounds( geometry, primitiveDef, parser );\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t: geometry;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {Number} drawMode\n\t * @return {BufferGeometry}\n\t */\n\tfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\tvar index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tvar indices = [];\n\n\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar numberOfTriangles = index.count - 2;\n\t\tvar newIndices = [];\n\n\t\tif ( drawMode === _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aa ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tvar newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\n\t\treturn newGeometry;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar primitive = primitives[ i ];\n\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tvar geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\tvar primitives = meshDef.primitives;\n\n\t\tvar pending = [];\n\n\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tvar materials = results.slice( 0, results.length - 1 );\n\t\t\tvar geometries = results[ results.length - 1 ];\n\n\t\t\tvar meshes = [];\n\n\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tvar material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material )\n\t\t\t\t\t\t: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ab );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aa );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.y( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tvar group = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.A( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.O( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\tvar pendingNodes = [];\n\t\tvar pendingInputAccessors = [];\n\t\tvar pendingOutputAccessors = [];\n\t\tvar pendingSamplers = [];\n\t\tvar pendingTargets = [];\n\n\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tvar target = channel.target;\n\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tvar node = nodes[ i ];\n\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tnode.updateMatrix();\n\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ae;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ad;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tTypedKeyframeTrack = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ac;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.J;\n\n\t\t\t\tvar targetNames = [];\n\n\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t// Node may be a Group (glTF mesh with several primitives) or a Mesh.\n\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t}\n\n\t\t\t\tvar outputArray = outputAccessor.array;\n\n\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\tvar scale;\n\n\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 127;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\n\n\t\t\t\t\t\tscale = 1 / 255;\n\n\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 32767;\n\n\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\n\n\t\t\t\t\t\tscale = 1 / 65535;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\tinterpolation\n\t\t\t\t\t);\n\n\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.K( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar parser = this;\n\n\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tvar nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\treturn ( function () {\n\n\t\t\tvar pending = [];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\tvar node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t\t} ) );\n\n\t\t\t}\n\n\t\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t\t} ).forEach( function ( promise ) {\n\n\t\t\t\tpending.push( promise );\n\n\t\t\t} );\n\n\t\t\treturn Promise.all( pending );\n\n\t\t}() ).then( function ( objects ) {\n\n\t\t\tvar node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tparser.associations.set( node, { type: 'nodes', index: nodeIndex } );\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t// build skeleton here as well\n\n\t\t\t\tvar skinEntry;\n\n\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\tvar mat = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmesh.bind( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn node;\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t// build node hierachy\n\n\t\t\t\tparentObject.add( node );\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\tvar parser = this;\n\n\t\t\t// Loader returns Group, not Scene.\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\t\tvar scene = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n\nvar TGALoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nTGALoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: TGALoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttexture.image = scope.parse( buffer );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tparse: function ( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tvar pixel_data,\n\t\t\t\tpixel_size,\n\t\t\t\tpixel_total,\n\t\t\t\tpalettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar color, i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tvar i = 0, x, y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tvar x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tvar content = new Uint8Array( buffer ),\n\t\t\toffset = 0,\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\tcanvas.width = header.width;\n\t\tcanvas.height = header.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n} );\n\nvar ColladaLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nColladaLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: ColladaLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( scope.path === '' ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\toptions: {\n\n\t\tset convertUpAxis( value ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n\t\t}\n\n\t},\n\n\tparse: function ( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tvar array = [];\n\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\tvar array = new Array( parts.length );\n\n\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( var name in data ) {\n\n\t\t\t\tvar object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tvar hasChildren = false;\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tvar target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tvar parts = target.split( '/' );\n\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tvar indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar channels = data.channels;\n\t\t\tvar samplers = data.samplers;\n\t\t\tvar sources = data.sources;\n\n\t\t\tfor ( var target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tvar channel = channels[ target ];\n\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tvar inputSource = sources[ inputId ];\n\t\t\t\t\tvar outputSource = sources[ outputId ];\n\n\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tvar node = library.nodes[ channel.id ];\n\t\t\tvar object3D = getNode( node.id );\n\n\t\t\tvar transform = node.transforms[ channel.sid ];\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tvar time, stride;\n\t\t\tvar i, il, j, jl;\n\n\t\t\tvar data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tvar animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tvar keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( var time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar position = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar scale = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\tvar quaternion = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tvar keyframes = animation.keyframes;\n\t\t\tvar name = animation.name;\n\n\t\t\tvar times = [];\n\t\t\tvar positionData = [];\n\t\t\tvar quaternionData = [];\n\t\t\tvar scaleData = [];\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tvar time = keyframe.time;\n\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ad( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ac( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tvar keyframe;\n\n\t\t\tvar empty = true;\n\t\t\tvar i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tvar prev, next;\n\n\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar name = data.name;\n\t\t\tvar duration = ( data.end - data.start ) || - 1;\n\t\t\tvar animations = data.animations;\n\n\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.K( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tvar build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tvar geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\tvar build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\tvar v = vertexWeights.v;\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tvar stride = 0;\n\n\t\t\tvar i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\n\t\t\t\t\tvar skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tvar d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tvar name = jointSource.array[ i ];\n\t\t\t\tvar boneInverse = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tvar data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tvar sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tvar loader;\n\n\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tvar effect = getEffect( data.url );\n\t\t\tvar technique = effect.profile.technique;\n\t\t\tvar extra = effect.profile.extra;\n\n\t\t\tvar material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tvar image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tvar loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tvar texture = loader.load( image );\n\n\t\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\t\t\t\ttexture.wrapT = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar parameters = technique.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvar parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar transparent = parameters[ 'transparent' ];\n\t\t\tvar transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\tmaterial.side = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tvar camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.A(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.O(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.A();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tvar data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tvar light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__._();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Z();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Y();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.am();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tvar data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tvar id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tvar primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tvar set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tvar inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tvar build = {};\n\n\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tvar count = 0;\n\n\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertices = data.vertices;\n\t\t\tvar primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( var type in groupedPrimitives ) {\n\n\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar position = { array: [], stride: 0 };\n\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\tvar uv2 = { array: [], stride: 0 };\n\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\tvar materialKeys = [];\n\n\t\t\tvar start = 0;\n\n\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tvar primitive = primitives[ p ];\n\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( var name in inputs ) {\n\n\t\t\t\t\tvar input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( var key in vertices ) {\n\n\t\t\t\t\t\t\t\tvar id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\tvar indices = primitive.p;\n\t\t\tvar stride = primitive.stride;\n\t\t\tvar vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\n\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tvar data;\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tvar array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tvar visualScene = getVisualScene( visualSceneId );\n\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tvar jointMap = {};\n\n\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tvar axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tvar m0 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tvar transforms = [];\n\n\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar matrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar vector = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( array );\n\t\t\t\t\t\tvar angle = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tvar elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar matrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar vector = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tvar angle = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tvar instance = instances[ j ];\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tvar boneData = [];\n\t\t\tvar sortedBoneData = [];\n\n\t\t\tvar i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tvar skeleton = skeletons[ i ];\n\n\t\t\t\tvar root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tvar child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tvar root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tvar bones = [];\n\t\t\tvar boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.X( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tvar joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tvar matrix = data.matrix;\n\t\t\tvar nodes = data.nodes;\n\t\t\tvar type = data.type;\n\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\tvar instanceLights = data.instanceLights;\n\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceControllers[ i ];\n\t\t\t\tvar controller = getController( instance.id );\n\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tvar instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tvar object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.N() : new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tvar fallbackMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tvar materials = [];\n\n\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tvar objects = [];\n\n\t\t\tfor ( var type in geometries ) {\n\n\t\t\t\tvar geometry = geometries[ type ];\n\n\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tvar elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tvar group = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tgroup.name = data.name;\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tvar clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\tfor ( var id in library.animations ) {\n\n\t\t\t\t\t\tvar animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.K( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tvar result = '';\n\t\t\tvar stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tvar node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ai() };\n\n\t\t}\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tvar parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tvar errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tvar errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tvar version = collada.getAttribute( 'version' );\n\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tvar textureLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tvar tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\n\t\t//\n\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tscene.quaternion.setFromEuler( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj( - Math.PI / 2, 0, 0 ) );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n} );\n\nvar OBJLoader = ( function () {\n\n\t// o object_name | g group_name\n\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t// mtllib file_reference\n\tvar material_library_pattern = /^mtllib /;\n\t// usemtl material_name\n\tvar material_use_pattern = /^usemtl /;\n\t// usemap map_name\n\tvar map_use_pattern = /^usemap /;\n\n\tvar vA = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vB = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar vC = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar ab = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\tvar cb = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tfunction ParserState() {\n\n\t\tvar state = {\n\t\t\tobjects: [],\n\t\t\tobject: {},\n\n\t\t\tvertices: [],\n\t\t\tnormals: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\n\t\t\tmaterials: {},\n\t\t\tmaterialLibraries: [],\n\n\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname: name || '',\n\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\thasUVIndices: false\n\t\t\t\t\t},\n\t\t\t\t\tmaterials: [],\n\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t},\n\n\t\t\tfinalize: function () {\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t},\n\n\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexPoint: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t},\n\n\t\t\taddNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddFaceNormal: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tvA.fromArray( src, a );\n\t\t\t\tvB.fromArray( src, b );\n\t\t\t\tvC.fromArray( src, c );\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tcb.normalize();\n\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\t\t\t\tdst.push( cb.x, cb.y, cb.z );\n\n\t\t\t},\n\n\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tif ( src[ a ] !== undefined ) dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tif ( src[ b ] !== undefined ) dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tif ( src[ c ] !== undefined ) dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t\t},\n\n\t\t\taddDefaultUV: function () {\n\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\t\t\t\tdst.push( 0, 0 );\n\n\t\t\t},\n\n\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t\t},\n\n\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\n\t\t\t\tthis.addVertex( ia, ib, ic );\n\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t// normals\n\n\t\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\t\tvar nLen = this.normals.length;\n\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\t\t\t\t\tib = this.parseNormalIndex( nb, nLen );\n\t\t\t\t\tic = this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.addFaceNormal( ia, ib, ic );\n\n\t\t\t\t}\n\n\t\t\t\t// uvs\n\n\t\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\tthis.object.geometry.hasUVIndices = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// add placeholder values (for inconsistent face definitions)\n\n\t\t\t\t\tthis.addDefaultUV();\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tvar index = this.parseVertexIndex( vertices[ vi ], vLen );\n\n\t\t\t\t\tthis.addVertexPoint( index );\n\t\t\t\t\tthis.addColor( index );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject( '', false );\n\n\t\treturn state;\n\n\t}\n\n\t//\n\n\tfunction OBJLoader( manager ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t\tthis.materials = null;\n\n\t}\n\n\tOBJLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: OBJLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setRequestHeader( this.requestHeader );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetMaterials: function ( materials ) {\n\n\t\t\tthis.materials = materials;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar state = new ParserState();\n\n\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t\t}\n\n\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t\t}\n\n\t\t\tvar lines = text.split( '\\n' );\n\t\t\tvar line = '', lineFirstChar = '';\n\t\t\tvar lineLength = 0;\n\t\t\tvar result = [];\n\n\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tline = lines[ i ];\n\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\tlineLength = line.length;\n\n\t\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\t\tvar data = line.split( /\\s+/ );\n\n\t\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if no colors are defined, add placeholders so color and vertex indices match\n\n\t\t\t\t\t\t\t\tstate.colors.push( undefined, undefined, undefined );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\n\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar vertex = vertexData[ j ];\n\n\t\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\n\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\tvar v1 = faceVertices[ 0 ];\n\n\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar v2 = faceVertices[ j ];\n\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( ' ' );\n\t\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\t\tif ( line.indexOf( '/' ) === - 1 ) {\n\n\t\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( '/' );\n\n\t\t\t\t\t\t\tif ( parts[ 0 ] !== '' ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\t\tif ( parts[ 1 ] !== '' ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\tvar pointData = lineData.split( ' ' );\n\n\t\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// o object_name\n\t\t\t\t\t// or\n\t\t\t\t\t// g group_name\n\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\tvar name = ( ' ' + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\t\tstate.startObject( name );\n\n\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\n\n\t\t\t\t\t// mtl file\n\n\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t\t} else if ( map_use_pattern.test( line ) ) {\n\n\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t/*\n\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t * or\n\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t *\n\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t * than 0.\"\n\t\t\t\t\t */\n\t\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.finalize();\n\n\t\t\tvar container = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\t\tvar hasPrimitives = ! ( state.objects.length === 1 && state.objects[ 0 ].geometry.vertices.length === 0 );\n\n\t\t\tif ( hasPrimitives === true ) {\n\n\t\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = state.objects[ i ];\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\t\tvar buffergeometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.vertices, 3 ) );\n\n\t\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.hasUVIndices === true ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( geometry.uvs, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create materials\n\n\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tvar materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\t\tvar material = state.materials[ materialHash ];\n\n\t\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q ) ) {\n\n\t\t\t\t\t\t\t\tvar materialLine = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\t\t\t\t\t\t\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P ) ) {\n\n\t\t\t\t\t\t\t\tvar materialPoints = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.p.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q();\n\n\t\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.w( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\tcontainer.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n\t\t\t\tif ( state.vertices.length > 0 ) {\n\n\t\t\t\t\tvar material = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\tvar buffergeometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( state.vertices, 3 ) );\n\n\t\t\t\t\tif ( state.colors.length > 0 && state.colors[ 0 ] !== undefined ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( state.colors, 3 ) );\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar points = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( buffergeometry, material );\n\t\t\t\t\tcontainer.add( points );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn container;\n\n\t\t}\n\n\t} );\n\n\treturn OBJLoader;\n\n} )();\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n */\n\nvar MTLLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n};\n\nMTLLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: MTLLoader,\n\n\t/**\n\t * Loads and parses a MTL asset from a URL.\n\t *\n\t * @param {String} url - URL to the MTL file.\n\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t * @param {Function} [onProgress] - Callback for download progress.\n\t * @param {Function} [onError] - Callback for download errors.\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to load.\n\t */\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar path = ( this.path === '' ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : this.path;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetMaterialOptions: function ( value ) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Parses a MTL file.\n\t *\n\t * @param {String} text - Content of MTL file\n\t * @return {MTLLoader.MaterialCreator}\n\t *\n\t * @see setPath setResourcePath\n\t *\n\t * @note In order for relative texture references to resolve correctly\n\t * you must call setResourcePath() explicitly prior to parse.\n\t */\n\tparse: function ( text, path ) {\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t} else {\n\n\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\treturn materialCreator;\n\n\t}\n\n} );\n\n/**\n * Create a new MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a8;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n};\n\nMTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: MTLLoader.MaterialCreator,\n\n\tcrossOrigin: 'anonymous',\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetManager: function ( value ) {\n\n\t\tthis.manager = value;\n\n\t},\n\n\tsetMaterials: function ( materialsInfo ) {\n\n\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t},\n\n\tconvert: function ( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function ( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function () {\n\n\t\tvar index = 0;\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\tindex ++;\n\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\treturn '';\n\n\t\t\t// Absolute URL\n\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\treturn baseUrl + url;\n\n\t\t}\n\n\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[ mapType ] = map;\n\n\t\t}\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\t\t\tvar n;\n\n\t\t\tif ( value === '' ) continue;\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ke':\n\n\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\tparams.emissive = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType( 'map', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType( 'specularMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t// Emissive map\n\n\t\t\t\t\tsetMapForType( 'emissiveMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType( 'normalMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType( 'bumpMap', value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t// Alpha map\n\n\t\t\t\t\tsetMapForType( 'alphaMap', value );\n\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.materials[ materialName ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al( params );\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tgetTextureParams: function ( value, matParams ) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a( 1, 1 ),\n\t\t\toffset: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a( 0, 0 )\n\n\t\t };\n\n\t\tvar items = value.split( /\\s+/ );\n\t\tvar pos;\n\n\t\tpos = items.indexOf( '-bm' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\titems.splice( pos, 2 );\n\n\t\t}\n\n\t\tpos = items.indexOf( '-s' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\tpos = items.indexOf( '-o' );\n\n\t\tif ( pos >= 0 ) {\n\n\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t}\n\n\t\ttexParams.url = items.join( ' ' ).trim();\n\t\treturn texParams;\n\n\t},\n\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\tvar texture;\n\t\tvar manager = ( this.manager !== undefined ) ? this.manager : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.an;\n\t\tvar loader = manager.getHandler( url );\n\n\t\tif ( loader === null ) {\n\n\t\t\tloader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.j( manager );\n\n\t\t}\n\n\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t}\n\n};\n\n/*! chevrotain - v4.6.0 */\n!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"chevrotain\",[],e):\"object\"==typeof exports?exports.chevrotain=e():t.chevrotain=e();}(\"undefined\"!=typeof self?self:undefined,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},n.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=18)}([function(t,e,n){function r(t){return t&&0===t.length}function i(t){return null==t?[]:Object.keys(t)}function o(t){for(var e=[],n=Object.keys(t),r=0;r<n.length;r++)e.push(t[n[r]]);return e}function a(t,e){for(var n=[],r=i(t),o=0;o<r.length;o++){var a=r[o];n.push(e.call(null,t[a],a));}return n}function s(t,e){for(var n=[],r=0;r<t.length;r++)n.push(e.call(null,t[r],r));return n}function u(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];Array.isArray(r)?e=e.concat(u(r)):e.push(r);}return e}function c(t){return r(t)?void 0:t[0]}function p(t){var e=t&&t.length;return e?t[e-1]:void 0}function l(t,e){if(Array.isArray(t))for(var n=0;n<t.length;n++)e.call(null,t[n],n);else {if(!C(t))throw Error(\"non exhaustive match\");var r=i(t);for(n=0;n<r.length;n++){var o=r[n],a=t[o];e.call(null,a,o);}}}function h(t){return \"string\"==typeof t}function f(t){return void 0===t}function d(t){return t instanceof Function}function E(t,e){return void 0===e&&(e=1),t.slice(e,t.length)}function m(t,e){return void 0===e&&(e=1),t.slice(0,t.length-e)}function y(t,e){var n=[];if(Array.isArray(t))for(var r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function T(t,e){return y(t,function(t){return !e(t)})}function v(t,e){for(var n=Object.keys(t),r={},i=0;i<n.length;i++){var o=n[i],a=t[o];e(a)&&(r[o]=a);}return r}function g(t,e){return !!C(t)&&t.hasOwnProperty(e)}function _(t,e){return void 0!==N(t,function(t){return t===e})}function R(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n]);return e}function A(t){var e={};for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}function N(t,e){for(var n=0;n<t.length;n++){var r=t[n];if(e.call(null,r))return r}}function O(t,e){for(var n=[],r=0;r<t.length;r++){var i=t[r];e.call(null,i)&&n.push(i);}return n}function S(t,e,n){for(var r=Array.isArray(t),a=r?t:o(t),s=r?[]:i(t),u=n,c=0;c<a.length;c++)u=e.call(null,u,a[c],r?c:s[c]);return u}function I(t){return T(t,function(t){return null==t})}function L(t,e){void 0===e&&(e=function(t){return t});var n=[];return S(t,function(t,r){var i=e(r);return _(n,i)?t:(n.push(i),t.concat(r))},[])}function k(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];var r=[null].concat(e);return Function.bind.apply(t,r)}function P(t){return Array.isArray(t)}function x(t){return t instanceof RegExp}function C(t){return t instanceof Object}function M(t,e){for(var n=0;n<t.length;n++)if(!e(t[n],n))return !1;return !0}function F(t,e){return T(t,function(t){return _(e,t)})}function b(t,e){for(var n=0;n<t.length;n++)if(e(t[n]))return !0;return !1}function D(t,e){for(var n=0;n<t.length;n++)if(t[n]===e)return n;return -1}function w(t,e){var n=R(t);return n.sort(function(t,n){return e(t)-e(n)}),n}function U(t,e){if(t.length!==e.length)throw Error(\"can't zipObject with different number of keys and values!\");for(var n={},r=0;r<t.length;r++)n[t[r]]=e[r];return n}function G(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++)for(var o=e[r],a=i(o),s=0;s<a.length;s++){var u=a[s];t[u]=o[u];}return t}function B(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];for(var r=0;r<e.length;r++){var o=e[r];if(!f(o))for(var a=i(o),s=0;s<a.length;s++){var u=a[s];g(t,u)||(t[u]=o[u]);}}return t}function K(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return B.apply(null,[{}].concat(t))}function W(t,e){var n={};return l(t,function(t){var r=e(t),i=n[r];i?i.push(t):n[r]=[t];}),n}function j(t,e){for(var n=A(t),r=i(e),o=0;o<r.length;o++){var a=r[o],s=e[a];n[a]=s;}return n}function V(){}function Y(t){return t}function H(t){for(var e=[],n=0;n<t.length;n++){var r=t[n];e.push(void 0!==r?r:void 0);}return e}function X(t){console&&console.error&&console.error(\"Error: \"+t);}function z(t){console&&console.warn&&console.warn(\"Warning: \"+t);}function q(){return \"function\"==typeof Map}function $(t,e){e.forEach(function(e){var n=e.prototype;Object.getOwnPropertyNames(n).forEach(function(r){if(\"constructor\"!==r){var i=Object.getOwnPropertyDescriptor(n,r);i&&(i.get||i.set)?Object.defineProperty(t.prototype,r,i):t.prototype[r]=e.prototype[r];}});});}function Z(t){function e(){}e.prototype=t;var n=new e;function r(){return typeof n.bar}return r(),r(),t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.isEmpty=r,e.keys=i,e.values=o,e.mapValues=a,e.map=s,e.flatten=u,e.first=c,e.last=p,e.forEach=l,e.isString=h,e.isUndefined=f,e.isFunction=d,e.drop=E,e.dropRight=m,e.filter=y,e.reject=T,e.pick=v,e.has=g,e.contains=_,e.cloneArr=R,e.cloneObj=A,e.find=N,e.findAll=O,e.reduce=S,e.compact=I,e.uniq=L,e.partial=k,e.isArray=P,e.isRegExp=x,e.isObject=C,e.every=M,e.difference=F,e.some=b,e.indexOf=D,e.sortBy=w,e.zipObject=U,e.assign=G,e.assignNoOverwrite=B,e.defaults=K,e.groupBy=W,e.merge=j,e.NOOP=V,e.IDENTITY=Y,e.packArray=H,e.PRINT_ERROR=X,e.PRINT_WARNING=z,e.isES2015MapSupported=q,e.applyMixins=$,e.toFastProperties=Z;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(2),s=function(){function t(t){this.definition=t;}return t.prototype.accept=function(t){t.visit(this),o.forEach(this.definition,function(e){e.accept(t);});},t}();e.AbstractProduction=s;var u=function(t){function e(e){var n=t.call(this,[])||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),Object.defineProperty(e.prototype,\"definition\",{get:function(){return void 0!==this.referencedRule?this.referencedRule.definition:[]},set:function(t){},enumerable:!0,configurable:!0}),e.prototype.accept=function(t){t.visit(this);},e}(s);e.NonTerminal=u;var c=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.orgText=\"\",o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Rule=c;var p=function(t){function e(e){var n=t.call(this,e.definition)||this;return o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Flat=p;var l=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Option=l;var h=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatory=h;var f=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionMandatoryWithSeparator=f;var d=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Repetition=d;var E=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.RepetitionWithSeparator=E;var m=function(t){function e(e){var n=t.call(this,e.definition)||this;return n.idx=1,o.assign(n,o.pick(e,function(t){return void 0!==t})),n}return i(e,t),e}(s);e.Alternation=m;var y=function(){function t(t){this.idx=1,o.assign(this,o.pick(t,function(t){return void 0!==t}));}return t.prototype.accept=function(t){t.visit(this);},t}();function T(t){function e(t){return o.map(t,T)}if(t instanceof u)return {type:\"NonTerminal\",name:t.nonTerminalName,idx:t.idx};if(t instanceof p)return {type:\"Flat\",definition:e(t.definition)};if(t instanceof l)return {type:\"Option\",idx:t.idx,definition:e(t.definition)};if(t instanceof h)return {type:\"RepetitionMandatory\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof f)return {type:\"RepetitionMandatoryWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof E)return {type:\"RepetitionWithSeparator\",name:t.name,idx:t.idx,separator:T(new y({terminalType:t.separator})),definition:e(t.definition)};if(t instanceof d)return {type:\"Repetition\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof m)return {type:\"Alternation\",name:t.name,idx:t.idx,definition:e(t.definition)};if(t instanceof y){var n={type:\"Terminal\",name:a.tokenName(t.terminalType),label:a.tokenLabel(t.terminalType),idx:t.idx},r=t.terminalType.PATTERN;return t.terminalType.PATTERN&&(n.pattern=o.isRegExp(r)?r.source:r),n}if(t instanceof c)return {type:\"Rule\",name:t.name,orgText:t.orgText,definition:e(t.definition)};throw Error(\"non exhaustive match\")}e.Terminal=y,e.serializeGrammar=function(t){return o.map(t,T)},e.serializeProduction=T;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(15),a=n(7);function s(t){return r.isString(t.LABEL)&&\"\"!==t.LABEL}function u(t){return r.isObject(t)&&t.hasOwnProperty(\"tokenName\")&&r.isString(t.tokenName)?t.tokenName:i.functionName(t)}e.tokenLabel=function(t){return s(t)?t.LABEL:u(t)},e.hasTokenLabel=s,e.tokenName=u;var c=\"parent\",p=\"categories\",l=\"label\",h=\"group\",f=\"push_mode\",d=\"pop_mode\",E=\"longer_alt\",m=\"line_breaks\",y=\"start_chars_hint\";function T(t){return function(t){var e=t.name,n=t.pattern,o={};i.defineNameProp(o,e)||(o.tokenName=e);r.isUndefined(n)||(o.PATTERN=n);if(r.has(t,c))throw \"The parent property is no longer supported.\\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.\";r.has(t,p)&&(o.CATEGORIES=t[p]);a.augmentTokenTypes([o]),r.has(t,l)&&(o.LABEL=t[l]);r.has(t,h)&&(o.GROUP=t[h]);r.has(t,d)&&(o.POP_MODE=t[d]);r.has(t,f)&&(o.PUSH_MODE=t[f]);r.has(t,E)&&(o.LONGER_ALT=t[E]);r.has(t,m)&&(o.LINE_BREAKS=t[m]);r.has(t,y)&&(o.START_CHARS_HINT=t[y]);return o}(t)}e.createToken=T,e.EOF=T({name:\"EOF\",pattern:o.Lexer.NA}),a.augmentTokenTypes([e.EOF]),e.createTokenInstance=function(t,e,n,r,i,o,a,s){return {image:e,startOffset:n,endOffset:r,startLine:i,endLine:o,startColumn:a,endColumn:s,tokenTypeIdx:t.tokenTypeIdx,tokenType:t}},e.tokenMatcher=function(t,e){return a.tokenStructuredMatcher(t,e)};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(4),a=n(0),s=n(26),u=n(2),c=n(23),p=n(16),l=n(10),h=n(24),f=n(25),d=n(31),E=n(32),m=n(34),y=n(35),T=n(36),v=n(37),g=n(38);e.END_OF_FILE=u.createTokenInstance(u.EOF,\"\",NaN,NaN,NaN,NaN,NaN,NaN),Object.freeze(e.END_OF_FILE),e.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:4,ignoredIssues:{},dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:l.defaultParserErrorProvider,serializedGrammar:null}),e.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0}),function(t){t[t.INVALID_RULE_NAME=0]=\"INVALID_RULE_NAME\",t[t.DUPLICATE_RULE_NAME=1]=\"DUPLICATE_RULE_NAME\",t[t.INVALID_RULE_OVERRIDE=2]=\"INVALID_RULE_OVERRIDE\",t[t.DUPLICATE_PRODUCTIONS=3]=\"DUPLICATE_PRODUCTIONS\",t[t.UNRESOLVED_SUBRULE_REF=4]=\"UNRESOLVED_SUBRULE_REF\",t[t.LEFT_RECURSION=5]=\"LEFT_RECURSION\",t[t.NONE_LAST_EMPTY_ALT=6]=\"NONE_LAST_EMPTY_ALT\",t[t.AMBIGUOUS_ALTS=7]=\"AMBIGUOUS_ALTS\",t[t.CONFLICT_TOKENS_RULES_NAMESPACE=8]=\"CONFLICT_TOKENS_RULES_NAMESPACE\",t[t.INVALID_TOKEN_NAME=9]=\"INVALID_TOKEN_NAME\",t[t.INVALID_NESTED_RULE_NAME=10]=\"INVALID_NESTED_RULE_NAME\",t[t.DUPLICATE_NESTED_NAME=11]=\"DUPLICATE_NESTED_NAME\",t[t.NO_NON_EMPTY_LOOKAHEAD=12]=\"NO_NON_EMPTY_LOOKAHEAD\",t[t.AMBIGUOUS_PREFIX_ALTS=13]=\"AMBIGUOUS_PREFIX_ALTS\",t[t.TOO_MANY_ALTS=14]=\"TOO_MANY_ALTS\";}(e.ParserDefinitionErrorType||(e.ParserDefinitionErrorType={})),e.EMPTY_ALT=function(t){return void 0===t&&(t=void 0),function(){return t}};var _=function(){function t(t,n){void 0===n&&(n=e.DEFAULT_PARSER_CONFIG),this.ignoredIssues=e.DEFAULT_PARSER_CONFIG.ignoredIssues,this.definitionErrors=[],this.selfAnalysisDone=!1;this.initErrorHandler(n),this.initLexerAdapter(),this.initLooksAhead(n),this.initRecognizerEngine(t,n),this.initRecoverable(n),this.initTreeBuilder(n),this.initContentAssist(),this.ignoredIssues=a.has(n,\"ignoredIssues\")?n.ignoredIssues:e.DEFAULT_PARSER_CONFIG.ignoredIssues,a.toFastProperties(this);}return t.performSelfAnalysis=function(t){t.performSelfAnalysis();},t.prototype.performSelfAnalysis=function(){var e,n=this;this.selfAnalysisDone=!0;var r=o.classNameFromInstance(this),i=this.gastProductionsCache;if(this.serializedGrammar){var u=c.deserializeGrammar(this.serializedGrammar,this.tokensMap);a.forEach(u,function(t){n.gastProductionsCache.put(t.name,t);});}var f=h.resolveGrammar({rules:i.values()});if(this.definitionErrors.push.apply(this.definitionErrors,f),a.isEmpty(f)){var d=h.validateGrammar({rules:i.values(),maxLookahead:this.maxLookahead,tokenTypes:a.values(this.tokensMap),ignoredIssues:this.ignoredIssues,errMsgProvider:l.defaultGrammarValidatorErrorProvider,grammarName:r});this.definitionErrors.push.apply(this.definitionErrors,d);}if(a.isEmpty(this.definitionErrors)){var E=s.computeAllProdsFollows(i.values());this.resyncFollows=E;}var m=p.analyzeCst(i.values(),this.fullRuleNameToShort);if(this.allRuleNames=m.allRuleNames,!t.DEFER_DEFINITION_ERRORS_HANDLING&&!a.isEmpty(this.definitionErrors))throw e=a.map(this.definitionErrors,function(t){return t.message}),new Error(\"Parser Definition Errors detected:\\n \"+e.join(\"\\n-------------------------------\\n\"))},t.DEFER_DEFINITION_ERRORS_HANDLING=!1,t}();e.Parser=_,a.applyMixins(_,[f.Recoverable,d.LooksAhead,E.TreeBuilder,m.LexerAdapter,T.RecognizerEngine,y.RecognizerApi,v.ErrorHandler,g.ContentAssist]);var R=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!0,t.call(this,n,i)||this}return i(n,t),n}(_);e.CstParser=R;var A=function(t){function n(n,r){void 0===r&&(r=e.DEFAULT_PARSER_CONFIG);var i=a.cloneObj(r);return i.outputCst=!1,t.call(this,n,i)||this}return i(n,t),n}(_);e.EmbeddedActionsParser=A;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0);e.classNameFromInstance=function(t){return a(t.constructor)};var i=/^\\s*function\\s*(\\S*)\\s*\\(/,o=\"name\";function a(t){var e=t.name;return e||t.toString().match(i)[1]}e.functionName=a,e.defineNameProp=function(t,e){var n=Object.getOwnPropertyDescriptor(t,o);return !(!r.isUndefined(n)&&!n.configurable||(Object.defineProperty(t,o,{enumerable:!1,configurable:!0,writable:!1,value:e}),0))};var s=function(){function t(){this._state={};}return t.prototype.keys=function(){return r.keys(this._state)},t.prototype.values=function(){return r.values(this._state)},t.prototype.put=function(t,e){this._state[t]=e;},t.prototype.putAll=function(t){this._state=r.assign(this._state,t._state);},t.prototype.get=function(t){return this._state[t]},t.prototype.containsKey=function(t){return r.has(this._state,t)},t.prototype.clear=function(){this._state={};},t}();e.HashTable=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(1),i=function(){function t(){}return t.prototype.visit=function(t){if(t instanceof r.NonTerminal)return this.visitNonTerminal(t);if(t instanceof r.Flat)return this.visitFlat(t);if(t instanceof r.Option)return this.visitOption(t);if(t instanceof r.RepetitionMandatory)return this.visitRepetitionMandatory(t);if(t instanceof r.RepetitionMandatoryWithSeparator)return this.visitRepetitionMandatoryWithSeparator(t);if(t instanceof r.RepetitionWithSeparator)return this.visitRepetitionWithSeparator(t);if(t instanceof r.Repetition)return this.visitRepetition(t);if(t instanceof r.Alternation)return this.visitAlternation(t);if(t instanceof r.Terminal)return this.visitTerminal(t);if(t instanceof r.Rule)return this.visitRule(t);throw Error(\"non exhaustive match\")},t.prototype.visitNonTerminal=function(t){},t.prototype.visitFlat=function(t){},t.prototype.visitOption=function(t){},t.prototype.visitRepetition=function(t){},t.prototype.visitRepetitionMandatory=function(t){},t.prototype.visitRepetitionMandatoryWithSeparator=function(t){},t.prototype.visitRepetitionWithSeparator=function(t){},t.prototype.visitAlternation=function(t){},t.prototype.visitTerminal=function(t){},t.prototype.visitRule=function(t){},t}();e.GAstVisitor=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=\"MismatchedTokenException\",o=\"NoViableAltException\",a=\"EarlyExitException\",s=\"NotAllInputParsedException\",u=[i,o,a,s];function c(t,e,n){this.name=i,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function p(t,e,n){this.name=o,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}function l(t,e){this.name=s,this.message=t,this.token=e,this.resyncedTokens=[];}function h(t,e,n){this.name=a,this.message=t,this.token=e,this.previousToken=n,this.resyncedTokens=[];}Object.freeze(u),e.isRecognitionException=function(t){return r.contains(u,t.name)},e.MismatchedTokenException=c,c.prototype=Error.prototype,e.NoViableAltException=p,p.prototype=Error.prototype,e.NotAllInputParsedException=l,l.prototype=Error.prototype,e.EarlyExitException=h,h.prototype=Error.prototype;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(2);function a(t){for(var e=r.cloneArr(t),n=t,i=!0;i;){n=r.compact(r.flatten(r.map(n,function(t){return t.CATEGORIES})));var o=r.difference(n,e);e=e.concat(o),r.isEmpty(o)?i=!1:n=o;}return e}function s(t){r.forEach(t,function(t){l(t)||(e.tokenIdxToClass.put(e.tokenShortNameIdx,t),t.tokenTypeIdx=e.tokenShortNameIdx++),h(t)&&!r.isArray(t.CATEGORIES)&&(t.CATEGORIES=[t.CATEGORIES]),h(t)||(t.CATEGORIES=[]),f(t)||(t.categoryMatches=[]),d(t)||(t.categoryMatchesMap={}),E(t)||(t.tokenName=o.tokenName(t));});}function u(t){r.forEach(t,function(t){t.categoryMatches=[],r.forEach(t.categoryMatchesMap,function(n,r){t.categoryMatches.push(e.tokenIdxToClass.get(r).tokenTypeIdx);});});}function c(t){r.forEach(t,function(t){p([],t);});}function p(t,e){r.forEach(t,function(t){e.categoryMatchesMap[t.tokenTypeIdx]=!0;}),r.forEach(e.CATEGORIES,function(n){var i=t.concat(e);r.contains(i,n)||p(i,n);});}function l(t){return r.has(t,\"tokenTypeIdx\")}function h(t){return r.has(t,\"CATEGORIES\")}function f(t){return r.has(t,\"categoryMatches\")}function d(t){return r.has(t,\"categoryMatchesMap\")}function E(t){return r.has(t,\"tokenName\")}e.tokenStructuredMatcher=function(t,e){var n=t.tokenTypeIdx;return n===e.tokenTypeIdx||!0===e.isParent&&!0===e.categoryMatchesMap[n]},e.tokenStructuredMatcherNoCategories=function(t,e){return t.tokenTypeIdx===e.tokenTypeIdx},e.tokenShortNameIdx=1,e.tokenIdxToClass=new i.HashTable,e.augmentTokenTypes=function(t){var e=a(t);s(e),c(e),u(e),r.forEach(e,function(t){t.isParent=t.categoryMatches.length>0;});},e.expandCategories=a,e.assignTokenDefaultProps=s,e.assignCategoriesTokensProp=u,e.assignCategoriesMapProp=c,e.singleAssignCategoriesToksMap=p,e.hasShortKeyProperty=l,e.hasCategoriesProperty=h,e.hasExtendingTokensTypesProperty=f,e.hasExtendingTokensTypesMapProperty=d,e.hasTokenNameProperty=E,e.isTokenType=function(t){return r.has(t,\"tokenTypeIdx\")};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(1),s=n(5),u=n(2);e.isSequenceProd=function(t){return t instanceof a.Flat||t instanceof a.Option||t instanceof a.Repetition||t instanceof a.RepetitionMandatory||t instanceof a.RepetitionMandatoryWithSeparator||t instanceof a.RepetitionWithSeparator||t instanceof a.Terminal||t instanceof a.Rule},e.isOptionalProd=function t(e,n){return void 0===n&&(n=[]),!!(e instanceof a.Option||e instanceof a.Repetition||e instanceof a.RepetitionWithSeparator)||(e instanceof a.Alternation?o.some(e.definition,function(e){return t(e,n)}):!(e instanceof a.NonTerminal&&o.contains(n,e))&&e instanceof a.AbstractProduction&&(e instanceof a.NonTerminal&&n.push(e),o.every(e.definition,function(e){return t(e,n)})))},e.isBranchingProd=function(t){return t instanceof a.Alternation},e.getProductionDslName=function(t){if(t instanceof a.NonTerminal)return \"SUBRULE\";if(t instanceof a.Option)return \"OPTION\";if(t instanceof a.Alternation)return \"OR\";if(t instanceof a.RepetitionMandatory)return \"AT_LEAST_ONE\";if(t instanceof a.RepetitionMandatoryWithSeparator)return \"AT_LEAST_ONE_SEP\";if(t instanceof a.RepetitionWithSeparator)return \"MANY_SEP\";if(t instanceof a.Repetition)return \"MANY\";if(t instanceof a.Terminal)return \"CONSUME\";throw Error(\"non exhaustive match\")};var c=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.separator=\"-\",e.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},e}return i(e,t),e.prototype.visitTerminal=function(t){var e=u.tokenName(t.terminalType)+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitNonTerminal=function(t){var e=t.nonTerminalName+this.separator+\"Terminal\";o.has(this.dslMethods,e)||(this.dslMethods[e]=[]),this.dslMethods[e].push(t);},e.prototype.visitOption=function(t){this.dslMethods.option.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.dslMethods.repetitionWithSeparator.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.dslMethods.repetitionMandatory.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.dslMethods.repetitionMandatoryWithSeparator.push(t);},e.prototype.visitRepetition=function(t){this.dslMethods.repetition.push(t);},e.prototype.visitAlternation=function(t){this.dslMethods.alternation.push(t);},e}(s.GAstVisitor);e.DslMethodsCollectorVisitor=c;},function(t,e,n){function r(t,e,n){return n|e|t}Object.defineProperty(e,\"__esModule\",{value:!0}),e.BITS_FOR_METHOD_IDX=4,e.BITS_FOR_OCCURRENCE_IDX=4,e.BITS_FOR_RULE_IDX=24,e.BITS_FOR_ALT_IDX=8,e.OR_IDX=1<<e.BITS_FOR_METHOD_IDX,e.OPTION_IDX=2<<e.BITS_FOR_METHOD_IDX,e.MANY_IDX=3<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_IDX=4<<e.BITS_FOR_METHOD_IDX,e.MANY_SEP_IDX=5<<e.BITS_FOR_METHOD_IDX,e.AT_LEAST_ONE_SEP_IDX=6<<e.BITS_FOR_METHOD_IDX,e.getKeyForAutomaticLookahead=r;var i=32-e.BITS_FOR_ALT_IDX;e.getKeyForAltIndex=function(t,e,n,o){var a=o+1<<i;return r(t,e,n)|a};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(0),a=n(1),s=n(8),u=n(11),c=n(17),p=n(3);e.defaultParserErrorProvider={buildMismatchTokenMessage:function(t){var e=t.expected,n=t.actual;t.previous,t.ruleName;return \"Expecting \"+(r.hasTokenLabel(e)?\"--\\x3e \"+r.tokenLabel(e)+\" <--\":\"token of type --\\x3e \"+r.tokenName(e)+\" <--\")+\" but found --\\x3e '\"+n.image+\"' <--\"},buildNotAllInputParsedMessage:function(t){var e=t.firstRedundant;t.ruleName;return \"Redundant input, expecting EOF but found: \"+e.image},buildNoViableAltMessage:function(t){var e=t.expectedPathsPerAlt,n=t.actual,i=(t.previous,t.customUserDescription),a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");if(i)return \"Expecting: \"+i+a;var s=o.reduce(e,function(t,e){return t.concat(e)},[]),u=o.map(s,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\", \")+\"]\"});return \"Expecting: \"+(\"one of these possible Token sequences:\\n\"+o.map(u,function(t,e){return \"  \"+(e+1)+\". \"+t}).join(\"\\n\"))+a},buildEarlyExitMessage:function(t){var e=t.expectedIterationPaths,n=t.actual,i=t.customUserDescription,a=(t.ruleName,\"\\nbut found: '\"+o.first(n).image+\"'\");return i?\"Expecting: \"+i+a:\"Expecting: \"+(\"expecting at least one iteration which starts with one of these possible Token sequences::\\n  <\"+o.map(e,function(t){return \"[\"+o.map(t,function(t){return r.tokenLabel(t)}).join(\",\")+\"]\"}).join(\" ,\")+\">\")+a}},Object.freeze(e.defaultParserErrorProvider),e.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(t,e){return \"Invalid grammar, reference to a rule which is not defined: ->\"+e.nonTerminalName+\"<-\\ninside top level rule: ->\"+t.name+\"<-\"}},e.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(t,e){var n,i=t.name,u=o.first(e),c=u.idx,p=s.getProductionDslName(u),l=(n=u)instanceof a.Terminal?r.tokenName(n.terminalType):n instanceof a.NonTerminal?n.nonTerminalName:\"\",h=\"->\"+p+\"<- with numerical suffix: ->\"+c+\"<-\\n                  \"+(l?\"and argument: ->\"+l+\"<-\":\"\")+\"\\n                  appears more than once (\"+e.length+\" times) in the top level rule: ->\"+i+\"<-.\\n                  \"+(0===c?\"Also note that numerical suffix 0 means \"+p+\" without any suffix.\":\"\")+\"\\n                  To fix this make sure each usage of \"+p+\" \"+(l?\"with the argument: ->\"+l+\"<-\":\"\")+\"\\n                  in the rule ->\"+i+\"<- has a different occurrence index (0-5), as that combination acts as a unique\\n                  position key in the grammar, which is needed by the parsing engine.\\n                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";return h=(h=h.replace(/[ \\t]+/g,\" \")).replace(/\\s\\s+/g,\"\\n\")},buildInvalidNestedRuleNameError:function(t,e){return \"Invalid nested rule name: ->\"+e.name+\"<- inside rule: ->\"+t.name+\"<-\\nit must match the pattern: ->\"+u.validNestedRuleName.toString()+\"<-.\\nNote that this means a nested rule name must start with the '$'(dollar) sign.\"},buildDuplicateNestedRuleNameError:function(t,e){return \"Duplicate nested rule name: ->\"+o.first(e).name+\"<- inside rule: ->\"+t.name+\"<-\\nA nested name must be unique in the scope of a top level grammar rule.\"},buildNamespaceConflictError:function(t){return \"Namespace conflict found in grammar.\\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\"+t.name+\">.\\nTo resolve this make sure each Terminal and Non-Terminal names are unique\\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\nand Non-Terminal names start with a lower case letter.\"},buildAlternationPrefixAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx;return \"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> due to common lookahead prefix\\nin <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\nFor Further details.\"},buildAlternationAmbiguityError:function(t){var e=o.map(t.prefixPath,function(t){return r.tokenLabel(t)}).join(\", \"),n=0===t.alternation.idx?\"\":t.alternation.idx,i=\"Ambiguous alternatives: <\"+t.ambiguityIndices.join(\" ,\")+\"> in <OR\"+n+\"> inside <\"+t.topLevelRule.name+\"> Rule,\\n<\"+e+\"> may appears as a prefix path in all these alternatives.\\n\",a=c.VERSION.replace(/\\./g,\"_\");return i=i+\"To Resolve this, try one of of the following: \\n1. Refactor your grammar to be LL(K) for the current value of k (by default k=\"+p.DEFAULT_PARSER_CONFIG.maxLookahead+\"})\\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/\"+a+\"/interfaces/iparserconfig.html#ignoredissues for more details\\n\"},buildEmptyRepetitionError:function(t){var e=s.getProductionDslName(t.repetition);return 0!==t.repetition.idx&&(e+=t.repetition.idx),\"The repetition <\"+e+\"> within Rule <\"+t.topLevelRule.name+\"> can never consume any tokens.\\nThis could lead to an infinite loop.\"},buildTokenNameError:function(t){return \"Invalid Grammar Token name: ->\"+r.tokenName(t.tokenType)+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildEmptyAlternationError:function(t){return \"Ambiguous empty alternative: <\"+(t.emptyChoiceIdx+1)+\"> in <OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\nOnly the last alternative may be an empty alternative.\"},buildTooManyAlternativesError:function(t){return \"An Alternation cannot have more than 256 alternatives:\\n<OR\"+t.alternation.idx+\"> inside <\"+t.topLevelRule.name+\"> Rule.\\n has \"+(t.alternation.definition.length+1)+\" alternatives.\"},buildLeftRecursionError:function(t){var e=t.topLevelRule.name;return \"Left Recursion found in grammar.\\nrule: <\"+e+\"> can be invoked from itself (directly or indirectly)\\nwithout consuming any Tokens. The grammar path that causes this is: \\n \"+(e+\" --\\x3e \"+i.map(t.leftRecursionPath,function(t){return t.name}).concat([e]).join(\" --\\x3e \"))+\"\\n To fix this refactor your grammar to remove the left recursion.\\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\"},buildInvalidRuleNameError:function(t){return \"Invalid grammar rule name: ->\"+t.topLevelRule.name+\"<- it must match the pattern: ->\"+t.expectedPattern.toString()+\"<-\"},buildDuplicateRuleNameError:function(t){return \"Duplicate definition, rule: ->\"+(t.topLevelRule instanceof a.Rule?t.topLevelRule.name:t.topLevelRule)+\"<- is already defined in the grammar: ->\"+t.grammarName+\"<-\"}};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(0),s=n(3),u=n(8),c=n(2),p=n(12),l=n(16),h=n(13),f=n(1),d=n(5);function E(t){return u.getProductionDslName(t)+\"_#_\"+t.idx+\"_#_\"+m(t)}function m(t){return t instanceof f.Terminal?c.tokenName(t.terminalType):t instanceof f.NonTerminal?t.nonTerminalName:\"\"}e.validateGrammar=function(t,e,n,r,i,p){var h=o.map(t,function(t){return function(t,e){var n=new y;t.accept(n);var r=n.allProductions,i=o.groupBy(r,E),a=o.pick(i,function(t){return t.length>1});return o.map(o.values(a),function(n){var r=o.first(n),i=e.buildDuplicateFoundError(t,n),a=u.getProductionDslName(r),c={message:i,type:s.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:t.name,dslName:a,occurrence:r.idx},p=m(r);return p&&(c.parameter=p),c})}(t,i)}),f=o.map(t,function(t){return R(t,t,i)}),d=[],A=[],N=[];a.every(f,a.isEmpty)&&(d=a.map(t,function(t){return O(t,i)}),A=a.map(t,function(t){return S(t,e,r,i)}),N=k(t,e,i));var I=function(t,e,n){var r=[],i=a.map(e,function(t){return c.tokenName(t)});return a.forEach(t,function(t){var e=t.name;if(a.contains(i,e)){var o=n.buildNamespaceConflictError(t);r.push({message:o,type:s.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:e});}}),r}(t,n,i),P=o.map(n,function(t){return g(t,i)}),x=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.map(r.result,function(t){return t.orgProd});n.push(a.map(i,function(n){return v(t,n,e)}));}),a.flatten(n)}(t,i),C=function(t,e){var n=[];return a.forEach(t,function(t){var r=new l.NamedDSLMethodsCollectorVisitor(\"\");t.accept(r);var i=a.groupBy(r.result,function(t){return t.name}),o=a.pick(i,function(t){return t.length>1});a.forEach(a.values(o),function(r){var i=a.map(r,function(t){return t.orgProd}),o=e.buildDuplicateNestedRuleNameError(t,i);n.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,ruleName:t.name});});}),n}(t,i),M=a.map(t,function(t){return L(t,i)}),F=a.map(t,function(t){return T(t,i)}),b=a.map(t,function(e){return _(e,t,p,i)});return o.flatten(h.concat(P,x,C,N,f,d,A,I,M,F,b))},e.identifyProductionForDuplicates=E;var y=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitNonTerminal=function(t){this.allProductions.push(t);},e.prototype.visitOption=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e.prototype.visitAlternation=function(t){this.allProductions.push(t);},e.prototype.visitTerminal=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function T(t,n){var r=[],i=t.name;return i.match(e.validTermsPattern)||r.push({message:n.buildInvalidRuleNameError({topLevelRule:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_RULE_NAME,ruleName:i}),r}function v(t,n,r){var i,o=[];return n.name.match(e.validNestedRuleName)||(i=r.buildInvalidNestedRuleNameError(t,n),o.push({message:i,type:s.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,ruleName:t.name})),o}function g(t,n){var r=[];return c.tokenName(t).match(e.validTermsPattern)||r.push({message:n.buildTokenNameError({tokenType:t,expectedPattern:e.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_TOKEN_NAME}),r}function _(t,e,n,r){var i=[];if(a.reduce(e,function(e,n){return n.name===t.name?e+1:e},0)>1){var o=r.buildDuplicateRuleNameError({topLevelRule:t,grammarName:n});i.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t.name});}return i}function R(t,e,n,r){void 0===r&&(r=[]);var i=[],a=A(e.definition);if(o.isEmpty(a))return [];var u=t.name;o.contains(a,t)&&i.push({message:n.buildLeftRecursionError({topLevelRule:t,leftRecursionPath:r}),type:s.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:u});var c=o.difference(a,r.concat([t])),p=o.map(c,function(e){var i=o.cloneArr(r);return i.push(e),R(t,e,n,i)});return i.concat(o.flatten(p))}function A(t){var e=[];if(o.isEmpty(t))return e;var n=o.first(t);if(n instanceof f.NonTerminal)e.push(n.referencedRule);else if(n instanceof f.Flat||n instanceof f.Option||n instanceof f.RepetitionMandatory||n instanceof f.RepetitionMandatoryWithSeparator||n instanceof f.RepetitionWithSeparator||n instanceof f.Repetition)e=e.concat(A(n.definition));else if(n instanceof f.Alternation)e=o.flatten(o.map(n.definition,function(t){return A(t.definition)}));else if(!(n instanceof f.Terminal))throw Error(\"non exhaustive match\");var r=u.isOptionalProd(n),i=t.length>1;if(r&&i){var a=o.drop(t);return e.concat(A(a))}return e}e.OccurrenceValidationCollector=y,e.validTermsPattern=/^[a-zA-Z_]\\w*$/,e.validNestedRuleName=new RegExp(e.validTermsPattern.source.replace(\"^\",\"^\\\\$\")),e.validateRuleName=T,e.validateNestedRuleName=v,e.validateTokenName=g,e.validateRuleDoesNotAlreadyExist=_,e.validateRuleIsOverridden=function(t,e,n){var r,i=[];return o.contains(e,t)||(r=\"Invalid rule override, rule: ->\"+t+\"<- cannot be overridden in the grammar: ->\"+n+\"<-as it is not defined in any of the super grammars \",i.push({message:r,type:s.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:t})),i},e.validateNoLeftRecursion=R,e.getFirstNoneTerminal=A;var N=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.alternations=[],e}return i(e,t),e.prototype.visitAlternation=function(t){this.alternations.push(t);},e}(d.GAstVisitor);function O(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){var i=o.dropRight(r.definition),a=o.map(i,function(n,i){var a=h.nextPossibleTokensAfter([n],[],null,1);return o.isEmpty(a)?{message:e.buildEmptyAlternationError({topLevelRule:t,alternation:r,emptyChoiceIdx:i}),type:s.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:t.name,occurrence:r.idx,alternative:i+1}:null});return n.concat(o.compact(a))},[])}function S(t,e,n,r){var i=new N;t.accept(i);var c=i.alternations,l=n[t.name];return l&&(c=a.reject(c,function(t){return l[u.getProductionDslName(t)+(0===t.idx?\"\":t.idx)]})),o.reduce(c,function(n,i){var u=i.idx,c=p.getLookaheadPathsForOr(u,t,e),l=function(t,e,n,r){var i=[],u=a.reduce(t,function(e,n,r){return a.forEach(n,function(n){var o=[r];a.forEach(t,function(t,e){r!==e&&p.containsPath(t,n)&&o.push(e);}),o.length>1&&!p.containsPath(i,n)&&(i.push(n),e.push({alts:o,path:n}));}),e},[]);return o.map(u,function(t){var i=a.map(t.alts,function(t){return t+1}),o=r.buildAlternationAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path});return {message:o,type:s.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:n.name,occurrence:e.idx,alternatives:[t.alts]}})}(c,i,t,r),h=P(c,i,t,r);return n.concat(l,h)},[])}e.validateEmptyOrAlternative=O,e.validateAmbiguousAlternationAlternatives=S;var I=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.allProductions=[],e}return i(e,t),e.prototype.visitRepetitionWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatory=function(t){this.allProductions.push(t);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.allProductions.push(t);},e.prototype.visitRepetition=function(t){this.allProductions.push(t);},e}(d.GAstVisitor);function L(t,e){var n=new N;t.accept(n);var r=n.alternations;return o.reduce(r,function(n,r){return r.definition.length>255&&n.push({message:e.buildTooManyAlternativesError({topLevelRule:t,alternation:r}),type:s.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:t.name,occurrence:r.idx}),n},[])}function k(t,e,n){var r=[];return a.forEach(t,function(t){var i=new I;t.accept(i);var o=i.allProductions;a.forEach(o,function(i){var o=p.getProdType(i),u=i.idx,c=p.getLookaheadPathsForOptionalProd(u,t,o,e)[0];if(a.isEmpty(a.flatten(c))){var l=n.buildEmptyRepetitionError({topLevelRule:t,repetition:i});r.push({message:l,type:s.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:t.name});}});}),r}function P(t,e,n,r){var i=[],o=a.reduce(t,function(t,e,n){var r=a.map(e,function(t){return {idx:n,path:t}});return t.concat(r)},[]);return a.forEach(o,function(t){var u=t.idx,c=t.path,l=a.findAll(o,function(t){return t.idx<u&&p.isStrictPrefixOfPath(t.path,c)}),h=a.map(l,function(t){var i=[t.idx+1,u+1],o=0===e.idx?\"\":e.idx;return {message:r.buildAlternationPrefixAmbiguityError({topLevelRule:n,alternation:e,ambiguityIndices:i,prefixPath:t.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:n.name,occurrence:o,alternatives:i}});i=i.concat(h);}),i}e.RepetionCollector=I,e.validateTooManyAlts=L,e.validateSomeNonEmptyLookaheadPath=k,e.checkPrefixAlternativesAmbiguities=P;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o,a=n(0),s=n(13),u=n(14),c=n(7),p=n(1),l=n(5);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.REPETITION=1]=\"REPETITION\",t[t.REPETITION_MANDATORY=2]=\"REPETITION_MANDATORY\",t[t.REPETITION_MANDATORY_WITH_SEPARATOR=3]=\"REPETITION_MANDATORY_WITH_SEPARATOR\",t[t.REPETITION_WITH_SEPARATOR=4]=\"REPETITION_WITH_SEPARATOR\",t[t.ALTERNATION=5]=\"ALTERNATION\";}(o=e.PROD_TYPE||(e.PROD_TYPE={})),e.getProdType=function(t){if(t instanceof p.Option)return o.OPTION;if(t instanceof p.Repetition)return o.REPETITION;if(t instanceof p.RepetitionMandatory)return o.REPETITION_MANDATORY;if(t instanceof p.RepetitionMandatoryWithSeparator)return o.REPETITION_MANDATORY_WITH_SEPARATOR;if(t instanceof p.RepetitionWithSeparator)return o.REPETITION_WITH_SEPARATOR;if(t instanceof p.Alternation)return o.ALTERNATION;throw Error(\"non exhaustive match\")},e.buildLookaheadFuncForOr=function(t,e,n,r,i,o){var a=E(t,e,n);return o(a,r,T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher,i)},e.buildLookaheadFuncForOptionalProd=function(t,e,n,r,i,o){var a=m(t,e,i,n),s=T(a)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher;return o(a[0],s,r)},e.buildAlternativesLookAheadFunc=function(t,e,n,r){var i=t.length,o=a.every(t,function(t){return a.every(t,function(t){return 1===t.length})});if(e)return function(e){for(var r=a.map(e,function(t){return t.GATE}),o=0;o<i;o++){var s=t[o],u=s.length,c=r[o];if(void 0===c||!1!==c.call(this))t:for(var p=0;p<u;p++){for(var l=s[p],h=l.length,f=0;f<h;f++){var d=this.LA(f+1);if(!1===n(d,l[f]))continue t}return o}}};if(o&&!r){var s=a.map(t,function(t){return a.flatten(t)}),u=a.reduce(s,function(t,e,n){return a.forEach(e,function(e){a.has(t,e.tokenTypeIdx)||(t[e.tokenTypeIdx]=n),a.forEach(e.categoryMatches,function(e){a.has(t,e)||(t[e]=n);});}),t},[]);return function(){var t=this.LA(1);return u[t.tokenTypeIdx]}}return function(){for(var e=0;e<i;e++){var r=t[e],o=r.length;t:for(var a=0;a<o;a++){for(var s=r[a],u=s.length,c=0;c<u;c++){var p=this.LA(c+1);if(!1===n(p,s[c]))continue t}return e}}}},e.buildSingleAlternativeLookaheadFunction=function(t,e,n){var r=a.every(t,function(t){return 1===t.length}),i=t.length;if(r&&!n){var o=a.flatten(t);if(1===o.length&&a.isEmpty(o[0].categoryMatches)){var s=o[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}var u=a.reduce(o,function(t,e,n){return t[e.tokenTypeIdx]=!0,a.forEach(e.categoryMatches,function(e){t[e]=!0;}),t},[]);return function(){var t=this.LA(1);return !0===u[t.tokenTypeIdx]}}return function(){t:for(var n=0;n<i;n++){for(var r=t[n],o=r.length,a=0;a<o;a++){var s=this.LA(a+1);if(!1===e(s,r[a]))continue t}return !0}return !1}};var h=function(t){function e(e,n,r){var i=t.call(this)||this;return i.topProd=e,i.targetOccurrence=n,i.targetProdType=r,i}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},e.prototype.checkIsTarget=function(t,e,n,r){return t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.restDef=n.concat(r),!0)},e.prototype.walkOption=function(e,n,r){this.checkIsTarget(e,o.OPTION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOne=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkAtLeastOneSep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_MANDATORY_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkMany=function(e,n,r){this.checkIsTarget(e,o.REPETITION,n,r)||t.prototype.walkOption.call(this,e,n,r);},e.prototype.walkManySep=function(e,n,r){this.checkIsTarget(e,o.REPETITION_WITH_SEPARATOR,n,r)||t.prototype.walkOption.call(this,e,n,r);},e}(u.RestWalker),f=function(t){function e(e,n){var r=t.call(this)||this;return r.targetOccurrence=e,r.targetProdType=n,r.result=[],r}return i(e,t),e.prototype.checkIsTarget=function(t,e){t.idx===this.targetOccurrence&&this.targetProdType===e&&(this.result=t.definition);},e.prototype.visitOption=function(t){this.checkIsTarget(t,o.OPTION);},e.prototype.visitRepetition=function(t){this.checkIsTarget(t,o.REPETITION);},e.prototype.visitRepetitionMandatory=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_MANDATORY_WITH_SEPARATOR);},e.prototype.visitRepetitionWithSeparator=function(t){this.checkIsTarget(t,o.REPETITION_WITH_SEPARATOR);},e.prototype.visitAlternation=function(t){this.checkIsTarget(t,o.ALTERNATION);},e}(l.GAstVisitor);function d(t,e){function n(t,e){return a.reduce(t,function(t,n,r){if(r!==e){var i=a.map(n,function(t){return t.partialPath});return t.concat(i)}return t},[])}function r(t,e){return void 0===a.find(t,function(t){return a.every(e,function(e,n){return r=e,i=t[n],r===i||r&&i&&(r.categoryMatchesMap[i.tokenTypeIdx]||i.categoryMatchesMap[r.tokenTypeIdx]);var r,i;})})}function i(t){for(var e=[],n=0;n<t;n++)e.push([]);return e}for(var o=a.map(t,function(t){return s.possiblePathsFrom([t],1)}),u=i(o.length),c=o,p=1;p<=e;p++){var l=c;c=i(l.length);for(var h=0;h<l.length;h++)for(var f=l[h],d=n(l,h),E=0;E<f.length;E++){var m=f[E].partialPath,T=f[E].suffixDef;if(r(d,m)||a.isEmpty(T)||m.length===e){var v=u[h];y(v,m)||v.push(m);}else {var g=s.possiblePathsFrom(T,p+1,m);c[h]=c[h].concat(g);}}}return u}function E(t,e,n){var r=new f(t,o.ALTERNATION);return e.accept(r),d(r.result,n)}function m(t,e,n,r){var i=new f(t,n);e.accept(i);var o=i.result,a=new h(e,t,n).startWalking();return d([new p.Flat({definition:o}),new p.Flat({definition:a})],r)}function y(t,e){return void 0!==a.find(t,function(t){return e.length===t.length&&a.every(e,function(e,n){return e===t[n]||t[n].categoryMatchesMap[e.tokenTypeIdx]})})}function T(t){return a.every(t,function(t){return a.every(t,function(t){return a.every(t,function(t){return a.isEmpty(t.categoryMatches)})})})}e.lookAheadSequenceFromAlternatives=d,e.getLookaheadPathsForOr=E,e.getLookaheadPathsForOptionalProd=m,e.containsPath=y,e.isStrictPrefixOfPath=function(t,e){return t.length<e.length&&a.every(t,function(t,n){var r=e[n];return t===r||r.categoryMatchesMap[t.tokenTypeIdx]})},e.areTokenCategoriesNotUsed=T;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(0),s=n(2),u=n(21),c=n(1),p=function(t){function e(e,n){var r=t.call(this)||this;return r.topProd=e,r.path=n,r.possibleTokTypes=[],r.nextProductionName=\"\",r.nextProductionOccurrence=0,r.found=!1,r.isAtEndOfPath=!1,r}return i(e,t),e.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error(\"The path does not start with the walker's top Rule!\");return this.ruleStack=a.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=a.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},e.prototype.walk=function(e,n){void 0===n&&(n=[]),this.found||t.prototype.walk.call(this,e,n);},e.prototype.walkProdRef=function(t,e,n){if(t.referencedRule.name===this.nextProductionName&&t.idx===this.nextProductionOccurrence){var r=e.concat(n);this.updateExpectedNext(),this.walk(t.referencedRule,r);}},e.prototype.updateExpectedNext=function(){a.isEmpty(this.ruleStack)?(this.nextProductionName=\"\",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop());},e}(o.RestWalker);e.AbstractNextPossibleTokensWalker=p;var l=function(t){function e(e,n){var r=t.call(this,e,n)||this;return r.path=n,r.nextTerminalName=\"\",r.nextTerminalOccurrence=0,r.nextTerminalName=s.tokenName(r.path.lastTok),r.nextTerminalOccurrence=r.path.lastTokOccurrence,r}return i(e,t),e.prototype.walkTerminal=function(t,e,n){if(this.isAtEndOfPath&&s.tokenName(t.terminalType)===this.nextTerminalName&&t.idx===this.nextTerminalOccurrence&&!this.found){var r=e.concat(n),i=new c.Flat({definition:r});this.possibleTokTypes=u.first(i),this.found=!0;}},e}(p);e.NextAfterTokenWalker=l;var h=function(t){function e(e,n){var r=t.call(this)||this;return r.topRule=e,r.occurrence=n,r.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},r}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topRule),this.result},e}(o.RestWalker);e.AbstractNextTerminalAfterProductionWalker=h;var f=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkMany=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkMany.call(this,e,n,r);},e}(h);e.NextTerminalAfterManyWalker=f;var d=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkManySep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkManySep.call(this,e,n,r);},e}(h);e.NextTerminalAfterManySepWalker=d;var E=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOne=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOne.call(this,e,n,r);},e}(h);e.NextTerminalAfterAtLeastOneWalker=E;var m=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return i(e,t),e.prototype.walkAtLeastOneSep=function(e,n,r){if(e.idx===this.occurrence){var i=a.first(n.concat(r));this.result.isEndOfRule=void 0===i,i instanceof c.Terminal&&(this.result.token=i.terminalType,this.result.occurrence=i.idx);}else t.prototype.walkAtLeastOneSep.call(this,e,n,r);},e}(h);function y(t,e,n,r){var i=a.cloneArr(n);i.push(t.name);var o=a.cloneArr(r);return o.push(1),{idx:e,def:t.definition,ruleStack:i,occurrenceStack:o}}e.NextTerminalAfterAtLeastOneSepWalker=m,e.possiblePathsFrom=function t(e,n,r){void 0===r&&(r=[]),r=a.cloneArr(r);var i=[],o=0;function s(s){var u=t(s.concat(a.drop(e,o+1)),n,r);return i.concat(u)}for(;r.length<n&&o<e.length;){var u=e[o];if(u instanceof c.Flat)return s(u.definition);if(u instanceof c.NonTerminal)return s(u.definition);if(u instanceof c.Option)i=s(u.definition);else {if(u instanceof c.RepetitionMandatory)return s(p=u.definition.concat([new c.Repetition({definition:u.definition})]));if(u instanceof c.RepetitionMandatoryWithSeparator)return s(p=[new c.Flat({definition:u.definition}),new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);if(u instanceof c.RepetitionWithSeparator){var p=u.definition.concat([new c.Repetition({definition:[new c.Terminal({terminalType:u.separator})].concat(u.definition)})]);i=s(p);}else if(u instanceof c.Repetition)p=u.definition.concat([new c.Repetition({definition:u.definition})]),i=s(p);else {if(u instanceof c.Alternation)return a.forEach(u.definition,function(t){i=s(t.definition);}),i;if(!(u instanceof c.Terminal))throw Error(\"non exhaustive match\");r.push(u.terminalType);}}o++;}return i.push({partialPath:r,suffixDef:a.drop(e,o)}),i},e.nextPossibleTokensAfter=function(t,e,n,r){var i=[\"EXIT_NONE_TERMINAL\"],o=!1,s=e.length,u=s-r-1,p=[],l=[];for(l.push({idx:-1,def:t,ruleStack:[],occurrenceStack:[]});!a.isEmpty(l);){var h=l.pop();if(\"EXIT_ALTERNATIVE\"!==h){var f=h.def,d=h.idx,E=h.ruleStack,m=h.occurrenceStack;if(!a.isEmpty(f)){var T=f[0];if(\"EXIT_NONE_TERMINAL\"===T){var v={idx:d,def:a.drop(f),ruleStack:a.dropRight(E),occurrenceStack:a.dropRight(m)};l.push(v);}else if(T instanceof c.Terminal)if(d<s-1){var g=d+1;n(e[g],T.terminalType)&&(v={idx:g,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(v));}else {if(d!==s-1)throw Error(\"non exhaustive match\");p.push({nextTokenType:T.terminalType,nextTokenOccurrence:T.idx,ruleStack:E,occurrenceStack:m}),o=!0;}else if(T instanceof c.NonTerminal){var _=a.cloneArr(E);_.push(T.nonTerminalName);var R=a.cloneArr(m);R.push(T.idx),v={idx:d,def:T.definition.concat(i,a.drop(f)),ruleStack:_,occurrenceStack:R},l.push(v);}else if(T instanceof c.Option){var A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m};l.push(A),l.push(\"EXIT_ALTERNATIVE\");var N={idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(N);}else if(T instanceof c.RepetitionMandatory){var O=new c.Repetition({definition:T.definition,idx:T.idx});v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionMandatoryWithSeparator){var S=new c.Terminal({terminalType:T.separator});O=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx}),v={idx:d,def:T.definition.concat([O],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(v);}else if(T instanceof c.RepetitionWithSeparator){A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),S=new c.Terminal({terminalType:T.separator});var I=new c.Repetition({definition:[S].concat(T.definition),idx:T.idx});N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);}else if(T instanceof c.Repetition)A={idx:d,def:a.drop(f),ruleStack:E,occurrenceStack:m},l.push(A),l.push(\"EXIT_ALTERNATIVE\"),I=new c.Repetition({definition:T.definition,idx:T.idx}),N={idx:d,def:T.definition.concat([I],a.drop(f)),ruleStack:E,occurrenceStack:m},l.push(N);else if(T instanceof c.Alternation)for(var L=T.definition.length-1;L>=0;L--){var k={idx:d,def:T.definition[L].definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m};l.push(k),l.push(\"EXIT_ALTERNATIVE\");}else if(T instanceof c.Flat)l.push({idx:d,def:T.definition.concat(a.drop(f)),ruleStack:E,occurrenceStack:m});else {if(!(T instanceof c.Rule))throw Error(\"non exhaustive match\");l.push(y(T,d,E,m));}}}else o&&a.last(l).idx<=u&&l.pop();}return p};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=function(){function t(){}return t.prototype.walk=function(t,e){var n=this;void 0===e&&(e=[]),r.forEach(t.definition,function(o,a){var s=r.drop(t.definition,a+1);if(o instanceof i.NonTerminal)n.walkProdRef(o,s,e);else if(o instanceof i.Terminal)n.walkTerminal(o,s,e);else if(o instanceof i.Flat)n.walkFlat(o,s,e);else if(o instanceof i.Option)n.walkOption(o,s,e);else if(o instanceof i.RepetitionMandatory)n.walkAtLeastOne(o,s,e);else if(o instanceof i.RepetitionMandatoryWithSeparator)n.walkAtLeastOneSep(o,s,e);else if(o instanceof i.RepetitionWithSeparator)n.walkManySep(o,s,e);else if(o instanceof i.Repetition)n.walkMany(o,s,e);else {if(!(o instanceof i.Alternation))throw Error(\"non exhaustive match\");n.walkOr(o,s,e);}});},t.prototype.walkTerminal=function(t,e,n){},t.prototype.walkProdRef=function(t,e,n){},t.prototype.walkFlat=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkOption=function(t,e,n){var r=e.concat(n);this.walk(t,r);},t.prototype.walkAtLeastOne=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkAtLeastOneSep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkMany=function(t,e,n){var r=[new i.Option({definition:t.definition})].concat(e,n);this.walk(t,r);},t.prototype.walkManySep=function(t,e,n){var r=a(t,e,n);this.walk(t,r);},t.prototype.walkOr=function(t,e,n){var o=this,a=e.concat(n);r.forEach(t.definition,function(t){var e=new i.Flat({definition:[t]});o.walk(e,a);});},t}();function a(t,e,n){return [new i.Option({definition:[new i.Terminal({terminalType:t.separator})].concat(t.definition)})].concat(e,n)}e.RestWalker=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(27),i=n(0),o=n(7),a=n(20);!function(t){t[t.MISSING_PATTERN=0]=\"MISSING_PATTERN\",t[t.INVALID_PATTERN=1]=\"INVALID_PATTERN\",t[t.EOI_ANCHOR_FOUND=2]=\"EOI_ANCHOR_FOUND\",t[t.UNSUPPORTED_FLAGS_FOUND=3]=\"UNSUPPORTED_FLAGS_FOUND\",t[t.DUPLICATE_PATTERNS_FOUND=4]=\"DUPLICATE_PATTERNS_FOUND\",t[t.INVALID_GROUP_TYPE_FOUND=5]=\"INVALID_GROUP_TYPE_FOUND\",t[t.PUSH_MODE_DOES_NOT_EXIST=6]=\"PUSH_MODE_DOES_NOT_EXIST\",t[t.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]=\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\",t[t.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]=\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\",t[t.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]=\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\",t[t.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]=\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\",t[t.SOI_ANCHOR_FOUND=11]=\"SOI_ANCHOR_FOUND\",t[t.EMPTY_MATCH_PATTERN=12]=\"EMPTY_MATCH_PATTERN\",t[t.NO_LINE_BREAKS_FLAGS=13]=\"NO_LINE_BREAKS_FLAGS\",t[t.UNREACHABLE_PATTERN=14]=\"UNREACHABLE_PATTERN\",t[t.IDENTIFY_TERMINATOR=15]=\"IDENTIFY_TERMINATOR\",t[t.CUSTOM_LINE_BREAK=16]=\"CUSTOM_LINE_BREAK\";}(e.LexerDefinitionErrorType||(e.LexerDefinitionErrorType={}));var s={deferDefinitionErrorsHandling:!1,positionTracking:\"full\",lineTerminatorsPattern:/\\n|\\r\\n?/g,lineTerminatorCharacters:[\"\\n\",\"\\r\"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:a.defaultLexerErrorProvider};Object.freeze(s);var u=function(){function t(t,e){var n=this;if(void 0===e&&(e=s),this.lexerDefinition=t,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},\"boolean\"==typeof e)throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");if(this.config=i.merge(s,e),this.config.lineTerminatorsPattern===s.lineTerminatorsPattern)this.config.lineTerminatorsPattern=r.LineTerminatorOptimizedTester;else if(this.config.lineTerminatorCharacters===s.lineTerminatorCharacters)throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");if(e.safeMode&&e.ensureOptimizations)throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking);var a,u=!0;i.isArray(t)?((a={modes:{}}).modes[r.DEFAULT_MODE]=i.cloneArr(t),a[r.DEFAULT_MODE]=r.DEFAULT_MODE):(u=!1,a=i.cloneObj(t)),this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(r.performRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(r.performWarningRuntimeChecks(a,this.trackStartLines,this.config.lineTerminatorCharacters)),a.modes=a.modes?a.modes:{},i.forEach(a.modes,function(t,e){a.modes[e]=i.reject(t,function(t){return i.isUndefined(t)});});var c=i.keys(a.modes);if(i.forEach(a.modes,function(t,a){if(n.modes.push(a),n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(r.validatePatterns(t,c)),i.isEmpty(n.lexerDefinitionErrors)){o.augmentTokenTypes(t);var s=r.analyzeTokenTypes(t,{lineTerminatorCharacters:n.config.lineTerminatorCharacters,positionTracking:e.positionTracking,ensureOptimizations:e.ensureOptimizations,safeMode:e.safeMode});n.patternIdxToConfig[a]=s.patternIdxToConfig,n.charCodeToPatternIdxToConfig[a]=s.charCodeToPatternIdxToConfig,n.emptyGroups=i.merge(n.emptyGroups,s.emptyGroups),n.hasCustom=s.hasCustom||n.hasCustom,n.canModeBeOptimized[a]=s.canBeOptimized;}}),this.defaultMode=a.defaultMode,!i.isEmpty(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){var p=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Errors detected in definition of Lexer:\\n\"+p)}if(i.forEach(this.lexerDefinitionWarning,function(t){i.PRINT_WARNING(t.message);}),r.SUPPORT_STICKY?(this.chopInput=i.IDENTITY,this.match=this.matchWithTest):(this.updateLastIndex=i.NOOP,this.match=this.matchWithExec),u&&(this.handleModes=i.NOOP),!1===this.trackStartLines&&(this.computeNewColumn=i.IDENTITY),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=i.NOOP),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else {if(!/onlyOffset/i.test(this.config.positionTracking))throw Error('Invalid <positionTracking> config option: \"'+this.config.positionTracking+'\"');this.createTokenInstance=this.createOffsetOnlyToken;}this.hasCustom?this.addToken=this.addTokenUsingPush:this.addToken=this.addTokenUsingMemberAccess;var l=i.reduce(this.canModeBeOptimized,function(t,e,n){return !1===e&&t.push(n),t},[]);if(e.ensureOptimizations&&!i.isEmpty(l))throw Error(\"Lexer Modes: < \"+l.join(\", \")+' > cannot be optimized.\\n\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\\t Or inspect the console log for details on how to resolve these issues.')}return t.prototype.tokenize=function(t,e){if(void 0===e&&(e=this.defaultMode),!i.isEmpty(this.lexerDefinitionErrors)){var n=i.map(this.lexerDefinitionErrors,function(t){return t.message}).join(\"-----------------------\\n\");throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\"+n)}return this.tokenizeInternal(t,e)},t.prototype.tokenizeInternal=function(t,e){var n,o,a,s,u,c,p,l,h,f,d,E,m=this,y=t,T=y.length,v=0,g=0,_=this.hasCustom?0:Math.floor(t.length/10),R=new Array(_),A=[],N=this.trackStartLines?1:void 0,O=this.trackStartLines?1:void 0,S=r.cloneEmptyGroups(this.emptyGroups),I=this.trackStartLines,L=this.config.lineTerminatorsPattern,k=0,P=[],x=[],C=[],M=[];Object.freeze(M);var F,b=void 0,D=function(t){if(1===C.length&&void 0===t.tokenType.PUSH_MODE){var e=m.config.errorMessageProvider.buildUnableToPopLexerModeMessage(t);A.push({offset:t.startOffset,line:void 0!==t.startLine?t.startLine:void 0,column:void 0!==t.startColumn?t.startColumn:void 0,length:t.image.length,message:e});}else {C.pop();var n=i.last(C);P=m.patternIdxToConfig[n],x=m.charCodeToPatternIdxToConfig[n],k=P.length;var r=m.canModeBeOptimized[n]&&!1===m.config.safeMode;b=x&&r?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}};function w(t){C.push(t),x=this.charCodeToPatternIdxToConfig[t],P=this.patternIdxToConfig[t],k=P.length,k=P.length;var e=this.canModeBeOptimized[t]&&!1===this.config.safeMode;b=x&&e?function(t){var e=x[t];return void 0===e?M:e}:function(){return P};}for(w.call(this,e);v<T;){u=null;var U=y.charCodeAt(v),G=b(U),B=G.length;for(n=0;n<B;n++){var K=(F=G[n]).pattern;if(!1!==(Z=F.short)?U===Z&&(u=K):!0===F.isCustom?u=null!==(E=K.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(K,v),u=this.match(K,t,v)),null!==u){if(void 0!==(s=F.longerAlt)){var W=P[s],j=W.pattern;!0===W.isCustom?a=null!==(E=j.exec(y,v,R,S))?E[0]:E:(this.updateLastIndex(j,v),a=this.match(j,t,v)),a&&a.length>u.length&&(u=a,F=W);}break}}if(null!==u){if(c=u.length,void 0!==(p=F.group)&&(l=F.tokenTypeIdx,h=this.createTokenInstance(u,v,l,F.tokenType,N,O,c),!1===p?g=this.addToken(R,g,h):S[p].push(h)),t=this.chopInput(t,c),v+=c,O=this.computeNewColumn(O,c),!0===I&&!0===F.canLineTerminator){var V=0,Y=void 0,H=void 0;L.lastIndex=0;do{!0===(Y=L.test(u))&&(H=L.lastIndex-1,V++);}while(Y);0!==V&&(N+=V,O=c-H,this.updateTokenEndLineColumnLocation(h,p,H,V,N,O,c));}this.handleModes(F,D,w,h);}else {for(var X=v,z=N,q=O,$=!1;!$&&v<T;)for(y.charCodeAt(v),t=this.chopInput(t,1),v++,o=0;o<k;o++){var Z,Q=P[o];K=Q.pattern;if(!1!==(Z=Q.short)?y.charCodeAt(v)===Z&&($=!0):!0===Q.isCustom?$=null!==K.exec(y,v,R,S):(this.updateLastIndex(K,v),$=null!==K.exec(t)),!0===$)break}f=v-X,d=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(y,X,f,z,q),A.push({offset:X,line:z,column:q,length:f,message:d});}}return this.hasCustom||(R.length=g),{tokens:R,groups:S,errors:A}},t.prototype.handleModes=function(t,e,n,r){if(!0===t.pop){var i=t.push;e(r),void 0!==i&&n.call(this,i);}else void 0!==t.push&&n.call(this,t.push);},t.prototype.chopInput=function(t,e){return t.substring(e)},t.prototype.updateLastIndex=function(t,e){t.lastIndex=e;},t.prototype.updateTokenEndLineColumnLocation=function(t,e,n,r,i,o,a){var s,u;void 0!==e&&(u=(s=n===a-1)?-1:0,1===r&&!0===s||(t.endLine=i+u,t.endColumn=o-1-u));},t.prototype.computeNewColumn=function(t,e){return t+e},t.prototype.createTokenInstance=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];return null},t.prototype.createOffsetOnlyToken=function(t,e,n,r){return {image:t,startOffset:e,tokenTypeIdx:n,tokenType:r}},t.prototype.createStartOnlyToken=function(t,e,n,r,i,o){return {image:t,startOffset:e,startLine:i,startColumn:o,tokenTypeIdx:n,tokenType:r}},t.prototype.createFullToken=function(t,e,n,r,i,o,a){return {image:t,startOffset:e,endOffset:e+a-1,startLine:i,endLine:i,startColumn:o,endColumn:o+a-1,tokenTypeIdx:n,tokenType:r}},t.prototype.addToken=function(t,e,n){return 666},t.prototype.addTokenUsingPush=function(t,e,n){return t.push(n),e},t.prototype.addTokenUsingMemberAccess=function(t,e,n){return t[e]=n,++e},t.prototype.match=function(t,e,n){return null},t.prototype.matchWithTest=function(t,e,n){return !0===t.test(e)?e.substring(n,t.lastIndex):null},t.prototype.matchWithExec=function(t,e){var n=t.exec(e);return null!==n?n[0]:n},t.SKIPPED=\"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\",t.NA=/NOT_APPLICABLE/,t}();e.Lexer=u;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(0),a=n(4),s=n(9),u=n(1),c=n(5);e.addTerminalToCst=function(t,e,n){void 0===t.children[n]?t.children[n]=[e]:t.children[n].push(e);},e.addNoneTerminalToCst=function(t,e,n){void 0===t.children[e]?t.children[e]=[n]:t.children[e].push(n);};var p=function(t){function e(e){var n=t.call(this)||this;return n.result=[],n.ruleIdx=e,n}return i(e,t),e.prototype.collectNamedDSLMethod=function(t,e,n){if(!o.isUndefined(t.name)){var r=void 0;if(t instanceof u.Option||t instanceof u.Repetition||t instanceof u.RepetitionMandatory||t instanceof u.Alternation)r=new e({definition:t.definition,idx:t.idx});else {if(!(t instanceof u.RepetitionMandatoryWithSeparator||t instanceof u.RepetitionWithSeparator))throw Error(\"non exhaustive match\");r=new e({definition:t.definition,idx:t.idx,separator:t.separator});}var i=[r],a=s.getKeyForAutomaticLookahead(this.ruleIdx,n,t.idx);this.result.push({def:i,key:a,name:t.name,orgProd:t});}},e.prototype.visitOption=function(t){this.collectNamedDSLMethod(t,u.Option,s.OPTION_IDX);},e.prototype.visitRepetition=function(t){this.collectNamedDSLMethod(t,u.Repetition,s.MANY_IDX);},e.prototype.visitRepetitionMandatory=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatory,s.AT_LEAST_ONE_IDX);},e.prototype.visitRepetitionMandatoryWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionMandatoryWithSeparator,s.AT_LEAST_ONE_SEP_IDX);},e.prototype.visitRepetitionWithSeparator=function(t){this.collectNamedDSLMethod(t,u.RepetitionWithSeparator,s.MANY_SEP_IDX);},e.prototype.visitAlternation=function(t){var e=this;this.collectNamedDSLMethod(t,u.Alternation,s.OR_IDX);var n=t.definition.length>1;o.forEach(t.definition,function(r,i){if(!o.isUndefined(r.name)){var a=r.definition;a=n?[new u.Option({definition:r.definition})]:r.definition;var c=s.getKeyForAltIndex(e.ruleIdx,s.OR_IDX,t.idx,i);e.result.push({def:a,key:c,name:r.name,orgProd:r});}});},e}(c.GAstVisitor);e.NamedDSLMethodsCollectorVisitor=p,e.analyzeCst=function(t,e){var n={dictDef:new a.HashTable,allRuleNames:[]};return o.forEach(t,function(t){var r=e.get(t.name);n.allRuleNames.push(t.name);var i=new p(r);t.accept(i),o.forEach(i.result,function(e){e.def,e.key;var r=e.name;n.allRuleNames.push(t.name+r);});}),n};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.VERSION=\"4.6.0\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=n(15),o=n(2),a=n(6),s=n(17),u=n(10),c=n(39),p=n(5),l=n(1),h=n(24),f=n(40),d=n(20),E={};E.VERSION=s.VERSION,E.Parser=r.Parser,E.CstParser=r.CstParser,E.EmbeddedActionsParser=r.EmbeddedActionsParser;E.ParserDefinitionErrorType=r.ParserDefinitionErrorType,E.Lexer=i.Lexer,E.LexerDefinitionErrorType=i.LexerDefinitionErrorType,E.EOF=o.EOF,E.tokenName=o.tokenName,E.tokenLabel=o.tokenLabel,E.tokenMatcher=o.tokenMatcher,E.createToken=o.createToken,E.createTokenInstance=o.createTokenInstance,E.EMPTY_ALT=r.EMPTY_ALT,E.defaultParserErrorProvider=u.defaultParserErrorProvider,E.isRecognitionException=a.isRecognitionException,E.EarlyExitException=a.EarlyExitException,E.MismatchedTokenException=a.MismatchedTokenException,E.NotAllInputParsedException=a.NotAllInputParsedException,E.NoViableAltException=a.NoViableAltException,E.defaultLexerErrorProvider=d.defaultLexerErrorProvider,E.Flat=l.Flat,E.Repetition=l.Repetition,E.RepetitionWithSeparator=l.RepetitionWithSeparator,E.RepetitionMandatory=l.RepetitionMandatory,E.RepetitionMandatoryWithSeparator=l.RepetitionMandatoryWithSeparator,E.Option=l.Option,E.Alternation=l.Alternation,E.NonTerminal=l.NonTerminal,E.Terminal=l.Terminal,E.Rule=l.Rule,E.GAstVisitor=p.GAstVisitor,E.serializeGrammar=l.serializeGrammar,E.serializeProduction=l.serializeProduction,E.resolveGrammar=h.resolveGrammar,E.defaultGrammarResolverErrorProvider=u.defaultGrammarResolverErrorProvider,E.validateGrammar=h.validateGrammar,E.defaultGrammarValidatorErrorProvider=u.defaultGrammarValidatorErrorProvider,E.assignOccurrenceIndices=h.assignOccurrenceIndices,E.clearCache=function(){console.warn(\"The clearCache function was 'soft' removed from the Chevrotain API.\\n\\t It performs no action other than printing this message.\\n\\t Please avoid using it as it will be completely removed in the future\");},E.createSyntaxDiagramsCode=c.createSyntaxDiagramsCode,E.generateParserFactory=f.generateParserFactory,E.generateParserModule=f.generateParserModule,t.exports=E;},function(t,e,n){var r,i,o;i=[],void 0===(o=\"function\"==typeof(r=function(){function t(){}t.prototype.saveState=function(){return {idx:this.idx,input:this.input,groupIdx:this.groupIdx}},t.prototype.restoreState=function(t){this.idx=t.idx,this.input=t.input,this.groupIdx=t.groupIdx;},t.prototype.pattern=function(t){this.idx=0,this.input=t,this.groupIdx=0,this.consumeChar(\"/\");var e=this.disjunction();this.consumeChar(\"/\");for(var n={type:\"Flags\",global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case\"g\":s(n,\"global\");break;case\"i\":s(n,\"ignoreCase\");break;case\"m\":s(n,\"multiLine\");break;case\"u\":s(n,\"unicode\");break;case\"y\":s(n,\"sticky\");}if(this.idx!==this.input.length)throw Error(\"Redundant input: \"+this.input.substring(this.idx));return {type:\"Pattern\",flags:n,value:e}},t.prototype.disjunction=function(){var t=[];for(t.push(this.alternative());\"|\"===this.peekChar();)this.consumeChar(\"|\"),t.push(this.alternative());return {type:\"Disjunction\",value:t}},t.prototype.alternative=function(){for(var t=[];this.isTerm();)t.push(this.term());return {type:\"Alternative\",value:t}},t.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},t.prototype.assertion=function(){switch(this.popChar()){case\"^\":return {type:\"StartAnchor\"};case\"$\":return {type:\"EndAnchor\"};case\"\\\\\":switch(this.popChar()){case\"b\":return {type:\"WordBoundary\"};case\"B\":return {type:\"NonWordBoundary\"}}throw Error(\"Invalid Assertion Escape\");case\"(\":var t;switch(this.consumeChar(\"?\"),this.popChar()){case\"=\":t=\"Lookahead\";break;case\"!\":t=\"NegativeLookahead\";}u(t);var e=this.disjunction();return this.consumeChar(\")\"),{type:t,value:e}}!function(){throw Error(\"Internal Error - Should never get here!\")}();},t.prototype.quantifier=function(t){var e;switch(this.popChar()){case\"*\":e={atLeast:0,atMost:1/0};break;case\"+\":e={atLeast:1,atMost:1/0};break;case\"?\":e={atLeast:0,atMost:1};break;case\"{\":var n=this.integerIncludingZero();switch(this.popChar()){case\"}\":e={atLeast:n,atMost:n};break;case\",\":var r;this.isDigit()?(r=this.integerIncludingZero(),e={atLeast:n,atMost:r}):e={atLeast:n,atMost:1/0},this.consumeChar(\"}\");}if(!0===t&&void 0===e)return;u(e);}if(!0!==t||void 0!==e)return u(e),\"?\"===this.peekChar(0)?(this.consumeChar(\"?\"),e.greedy=!1):e.greedy=!0,e.type=\"Quantifier\",e},t.prototype.atom=function(){var t;switch(this.peekChar()){case\".\":t=this.dotAll();break;case\"\\\\\":t=this.atomEscape();break;case\"[\":t=this.characterClass();break;case\"(\":t=this.group();}return void 0===t&&this.isPatternCharacter()&&(t=this.patternCharacter()),u(t),this.isQuantifier()&&(t.quantifier=this.quantifier()),t},t.prototype.dotAll=function(){return this.consumeChar(\".\"),{type:\"Set\",complement:!0,value:[o(\"\\n\"),o(\"\\r\"),o(\"\\u2028\"),o(\"\\u2029\")]}},t.prototype.atomEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"1\":case\"2\":case\"3\":case\"4\":case\"5\":case\"6\":case\"7\":case\"8\":case\"9\":return this.decimalEscapeAtom();case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.decimalEscapeAtom=function(){var t=this.positiveInteger();return {type:\"GroupBackReference\",value:t}},t.prototype.characterClassEscape=function(){var t,e=!1;switch(this.popChar()){case\"d\":t=c;break;case\"D\":t=c,e=!0;break;case\"s\":t=l;break;case\"S\":t=l,e=!0;break;case\"w\":t=p;break;case\"W\":t=p,e=!0;}return u(t),{type:\"Set\",value:t,complement:e}},t.prototype.controlEscapeAtom=function(){var t;switch(this.popChar()){case\"f\":t=o(\"\\f\");break;case\"n\":t=o(\"\\n\");break;case\"r\":t=o(\"\\r\");break;case\"t\":t=o(\"\\t\");break;case\"v\":t=o(\"\\v\");}return u(t),{type:\"Character\",value:t}},t.prototype.controlLetterEscapeAtom=function(){this.consumeChar(\"c\");var t=this.popChar();if(!1===/[a-zA-Z]/.test(t))throw Error(\"Invalid \");var e=t.toUpperCase().charCodeAt(0)-64;return {type:\"Character\",value:e}},t.prototype.nulCharacterAtom=function(){return this.consumeChar(\"0\"),{type:\"Character\",value:o(\"\\0\")}},t.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar(\"x\"),this.parseHexDigits(2)},t.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar(\"u\"),this.parseHexDigits(4)},t.prototype.identityEscapeAtom=function(){var t=this.popChar();return {type:\"Character\",value:o(t)}},t.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"\\\\\":case\"]\":throw Error(\"TBD\");default:var t=this.popChar();return {type:\"Character\",value:o(t)}}},t.prototype.characterClass=function(){var t=[],e=!1;for(this.consumeChar(\"[\"),\"^\"===this.peekChar(0)&&(this.consumeChar(\"^\"),e=!0);this.isClassAtom();){var n=this.classAtom(),r=\"Character\"===n.type;if(r&&this.isRangeDash()){this.consumeChar(\"-\");var i=this.classAtom(),s=\"Character\"===i.type;if(s){if(i.value<n.value)throw Error(\"Range out of order in character class\");t.push({from:n.value,to:i.value});}else a(n.value,t),t.push(o(\"-\")),a(i.value,t);}else a(n.value,t);}return this.consumeChar(\"]\"),{type:\"Set\",complement:e,value:t}},t.prototype.classAtom=function(){switch(this.peekChar()){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":throw Error(\"TBD\");case\"\\\\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},t.prototype.classEscape=function(){switch(this.consumeChar(\"\\\\\"),this.peekChar()){case\"b\":return this.consumeChar(\"b\"),{type:\"Character\",value:o(\"\\b\")};case\"d\":case\"D\":case\"s\":case\"S\":case\"w\":case\"W\":return this.characterClassEscape();case\"f\":case\"n\":case\"r\":case\"t\":case\"v\":return this.controlEscapeAtom();case\"c\":return this.controlLetterEscapeAtom();case\"0\":return this.nulCharacterAtom();case\"x\":return this.hexEscapeSequenceAtom();case\"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},t.prototype.group=function(){var t=!0;switch(this.consumeChar(\"(\"),this.peekChar(0)){case\"?\":this.consumeChar(\"?\"),this.consumeChar(\":\"),t=!1;break;default:this.groupIdx++;}var e=this.disjunction();this.consumeChar(\")\");var n={type:\"Group\",capturing:t,value:e};return t&&(n.idx=this.groupIdx),n},t.prototype.positiveInteger=function(){var t=this.popChar();if(!1===i.test(t))throw Error(\"Expecting a positive integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.integerIncludingZero=function(){var t=this.popChar();if(!1===r.test(t))throw Error(\"Expecting an integer\");for(;r.test(this.peekChar(0));)t+=this.popChar();return parseInt(t,10)},t.prototype.patternCharacter=function(){var t=this.popChar();switch(t){case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":throw Error(\"TBD\");default:return {type:\"Character\",value:o(t)}}},t.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case\"g\":case\"i\":case\"m\":case\"u\":case\"y\":return !0;default:return !1}},t.prototype.isRangeDash=function(){return \"-\"===this.peekChar()&&this.isClassAtom(1)},t.prototype.isDigit=function(){return r.test(this.peekChar(0))},t.prototype.isClassAtom=function(t){switch(void 0===t&&(t=0),this.peekChar(t)){case\"]\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},t.prototype.isAtom=function(){if(this.isPatternCharacter())return !0;switch(this.peekChar(0)){case\".\":case\"\\\\\":case\"[\":case\"(\":return !0;default:return !1}},t.prototype.isAssertion=function(){switch(this.peekChar(0)){case\"^\":case\"$\":return !0;case\"\\\\\":switch(this.peekChar(1)){case\"b\":case\"B\":return !0;default:return !1}case\"(\":return \"?\"===this.peekChar(1)&&(\"=\"===this.peekChar(2)||\"!\"===this.peekChar(2));default:return !1}},t.prototype.isQuantifier=function(){var t=this.saveState();try{return void 0!==this.quantifier(!0)}catch(t){return !1}finally{this.restoreState(t);}},t.prototype.isPatternCharacter=function(){switch(this.peekChar()){case\"^\":case\"$\":case\"\\\\\":case\".\":case\"*\":case\"+\":case\"?\":case\"(\":case\")\":case\"[\":case\"|\":case\"/\":case\"\\n\":case\"\\r\":case\"\\u2028\":case\"\\u2029\":return !1;default:return !0}},t.prototype.parseHexDigits=function(t){for(var e=\"\",r=0;r<t;r++){var i=this.popChar();if(!1===n.test(i))throw Error(\"Expecting a HexDecimal digits\");e+=i;}var o=parseInt(e,16);return {type:\"Character\",value:o}},t.prototype.peekChar=function(t){return void 0===t&&(t=0),this.input[this.idx+t]},t.prototype.popChar=function(){var t=this.peekChar(0);return this.consumeChar(),t},t.prototype.consumeChar=function(t){if(void 0!==t&&this.input[this.idx]!==t)throw Error(\"Expected: '\"+t+\"' but found: '\"+this.input[this.idx]+\"' at offset: \"+this.idx);if(this.idx>=this.input.length)throw Error(\"Unexpected end of input\");this.idx++;};var e,n=/[0-9a-fA-F]/,r=/[0-9]/,i=/[1-9]/;function o(t){return t.charCodeAt(0)}function a(t,e){void 0!==t.length?t.forEach(function(t){e.push(t);}):e.push(t);}function s(t,e){if(!0===t[e])throw \"duplicate flag \"+e;t[e]=!0;}function u(t){if(void 0===t)throw Error(\"Internal Error - Should never get here!\")}var c=[];for(e=o(\"0\");e<=o(\"9\");e++)c.push(e);var p=[o(\"_\")].concat(c);for(e=o(\"a\");e<=o(\"z\");e++)p.push(e);for(e=o(\"A\");e<=o(\"Z\");e++)p.push(e);var l=[o(\" \"),o(\"\\f\"),o(\"\\n\"),o(\"\\r\"),o(\"\\t\"),o(\"\\v\"),o(\"\\t\"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\" \"),o(\"\\u2028\"),o(\"\\u2029\"),o(\" \"),o(\" \"),o(\"　\"),o(\"\\ufeff\")];function h(){}return h.prototype.visitChildren=function(t){for(var e in t){var n=t[e];t.hasOwnProperty(e)&&(void 0!==n.type?this.visit(n):Array.isArray(n)&&n.forEach(function(t){this.visit(t);},this));}},h.prototype.visit=function(t){switch(t.type){case\"Pattern\":this.visitPattern(t);break;case\"Flags\":this.visitFlags(t);break;case\"Disjunction\":this.visitDisjunction(t);break;case\"Alternative\":this.visitAlternative(t);break;case\"StartAnchor\":this.visitStartAnchor(t);break;case\"EndAnchor\":this.visitEndAnchor(t);break;case\"WordBoundary\":this.visitWordBoundary(t);break;case\"NonWordBoundary\":this.visitNonWordBoundary(t);break;case\"Lookahead\":this.visitLookahead(t);break;case\"NegativeLookahead\":this.visitNegativeLookahead(t);break;case\"Character\":this.visitCharacter(t);break;case\"Set\":this.visitSet(t);break;case\"Group\":this.visitGroup(t);break;case\"GroupBackReference\":this.visitGroupBackReference(t);break;case\"Quantifier\":this.visitQuantifier(t);}this.visitChildren(t);},h.prototype.visitPattern=function(t){},h.prototype.visitFlags=function(t){},h.prototype.visitDisjunction=function(t){},h.prototype.visitAlternative=function(t){},h.prototype.visitStartAnchor=function(t){},h.prototype.visitEndAnchor=function(t){},h.prototype.visitWordBoundary=function(t){},h.prototype.visitNonWordBoundary=function(t){},h.prototype.visitLookahead=function(t){},h.prototype.visitNegativeLookahead=function(t){},h.prototype.visitCharacter=function(t){},h.prototype.visitSet=function(t){},h.prototype.visitGroup=function(t){},h.prototype.visitGroupBackReference=function(t){},h.prototype.visitQuantifier=function(t){},{RegExpParser:t,BaseRegExpVisitor:h,VERSION:\"0.4.0\"}})?r.apply(e,i):r)||(t.exports=o);},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(t){return \"Unable to pop Lexer Mode after encountering Token ->\"+t.image+\"<- The Mode Stack is empty\"},buildUnexpectedCharactersMessage:function(t,e,n,r,i){return \"unexpected character: ->\"+t.charAt(e)+\"<- at offset: \"+e+\", skipped \"+n+\" characters.\"}};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(1),o=n(8);function a(t){if(t instanceof i.NonTerminal)return a(t.referencedRule);if(t instanceof i.Terminal)return c(t);if(o.isSequenceProd(t))return s(t);if(o.isBranchingProd(t))return u(t);throw Error(\"non exhaustive match\")}function s(t){for(var e,n=[],i=t.definition,s=0,u=i.length>s,c=!0;u&&c;)e=i[s],c=o.isOptionalProd(e),n=n.concat(a(e)),s+=1,u=i.length>s;return r.uniq(n)}function u(t){var e=r.map(t.definition,function(t){return a(t)});return r.uniq(r.flatten(e))}function c(t){return [t.terminalType]}e.first=a,e.firstForSequence=s,e.firstForBranching=u,e.firstForTerminal=c;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0}),e.IN=\"_~IN~_\";},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(29),o=n(0),a=n(1);!function(t){t[t.OPTION=0]=\"OPTION\",t[t.OR=1]=\"OR\",t[t.MANY=2]=\"MANY\",t[t.MANY_SEP=3]=\"MANY_SEP\",t[t.AT_LEAST_ONE=4]=\"AT_LEAST_ONE\",t[t.AT_LEAST_ONE_SEP=5]=\"AT_LEAST_ONE_SEP\",t[t.REF=6]=\"REF\",t[t.TERMINAL=7]=\"TERMINAL\",t[t.FLAT=8]=\"FLAT\";}(r=e.ProdType||(e.ProdType={}));var s=/(?:\\s*{\\s*NAME\\s*:\\s*[\"'`]([\\w$]*)[\"'`])?/,u=new RegExp(s.source.replace(\"{\",\"\").replace(\")?\",\"\\\\s*,)?\")),c=/\\.\\s*CONSUME(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,p=new RegExp(c.source,\"g\"),l=/\\.\\s*SUBRULE(\\d+)?\\s*\\(\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,h=new RegExp(l.source,\"g\"),f=/\\.\\s*OPTION(\\d+)?\\s*\\(/,d=new RegExp(f.source+s.source),E=new RegExp(f.source,\"g\"),m=/\\.\\s*MANY(\\d+)?\\s*\\(/,y=new RegExp(m.source+s.source),T=new RegExp(m.source,\"g\"),v=/\\s*SEP\\s*:\\s*(?:[a-zA-Z_$]\\w*\\s*\\.\\s*)*([a-zA-Z_$]\\w*)/,g=new RegExp(/\\.\\s*MANY_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),_=new RegExp(g.source,\"g\"),R=new RegExp(/\\.\\s*AT_LEAST_ONE_SEP(\\d+)?\\s*\\(\\s*{/.source+u.source+v.source),A=new RegExp(R.source,\"g\"),N=/\\.\\s*AT_LEAST_ONE(\\d+)?\\s*\\(/,O=new RegExp(N.source+s.source),S=new RegExp(N.source,\"g\"),I=/\\.\\s*OR(\\d+)?\\s*\\(/,L=new RegExp(I.source+s.source),k=new RegExp(I.source,\"g\"),P=new RegExp(u.source+/\\s*(ALT)\\s*:/.source),x=new RegExp(P.source,\"g\");function C(t,n,i){switch(t.type){case r.AT_LEAST_ONE:return function(t,e,n){return M(O,new a.RepetitionMandatory({definition:[]}),t,e,n)}(t,n,i);case r.AT_LEAST_ONE_SEP:return function(t,e,n){return F(t,e,a.RepetitionMandatoryWithSeparator,R,n)}(t,n,i);case r.MANY_SEP:return function(t,e,n){return F(t,e,a.RepetitionWithSeparator,g,n)}(t,n,i);case r.MANY:return function(t,e,n){return M(y,new a.Repetition({definition:[]}),t,e,n)}(t,n,i);case r.OPTION:return function(t,e,n){return M(d,new a.Option({definition:[]}),t,e,n)}(t,n,i);case r.OR:return function(t,e,n){return M(L,new a.Alternation({definition:[]}),t,e,n)}(t,n,i);case r.FLAT:return function(t,e,n){var r=new a.Flat({definition:[]}),i=P.exec(t.text)[1];o.isUndefined(i)||(r.name=i);return b(r,t.range,e,n)}(t,n,i);case r.REF:return function(t){var e=l.exec(t.text),n=void 0===e[1]?0:parseInt(e[1],10),r=e[2];return new a.NonTerminal({nonTerminalName:r,idx:n})}(t);case r.TERMINAL:return function(t,n){var r=c.exec(t.text),i=void 0===r[1]?0:parseInt(r[1],10),o=r[2],s=e.terminalNameToConstructor[o];if(!s)throw Error(\"Terminal Token name: <\"+o+\"> not found in rule: <\"+n+\">  \\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\\n\\tFor Further details.\");return new a.Terminal({terminalType:s,idx:i})}(t,i);default:throw Error(\"non exhaustive match\")}}function M(t,e,n,r,i){var a=t.exec(n.text),s=void 0===a[1];e.idx=s?0:parseInt(a[1],10);var u=a[2];return o.isUndefined(u)||(e.name=u),b(e,n.range,r,i)}function F(t,n,r,i,a){var s=i.exec(t.text),u=void 0===s[1]?0:parseInt(s[1],10),c=s[3],p=e.terminalNameToConstructor[c];if(!p)throw Error(\"Separator Terminal Token name: \"+c+\" not found\");var l=new r({definition:[],separator:p,idx:u}),h=s[2];return o.isUndefined(h)||(l.name=h),b(l,t.range,n,a)}function b(t,e,n,r){var i=D(e,n),a=o.sortBy(i,function(t){return t.range.start}),s=[];return o.forEach(a,function(t){s.push(C(t,n,r));}),t.definition=s,t}function D(t,e){return o.filter(e,function(n){var r=t.strictlyContainsRange(n.range),i=o.every(e,function(e){var r=e.range.strictlyContainsRange(n.range),i=e.range.isStrictlyContainedInRange(t);return !(r&&i)});return r&&i})}e.terminalNameToConstructor={},e.buildTopProduction=function(t,n,r){e.terminalNameToConstructor=r;var o=V(j(K(\"  \"+t)));return function(t,e,n,r){return b(new a.Rule({name:t,definition:[],orgText:r}),e,n,t)}(n,new i.Range(0,t.length+2),o,t)},e.buildProdGast=C,e.getDirectlyContainedRanges=D;var w=/\\/\\/.*/g,U=/\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\//g,G=/(NAME\\s*:\\s*)?\"([^\\\\\"]|\\\\([bfnrtv\"\\\\\\/]|u[0-9a-fA-F]{4}))*\"/g,B=/(NAME\\s*:\\s*)?'([^\\\\']|\\\\([bfnrtv'\\\\\\/]|u[0-9a-fA-F]{4}))*'/g;function K(t){return t.replace(w,\"\").replace(U,\"\")}function W(t,e){return void 0!==e?t:\"\"}function j(t){return t.replace(G,W).replace(B,W)}function V(t){var e=Y(t),n=H(t),r=X(t),i=z(t),o=q(t),a=$(t),s=Z(t),u=Q(t);return [].concat(e,n,r,i,o,a,s,u)}function Y(t){return nt(t,r.TERMINAL,p)}function H(t){return nt(t,r.REF,h)}function X(t){return rt(t,r.AT_LEAST_ONE,S)}function z(t){return rt(t,r.AT_LEAST_ONE_SEP,A)}function q(t){return rt(t,r.MANY,T)}function $(t){return rt(t,r.MANY_SEP,_)}function Z(t){return rt(t,r.OPTION,E)}function Q(t){var e=rt(t,r.OR,k),n=et(e);return e.concat(n)}e.removeComments=K,e.removeStringLiterals=j,e.createRanges=V,e.createTerminalRanges=Y,e.createRefsRanges=H,e.createAtLeastOneRanges=X,e.createAtLeastOneSepRanges=z,e.createManyRanges=q,e.createManySepRanges=$,e.createOptionRanges=Z,e.createOrRanges=Q;var J=o.partial(ot,\"{\",\"}\"),tt=o.partial(ot,\"(\",\")\");function et(t){var e=[];return o.forEach(t,function(t){var n=it(t.text,r.FLAT,x,J),i=t.range.start;o.forEach(n,function(t){t.range.start+=i,t.range.end+=i;}),e=e.concat(n);}),o.uniq(e,function(t){return t.type+\"~\"+t.range.start+\"~\"+t.range.end+\"~\"+t.text})}function nt(t,e,n){for(var r,o=[];r=n.exec(t);){var a=r.index,s=n.lastIndex,u=new i.Range(a,s),c=r[0];o.push({range:u,text:c,type:e});}return o}function rt(t,e,n){return it(t,e,n,tt)}function it(t,e,n,r){for(var o,a=[];o=n.exec(t);){var s=o.index,u=r(s+o[0].length,t),c=new i.Range(s,u),p=t.substr(s,u-s+1);a.push({range:c,text:p,type:e});}return a}function ot(t,e,n,r){for(var i=[1],a=-1;!o.isEmpty(i)&&a+n<r.length;){a++;var s=r.charAt(n+a);s===t?i.push(1):s===e&&i.pop();}if(o.isEmpty(i))return a+n;throw new Error(\"INVALID INPUT TEXT, UNTERMINATED PARENTHESIS\")}function at(t,e){return o.map(t,function(t){return st(t,e)})}function st(t,e){switch(t.type){case\"NonTerminal\":return new a.NonTerminal({nonTerminalName:t.name,idx:t.idx});case\"Flat\":return new a.Flat({name:t.name,definition:at(t.definition,e)});case\"Option\":return new a.Option({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatory\":return new a.RepetitionMandatory({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"RepetitionMandatoryWithSeparator\":return new a.RepetitionMandatoryWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"RepetitionWithSeparator\":return new a.RepetitionWithSeparator({name:t.name,idx:t.idx,separator:e[t.separator.name],definition:at(t.definition,e)});case\"Repetition\":return new a.Repetition({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Alternation\":return new a.Alternation({name:t.name,idx:t.idx,definition:at(t.definition,e)});case\"Terminal\":return new a.Terminal({terminalType:e[t.name],idx:t.idx});case\"Rule\":return new a.Rule({name:t.name,orgText:t.orgText,definition:at(t.definition,e)});}}e.createOrPartRanges=et,e.findClosingOffset=ot,e.deserializeGrammar=at,e.deserializeProduction=st;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(4),o=n(30),a=n(11),s=n(10),u=n(8);e.resolveGrammar=function(t){t=r.defaults(t,{errMsgProvider:s.defaultGrammarResolverErrorProvider});var e=new i.HashTable;return r.forEach(t.rules,function(t){e.put(t.name,t);}),o.resolveGrammar(e,t.errMsgProvider)},e.validateGrammar=function(t){return t=r.defaults(t,{errMsgProvider:s.defaultGrammarValidatorErrorProvider,ignoredIssues:{}}),a.validateGrammar(t.rules,t.maxLookahead,t.tokenTypes,t.ignoredIssues,t.errMsgProvider,t.grammarName)},e.assignOccurrenceIndices=function(t){r.forEach(t.rules,function(t){var e=new u.DslMethodsCollectorVisitor;t.accept(e),r.forEach(e.dslMethods,function(t){r.forEach(t,function(t,e){t.idx=e+1;});});});};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(2),i=n(0),o=n(6),a=n(22),s=n(4),u=n(3);function c(t){this.name=e.IN_RULE_RECOVERY_EXCEPTION,this.message=t;}e.EOF_FOLLOW_KEY={},e.IN_RULE_RECOVERY_EXCEPTION=\"InRuleRecoveryException\",e.InRuleRecoveryException=c,c.prototype=Error.prototype;var p=function(){function t(){}return t.prototype.initRecoverable=function(t){this.firstAfterRepMap=new s.HashTable,this.resyncFollows=new s.HashTable,this.recoveryEnabled=i.has(t,\"recoveryEnabled\")?t.recoveryEnabled:u.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=l);},t.prototype.getTokenToInsert=function(t){var e=r.createTokenInstance(t,\"\",NaN,NaN,NaN,NaN,NaN,NaN);return e.isInsertedInRecovery=!0,e},t.prototype.canTokenTypeBeInsertedInRecovery=function(t){return !0},t.prototype.tryInRepetitionRecovery=function(t,e,n,r){for(var a=this,s=this.findReSyncTokenType(),u=this.exportLexerState(),c=[],p=!1,l=this.LA(1),h=this.LA(1),f=function(){var t=a.LA(0),e=a.errorMessageProvider.buildMismatchTokenMessage({expected:r,actual:l,previous:t,ruleName:a.getCurrRuleFullName()}),n=new o.MismatchedTokenException(e,l,a.LA(0));n.resyncedTokens=i.dropRight(c),a.SAVE_ERROR(n);};!p;){if(this.tokenMatcher(h,r))return void f();if(n.call(this))return f(),void t.apply(this,e);this.tokenMatcher(h,s)?p=!0:(h=this.SKIP_TOKEN(),this.addToResyncTokens(h,c));}this.importLexerState(u);},t.prototype.shouldInRepetitionRecoveryBeTried=function(t,e){return void 0!==t&&void 0!==e&&(!this.tokenMatcher(this.LA(1),t)&&(!this.isBackTracking()&&!this.canPerformInRuleRecovery(t,this.getFollowsForInRuleRecovery(t,e))))},t.prototype.getFollowsForInRuleRecovery=function(t,e){var n=this.getCurrentGrammarPath(t,e);return this.getNextPossibleTokenTypes(n)},t.prototype.tryInRuleRecovery=function(t,e){if(this.canRecoverWithSingleTokenInsertion(t,e))return this.getTokenToInsert(t);if(this.canRecoverWithSingleTokenDeletion(t)){var n=this.SKIP_TOKEN();return this.consumeToken(),n}throw new c(\"sad sad panda\")},t.prototype.canPerformInRuleRecovery=function(t,e){return this.canRecoverWithSingleTokenInsertion(t,e)||this.canRecoverWithSingleTokenDeletion(t)},t.prototype.canRecoverWithSingleTokenInsertion=function(t,e){var n=this;if(!this.canTokenTypeBeInsertedInRecovery(t))return !1;if(i.isEmpty(e))return !1;var r=this.LA(1);return void 0!==i.find(e,function(t){return n.tokenMatcher(r,t)})},t.prototype.canRecoverWithSingleTokenDeletion=function(t){return this.tokenMatcher(this.LA(2),t)},t.prototype.isInCurrentRuleReSyncSet=function(t){var e=this.getCurrFollowKey(),n=this.getFollowSetFromFollowKey(e);return i.contains(n,t)},t.prototype.findReSyncTokenType=function(){for(var t=this.flattenFollowSet(),e=this.LA(1),n=2;;){var r=e.tokenType;if(i.contains(t,r))return r;e=this.LA(n),n++;}},t.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return e.EOF_FOLLOW_KEY;var t=this.getLastExplicitRuleShortName(),n=this.getLastExplicitRuleOccurrenceIndex(),r=this.getPreviousExplicitRuleShortName();return {ruleName:this.shortRuleNameToFullName(t),idxInCallingRule:n,inRule:this.shortRuleNameToFullName(r)}},t.prototype.buildFullFollowKeyStack=function(){var t=this,n=this.RULE_STACK,r=this.RULE_OCCURRENCE_STACK;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)||(n=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_STACK[e]}),r=i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.RULE_OCCURRENCE_STACK[e]})),i.map(n,function(i,o){return 0===o?e.EOF_FOLLOW_KEY:{ruleName:t.shortRuleNameToFullName(i),idxInCallingRule:r[o],inRule:t.shortRuleNameToFullName(n[o-1])}})},t.prototype.flattenFollowSet=function(){var t=this,e=i.map(this.buildFullFollowKeyStack(),function(e){return t.getFollowSetFromFollowKey(e)});return i.flatten(e)},t.prototype.getFollowSetFromFollowKey=function(t){if(t===e.EOF_FOLLOW_KEY)return [r.EOF];var n=t.ruleName+t.idxInCallingRule+a.IN+t.inRule;return this.resyncFollows.get(n)},t.prototype.addToResyncTokens=function(t,e){return this.tokenMatcher(t,r.EOF)||e.push(t),e},t.prototype.reSyncTo=function(t){for(var e=[],n=this.LA(1);!1===this.tokenMatcher(n,t);)n=this.SKIP_TOKEN(),this.addToResyncTokens(n,e);return i.dropRight(e)},t.prototype.attemptInRepetitionRecovery=function(t,e,n,r,i,o){},t.prototype.getCurrentGrammarPath=function(t,e){return {ruleStack:this.getHumanReadableRuleStack(),occurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK),lastTok:t,lastTokOccurrence:e}},t.prototype.getHumanReadableRuleStack=function(){var t=this;return i.isEmpty(this.LAST_EXPLICIT_RULE_STACK)?i.map(this.RULE_STACK,function(e){return t.shortRuleNameToFullName(e)}):i.map(this.LAST_EXPLICIT_RULE_STACK,function(e){return t.shortRuleNameToFullName(t.RULE_STACK[e])})},t}();function l(t,e,n,i,o,a){var s=this.getKeyForAutomaticLookahead(i,o),u=this.firstAfterRepMap.get(s);if(void 0===u){var c=this.getCurrRuleFullName();u=new a(this.getGAstProductions().get(c),o).startWalking(),this.firstAfterRepMap.put(s,u);}var p=u.token,l=u.occurrence,h=u.isEndOfRule;1===this.RULE_STACK.length&&h&&void 0===p&&(p=r.EOF,l=1),this.shouldInRepetitionRecoveryBeTried(p,l)&&this.tryInRepetitionRecovery(t,e,n,p);}e.Recoverable=p,e.attemptInRepetitionRecovery=l;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(14),a=n(4),s=n(21),u=n(0),c=n(22),p=n(2),l=n(1),h=function(t){function e(e){var n=t.call(this)||this;return n.topProd=e,n.follows=new a.HashTable,n}return i(e,t),e.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},e.prototype.walkTerminal=function(t,e,n){},e.prototype.walkProdRef=function(t,e,n){var r=f(t.referencedRule,t.idx)+this.topProd.name,i=e.concat(n),o=new l.Flat({definition:i}),a=s.first(o);this.follows.put(r,a);},e}(o.RestWalker);function f(t,e){return t.name+e+c.IN}e.ResyncFollowsWalker=h,e.computeAllProdsFollows=function(t){var e=new a.HashTable;return u.forEach(t,function(t){var n=new h(t).startWalking();e.putAll(n);}),e},e.buildBetweenProdsFollowPrefix=f,e.buildInProdFollowPrefix=function(t){return p.tokenName(t.terminalType)+t.idx+c.IN};},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(2),s=n(15),u=n(0),c=n(28),p=new o.RegExpParser,l=\"PATTERN\";function h(t){var e=u.filter(t,function(t){return !u.has(t,l)});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- missing static 'PATTERN' property\",type:s.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}function f(t){var e=u.filter(t,function(t){var e=t[l];return !(u.isRegExp(e)||u.isFunction(e)||u.has(e,\"exec\")||u.isString(e))});return {errors:u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",type:s.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[t]}}),valid:u.difference(t,e)}}e.DEFAULT_MODE=\"defaultMode\",e.MODES=\"modes\",e.SUPPORT_STICKY=\"boolean\"==typeof new RegExp(\"(?:)\").sticky,e.disableSticky=function(){e.SUPPORT_STICKY=!1;},e.enableSticky=function(){e.SUPPORT_STICKY=!0;},e.analyzeTokenTypes=function(t,n){n=u.defaults(n,{useSticky:e.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:\"full\",lineTerminatorCharacters:[\"\\r\",\"\\n\"]});var r=u.reject(t,function(t){return t[l]===s.Lexer.NA}),i=!1,o=u.map(r,function(t){var e=t[l];if(u.isRegExp(e)){var r=e.source;return 1===r.length&&\"^\"!==r&&\"$\"!==r&&\".\"!==r?r:2!==r.length||\"\\\\\"!==r[0]||u.contains([\"d\",\"D\",\"s\",\"S\",\"t\",\"r\",\"n\",\"t\",\"0\",\"c\",\"b\",\"B\",\"f\",\"v\",\"w\",\"W\"],r[1])?n.useSticky?O(e):N(e):r[1]}if(u.isFunction(e))return i=!0,{exec:e};if(u.has(e,\"exec\"))return i=!0,e;if(\"string\"==typeof e){if(1===e.length)return e;var o=e.replace(/[\\\\^$.*+?()[\\]{}|]/g,\"\\\\$&\"),a=new RegExp(o);return n.useSticky?O(a):N(a)}throw Error(\"non exhaustive match\")}),p=u.map(r,function(t){return t.tokenTypeIdx}),h=u.map(r,function(t){var e=t.GROUP;if(e!==s.Lexer.SKIPPED){if(u.isString(e))return e;if(u.isUndefined(e))return !1;throw Error(\"non exhaustive match\")}}),f=u.map(r,function(t){var e=t.LONGER_ALT;if(e)return u.indexOf(r,e)}),d=u.map(r,function(t){return t.PUSH_MODE}),E=u.map(r,function(t){return u.has(t,\"POP_MODE\")}),m=P(n.lineTerminatorCharacters),y=u.map(r,function(t){return !1});\"onlyOffset\"!==n.positionTracking&&(y=u.map(r,function(t){return u.has(t,\"LINE_BREAKS\")?t.LINE_BREAKS:!1===L(t,m)?c.canMatchCharCode(m,t.PATTERN):void 0}));var T=u.map(r,S),v=u.map(o,I),g=u.reduce(r,function(t,e){var n=e.GROUP;return u.isString(n)&&n!==s.Lexer.SKIPPED&&(t[n]=[]),t},{}),_=u.map(o,function(t,e){return {pattern:o[e],longerAlt:f[e],canLineTerminator:y[e],isCustom:T[e],short:v[e],group:h[e],push:d[e],pop:E[e],tokenTypeIdx:p[e],tokenType:r[e]}});function R(t,e,n){void 0===t[e]&&(t[e]=[]),t[e].push(n);}var A=!0,k=[];return n.safeMode||(k=u.reduce(r,function(t,e,r){if(\"string\"==typeof e.PATTERN){var i=e.PATTERN.charCodeAt(0);R(t,i,_[r]);}else if(u.isArray(e.START_CHARS_HINT))u.forEach(e.START_CHARS_HINT,function(e){var n=\"string\"==typeof e?e.charCodeAt(0):e;R(t,n,_[r]);});else if(u.isRegExp(e.PATTERN))if(e.PATTERN.unicode)A=!1,n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tUnable to analyze < \"+e.PATTERN.toString()+\" > pattern.\\n\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\");else {var o=c.getStartCodes(e.PATTERN,n.ensureOptimizations);u.isEmpty(o)&&(A=!1),u.forEach(o,function(e){R(t,e,_[r]);});}else n.ensureOptimizations&&u.PRINT_ERROR(c.failedOptimizationPrefixMsg+\"\\tTokenType: <\"+a.tokenName(e)+\"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"),A=!1;return t},[])),A&&k.length<65536&&(k=u.packArray(k)),{emptyGroups:g,patternIdxToConfig:_,charCodeToPatternIdxToConfig:k,hasCustom:i,canBeOptimized:A}},e.validatePatterns=function(t,e){var n=[],r=h(t);n=n.concat(r.errors);var i=f(r.valid),o=i.valid;return n=(n=(n=(n=(n=n.concat(i.errors)).concat(function(t){var e=[],n=u.filter(t,function(t){return u.isRegExp(t[l])});return e=(e=(e=(e=(e=e.concat(E(n))).concat(T(n))).concat(v(n))).concat(g(n))).concat(m(n))}(o))).concat(_(o))).concat(R(o,e))).concat(A(o))},e.findMissingPatterns=h,e.findInvalidPatterns=f;var d=/[^\\\\][\\$]/;function E(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitEndAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return d.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[t]}})}function m(t){var e=u.filter(t,function(t){return t[l].test(\"\")});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' must not match an empty string\",type:s.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[t]}})}e.findEndOfInputAnchor=E,e.findEmptyMatchRegExps=m;var y=/[^\\\\[][\\^]|^\\^/;function T(t){var e=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e.found=!1,e}return i(e,t),e.prototype.visitStartAnchor=function(t){this.found=!0;},e}(o.BaseRegExpVisitor),n=u.filter(t,function(t){var n=t[l];try{var r=p.pattern(n.toString()),i=new e;return i.visit(r),i.found}catch(t){return y.test(n.source)}});return u.map(n,function(t){return {message:\"Unexpected RegExp Anchor Error:\\n\\tToken Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\\tfor details.\",type:s.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[t]}})}function v(t){var e=u.filter(t,function(t){var e=t[l];return e instanceof RegExp&&(e.multiline||e.global)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",type:s.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[t]}})}function g(t){var e=[],n=u.map(t,function(n){return u.reduce(t,function(t,r){return n.PATTERN.source!==r.PATTERN.source||u.contains(e,r)||r.PATTERN===s.Lexer.NA?t:(e.push(r),t.push(r),t)},[])});n=u.compact(n);var r=u.filter(n,function(t){return t.length>1});return u.map(r,function(t){var e=u.map(t,function(t){return a.tokenName(t)});return {message:\"The same RegExp pattern ->\"+u.first(t).PATTERN+\"<-has been used in all of the following Token Types: \"+e.join(\", \")+\" <-\",type:s.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:t}})}function _(t){var e=u.filter(t,function(t){if(!u.has(t,\"GROUP\"))return !1;var e=t.GROUP;return e!==s.Lexer.SKIPPED&&e!==s.Lexer.NA&&!u.isString(e)});return u.map(e,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",type:s.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[t]}})}function R(t,e){var n=u.filter(t,function(t){return void 0!==t.PUSH_MODE&&!u.contains(e,t.PUSH_MODE)});return u.map(n,function(t){return {message:\"Token Type: ->\"+a.tokenName(t)+\"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\"+t.PUSH_MODE+\"<-which does not exist\",type:s.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[t]}})}function A(t){var e=[],n=u.reduce(t,function(t,e,n){var r,i=e.PATTERN;return i===s.Lexer.NA?t:(u.isString(i)?t.push({str:i,idx:n,tokenType:e}):u.isRegExp(i)&&(r=i,void 0===u.find([\".\",\"\\\\\",\"[\",\"]\",\"|\",\"^\",\"$\",\"(\",\")\",\"?\",\"*\",\"+\",\"{\"],function(t){return -1!==r.source.indexOf(t)}))&&t.push({str:i.source,idx:n,tokenType:e}),t)},[]);return u.forEach(t,function(t,r){u.forEach(n,function(n){var i=n.str,o=n.idx,c=n.tokenType;if(r<o&&function(t,e){if(u.isRegExp(e)){var n=e.exec(t);return null!==n&&0===n.index}if(u.isFunction(e))return e(t,0,[],{});if(u.has(e,\"exec\"))return e.exec(t,0,[],{});if(\"string\"==typeof e)return e===t;throw Error(\"non exhaustive match\")}(i,t.PATTERN)){var p=\"Token: ->\"+a.tokenName(c)+\"<- can never be matched.\\nBecause it appears AFTER the Token Type ->\"+a.tokenName(t)+\"<-in the lexer's definition.\\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE\";e.push({message:p,type:s.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[t,c]});}});}),e}function N(t){var e=t.ignoreCase?\"i\":\"\";return new RegExp(\"^(?:\"+t.source+\")\",e)}function O(t){var e=t.ignoreCase?\"iy\":\"y\";return new RegExp(\"\"+t.source,e)}function S(t){var e=t.PATTERN;if(u.isRegExp(e))return !1;if(u.isFunction(e))return !0;if(u.has(e,\"exec\"))return !0;if(u.isString(e))return !1;throw Error(\"non exhaustive match\")}function I(t){return !(!u.isString(t)||1!==t.length)&&t.charCodeAt(0)}function L(t,e){if(u.has(t,\"LINE_BREAKS\"))return !1;if(u.isRegExp(t.PATTERN)){try{c.canMatchCharCode(e,t.PATTERN);}catch(t){return {issue:s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:t.message}}return !1}if(u.isString(t.PATTERN))return !1;if(S(t))return {issue:s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error(\"non exhaustive match\")}function k(t,e){if(e.issue===s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return \"Warning: unable to identify line terminator usage in pattern.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\t Root cause: \"+e.errMsg+\".\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\";if(e.issue===s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\\tThe problem is in the <\"+t.name+\"> Token Type\\n\\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\";throw Error(\"non exhaustive match\")}function P(t){return u.map(t,function(t){return u.isString(t)&&t.length>0?t.charCodeAt(0):t})}e.findStartOfInputAnchor=T,e.findUnsupportedFlags=v,e.findDuplicatePatterns=g,e.findInvalidGroupType=_,e.findModesThatDoNotExist=R,e.findUnreachablePatterns=A,e.addStartOfInput=N,e.addStickyFlag=O,e.performRuntimeChecks=function(t,n,r){var i=[];return u.has(t,e.DEFAULT_MODE)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.DEFAULT_MODE+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),u.has(t,e.MODES)||i.push({message:\"A MultiMode Lexer cannot be initialized without a <\"+e.MODES+\"> property in its definition\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),u.has(t,e.MODES)&&u.has(t,e.DEFAULT_MODE)&&!u.has(t.modes,t.defaultMode)&&i.push({message:\"A MultiMode Lexer cannot be initialized with a \"+e.DEFAULT_MODE+\": <\"+t.defaultMode+\">which does not exist\\n\",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),u.has(t,e.MODES)&&u.forEach(t.modes,function(t,e){u.forEach(t,function(t,n){u.isUndefined(t)&&i.push({message:\"A Lexer cannot be initialized using an undefined Token Type. Mode:<\"+e+\"> at index: <\"+n+\">\\n\",type:s.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED});});}),i},e.performWarningRuntimeChecks=function(t,e,n){var r=[],i=!1,o=u.compact(u.flatten(u.mapValues(t.modes,function(t){return t}))),a=u.reject(o,function(t){return t[l]===s.Lexer.NA}),p=P(n);return e&&u.forEach(a,function(t){var e=L(t,p);if(!1!==e){var n={message:k(t,e),type:e.issue,tokenType:t};r.push(n);}else u.has(t,\"LINE_BREAKS\")?!0===t.LINE_BREAKS&&(i=!0):c.canMatchCharCode(p,t.PATTERN)&&(i=!0);}),e&&!i&&r.push({message:\"Warning: No LINE_BREAKS Found.\\n\\tThis Lexer has been defined to track line and column information,\\n\\tBut none of the Token Types can be identified as matching a line terminator.\\n\\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\\tfor details.\",type:s.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),r},e.cloneEmptyGroups=function(t){var e={},n=u.keys(t);return u.forEach(n,function(n){var r=t[n];if(!u.isArray(r))throw Error(\"non exhaustive match\");e[n]=[];}),e},e.isCustomPattern=S,e.isShortPattern=I,e.LineTerminatorOptimizedTester={test:function(t){for(var e=t.length,n=this.lastIndex;n<e;n++){var r=t.charCodeAt(n);if(10===r)return this.lastIndex=n+1,!0;if(13===r)return 10===t.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return !1},lastIndex:0},e.buildLineBreakIssueMessage=k;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(19),a=n(0),s=new o.RegExpParser,u=\"Complement Sets are not supported for first char optimization\";function c(t){switch(t.type){case\"Disjunction\":return a.flatten(a.map(t.value,c));case\"Alternative\":for(var e=[],n=t.value,r=0;r<n.length;r++){var i=n[r];if(!a.contains([\"GroupBackReference\",\"Lookahead\",\"NegativeLookahead\",\"StartAnchor\",\"EndAnchor\",\"WordBoundary\",\"NonWordBoundary\"],i.type)){var o=i;switch(o.type){case\"Character\":e.push(o.value);break;case\"Set\":if(!0===o.complement)throw Error(u);a.forEach(o.value,function(t){if(\"number\"==typeof t)e.push(t);else for(var n=t,r=n.from;r<=n.to;r++)e.push(r);});break;case\"Group\":var s=c(o.value);a.forEach(s,function(t){return e.push(t)});break;default:throw Error(\"Non Exhaustive Match\")}var p=void 0!==o.quantifier&&0===o.quantifier.atLeast;if(\"Group\"===o.type&&!1===h(o)||\"Group\"!==o.type&&!1===p)break}}return e;default:throw Error(\"non exhaustive match!\")}}function p(t){var e=[];return a.forEach(t,function(t){e.push(t);var n=String.fromCharCode(t);n.toUpperCase()!==n?e.push(n.toUpperCase().charCodeAt(0)):n.toLowerCase()!==n&&e.push(n.toLowerCase().charCodeAt(0));}),e}function l(t,e){return a.find(t.value,function(t){if(\"number\"==typeof t)return a.contains(e,t);var n=t;return void 0!==a.find(e,function(t){return n.from<=t&&t<=n.to})})}function h(t){return !(!t.quantifier||0!==t.quantifier.atLeast)||!!t.value&&(a.isArray(t.value)?a.every(t.value,h):h(t.value))}e.failedOptimizationPrefixMsg='Unable to use \"first char\" lexer optimizations:\\n',e.getStartCodes=function(t,n){void 0===n&&(n=!1);try{var r=s.pattern(t.toString()),i=c(r.value);return r.flags.ignoreCase&&(i=p(i)),i}catch(r){if(r.message===u)n&&a.PRINT_WARNING(e.failedOptimizationPrefixMsg+\"\\tUnable to optimize: < \"+t.toString()+\" >\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");else {var l=\"\";n&&(l=\"\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"),a.PRINT_ERROR(e.failedOptimizationPrefixMsg+\"\\n\\tFailed parsing: < \"+t.toString()+\" >\\n\\tUsing the regexp-to-ast library version: \"+o.VERSION+\"\\n\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\"+l);}}return []},e.firstChar=c,e.applyIgnoreCase=p;var f=function(t){function e(e){var n=t.call(this)||this;return n.targetCharCodes=e,n.found=!1,n}return i(e,t),e.prototype.visitChildren=function(e){switch(e.type){case\"Lookahead\":return void this.visitLookahead(e);case\"NegativeLookahead\":return void this.visitNegativeLookahead(e)}t.prototype.visitChildren.call(this,e);},e.prototype.visitCharacter=function(t){a.contains(this.targetCharCodes,t.value)&&(this.found=!0);},e.prototype.visitSet=function(t){t.complement?void 0===l(t,this.targetCharCodes)&&(this.found=!0):void 0!==l(t,this.targetCharCodes)&&(this.found=!0);},e}(o.BaseRegExpVisitor);e.canMatchCharCode=function(t,e){if(e instanceof RegExp){var n=s.pattern(e.toString()),r=new f(t);return r.visit(n),r.found}return void 0!==a.find(e,function(e){return a.contains(t,e.charCodeAt(0))})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=function(){function t(t,e){if(this.start=t,this.end=e,!i(t,e))throw new Error(\"INVALID RANGE\")}return t.prototype.contains=function(t){return this.start<=t&&this.end>=t},t.prototype.containsRange=function(t){return this.start<=t.start&&this.end>=t.end},t.prototype.isContainedInRange=function(t){return t.containsRange(this)},t.prototype.strictlyContainsRange=function(t){return this.start<t.start&&this.end>t.end},t.prototype.isStrictlyContainedInRange=function(t){return t.strictlyContainsRange(this)},t}();function i(t,e){return !(t<0||e<t)}e.Range=r,e.isValidRange=i;},function(t,e,n){var r,i=this&&this.__extends||(r=function(t,e){return (r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);})(t,e)},function(t,e){function n(){this.constructor=t;}r(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n);});Object.defineProperty(e,\"__esModule\",{value:!0});var o=n(3),a=n(0),s=n(5);e.resolveGrammar=function(t,e){var n=new u(t,e);return n.resolveRefs(),n.errors};var u=function(t){function e(e,n){var r=t.call(this)||this;return r.nameToTopRule=e,r.errMsgProvider=n,r.errors=[],r}return i(e,t),e.prototype.resolveRefs=function(){var t=this;a.forEach(this.nameToTopRule.values(),function(e){t.currTopLevel=e,e.accept(t);});},e.prototype.visitNonTerminal=function(t){var e=this.nameToTopRule.get(t.nonTerminalName);if(e)t.referencedRule=e;else {var n=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,t);this.errors.push({message:n,type:o.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:t.nonTerminalName});}},e}(s.GAstVisitor);e.GastRefResolverVisitor=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(12),i=n(0),o=n(3),a=n(9),s=function(){function t(){}return t.prototype.initLooksAhead=function(t){this.dynamicTokensEnabled=i.has(t,\"dynamicTokensEnabled\")?t.dynamicTokensEnabled:o.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=i.has(t,\"maxLookahead\")?t.maxLookahead:o.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=i.isES2015MapSupported()?new Map:[],i.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj);},t.prototype.lookAheadBuilderForOptional=function(t,e,n){return r.buildSingleAlternativeLookaheadFunction(t,e,n)},t.prototype.lookAheadBuilderForAlternatives=function(t,e,n,i){return r.buildAlternativesLookAheadFunc(t,e,n,i)},t.prototype.getKeyForAutomaticLookahead=function(t,e){var n=this.getLastExplicitRuleShortName();return a.getKeyForAutomaticLookahead(n,t,e)},t.prototype.getLookaheadFuncForOr=function(t,e){var n=this.getKeyForAutomaticLookahead(a.OR_IDX,t),o=this.getLaFuncFromCache(n);if(void 0===o){var s=this.getCurrRuleFullName(),u=this.getGAstProductions().get(s),c=i.some(e,function(t){return i.isFunction(t.GATE)});return o=r.buildLookaheadFuncForOr(t,u,this.maxLookahead,c,this.dynamicTokensEnabled,this.lookAheadBuilderForAlternatives),this.setLaFuncCache(n,o),o}return o},t.prototype.getLookaheadFuncForOption=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.OPTION)},t.prototype.getLookaheadFuncForMany=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION)},t.prototype.getLookaheadFuncForManySep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_WITH_SEPARATOR)},t.prototype.getLookaheadFuncForAtLeastOne=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY)},t.prototype.getLookaheadFuncForAtLeastOneSep=function(t,e){return this.getLookaheadFuncFor(t,e,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)},t.prototype.getLookaheadFuncFor=function(t,e,n,i){var o=this.getLaFuncFromCache(t);if(void 0===o){var a=this.getCurrRuleFullName(),s=this.getGAstProductions().get(a);return o=r.buildLookaheadFuncForOptionalProd(e,s,n,this.dynamicTokensEnabled,i,this.lookAheadBuilderForOptional),this.setLaFuncCache(t,o),o}return o},t.prototype.getLaFuncFromCache=function(t){},t.prototype.getLaFuncFromMap=function(t){return this.lookAheadFuncsCache.get(t)},t.prototype.getLaFuncFromObj=function(t){return this.lookAheadFuncsCache[t]},t.prototype.setLaFuncCache=function(t,e){},t.prototype.setLaFuncCacheUsingMap=function(t,e){this.lookAheadFuncsCache.set(t,e);},t.prototype.setLaFuncUsingObj=function(t,e){this.lookAheadFuncsCache[t]=e;},t}();e.LooksAhead=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(16),i=n(0),o=n(33),a=n(9),s=n(3),u=function(){function t(){}return t.prototype.initTreeBuilder=function(t){this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.outputCst=i.has(t,\"outputCst\")?t.outputCst:s.DEFAULT_PARSER_CONFIG.outputCst,this.outputCst||(this.cstInvocationStateUpdate=i.NOOP,this.cstFinallyStateUpdate=i.NOOP,this.cstPostTerminal=i.NOOP,this.cstPostNonTerminal=i.NOOP,this.getLastExplicitRuleShortName=this.getLastExplicitRuleShortNameNoCst,this.getPreviousExplicitRuleShortName=this.getPreviousExplicitRuleShortNameNoCst,this.getLastExplicitRuleOccurrenceIndex=this.getLastExplicitRuleOccurrenceIndexNoCst,this.manyInternal=this.manyInternalNoCst,this.orInternal=this.orInternalNoCst,this.optionInternal=this.optionInternalNoCst,this.atLeastOneInternal=this.atLeastOneInternalNoCst,this.manySepFirstInternal=this.manySepFirstInternalNoCst,this.atLeastOneSepFirstInternal=this.atLeastOneSepFirstInternalNoCst);},t.prototype.cstNestedInvocationStateUpdate=function(t,e){this.CST_STACK.push({name:t,fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName())+t,children:{}});},t.prototype.cstInvocationStateUpdate=function(t,e){this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length-1),this.CST_STACK.push({name:t,children:{}});},t.prototype.cstFinallyStateUpdate=function(){this.LAST_EXPLICIT_RULE_STACK.pop(),this.CST_STACK.pop();},t.prototype.cstNestedFinallyStateUpdate=function(){this.CST_STACK.pop();},t.prototype.cstPostTerminal=function(t,e){var n=this.CST_STACK[this.CST_STACK.length-1];r.addTerminalToCst(n,e,t);},t.prototype.cstPostNonTerminal=function(t,e){r.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length-1],e,t);},t.prototype.getBaseCstVisitorConstructor=function(){if(i.isUndefined(this.baseCstVisitorConstructor)){var t=o.createBaseSemanticVisitorConstructor(this.className,this.allRuleNames);return this.baseCstVisitorConstructor=t,t}return this.baseCstVisitorConstructor},t.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(i.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var t=o.createBaseVisitorConstructorWithDefaults(this.className,this.allRuleNames,this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=t,t}return this.baseCstVisitorWithDefaultsConstructor},t.prototype.nestedRuleBeforeClause=function(t,e){var n;return void 0!==t.NAME?(n=t.NAME,this.nestedRuleInvocationStateUpdate(n,e),n):void 0},t.prototype.nestedAltBeforeClause=function(t,e,n,r){var i,o=this.getLastExplicitRuleShortName(),s=a.getKeyForAltIndex(o,n,e,r);return void 0!==t.NAME?(i=t.NAME,this.nestedRuleInvocationStateUpdate(i,s),{shortName:s,nestedName:i}):void 0},t.prototype.nestedRuleFinallyClause=function(t,e){var n=this.CST_STACK,i=n[n.length-1];this.nestedRuleFinallyStateUpdate();var o=n[n.length-1];r.addNoneTerminalToCst(o,e,i);},t.prototype.getLastExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_STACK[t]},t.prototype.getLastExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-1]},t.prototype.getPreviousExplicitRuleShortName=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-2];return this.RULE_STACK[t]},t.prototype.getPreviousExplicitRuleShortNameNoCst=function(){var t=this.RULE_STACK;return t[t.length-2]},t.prototype.getLastExplicitRuleOccurrenceIndex=function(){var t=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_OCCURRENCE_STACK[t]},t.prototype.getLastExplicitRuleOccurrenceIndexNoCst=function(){var t=this.RULE_OCCURRENCE_STACK;return t[t.length-1]},t.prototype.nestedRuleInvocationStateUpdate=function(t,e){this.RULE_OCCURRENCE_STACK.push(1),this.RULE_STACK.push(e),this.cstNestedInvocationStateUpdate(t,e);},t.prototype.nestedRuleFinallyStateUpdate=function(){this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstNestedFinallyStateUpdate();},t}();e.TreeBuilder=u;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r,i=n(0),o=n(4),a=n(11);function s(t,e){for(var n=i.keys(t),r=n.length,o=0;o<r;o++)for(var a=t[n[o]],s=a.length,u=0;u<s;u++){var c=a[u];void 0===c.tokenTypeIdx&&(void 0!==c.fullName?this[c.fullName](c.children,e):this[c.name](c.children,e));}}function u(t,e){var n=c(t,e),r=l(t,e);return n.concat(r)}function c(t,e){var n=i.map(e,function(e){if(!i.isFunction(t[e]))return {msg:\"Missing visitor method: <\"+e+\"> on \"+o.functionName(t.constructor)+\" CST Visitor.\",type:r.MISSING_METHOD,methodName:e}});return i.compact(n)}e.defaultVisit=s,e.createBaseSemanticVisitorConstructor=function(t,e){var n=function(){};return o.defineNameProp(n,t+\"BaseSemantics\"),(n.prototype={visit:function(t,e){if(i.isArray(t)&&(t=t[0]),!i.isUndefined(t))return void 0!==t.fullName?this[t.fullName](t.children,e):this[t.name](t.children,e)},validateVisitor:function(){var t=u(this,e);if(!i.isEmpty(t)){var n=i.map(t,function(t){return t.msg});throw Error(\"Errors Detected in CST Visitor <\"+o.functionName(this.constructor)+\">:\\n\\t\"+n.join(\"\\n\\n\").replace(/\\n/g,\"\\n\\t\"))}}}).constructor=n,n._RULE_NAMES=e,n},e.createBaseVisitorConstructorWithDefaults=function(t,e,n){var r=function(){};o.defineNameProp(r,t+\"BaseSemanticsWithDefaults\");var a=Object.create(n.prototype);return i.forEach(e,function(t){a[t]=s;}),(r.prototype=a).constructor=r,r},function(t){t[t.REDUNDANT_METHOD=0]=\"REDUNDANT_METHOD\",t[t.MISSING_METHOD=1]=\"MISSING_METHOD\";}(r=e.CstVisitorDefinitionError||(e.CstVisitorDefinitionError={})),e.validateVisitor=u,e.validateMissingCstMethods=c;var p=[\"constructor\",\"visit\",\"validateVisitor\"];function l(t,e){var n=[];for(var s in t)a.validTermsPattern.test(s)&&i.isFunction(t[s])&&!i.contains(p,s)&&!i.contains(e,s)&&n.push({msg:\"Redundant visitor method: <\"+s+\"> on \"+o.functionName(t.constructor)+\" CST Visitor\\nThere is no Grammar Rule corresponding to this method's name.\\nFor utility methods on visitor classes use methods names that do not match /\"+a.validTermsPattern.source+\"/.\",type:r.REDUNDANT_METHOD,methodName:s});return n}e.validateRedundantMethods=l;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(3),i=function(){function t(){}return t.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1;},Object.defineProperty(t.prototype,\"input\",{get:function(){return this.tokVector},set:function(t){this.reset(),this.tokVector=t,this.tokVectorLength=t.length;},enumerable:!0,configurable:!0}),t.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):r.END_OF_FILE},t.prototype.LA=function(t){return this.currIdx+t<0||this.tokVectorLength<=this.currIdx+t?r.END_OF_FILE:this.tokVector[this.currIdx+t]},t.prototype.consumeToken=function(){this.currIdx++;},t.prototype.exportLexerState=function(){return this.currIdx},t.prototype.importLexerState=function(t){this.currIdx=t;},t.prototype.resetLexerState=function(){this.currIdx=-1;},t.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1;},t.prototype.getLexerPosition=function(){return this.exportLexerState()},t}();e.LexerAdapter=i;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(6),o=n(3),a=n(10),s=n(23),u=n(11),c=n(1),p=function(){function t(){}return t.prototype.CONSUME=function(t,e){return this.consumeInternal(t,0,e)},t.prototype.CONSUME1=function(t,e){return this.consumeInternal(t,1,e)},t.prototype.CONSUME2=function(t,e){return this.consumeInternal(t,2,e)},t.prototype.CONSUME3=function(t,e){return this.consumeInternal(t,3,e)},t.prototype.CONSUME4=function(t,e){return this.consumeInternal(t,4,e)},t.prototype.CONSUME5=function(t,e){return this.consumeInternal(t,5,e)},t.prototype.CONSUME6=function(t,e){return this.consumeInternal(t,6,e)},t.prototype.CONSUME7=function(t,e){return this.consumeInternal(t,7,e)},t.prototype.CONSUME8=function(t,e){return this.consumeInternal(t,8,e)},t.prototype.CONSUME9=function(t,e){return this.consumeInternal(t,9,e)},t.prototype.SUBRULE=function(t,e){return this.subruleInternal(t,0,e)},t.prototype.SUBRULE1=function(t,e){return this.subruleInternal(t,1,e)},t.prototype.SUBRULE2=function(t,e){return this.subruleInternal(t,2,e)},t.prototype.SUBRULE3=function(t,e){return this.subruleInternal(t,3,e)},t.prototype.SUBRULE4=function(t,e){return this.subruleInternal(t,4,e)},t.prototype.SUBRULE5=function(t,e){return this.subruleInternal(t,5,e)},t.prototype.SUBRULE6=function(t,e){return this.subruleInternal(t,6,e)},t.prototype.SUBRULE7=function(t,e){return this.subruleInternal(t,7,e)},t.prototype.SUBRULE8=function(t,e){return this.subruleInternal(t,8,e)},t.prototype.SUBRULE9=function(t,e){return this.subruleInternal(t,9,e)},t.prototype.OPTION=function(t){return this.optionInternal(t,0)},t.prototype.OPTION1=function(t){return this.optionInternal(t,1)},t.prototype.OPTION2=function(t){return this.optionInternal(t,2)},t.prototype.OPTION3=function(t){return this.optionInternal(t,3)},t.prototype.OPTION4=function(t){return this.optionInternal(t,4)},t.prototype.OPTION5=function(t){return this.optionInternal(t,5)},t.prototype.OPTION6=function(t){return this.optionInternal(t,6)},t.prototype.OPTION7=function(t){return this.optionInternal(t,7)},t.prototype.OPTION8=function(t){return this.optionInternal(t,8)},t.prototype.OPTION9=function(t){return this.optionInternal(t,9)},t.prototype.OR=function(t){return this.orInternal(t,0)},t.prototype.OR1=function(t){return this.orInternal(t,1)},t.prototype.OR2=function(t){return this.orInternal(t,2)},t.prototype.OR3=function(t){return this.orInternal(t,3)},t.prototype.OR4=function(t){return this.orInternal(t,4)},t.prototype.OR5=function(t){return this.orInternal(t,5)},t.prototype.OR6=function(t){return this.orInternal(t,6)},t.prototype.OR7=function(t){return this.orInternal(t,7)},t.prototype.OR8=function(t){return this.orInternal(t,8)},t.prototype.OR9=function(t){return this.orInternal(t,9)},t.prototype.MANY=function(t){this.manyInternal(0,t);},t.prototype.MANY1=function(t){this.manyInternal(1,t);},t.prototype.MANY2=function(t){this.manyInternal(2,t);},t.prototype.MANY3=function(t){this.manyInternal(3,t);},t.prototype.MANY4=function(t){this.manyInternal(4,t);},t.prototype.MANY5=function(t){this.manyInternal(5,t);},t.prototype.MANY6=function(t){this.manyInternal(6,t);},t.prototype.MANY7=function(t){this.manyInternal(7,t);},t.prototype.MANY8=function(t){this.manyInternal(8,t);},t.prototype.MANY9=function(t){this.manyInternal(9,t);},t.prototype.MANY_SEP=function(t){this.manySepFirstInternal(0,t);},t.prototype.MANY_SEP1=function(t){this.manySepFirstInternal(1,t);},t.prototype.MANY_SEP2=function(t){this.manySepFirstInternal(2,t);},t.prototype.MANY_SEP3=function(t){this.manySepFirstInternal(3,t);},t.prototype.MANY_SEP4=function(t){this.manySepFirstInternal(4,t);},t.prototype.MANY_SEP5=function(t){this.manySepFirstInternal(5,t);},t.prototype.MANY_SEP6=function(t){this.manySepFirstInternal(6,t);},t.prototype.MANY_SEP7=function(t){this.manySepFirstInternal(7,t);},t.prototype.MANY_SEP8=function(t){this.manySepFirstInternal(8,t);},t.prototype.MANY_SEP9=function(t){this.manySepFirstInternal(9,t);},t.prototype.AT_LEAST_ONE=function(t){this.atLeastOneInternal(0,t);},t.prototype.AT_LEAST_ONE1=function(t){return this.atLeastOneInternal(1,t)},t.prototype.AT_LEAST_ONE2=function(t){this.atLeastOneInternal(2,t);},t.prototype.AT_LEAST_ONE3=function(t){this.atLeastOneInternal(3,t);},t.prototype.AT_LEAST_ONE4=function(t){this.atLeastOneInternal(4,t);},t.prototype.AT_LEAST_ONE5=function(t){this.atLeastOneInternal(5,t);},t.prototype.AT_LEAST_ONE6=function(t){this.atLeastOneInternal(6,t);},t.prototype.AT_LEAST_ONE7=function(t){this.atLeastOneInternal(7,t);},t.prototype.AT_LEAST_ONE8=function(t){this.atLeastOneInternal(8,t);},t.prototype.AT_LEAST_ONE9=function(t){this.atLeastOneInternal(9,t);},t.prototype.AT_LEAST_ONE_SEP=function(t){this.atLeastOneSepFirstInternal(0,t);},t.prototype.AT_LEAST_ONE_SEP1=function(t){this.atLeastOneSepFirstInternal(1,t);},t.prototype.AT_LEAST_ONE_SEP2=function(t){this.atLeastOneSepFirstInternal(2,t);},t.prototype.AT_LEAST_ONE_SEP3=function(t){this.atLeastOneSepFirstInternal(3,t);},t.prototype.AT_LEAST_ONE_SEP4=function(t){this.atLeastOneSepFirstInternal(4,t);},t.prototype.AT_LEAST_ONE_SEP5=function(t){this.atLeastOneSepFirstInternal(5,t);},t.prototype.AT_LEAST_ONE_SEP6=function(t){this.atLeastOneSepFirstInternal(6,t);},t.prototype.AT_LEAST_ONE_SEP7=function(t){this.atLeastOneSepFirstInternal(7,t);},t.prototype.AT_LEAST_ONE_SEP8=function(t){this.atLeastOneSepFirstInternal(8,t);},t.prototype.AT_LEAST_ONE_SEP9=function(t){this.atLeastOneSepFirstInternal(9,t);},t.prototype.RULE=function(t,e,n){if(void 0===n&&(n=o.DEFAULT_RULE_CONFIG),r.contains(this.definedRulesNames,t)){var i={message:a.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:t,grammarName:this.className}),type:o.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:t};this.definitionErrors.push(i);}if(this.definedRulesNames.push(t),!this.gastProductionsCache.containsKey(t)&&!this.serializedGrammar){var u=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,u);}var c=this.defineRule(t,e,n);return this[t]=c,c},t.prototype.OVERRIDE_RULE=function(t,e,n){void 0===n&&(n=o.DEFAULT_RULE_CONFIG);var r=[];if(r=r.concat(u.validateRuleIsOverridden(t,this.definedRulesNames,this.className)),this.definitionErrors.push.apply(this.definitionErrors,r),!this.serializedGrammar){var i=s.buildTopProduction(e.toString(),t,this.tokensMap);this.gastProductionsCache.put(t,i);}var a=this.defineRule(t,e,n);return this[t]=a,a},t.prototype.BACKTRACK=function(t,e){return function(){this.isBackTrackingStack.push(1);var n=this.saveRecogState();try{return t.apply(this,e),!0}catch(t){if(i.isRecognitionException(t))return !1;throw t}finally{this.reloadRecogState(n),this.isBackTrackingStack.pop();}}},t.prototype.getGAstProductions=function(){return this.gastProductionsCache},t.prototype.getSerializedGastProductions=function(){return c.serializeGrammar(this.gastProductionsCache.values())},t}();e.RecognizerApi=p;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(9),o=n(6),a=n(12),s=n(13),u=n(3),c=n(25),p=n(2),l=n(7),h=n(4),f=function(){function t(){}return t.prototype.initRecognizerEngine=function(t,e){if(this.className=h.classNameFromInstance(this),this.shortRuleNameToFull=new h.HashTable,this.fullRuleNameToShort=new h.HashTable,this.ruleShortNameIdx=256,this.tokenMatcher=l.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.allRuleNames=[],this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache=new h.HashTable,this.serializedGrammar=r.has(e,\"serializedGrammar\")?e.serializedGrammar:u.DEFAULT_PARSER_CONFIG.serializedGrammar,r.isArray(t)){if(r.isEmpty(t))throw Error(\"A Token Vocabulary cannot be empty.\\n\\tNote that the first argument for the parser constructor\\n\\tis no longer a Token vector (since v4.0).\");if(\"number\"==typeof t[0].startOffset)throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\\tFor Further details.\")}if(r.isArray(t))this.tokensMap=r.reduce(t,function(t,e){return t[p.tokenName(e)]=e,t},{});else if(r.has(t,\"modes\")&&r.every(r.flatten(r.values(t.modes)),l.isTokenType)){var n=r.flatten(r.values(t.modes)),i=r.uniq(n);this.tokensMap=r.reduce(i,function(t,e){return t[p.tokenName(e)]=e,t},{});}else {if(!r.isObject(t))throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");this.tokensMap=r.cloneObj(t);}this.tokensMap.EOF=p.EOF;var o=r.every(r.values(t),function(t){return r.isEmpty(t.categoryMatches)});this.tokenMatcher=o?l.tokenStructuredMatcherNoCategories:l.tokenStructuredMatcher,l.augmentTokenTypes(r.values(this.tokensMap));},t.prototype.defineRule=function(t,e,n){if(this.selfAnalysisDone)throw Error(\"Grammar rule <\"+t+\"> may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");var a,s=r.has(n,\"resyncEnabled\")?n.resyncEnabled:u.DEFAULT_RULE_CONFIG.resyncEnabled,c=r.has(n,\"recoveryValueFunc\")?n.recoveryValueFunc:u.DEFAULT_RULE_CONFIG.recoveryValueFunc,p=this.ruleShortNameIdx<<i.BITS_FOR_METHOD_IDX+i.BITS_FOR_OCCURRENCE_IDX;this.ruleShortNameIdx++,this.shortRuleNameToFull.put(p,t),this.fullRuleNameToShort.put(t,p);return (a=function(n,r){return void 0===n&&(n=0),this.ruleInvocationStateUpdate(p,t,n),function(t){try{return !0===this.outputCst?(e.apply(this,t),this.CST_STACK[this.CST_STACK.length-1]):e.apply(this,t)}catch(t){var n=1===this.RULE_STACK.length,r=s&&!this.isBackTracking()&&this.recoveryEnabled;if(o.isRecognitionException(t)){if(r){var i,a=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(a))return t.resyncedTokens=this.reSyncTo(a),this.outputCst?((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,i):c();throw this.outputCst&&((i=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,t.partialCstResult=i),t}if(n)return this.moveToTerminatedState(),c();throw t}throw t}finally{this.ruleFinallyStateUpdate();}}.call(this,r)}).ruleName=t,a},t.prototype.optionInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{return this.optionInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.optionInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OPTION_IDX,e);return this.optionInternalLogic(t,e,n)},t.prototype.optionInternalLogic=function(t,e,n){var r,i,o=this,a=this.getLookaheadFuncForOption(n,e);if(void 0!==t.DEF){if(r=t.DEF,void 0!==(i=t.GATE)){var s=a;a=function(){return i.call(o)&&s.call(o)};}}else r=t;if(!0===a.call(this))return r.call(this)},t.prototype.atLeastOneInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.atLeastOneInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_IDX,t);this.atLeastOneInternalLogic(t,e,n);},t.prototype.atLeastOneInternalLogic=function(t,e,n){var r,o,u=this,c=this.getLookaheadFuncForAtLeastOne(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var p=c;c=function(){return o.call(u)&&p.call(u)};}}else r=e;if(!0!==c.call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY,e.ERR_MSG);for(var l=this.doSingleRepetition(r);!0===c.call(this)&&!0===l;)l=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[t,e],c,i.AT_LEAST_ONE_IDX,t,s.NextTerminalAfterAtLeastOneWalker);},t.prototype.atLeastOneSepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.atLeastOneSepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.atLeastOneSepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.AT_LEAST_ONE_SEP_IDX,t);this.atLeastOneSepFirstInternalLogic(t,e,n);},t.prototype.atLeastOneSepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,u=e.SEP;if(!0!==this.getLookaheadFuncForAtLeastOneSep(n,t).call(this))throw this.raiseEarlyExitException(t,a.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,e.ERR_MSG);o.call(this);for(var c=function(){return r.tokenMatcher(r.LA(1),u)};!0===this.tokenMatcher(this.LA(1),u);)this.CONSUME(u),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,u,c,o,s.NextTerminalAfterAtLeastOneSepWalker],c,i.AT_LEAST_ONE_SEP_IDX,t,s.NextTerminalAfterAtLeastOneSepWalker);},t.prototype.manyInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.manyInternalLogic(t,e,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manyInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_IDX,t);return this.manyInternalLogic(t,e,n)},t.prototype.manyInternalLogic=function(t,e,n){var r,o,a=this,u=this.getLookaheadFuncForMany(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var c=u;u=function(){return o.call(a)&&c.call(a)};}}else r=e;for(var p=!0;!0===u.call(this)&&!0===p;)p=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.manyInternal,[t,e],u,i.MANY_IDX,t,s.NextTerminalAfterManyWalker);},t.prototype.manySepFirstInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{this.manySepFirstInternalLogic(t,e,n);}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r);}},t.prototype.manySepFirstInternalNoCst=function(t,e){var n=this.getKeyForAutomaticLookahead(i.MANY_SEP_IDX,t);this.manySepFirstInternalLogic(t,e,n);},t.prototype.manySepFirstInternalLogic=function(t,e,n){var r=this,o=e.DEF,a=e.SEP;if(!0===this.getLookaheadFuncForManySep(n,t).call(this)){o.call(this);for(var u=function(){return r.tokenMatcher(r.LA(1),a)};!0===this.tokenMatcher(this.LA(1),a);)this.CONSUME(a),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,a,u,o,s.NextTerminalAfterManySepWalker],u,i.MANY_SEP_IDX,t,s.NextTerminalAfterManySepWalker);}},t.prototype.repetitionSepSecondInternal=function(t,e,n,r,o){for(;n();)this.CONSUME(e),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,e,n,r,o],n,i.AT_LEAST_ONE_SEP_IDX,t,o);},t.prototype.doSingleRepetition=function(t){var e=this.getLexerPosition();return t.call(this),this.getLexerPosition()>e},t.prototype.orInternalNoCst=function(t,e){var n=r.isArray(t)?t:t.DEF,i=this.getLookaheadFuncForOr(e,n).call(this,n);if(void 0!==i)return n[i].ALT.call(this);this.raiseNoAltException(e,t.ERR_MSG);},t.prototype.orInternal=function(t,e){var n=this.getKeyForAutomaticLookahead(i.OR_IDX,e),o=this.nestedRuleBeforeClause(t,n);try{var a=r.isArray(t)?t:t.DEF,s=this.getLookaheadFuncForOr(e,a).call(this,a);if(void 0!==s){var u=a[s],c=this.nestedAltBeforeClause(u,e,i.OR_IDX,s);try{return u.ALT.call(this)}finally{void 0!==c&&this.nestedRuleFinallyClause(c.shortName,c.nestedName);}}this.raiseNoAltException(e,t.ERR_MSG);}finally{void 0!==o&&this.nestedRuleFinallyClause(n,o);}},t.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),0===this.RULE_STACK.length&&!this.isAtEndOfInput()){var t=this.LA(1),e=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:t,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new o.NotAllInputParsedException(e,t));}},t.prototype.subruleInternal=function(t,e,n){var r;try{var i=void 0!==n?n.ARGS:void 0;return r=t.call(this,e,i),this.cstPostNonTerminal(r,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),r}catch(e){throw o.isRecognitionException(e)&&void 0!==e.partialCstResult&&(this.cstPostNonTerminal(e.partialCstResult,void 0!==n&&void 0!==n.LABEL?n.LABEL:t.ruleName),delete e.partialCstResult),e}},t.prototype.consumeInternal=function(t,e,n){var r;try{var i=this.LA(1);if(!0!==this.tokenMatcher(i,t)){var a=void 0,s=this.LA(0);throw a=void 0!==n&&n.ERR_MSG?n.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:t,actual:i,previous:s,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new o.MismatchedTokenException(a,i,s))}this.consumeToken(),r=i;}catch(n){if(!this.recoveryEnabled||\"MismatchedTokenException\"!==n.name||this.isBackTracking())throw n;var u=this.getFollowsForInRuleRecovery(t,e);try{r=this.tryInRuleRecovery(t,u);}catch(t){throw t.name===c.IN_RULE_RECOVERY_EXCEPTION?n:t}}return this.cstPostTerminal(void 0!==n&&void 0!==n.LABEL?n.LABEL:t.tokenName,r),r},t.prototype.saveRecogState=function(){var t=this.errors,e=r.cloneArr(this.RULE_STACK);return {errors:t,lexerState:this.exportLexerState(),RULE_STACK:e,CST_STACK:this.CST_STACK,LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK}},t.prototype.reloadRecogState=function(t){this.errors=t.errors,this.importLexerState(t.lexerState),this.RULE_STACK=t.RULE_STACK;},t.prototype.ruleInvocationStateUpdate=function(t,e,n){this.RULE_OCCURRENCE_STACK.push(n),this.RULE_STACK.push(t),this.cstInvocationStateUpdate(e,t);},t.prototype.isBackTracking=function(){return !r.isEmpty(this.isBackTrackingStack)},t.prototype.getCurrRuleFullName=function(){var t=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull.get(t)},t.prototype.shortRuleNameToFullName=function(t){return this.shortRuleNameToFull.get(t)},t.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),p.EOF)},t.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[];},t}();e.RecognizerEngine=f;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(6),i=n(0),o=n(12),a=n(3),s=function(){function t(){}return t.prototype.initErrorHandler=function(t){this._errors=[],this.errorMessageProvider=i.defaults(t.errorMessageProvider,a.DEFAULT_PARSER_CONFIG.errorMessageProvider);},t.prototype.SAVE_ERROR=function(t){if(r.isRecognitionException(t))return t.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:i.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(t),t;throw Error(\"Trying to save an Error which is not a RecognitionException\")},Object.defineProperty(t.prototype,\"errors\",{get:function(){return i.cloneArr(this._errors)},set:function(t){this._errors=t;},enumerable:!0,configurable:!0}),t.prototype.raiseEarlyExitException=function(t,e,n){for(var i=this.getCurrRuleFullName(),a=this.getGAstProductions().get(i),s=o.getLookaheadPathsForOptionalProd(t,a,e,this.maxLookahead)[0],u=[],c=1;c<this.maxLookahead;c++)u.push(this.LA(c));var p=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:u,previous:this.LA(0),customUserDescription:n,ruleName:i});throw this.SAVE_ERROR(new r.EarlyExitException(p,this.LA(1),this.LA(0)))},t.prototype.raiseNoAltException=function(t,e){for(var n=this.getCurrRuleFullName(),i=this.getGAstProductions().get(n),a=o.getLookaheadPathsForOr(t,i,this.maxLookahead),s=[],u=1;u<=this.maxLookahead;u++)s.push(this.LA(u));var c=this.LA(0),p=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:a,actual:s,previous:c,customUserDescription:e,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new r.NoViableAltException(p,this.LA(1),c))},t}();e.ErrorHandler=s;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(13),i=n(0),o=function(){function t(){}return t.prototype.initContentAssist=function(){},t.prototype.computeContentAssist=function(t,e){var n=this.gastProductionsCache.get(t);if(i.isUndefined(n))throw Error(\"Rule ->\"+t+\"<- does not exist in this grammar.\");return r.nextPossibleTokensAfter([n],e,this.tokenMatcher,this.maxLookahead)},t.prototype.getNextPossibleTokenTypes=function(t){var e=i.first(t.ruleStack),n=this.getGAstProductions().get(e);return new r.NextAfterTokenWalker(n,t).startWalking()},t}();e.ContentAssist=o;},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(17);e.createSyntaxDiagramsCode=function(t,e){var n=void 0===e?{}:e,i=n.resourceBase,o=void 0===i?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/\":i,a=n.css;return \"\\n\\x3c!-- This is a generated file --\\x3e\\n<!DOCTYPE html>\\n<meta charset=\\\"utf-8\\\">\\n<style>\\n  body {\\n    background-color: hsl(30, 20%, 95%)\\n  }\\n</style>\\n\\n\\n<link rel='stylesheet' href='\"+(void 0===a?\"https://unpkg.com/chevrotain@\"+r.VERSION+\"/diagrams/diagrams.css\":a)+\"'>\\n\\n<script src='\"+o+\"vendor/railroad-diagrams.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_builder.js'><\\/script>\\n<script src='\"+o+\"src/diagrams_behavior.js'><\\/script>\\n<script src='\"+o+'src/main.js\\'><\\/script>\\n\\n<div id=\"diagrams\" align=\"center\"></div>    \\n\\n<script>\\n    window.serializedGrammar = '+JSON.stringify(t,null,\"  \")+';\\n<\\/script>\\n\\n<script>\\n    var diagramsDiv = document.getElementById(\"diagrams\");\\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\\n<\\/script>\\n'};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(41);e.generateParserFactory=function(t){var e=r.genWrapperFunction({name:t.name,rules:t.rules}),i=new Function(\"tokenVocabulary\",\"config\",\"chevrotain\",e);return function(e){return i(t.tokenVocabulary,e,n(18))}},e.generateParserModule=function(t){return r.genUmdModule({name:t.name,rules:t.rules})};},function(t,e,n){Object.defineProperty(e,\"__esModule\",{value:!0});var r=n(0),i=n(2),o=n(1),a=\"\\n\";function s(t){return \"\\nfunction \"+t.name+\"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \"+u(t.rules)+\"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\"+t.name+\".prototype = Object.create(chevrotain.CstParser.prototype)\\n\"+t.name+\".prototype.constructor = \"+t.name+\"    \\n    \"}function u(t){return r.map(t,function(t){return c(t,1)}).join(\"\\n\")}function c(t,e){var n=y(e,'$.RULE(\"'+t.name+'\", function() {')+a;return n+=m(t.definition,e+1),n+=y(e+1,\"})\")+a}function p(t,e){var n=i.tokenName(t.terminalType);return y(e,\"$.CONSUME\"+t.idx+\"(this.tokensMap.\"+n+\")\"+a)}function l(t,e){return y(e,\"$.SUBRULE\"+t.idx+\"($.\"+t.nonTerminalName+\")\"+a)}function h(t,e){var n=y(e,\"$.OR\"+t.idx+\"([\")+a;return n+=r.map(t.definition,function(t){return f(t,e+1)}).join(\",\"+a),n+=a+y(e,\"])\"+a)}function f(t,e){var n=y(e,\"{\")+a;return t.name&&(n+=y(e+1,'NAME: \"'+t.name+'\",')+a),n+=y(e+1,\"ALT: function() {\")+a,n+=m(t.definition,e+1),n+=y(e+1,\"}\")+a,n+=y(e,\"}\")}function d(t,e,n){var r=y(n,\"$.\"+(t+e.idx)+\"(\");return e.name||e.separator?(r+=\"{\"+a,e.name&&(r+=y(n+1,'NAME: \"'+e.name+'\"')+\",\"+a),e.separator&&(r+=y(n+1,\"SEP: this.tokensMap.\"+i.tokenName(e.separator))+\",\"+a),r+=\"DEF: \"+E(e.definition,n+2)+a,r+=y(n,\"}\")+a):r+=E(e.definition,n+1),r+=y(n,\")\")+a}function E(t,e){var n=\"function() {\"+a;return n+=m(t,e),n+=y(e,\"}\")+a}function m(t,e){var n=\"\";return r.forEach(t,function(t){n+=function(t,e){if(t instanceof o.NonTerminal)return l(t,e);if(t instanceof o.Option)return d(\"OPTION\",t,e);if(t instanceof o.RepetitionMandatory)return d(\"AT_LEAST_ONE\",t,e);if(t instanceof o.RepetitionMandatoryWithSeparator)return d(\"AT_LEAST_ONE_SEP\",t,e);if(t instanceof o.RepetitionWithSeparator)return d(\"MANY_SEP\",t,e);if(t instanceof o.Repetition)return d(\"MANY\",t,e);if(t instanceof o.Alternation)return h(t,e);if(t instanceof o.Terminal)return p(t,e);if(t instanceof o.Flat)return m(t.definition,e);throw Error(\"non exhaustive match\")}(t,e+1);}),n}function y(t,e){return Array(4*t+1).join(\" \")+e}e.genUmdModule=function(t){return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\"+s(t)+\"\\n    \\nreturn {\\n    \"+t.name+\": \"+t.name+\" \\n}\\n}));\\n\"},e.genWrapperFunction=function(t){return \"    \\n\"+s(t)+\"\\nreturn new \"+t.name+\"(tokenVocabulary, config)    \\n\"},e.genClass=s,e.genAllRules=u,e.genRule=c,e.genTerminal=p,e.genNonTerminal=l,e.genAlternation=h,e.genSingleAlt=f;}])});\nvar chevrotain = window.chevrotain;\n\nvar VRMLLoader = ( function () {\n\n\t// dependency check\n\n\tif ( typeof chevrotain === 'undefined' ) { // eslint-disable-line no-undef\n\n\t\tthrow Error( 'THREE.VRMLLoader: External library chevrotain.min.js required.' );\n\n\t}\n\n\t// class definitions\n\n\tfunction VRMLLoader( manager ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tVRMLLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: VRMLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, path ) {\n\n\t\t\tvar nodeMap = {};\n\n\t\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t\t// create lexer, parser and visitor\n\n\t\t\t\tvar tokenData = createTokens();\n\n\t\t\t\tvar lexer = new VRMLLexer( tokenData.tokens );\n\t\t\t\tvar parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\t\tvar visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t\t// lexing\n\n\t\t\t\tvar lexingResult = lexer.lex( data );\n\t\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t\t// parsing\n\n\t\t\t\tvar cstOutput = parser.vrml();\n\n\t\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t\t}\n\n\t\t\t\t// actions\n\n\t\t\t\tvar ast = visitor.visit( cstOutput );\n\n\t\t\t\treturn ast;\n\n\t\t\t}\n\n\t\t\tfunction createTokens() {\n\n\t\t\t\tvar createToken = chevrotain.createToken; // eslint-disable-line no-undef\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\t\tvar RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\t\tvar Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } );\n\n\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\t\tvar nodeTypes = [\n\t\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t\t];\n\n\t\t\t\t//\n\n\t\t\t\tvar Version = createToken( {\n\t\t\t\t\tname: 'Version',\n\t\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar NodeName = createToken( {\n\t\t\t\t\tname: 'NodeName',\n\t\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar DEF = createToken( {\n\t\t\t\t\tname: 'DEF',\n\t\t\t\t\tpattern: /DEF/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar USE = createToken( {\n\t\t\t\t\tname: 'USE',\n\t\t\t\t\tpattern: /USE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar ROUTE = createToken( {\n\t\t\t\t\tname: 'ROUTE',\n\t\t\t\t\tpattern: /ROUTE/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\tvar TO = createToken( {\n\t\t\t\t\tname: 'TO',\n\t\t\t\t\tpattern: /TO/,\n\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t} );\n\n\t\t\t\t//\n\n\t\t\t\tvar StringLiteral = createToken( { name: 'StringLiteral', pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/ } );\n\t\t\t\tvar HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\t\tvar NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\t\tvar TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\t\tvar FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\t\tvar NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\t\tvar LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\t\tvar RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\t\tvar LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\t\tvar RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\t\tvar Comment = createToken( {\n\t\t\t\t\tname: 'Comment',\n\t\t\t\t\tpattern: /#.*/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\t\tvar WhiteSpace = createToken( {\n\t\t\t\t\tname: 'WhiteSpace',\n\t\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\t\t\t\t} );\n\n\t\t\t\tvar tokens = [\n\t\t\t\t\tWhiteSpace,\n\t\t\t\t\t// keywords appear before the Identifier\n\t\t\t\t\tNodeName,\n\t\t\t\t\tDEF,\n\t\t\t\t\tUSE,\n\t\t\t\t\tROUTE,\n\t\t\t\t\tTO,\n\t\t\t\t\tTrueLiteral,\n\t\t\t\t\tFalseLiteral,\n\t\t\t\t\tNullLiteral,\n\t\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\t\tVersion,\n\t\t\t\t\tIdentifier,\n\t\t\t\t\tRouteIdentifier,\n\t\t\t\t\tStringLiteral,\n\t\t\t\t\tHexLiteral,\n\t\t\t\t\tNumberLiteral,\n\t\t\t\t\tLSquare,\n\t\t\t\t\tRSquare,\n\t\t\t\t\tLCurly,\n\t\t\t\t\tRCurly,\n\t\t\t\t\tComment\n\t\t\t\t];\n\n\t\t\t\tvar tokenVocabulary = {};\n\n\t\t\t\tfor ( var i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar token = tokens[ i ];\n\n\t\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t\t}\n\n\t\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t\t}\n\n\n\t\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\t\tfunction VRMLToASTVisitor() {\n\n\t\t\t\t\tBaseVRMLVisitor.call( this );\n\n\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tVRMLToASTVisitor.prototype = Object.assign( Object.create( BaseVRMLVisitor.prototype ), {\n\n\t\t\t\t\tconstructor: VRMLToASTVisitor,\n\n\t\t\t\t\tvrml: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\troutes: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar route = ctx.route[ i ];\n\n\t\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tversion: function ( ctx ) {\n\n\t\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tnode: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar field = ctx.field[ i ];\n\n\t\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// DEF\n\n\t\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tfield: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\tvalues: null\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar result;\n\n\t\t\t\t\t\t// SFValue\n\n\t\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// MFValue\n\n\t\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tdef: function ( ctx ) {\n\n\t\t\t\t\t\treturn ( ctx.Identifier || ctx.NodeName )[ 0 ].image;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tuse: function ( ctx ) {\n\n\t\t\t\t\t\treturn { USE: ( ctx.Identifier || ctx.NodeName )[ 0 ].image };\n\n\t\t\t\t\t},\n\n\t\t\t\t\tsingleFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\tmultiFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t},\n\n\t\t\t\t\troute: function ( ctx ) {\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\t\tvar field = {\n\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\tvalues: []\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar use = ctx.use[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\tfor ( var i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tvar falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn field;\n\n\t\t\t\t}\n\n\t\t\t\treturn new VRMLToASTVisitor();\n\n\t\t\t}\n\n\t\t\tfunction parseTree( tree ) {\n\n\t\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\t\tvar nodes = tree.nodes;\n\t\t\t\tvar scene = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ai();\n\n\t\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\n\t\t\t\t\tbuildNodeMap( node );\n\n\t\t\t\t}\n\n\t\t\t\t// second iteration: build nodes\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\tvar object = getNode( node );\n\n\t\t\t\t\tif ( object instanceof _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U ) scene.add( object );\n\n\t\t\t\t\tif ( node.name === 'WorldInfo' ) scene.userData.worldInfo = object;\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t\tfunction buildNodeMap( node ) {\n\n\t\t\t\tif ( node.DEF ) {\n\n\t\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t\t}\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\n\t\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction getNode( node ) {\n\n\t\t\t\t// handle case where a node refers to a different one\n\n\t\t\t\tif ( node.USE ) {\n\n\t\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\t\tnode.build = buildNode( node );\n\n\t\t\t\treturn node.build;\n\n\t\t\t}\n\n\t\t\t// node builder\n\n\t\t\tfunction buildNode( node ) {\n\n\t\t\t\tvar nodeName = node.name;\n\t\t\t\tvar build;\n\n\t\t\t\tswitch ( nodeName ) {\n\n\t\t\t\t\tcase 'Group':\n\t\t\t\t\tcase 'Transform':\n\t\t\t\t\tcase 'Collision':\n\t\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Background':\n\t\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Shape':\n\t\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Appearance':\n\t\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Material':\n\t\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointSet':\n\t\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Box':\n\t\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cone':\n\t\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Cylinder':\n\t\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Sphere':\n\t\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\t\tbuild = buildElevationGridNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Extrusion':\n\t\t\t\t\t\tbuild = buildExtrusionNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\tcase 'Coordinate':\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'WorldInfo':\n\t\t\t\t\t\tbuild = buildWorldInfoNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Anchor':\n\t\t\t\t\tcase 'Billboard':\n\n\t\t\t\t\tcase 'Inline':\n\t\t\t\t\tcase 'LOD':\n\t\t\t\t\tcase 'Switch':\n\n\t\t\t\t\tcase 'AudioClip':\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\tcase 'Script':\n\t\t\t\t\tcase 'Sound':\n\t\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tcase 'CylinderSensor':\n\t\t\t\t\tcase 'PlaneSensor':\n\t\t\t\t\tcase 'ProximitySensor':\n\t\t\t\t\tcase 'SphereSensor':\n\t\t\t\t\tcase 'TimeSensor':\n\t\t\t\t\tcase 'TouchSensor':\n\t\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\t\tcase 'Text':\n\n\t\t\t\t\tcase 'FontStyle':\n\t\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\t\tcase 'Fog':\n\t\t\t\t\tcase 'NavigationInfo':\n\t\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t\t// node not supported yet\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( build !== undefined && node.DEF !== undefined && build.hasOwnProperty( 'name' ) === true ) {\n\n\t\t\t\t\tbuild.name = node.DEF;\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGroupingNode( node ) {\n\n\t\t\t\tvar object = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\t//\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'children':\n\t\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'collide':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\tvar axis = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tvar angle = fieldValues[ 3 ];\n\t\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'proxy':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\t\tvar group = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\t\tvar groundAngle, groundColor;\n\t\t\t\tvar skyAngle, skyColor;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar radius = 10000;\n\n\t\t\t\t// sky\n\n\t\t\t\tif ( skyColor ) {\n\n\t\t\t\t\tvar skyGeometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16 );\n\t\t\t\t\tvar skyMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ap, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar sky = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( skyGeometry, skyMaterial );\n\t\t\t\t\tgroup.add( sky );\n\n\t\t\t\t}\n\n\t\t\t\t// ground\n\n\t\t\t\tif ( groundColor ) {\n\n\t\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\t\tvar groundGeometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\t\tvar groundMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g( { fog: false, side: _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ap, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\t\tvar ground = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( groundGeometry, groundMaterial );\n\t\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// render background group first\n\n\t\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction buildShapeNode( node ) {\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\tvar material = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\t\t\t\tvar geometry;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\t\tvar type = geometry._type;\n\n\t\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\t\tvar pointsMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, pointsMaterial );\n\n\t\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\t\tvar lineMaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0xffffff } );\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.w( geometry, lineMaterial );\n\n\t\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a8 : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.D;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\t\tvar material = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\tvar transformData;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\tvar materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.g( { color: 0x000000 } );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tvar textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\t// respect VRML lighting model\n\n\t\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply texture transform\n\n\t\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction buildMaterialNode( node ) {\n\n\t\t\t\tvar materialData = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\t\tmaterialData.diffuseColor = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\t\tmaterialData.emissiveColor = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materialData;\n\n\t\t\t}\n\n\t\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\t\tswitch ( textureType ) {\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\t\tvar value = parseInt( hex );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\t\tvar value = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\t\tcolor.r = parseInt( '0x' + hex.substring( 2, 4 ) );\n\t\t\t\t\t\tcolor.g = parseInt( '0x' + hex.substring( 4, 6 ) );\n\t\t\t\t\t\tcolor.b = parseInt( '0x' + hex.substring( 6, 8 ) );\n\t\t\t\t\t\tcolor.a = parseInt( '0x' + hex.substring( 8, 10 ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getTextureType( num_components ) {\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch ( num_components ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn type;\n\n\t\t\t}\n\n\t\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'image':\n\t\t\t\t\t\t\tvar width = fieldValues[ 0 ];\n\t\t\t\t\t\t\tvar height = fieldValues[ 1 ];\n\t\t\t\t\t\t\tvar num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\t\tvar useAlpha = ( num_components === 2 || num_components === 4 );\n\t\t\t\t\t\t\tvar textureType = getTextureType( num_components );\n\n\t\t\t\t\t\t\tvar size = ( ( useAlpha === true ) ? 4 : 3 ) * ( width * height );\n\t\t\t\t\t\t\tvar data = new Uint8Array( size );\n\n\t\t\t\t\t\t\tvar color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\t\tfor ( var j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\t\tif ( useAlpha === true ) {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 4;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar stride = k * 3;\n\n\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttexture = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aq( data, width, height, ( useAlpha === true ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ar : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.R );\n\t\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar wrapS = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\t\t\t\tvar wrapT = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\tvar url = fieldValues[ 0 ];\n\t\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture ) {\n\n\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\t\tvar transformData = {\n\t\t\t\t\tcenter: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\trotation: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\tscale: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a(),\n\t\t\t\t\ttranslation: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a()\n\t\t\t\t};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn transformData;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometricNode( node ) {\n\n\t\t\t\treturn node.fields[ 0 ].values;\n\n\t\t\t}\n\n\t\t\tfunction buildWorldInfoNode( node ) {\n\n\t\t\t\tvar worldInfo = {};\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'title':\n\t\t\t\t\t\t\tworldInfo.title = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'info':\n\t\t\t\t\t\t\tworldInfo.info = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn worldInfo;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\t\tvar color, coord, normal, texCoord;\n\t\t\t\tvar ccw = true, solid = true, creaseAngle = 0;\n\t\t\t\tvar colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\t\tvar colorPerVertex = true, normalPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B(); // handle VRML files with incomplete geometry definition\n\n\t\t\t\t}\n\n\t\t\t\tvar triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\t\tvar positionAttribute;\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\t\t\t\tvar uvAttribute;\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// consider face normals\n\n\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\tvar flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\tvar triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( texCoord, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tpositionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t// optional attributes\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\t\tvar color, coord;\n\t\t\t\tvar colorIndex, coordIndex;\n\t\t\t\tvar colorPerVertex = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build lines\n\n\t\t\t\tvar colorAttribute;\n\n\t\t\t\tvar expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\t\tvar expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\t\tvar flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( expandedLineIndex, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\tgeometry._type = 'line';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildPointSetNode( node ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar color, coord;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( coord, 3 ) );\n\t\t\t\tif ( color ) geometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\t\t\tgeometry._type = 'points';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildBoxNode( node ) {\n\n\t\t\t\tvar size = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V( 2, 2, 2 );\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.as( size.x, size.y, size.z );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildConeNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2, openEnded = false;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.at( radius, height, 16, 1, openEnded );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildCylinderNode( node ) {\n\n\t\t\t\tvar radius = 1, height = 2;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.au( radius, radius, height, 16, 1 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildSphereNode( node ) {\n\n\t\t\t\tvar radius = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ao( radius, 16, 16 );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildElevationGridNode( node ) {\n\n\t\t\t\tvar color;\n\t\t\t\tvar normal;\n\t\t\t\tvar texCoord;\n\t\t\t\tvar height;\n\n\t\t\t\tvar colorPerVertex = true;\n\t\t\t\tvar normalPerVertex = true;\n\t\t\t\tvar solid = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar xDimension = 2;\n\t\t\t\tvar zDimension = 2;\n\t\t\t\tvar xSpacing = 1;\n\t\t\t\tvar zSpacing = 1;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\theight = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xDimension':\n\t\t\t\t\t\t\txDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'xSpacing':\n\t\t\t\t\t\t\txSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zDimension':\n\t\t\t\t\t\t\tzDimension = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'zSpacing':\n\t\t\t\t\t\t\tzSpacing = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// vertex data\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar colors = [];\n\t\t\t\tvar uvs = [];\n\n\t\t\t\tfor ( var i = 0; i < zDimension; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < xDimension; j ++ ) {\n\n\t\t\t\t\t\t// compute a row major index\n\n\t\t\t\t\t\tvar index = ( i * xDimension ) + j;\n\n\t\t\t\t\t\t// vertices\n\n\t\t\t\t\t\tvar x = xSpacing * i;\n\t\t\t\t\t\tvar y = height[ index ];\n\t\t\t\t\t\tvar z = zSpacing * j;\n\n\t\t\t\t\t\tvertices.push( x, y, z );\n\n\t\t\t\t\t\t// colors\n\n\t\t\t\t\t\tif ( color && colorPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normals\n\n\t\t\t\t\t\tif ( normal && normalPerVertex === true ) {\n\n\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\tnormals.push( xn, yn, zn );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\t\tvar s = texCoord[ index * 2 + 0 ];\n\t\t\t\t\t\t\tvar t = texCoord[ index * 2 + 1 ];\n\n\t\t\t\t\t\t\tuvs.push( s, t );\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tuvs.push( i / ( xDimension - 1 ), j / ( zDimension - 1 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t// from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n\t\t\t\t\t\tvar a = i + j * xDimension;\n\t\t\t\t\t\tvar b = i + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar c = ( i + 1 ) + ( j + 1 ) * xDimension;\n\t\t\t\t\t\tvar d = ( i + 1 ) + j * xDimension;\n\n\t\t\t\t\t\t// faces\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, a, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, d, a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar uvAttribute = toNonIndexedAttribute( indices, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\t\t\t\tvar colorAttribute;\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\t// color attribute\n\n\t\t\t\tif ( color ) {\n\n\t\t\t\t\tif ( colorPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar r = color[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar g = color[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar b = color[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one color per quad\n\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b ); colors.push( r, g, b ); colors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcolorAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( indices, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normal attribute\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( normalPerVertex === false ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xDimension - 1; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < zDimension - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = i + j * ( xDimension - 1 );\n\n\t\t\t\t\t\t\t\tvar xn = normal[ index * 3 + 0 ];\n\t\t\t\t\t\t\t\tvar yn = normal[ index * 3 + 1 ];\n\t\t\t\t\t\t\t\tvar zn = normal[ index * 3 + 2 ];\n\n\t\t\t\t\t\t\t\t// one normal per quad\n\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\t\t\t\t\t\t\t\tnormals.push( xn, yn, zn ); normals.push( xn, yn, zn ); normals.push( xn, yn, zn );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( indices, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\t}\n\n\t\t\t\t// build geometry\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\tgeometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction buildExtrusionNode( node ) {\n\n\t\t\t\tvar crossSection = [ 1, 1, 1, - 1, - 1, - 1, - 1, 1, 1, 1 ];\n\t\t\t\tvar spine = [ 0, 0, 0, 0, 1, 0 ];\n\t\t\t\tvar scale;\n\t\t\t\tvar orientation;\n\n\t\t\t\tvar beginCap = true;\n\t\t\t\tvar ccw = true;\n\t\t\t\tvar creaseAngle = 0;\n\t\t\t\tvar endCap = true;\n\t\t\t\tvar solid = true;\n\n\t\t\t\tvar fields = node.fields;\n\n\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\tcase 'beginCap':\n\t\t\t\t\t\t\tbeginCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'crossSection':\n\t\t\t\t\t\t\tcrossSection = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'endCap':\n\t\t\t\t\t\t\tendCap = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'orientation':\n\t\t\t\t\t\t\torientation = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tscale = fieldValues;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'spine':\n\t\t\t\t\t\t\tspine = fieldValues; // only extrusion along the Y-axis are supported so far\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar crossSectionClosed = ( crossSection[ 0 ] === crossSection[ crossSection.length - 2 ] && crossSection[ 1 ] === crossSection[ crossSection.length - 1 ] );\n\n\t\t\t\t// vertices\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar spineVector = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar scaling = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tvar axis = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar vertex = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar quaternion = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\n\t\t\t\tfor ( var i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4 ) {\n\n\t\t\t\t\tspineVector.fromArray( spine, i );\n\n\t\t\t\t\tscaling.x = scale ? scale[ j + 0 ] : 1;\n\t\t\t\t\tscaling.y = 1;\n\t\t\t\t\tscaling.z = scale ? scale[ j + 1 ] : 1;\n\n\t\t\t\t\taxis.x = orientation ? orientation[ o + 0 ] : 0;\n\t\t\t\t\taxis.y = orientation ? orientation[ o + 1 ] : 0;\n\t\t\t\t\taxis.z = orientation ? orientation[ o + 2 ] : 1;\n\t\t\t\t\tvar angle = orientation ? orientation[ o + 3 ] : 0;\n\n\t\t\t\t\tfor ( var k = 0, kl = crossSection.length; k < kl; k += 2 ) {\n\n\t\t\t\t\t\tvertex.x = crossSection[ k + 0 ];\n\t\t\t\t\t\tvertex.y = 0;\n\t\t\t\t\t\tvertex.z = crossSection[ k + 1 ];\n\n\t\t\t\t\t\t// scale\n\n\t\t\t\t\t\tvertex.multiply( scaling );\n\n\t\t\t\t\t\t// rotate\n\n\t\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\tvertex.applyQuaternion( quaternion );\n\n\t\t\t\t\t\t// translate\n\n\t\t\t\t\t\tvertex.add( spineVector );\n\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar spineCount = spine.length / 3;\n\t\t\t\tvar crossSectionCount = crossSection.length / 2;\n\n\t\t\t\tfor ( var i = 0; i < spineCount - 1; i ++ ) {\n\n\t\t\t\t\tfor ( var j = 0; j < crossSectionCount - 1; j ++ ) {\n\n\t\t\t\t\t\tvar a = j + i * crossSectionCount;\n\t\t\t\t\t\tvar b = ( j + 1 ) + i * crossSectionCount;\n\t\t\t\t\t\tvar c = j + ( i + 1 ) * crossSectionCount;\n\t\t\t\t\t\tvar d = ( j + 1 ) + ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\tif ( ( j === crossSectionCount - 2 ) && ( crossSectionClosed === true ) ) {\n\n\t\t\t\t\t\t\tb = i * crossSectionCount;\n\t\t\t\t\t\t\td = ( i + 1 ) * crossSectionCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\tindices.push( c, b, d );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindices.push( a, c, b );\n\t\t\t\t\t\t\tindices.push( c, d, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// triangulate cap\n\n\t\t\t\tif ( beginCap === true || endCap === true ) {\n\n\t\t\t\t\tvar contour = [];\n\n\t\t\t\t\tfor ( var i = 0, l = crossSection.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tcontour.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a( crossSection[ i ], crossSection[ i + 1 ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar faces = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.av.triangulateShape( contour, [] );\n\t\t\t\t\tvar capIndices = [];\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\t\tcapIndices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// begin cap\n\n\t\t\t\t\tif ( beginCap === true ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 1 ], capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( capIndices[ i + 0 ], capIndices[ i + 2 ], capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// end cap\n\n\t\t\t\t\tif ( endCap === true ) {\n\n\t\t\t\t\t\tvar indexOffset = crossSectionCount * ( spineCount - 1 ); // references to the first vertex of the last cross section\n\n\t\t\t\t\t\tfor ( var i = 0, l = capIndices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 2 ], indexOffset + capIndices[ i + 1 ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices.push( indexOffset + capIndices[ i + 0 ], indexOffset + capIndices[ i + 1 ], indexOffset + capIndices[ i + 2 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar positionAttribute = toNonIndexedAttribute( indices, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\t\t\t\tvar normalAttribute = computeNormalAttribute( indices, vertices, creaseAngle );\n\n\t\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\t\t\t\t// no uvs yet\n\n\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\tgeometry._solid = solid;\n\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\t// helper functions\n\n\t\t\tfunction resolveUSE( identifier ) {\n\n\t\t\t\tvar node = nodeMap[ identifier ];\n\t\t\t\tvar build = getNode( node );\n\n\t\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t\t// any side effects\n\n\t\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t\t}\n\n\t\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = getNode( children[ i ] );\n\n\t\t\t\t\tif ( object instanceof _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U ) owner.add( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t\t// perform a simple triangulation\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ start ];\n\t\t\t\t\tvar i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\t\tvar i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tfunction flattenData( data, index ) {\n\n\t\t\t\tvar flattenData = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\n\t\t\t\t\tvar stride = i1 * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t\t}\n\n\t\t\t\treturn flattenData;\n\n\t\t\t}\n\n\t\t\tfunction expandLineIndex( index ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar i1 = index[ i ];\n\t\t\t\t\tvar i2 = index[ i + 1 ];\n\n\t\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn indices;\n\n\t\t\t}\n\n\t\t\tfunction expandLineData( data, index ) {\n\n\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn triangulatedData;\n\n\t\t\t}\n\n\t\t\tvar vA = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vB = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar vC = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tvar uvA = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvB = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar uvC = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\t\tfor ( var i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( array, itemSize );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( array, 3 );\n\n\t\t\t}\n\n\t\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( array2, itemSize );\n\n\t\t\t}\n\n\t\t\tvar ab = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar cb = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\t\tvar faces = [];\n\t\t\t\tvar vertexNormals = {};\n\n\t\t\t\t// prepare face and raw vertex normals\n\n\t\t\t\tfor ( var i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\tvar face = new Face( a, b, c );\n\n\t\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t\t// compute vertex normals and build final geometry\n\n\t\t\t\tvar normals = [];\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\tvar nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\t\tvar nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\t\tvar nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 );\n\n\t\t\t}\n\n\t\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\t\tvar normal = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\t\tnormal.copy( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn normal.normalize();\n\n\t\t\t}\n\n\t\t\tfunction toColorArray( colors ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\t\tarray.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Vertically paints the faces interpolating between the\n\t\t\t * specified colors at the specified angels. This is used for the Background\n\t\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t\t *\n\t\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t\t *\n\t\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t\t * is linear along the Y axis in any case.\n\t\t\t *\n\t\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t\t * This is the color of the Zenith (the top of the shape).\n\t\t\t *\n\t\t\t * @param {BufferGeometry} geometry\n\t\t\t * @param {number} radius\n\t\t\t * @param {array} angles\n\t\t\t * @param {array} colors\n\t\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t\t */\n\t\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t\t// compute threshold values\n\n\t\t\t\tvar thresholds = [];\n\t\t\t\tvar startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\t\tvar point = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\t\tthresholds.push( point );\n\n\t\t\t\t}\n\n\t\t\t\t// generate vertex colors\n\n\t\t\t\tvar indices = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar colorAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\t\tvar position = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\t\tvar color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C();\n\n\t\t\t\tfor ( var i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\t\tvar index = indices.getX( i );\n\t\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\t\tvar thresholdIndexA, thresholdIndexB;\n\t\t\t\t\tvar t = 1;\n\n\t\t\t\t\tfor ( var j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\t\tvar thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\t\tvar thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar colorA = colors[ thresholdIndexA ];\n\t\t\t\t\tvar colorB = colors[ thresholdIndexB ];\n\n\t\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar textureLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t// check version (only 2.0 is supported)\n\n\t\t\tif ( data.indexOf( '#VRML V2.0' ) === - 1 ) {\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t\t}\n\n\t\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\t\tvar tree = generateVRMLTree( data );\n\n\t\t\t// parse the tree structure to a three.js scene\n\n\t\t\tvar scene = parseTree( tree );\n\n\t\t\treturn scene;\n\n\t\t}\n\n\t} );\n\n\tfunction VRMLLexer( tokens ) {\n\n\t\tthis.lexer = new chevrotain.Lexer( tokens ); // eslint-disable-line no-undef\n\n\t}\n\n\tVRMLLexer.prototype = {\n\n\t\tconstructor: VRMLLexer,\n\n\t\tlex: function ( inputText ) {\n\n\t\t\tvar lexingResult = this.lexer.tokenize( inputText );\n\n\t\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t\t}\n\n\t\t\treturn lexingResult;\n\n\t\t}\n\n\t};\n\n\tfunction VRMLParser( tokenVocabulary ) {\n\n\t\tchevrotain.Parser.call( this, tokenVocabulary ); // eslint-disable-line no-undef\n\n\t\tvar $ = this;\n\n\t\tvar Version = tokenVocabulary[ 'Version' ];\n\t\tvar LCurly = tokenVocabulary[ 'LCurly' ];\n\t\tvar RCurly = tokenVocabulary[ 'RCurly' ];\n\t\tvar LSquare = tokenVocabulary[ 'LSquare' ];\n\t\tvar RSquare = tokenVocabulary[ 'RSquare' ];\n\t\tvar Identifier = tokenVocabulary[ 'Identifier' ];\n\t\tvar RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\tvar StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\tvar HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\tvar NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\tvar TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\tvar FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\tvar NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\tvar DEF = tokenVocabulary[ 'DEF' ];\n\t\tvar USE = tokenVocabulary[ 'USE' ];\n\t\tvar ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\tvar TO = tokenVocabulary[ 'TO' ];\n\t\tvar NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t$.RULE( 'vrml', function () {\n\n\t\t\t$.SUBRULE( $.version );\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t} );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'version', function () {\n\n\t\t\t$.CONSUME( Version );\n\n\t\t} );\n\n\t\t$.RULE( 'node', function () {\n\n\t\t\t$.OPTION( function () {\n\n\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t} );\n\n\t\t\t$.CONSUME( NodeName );\n\t\t\t$.CONSUME( LCurly );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RCurly );\n\n\t\t} );\n\n\t\t$.RULE( 'field', function () {\n\n\t\t\t$.CONSUME( Identifier );\n\n\t\t\t$.OR2( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'def', function () {\n\n\t\t\t$.CONSUME( DEF );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'use', function () {\n\n\t\t\t$.CONSUME( USE );\n\t\t\t$.OR( [\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t} },\n\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t$.CONSUME( NodeName );\n\n\t\t\t\t} }\n\t\t\t] );\n\n\t\t} );\n\n\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\n\t\t\t} );\n\n\t\t} );\n\n\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t$.CONSUME( LSquare );\n\t\t\t$.MANY( function () {\n\n\t\t\t\t$.OR( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\t\t\t$.CONSUME( RSquare );\n\n\t\t} );\n\n\t\t$.RULE( 'route', function () {\n\n\t\t\t$.CONSUME( ROUTE );\n\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t$.CONSUME( TO );\n\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t} );\n\n\t\tthis.performSelfAnalysis();\n\n\t}\n\n\tVRMLParser.prototype = Object.create( chevrotain.Parser.prototype ); // eslint-disable-line no-undef\n\tVRMLParser.prototype.constructor = VRMLParser;\n\n\tfunction Face( a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.normal = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t}\n\n\tvar TEXTURE_TYPE = {\n\t\tINTENSITY: 1,\n\t\tINTENSITY_ALPHA: 2,\n\t\tRGB: 3,\n\t\tRGBA: 4\n\t};\n\n\treturn VRMLLoader;\n\n} )();\n\nvar PCDLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.littleEndian = true;\n\n};\n\n\nPCDLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PCDLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( data, url ) {\n\n\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\tvar inLength = inData.length;\n\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\tvar inPtr = 0;\n\t\t\tvar outPtr = 0;\n\t\t\tvar ctrl;\n\t\t\tvar len;\n\t\t\tvar ref;\n\t\t\tdo {\n\n\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\tctrl ++;\n\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t}\n\n\t\t\t} while ( inPtr < inLength );\n\n\t\t\treturn outData;\n\n\t\t}\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar PCDheader = {};\n\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t// evaluate\n\n\t\t\tif ( PCDheader.version !== null )\n\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.type !== null )\n\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\tif ( PCDheader.width !== null )\n\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\tif ( PCDheader.height !== null )\n\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\tif ( PCDheader.points !== null )\n\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\tif ( PCDheader.points === null )\n\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tvar sizeSum = 0;\n\n\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[ i ] * PCDheader.count[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\n\t\t}\n\n\t\tvar textData = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\n\t\t// parse header (always ascii format)\n\n\t\tvar PCDheader = parseHeader( textData );\n\n\t\t// parse data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar color = [];\n\n\t\t// ascii\n\n\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\tvar offset = PCDheader.offset;\n\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary-compressed\n\n\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// binary\n\n\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( position, 3 ) );\n\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normal, 3 ) );\n\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( color, 3 ) );\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tvar material = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.P( { size: 0.005 } );\n\n\t\tif ( color.length > 0 ) {\n\n\t\t\tmaterial.vertexColors = true;\n\n\t\t} else {\n\n\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t}\n\n\t\t// build point cloud\n\n\t\tvar mesh = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.z( geometry, material );\n\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\tname = /([^\\/]*)/.exec( name );\n\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\tmesh.name = name;\n\n\t\treturn mesh;\n\n\t}\n\n} );\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\n\nvar PLYLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\tthis.propertyNameMapping = {};\n\n};\n\nPLYLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: PLYLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\tvar element = {};\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tvar lines = body.split( '\\n' );\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tvar element = {};\n\t\t\tvar result, read = 0;\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tfaceVertexUvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\tvar result, loc = 0;\n\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tvar text = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( data ) );\n\t\t\tvar header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n/*!\nfflate - fast JavaScript compression/decompression\n<https://101arrowz.github.io/fflate>\nLicensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE\n*/\nvar gn={},bn=function(n,r,t,e,i){var a=gn[r]||(gn[r]=URL.createObjectURL(new Blob([n],{type:\"text/javascript\"}))),o=new Worker(a);return o.onerror=function(f){return i(f.error,null)},o.onmessage=function(f){return i(null,f.data)},o.postMessage(t,e),o},A=Uint8Array,R=Uint16Array,nr=Uint32Array,ur=new A([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),lr=new A([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Mr=new A([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),wn=function(n,r){for(var t=new R(31),e=0;e<31;++e)t[e]=r+=1<<n[e-1];for(var i=new nr(t[30]),e=1;e<30;++e)for(var a=t[e];a<t[e+1];++a)i[a]=a-t[e]<<5|e;return [t,i]},yn=wn(ur,2),Nr=yn[0],Ir=yn[1];Nr[28]=258,Ir[258]=28;for(var mn=wn(lr,0),zn=mn[0],Qr=mn[1],Ur=new R(32768),T=0;T<32768;++T){var ir=(T&43690)>>>1|(T&21845)<<1;ir=(ir&52428)>>>2|(ir&13107)<<2,ir=(ir&61680)>>>4|(ir&3855)<<4,Ur[T]=((ir&65280)>>>8|(ir&255)<<8)>>>1;}for(var V=function(n,r,t){for(var e=n.length,i=0,a=new R(r);i<e;++i)++a[n[i]-1];var o=new R(r);for(i=0;i<r;++i)o[i]=o[i-1]+a[i-1]<<1;var f;if(t){f=new R(1<<r);var h=15-r;for(i=0;i<e;++i)if(n[i])for(var s=i<<4|n[i],u=r-n[i],l=o[n[i]-1]++<<u,p=l|(1<<u)-1;l<=p;++l)f[Ur[l]>>>h]=s;}else for(f=new R(e),i=0;i<e;++i)n[i]&&(f[i]=Ur[o[n[i]-1]++]>>>15-n[i]);return f},tr=new A(288),T=0;T<144;++T)tr[T]=8;for(var T=144;T<256;++T)tr[T]=9;for(var T=256;T<280;++T)tr[T]=7;for(var T=280;T<288;++T)tr[T]=8;for(var vr=new A(32),T=0;T<32;++T)vr[T]=5;var xn=V(tr,9,0),An=V(tr,9,1),Dn=V(vr,5,0),Mn=V(vr,5,1),Gr=function(n){for(var r=n[0],t=1;t<n.length;++t)n[t]>r&&(r=n[t]);return r},X=function(n,r,t){var e=r/8|0;return (n[e]|n[e+1]<<8)>>(r&7)&t},Or=function(n,r){var t=r/8|0;return (n[t]|n[t+1]<<8|n[t+2]<<16)>>(r&7)},Cr=function(n){return (n/8|0)+(n&7&&1)},$=function(n,r,t){(r==null||r<0)&&(r=0),(t==null||t>n.length)&&(t=n.length);var e=new(n instanceof R?R:n instanceof nr?nr:A)(t-r);return e.set(n.subarray(r,t)),e},Fr=function(n,r,t){var e=n.length;if(!e||t&&!t.l&&e<5)return r||new A(0);var i=!r||t,a=!t||t.i;t||(t={}),r||(r=new A(e*3));var o=function(Tr){var Dr=r.length;if(Tr>Dr){var hr=new A(Math.max(Dr*2,Tr));hr.set(r),r=hr;}},f=t.f||0,h=t.p||0,s=t.b||0,u=t.l,l=t.d,p=t.m,y=t.n,c=e*8;do{if(!u){t.f=f=X(n,h,1);var g=X(n,h+1,3);if(h+=3,g)if(g==1)u=An,l=Mn,p=9,y=5;else if(g==2){var m=X(n,h,31)+257,D=X(n,h+10,15)+4,C=m+X(n,h+5,31)+1;h+=14;for(var U=new A(C),x=new A(19),v=0;v<D;++v)x[Mr[v]]=X(n,h+v*3,7);h+=D*3;var E=Gr(x),S=(1<<E)-1;if(!a&&h+C*(E+7)>c)break;for(var K=V(x,E,1),v=0;v<C;){var I=K[X(n,h,S)];h+=I&15;var w=I>>>4;if(w<16)U[v++]=w;else {var Z=0,B=0;for(w==16?(B=3+X(n,h,3),h+=2,Z=U[v-1]):w==17?(B=3+X(n,h,7),h+=3):w==18&&(B=11+X(n,h,127),h+=7);B--;)U[v++]=Z;}}var G=U.subarray(0,m),k=U.subarray(m);p=Gr(G),y=Gr(k),u=V(G,p,1),l=V(k,y,1);}else throw \"invalid block type\";else {var w=Cr(h)+4,M=n[w-4]|n[w-3]<<8,z=w+M;if(z>e){if(a)throw \"unexpected EOF\";break}i&&o(s+M),r.set(n.subarray(w,z),s),t.b=s+=M,t.p=h=z*8;continue}if(h>c)throw \"unexpected EOF\"}i&&o(s+131072);for(var O=(1<<p)-1,H=(1<<y)-1,N=p+y+18;a||h+N<c;){var Z=u[Or(n,h)&O],Q=Z>>>4;if(h+=Z&15,h>c)throw \"unexpected EOF\";if(!Z)throw \"invalid length/literal\";if(Q<256)r[s++]=Q;else if(Q==256){u=null;break}else {var W=Q-254;if(Q>264){var v=Q-257,d=ur[v];W=X(n,h,(1<<d)-1)+Nr[v],h+=d;}var _=l[Or(n,h)&H],j=_>>>4;if(!_)throw \"invalid distance\";h+=_&15;var k=zn[j];if(j>3){var d=lr[j];k+=Or(n,h)&(1<<d)-1,h+=d;}if(h>c)throw \"unexpected EOF\";i&&o(s+131072);for(var q=s+W;s<q;s+=4)r[s]=r[s-k],r[s+1]=r[s+1-k],r[s+2]=r[s+2-k],r[s+3]=r[s+3-k];s=q;}}t.l=u,t.p=h,t.b=s,u&&(f=1,t.m=p,t.d=l,t.n=y);}while(!f);return s==r.length?r:$(r,0,s)},b=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8;},cr=function(n,r,t){t<<=r&7;var e=r/8|0;n[e]|=t,n[e+1]|=t>>>8,n[e+2]|=t>>>16;},Er=function(n,r){for(var t=[],e=0;e<n.length;++e)n[e]&&t.push({s:e,f:n[e]});var i=t.length,a=t.slice();if(!i)return [er,0];if(i==1){var o=new A(t[0].s+1);return o[t[0].s]=1,[o,1]}t.sort(function(C,U){return C.f-U.f}),t.push({s:-1,f:25001});var f=t[0],h=t[1],s=0,u=1,l=2;for(t[0]={s:-1,f:f.f+h.f,l:f,r:h};u!=i-1;)f=t[t[s].f<t[l].f?s++:l++],h=t[s!=u&&t[s].f<t[l].f?s++:l++],t[u++]={s:-1,f:f.f+h.f,l:f,r:h};for(var p=a[0].s,e=1;e<i;++e)a[e].s>p&&(p=a[e].s);var y=new R(p+1),c=Pr(t[u-1],y,0);if(c>r){var e=0,g=0,w=c-r,M=1<<w;for(a.sort(function(U,x){return y[x.s]-y[U.s]||U.f-x.f});e<i;++e){var z=a[e].s;if(y[z]>r)g+=M-(1<<c-y[z]),y[z]=r;else break}for(g>>>=w;g>0;){var m=a[e].s;y[m]<r?g-=1<<r-y[m]++-1:++e;}for(;e>=0&&g;--e){var D=a[e].s;y[D]==r&&(--y[D],++g);}c=r;}return [new A(y),c]},Pr=function(n,r,t){return n.s==-1?Math.max(Pr(n.l,r,t+1),Pr(n.r,r,t+1)):r[n.s]=t},Vr=function(n){for(var r=n.length;r&&!n[--r];);for(var t=new R(++r),e=0,i=n[0],a=1,o=function(h){t[e++]=h;},f=1;f<=r;++f)if(n[f]==i&&f!=r)++a;else {if(!i&&a>2){for(;a>138;a-=138)o(32754);a>2&&(o(a>10?a-11<<5|28690:a-3<<5|12305),a=0);}else if(a>3){for(o(i),--a;a>6;a-=6)o(8304);a>2&&(o(a-3<<5|8208),a=0);}for(;a--;)o(i);a=1,i=n[f];}return [t.subarray(0,e),r]},pr=function(n,r){for(var t=0,e=0;e<r.length;++e)t+=n[e]*r[e];return t},Sr=function(n,r,t){var e=t.length,i=Cr(r+2);n[i]=e&255,n[i+1]=e>>>8,n[i+2]=n[i]^255,n[i+3]=n[i+1]^255;for(var a=0;a<e;++a)n[i+a+4]=t[a];return (i+4+e)*8},Xr=function(n,r,t,e,i,a,o,f,h,s,u){b(r,u++,t),++i[256];for(var l=Er(i,15),p=l[0],y=l[1],c=Er(a,15),g=c[0],w=c[1],M=Vr(p),z=M[0],m=M[1],D=Vr(g),C=D[0],U=D[1],x=new R(19),v=0;v<z.length;++v)x[z[v]&31]++;for(var v=0;v<C.length;++v)x[C[v]&31]++;for(var E=Er(x,7),S=E[0],K=E[1],I=19;I>4&&!S[Mr[I-1]];--I);var Z=s+5<<3,B=pr(i,tr)+pr(a,vr)+o,G=pr(i,p)+pr(a,g)+o+14+3*I+pr(x,S)+(2*x[16]+3*x[17]+7*x[18]);if(Z<=B&&Z<=G)return Sr(r,u,n.subarray(h,h+s));var k,O,H,N;if(b(r,u,1+(G<B)),u+=2,G<B){k=V(p,y,0),O=p,H=V(g,w,0),N=g;var Q=V(S,K,0);b(r,u,m-257),b(r,u+5,U-1),b(r,u+10,I-4),u+=14;for(var v=0;v<I;++v)b(r,u+3*v,S[Mr[v]]);u+=3*I;for(var W=[z,C],d=0;d<2;++d)for(var _=W[d],v=0;v<_.length;++v){var j=_[v]&31;b(r,u,Q[j]),u+=S[j],j>15&&(b(r,u,_[v]>>>5&127),u+=_[v]>>>12);}}else k=xn,O=tr,H=Dn,N=vr;for(var v=0;v<f;++v)if(e[v]>255){var j=e[v]>>>18&31;cr(r,u,k[j+257]),u+=O[j+257],j>7&&(b(r,u,e[v]>>>23&31),u+=ur[j]);var q=e[v]&31;cr(r,u,H[q]),u+=N[q],q>3&&(cr(r,u,e[v]>>>5&8191),u+=lr[q]);}else cr(r,u,k[e[v]]),u+=O[e[v]];return cr(r,u,k[256]),u+O[256]},Un=new nr([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),er=new A(0),Cn=function(n,r,t,e,i,a){var o=n.length,f=new A(e+o+5*(1+Math.ceil(o/7e3))+i),h=f.subarray(e,f.length-i),s=0;if(!r||o<8)for(var u=0;u<=o;u+=65535){var l=u+65535;l<o?s=Sr(h,s,n.subarray(u,l)):(h[u]=a,s=Sr(h,s,n.subarray(u,o)));}else {for(var p=Un[r-1],y=p>>>13,c=p&8191,g=(1<<t)-1,w=new R(32768),M=new R(g+1),z=Math.ceil(t/3),m=2*z,D=function(Kr){return (n[Kr]^n[Kr+1]<<z^n[Kr+2]<<m)&g},C=new nr(25e3),U=new R(288),x=new R(32),v=0,E=0,u=0,S=0,K=0,I=0;u<o;++u){var Z=D(u),B=u&32767,G=M[Z];if(w[B]=G,M[Z]=B,K<=u){var k=o-u;if((v>7e3||S>24576)&&k>423){s=Xr(n,h,0,C,U,x,E,S,I,u-I,s),S=v=E=0,I=u;for(var O=0;O<286;++O)U[O]=0;for(var O=0;O<30;++O)x[O]=0;}var H=2,N=0,Q=c,W=B-G&32767;if(k>2&&Z==D(u-W))for(var d=Math.min(y,k)-1,_=Math.min(32767,u),j=Math.min(258,k);W<=_&&--Q&&B!=G;){if(n[u+H]==n[u+H-W]){for(var q=0;q<j&&n[u+q]==n[u+q-W];++q);if(q>H){if(H=q,N=W,q>d)break;for(var Tr=Math.min(W,q-2),Dr=0,O=0;O<Tr;++O){var hr=u-W+O+32768&32767,_n=w[hr],vn=hr-_n+32768&32767;vn>Dr&&(Dr=vn,G=hr);}}}B=G,G=w[B],W+=B-G+32768&32767;}if(N){C[S++]=268435456|Ir[H]<<18|Qr[N];var cn=Ir[H]&31,pn=Qr[N]&31;E+=ur[cn]+lr[pn],++U[257+cn],++x[pn],K=u+H,++v;}else C[S++]=n[u],++U[n[u]];}}s=Xr(n,h,a,C,U,x,E,S,I,u-I,s),!a&&s&7&&(s=Sr(h,s+1,er));}return $(f,0,e+Cr(s)+i)},Fn=function(){for(var n=new nr(256),r=0;r<256;++r){for(var t=r,e=9;--e;)t=(t&1&&3988292384)^t>>>1;n[r]=t;}return n}(),gr=function(){var n=-1;return {p:function(r){for(var t=n,e=0;e<r.length;++e)t=Fn[t&255^r[e]]^t>>>8;n=t;},d:function(){return ~n}}},$r=function(){var n=1,r=0;return {p:function(t){for(var e=n,i=r,a=t.length,o=0;o!=a;){for(var f=Math.min(o+2655,a);o<f;++o)i+=e+=t[o];e=(e&65535)+15*(e>>16),i=(i&65535)+15*(i>>16);}n=e,r=i;},d:function(){return n%=65521,r%=65521,(n>>>8<<16|(r&255)<<8|r>>>8)+((n&255)<<23)*2}}},sr=function(n,r,t,e,i){return Cn(n,r.level==null?6:r.level,r.mem==null?Math.ceil(Math.max(8,Math.min(13,Math.log(n.length)))*1.5):12+r.mem,t,e,!i)},Zr=function(n,r){var t={};for(var e in n)t[e]=n[e];for(var e in r)t[e]=r[e];return t},Sn=function(n,r,t){for(var e=n(),i=n.toString(),a=i.slice(i.indexOf(\"[\")+1,i.lastIndexOf(\"]\")).replace(/ /g,\"\").split(\",\"),o=0;o<e.length;++o){var f=e[o],h=a[o];if(typeof f==\"function\"){r+=\";\"+h+\"=\";var s=f.toString();if(f.prototype)if(s.indexOf(\"[native code]\")!=-1){var u=s.indexOf(\" \",8)+1;r+=s.slice(u,s.indexOf(\"(\",u));}else {r+=s;for(var l in f.prototype)r+=\";\"+h+\".prototype.\"+l+\"=\"+f.prototype[l].toString();}else r+=s;}else t[h]=f;}return [r,t]},Rr=[],rt=function(n){var r=[];for(var t in n)(n[t]instanceof A||n[t]instanceof R||n[t]instanceof nr)&&r.push((n[t]=new n[t].constructor(n[t])).buffer);return r},Zn=function(n,r,t,e){var i;if(!Rr[t]){for(var a=\"\",o={},f=n.length-1,h=0;h<f;++h)i=Sn(n[h],a,o),a=i[0],o=i[1];Rr[t]=Sn(n[f],a,o);}var s=Zr({},Rr[t][1]);return bn(Rr[t][0]+\";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\"+r.toString()+\"}\",t,s,rt(s),e)},wr=function(){return [A,R,nr,ur,lr,Mr,Nr,zn,An,Mn,Ur,V,Gr,X,Or,Cr,$,Fr,xr,ar,Lr]},yr=function(){return [A,R,nr,ur,lr,Mr,Ir,Qr,xn,tr,Dn,vr,Ur,Un,er,V,b,cr,Er,Pr,Vr,pr,Sr,Xr,Cr,$,Cn,sr,kr,ar]},kn=function(){return [_r,rn,F,gr,Fn]},Bn=function(){return [br,Gn]},Tn=function(){return [nn,F,$r]},In=function(){return [On]},ar=function(n){return postMessage(n,[n.buffer])},Lr=function(n){return n&&n.size&&new A(n.size)},mr=function(n,r,t,e,i,a){var o=Zn(t,e,i,function(f,h){o.terminate(),a(f,h);});return o.postMessage([n,r],r.consume?[n.buffer]:[]),function(){o.terminate();}},L=function(n){return n.ondata=function(r,t){return postMessage([r,t],[r.buffer])},function(r){return n.push(r.data[0],r.data[1])}},zr=function(n,r,t,e,i){var a,o=Zn(n,e,i,function(f,h){f?(o.terminate(),r.ondata.call(r,f)):(h[1]&&o.terminate(),r.ondata.call(r,f,h[0],h[1]));});o.postMessage(t),r.push=function(f,h){if(a)throw \"stream finished\";if(!r.ondata)throw \"no stream handler\";o.postMessage([f,a=h],[f.buffer]);},r.terminate=function(){o.terminate();};},Y=function(n,r){return n[r]|n[r+1]<<8},P=function(n,r){return (n[r]|n[r+1]<<8|n[r+2]<<16)+(n[r+3]<<23)*2},dr=function(n,r){return P(n,r)|P(n,r)*4294967296},F=function(n,r,t){for(;t;++r)n[r]=t,t>>>=8;},_r=function(n,r){var t=r.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=r.level<2?4:r.level==9?2:0,n[9]=3,r.mtime!=0&&F(n,4,Math.floor(new Date(r.mtime||Date.now())/1e3)),t){n[3]=8;for(var e=0;e<=t.length;++e)n[e+10]=t.charCodeAt(e);}},br=function(n){if(n[0]!=31||n[1]!=139||n[2]!=8)throw \"invalid gzip data\";var r=n[3],t=10;r&4&&(t+=n[10]|(n[11]<<8)+2);for(var e=(r>>3&1)+(r>>4&1);e>0;e-=!n[t++]);return t+(r&2)},Gn=function(n){var r=n.length;return (n[r-4]|n[r-3]<<8|n[r-2]<<16)+2*(n[r-1]<<23)},rn=function(n){return 10+(n.filename&&n.filename.length+1||0)},nn=function(n,r){var t=r.level,e=t==0?0:t<6?1:t==9?3:2;n[0]=120,n[1]=e<<6|(e?32-2*e:1);},On=function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw \"invalid zlib data\";if(n[1]&32)throw \"invalid zlib data: preset dictionaries not supported\"};function tn(n,r){return !r&&typeof n==\"function\"&&(r=n,n={}),this.ondata=r,n}var rr=function(){function n(r,t){!t&&typeof r==\"function\"&&(t=r,r={}),this.ondata=t,this.o=r||{};}return n.prototype.p=function(r,t){this.ondata(sr(r,this.o,0,0,!t),t);},n.prototype.push=function(r,t){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";this.d=t,this.p(r,t||!1);},n}(),En=function(){function n(r,t){zr([yr,function(){return [L,rr]}],this,tn.call(this,r,t),function(e){var i=new rr(e.data);onmessage=L(i);},6);}return n}();function Pn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr],function(e){return ar(kr(e.data[0],e.data[1]))},0,t)}function kr(n,r){return sr(n,r||{},0,0)}var J=function(){function n(r){this.s={},this.p=new A(0),this.ondata=r;}return n.prototype.e=function(r){if(this.d)throw \"stream finished\";if(!this.ondata)throw \"no stream handler\";var t=this.p.length,e=new A(t+r.length);e.set(this.p),e.set(r,t),this.p=e;},n.prototype.c=function(r){this.d=this.s.i=r||!1;var t=this.s.b,e=Fr(this.p,this.o,this.s);this.ondata($(e,t,this.s.b),this.d),this.o=$(e,this.s.b-32768),this.s.b=this.o.length,this.p=$(this.p,this.s.p/8|0),this.s.p&=7;},n.prototype.push=function(r,t){this.e(r),this.c(t);},n}(),en=function(){function n(r){this.ondata=r,zr([wr,function(){return [L,J]}],this,0,function(){var t=new J;onmessage=L(t);},7);}return n}();function an(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr],function(e){return ar(xr(e.data[0],Lr(e.data[1])))},1,t)}function xr(n,r){return Fr(n,r)}var qr=function(){function n(r,t){this.c=gr(),this.l=0,this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r),this.l+=r.length;var e=sr(r,this.o,this.v&&rn(this.o),t&&8,!t);this.v&&(_r(e,this.o),this.v=0),t&&(F(e,e.length-8,this.c.d()),F(e,e.length-4,this.l)),this.ondata(e,t);},n}(),Rn=function(){function n(r,t){zr([yr,kn,function(){return [L,rr,qr]}],this,tn.call(this,r,t),function(e){var i=new qr(e.data);onmessage=L(i);},8);}return n}();function qn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,kn,function(){return [Hr]}],function(e){return ar(Hr(e.data[0],e.data[1]))},2,t)}function Hr(n,r){r||(r={});var t=gr(),e=n.length;t.p(n);var i=sr(n,r,rn(r),8),a=i.length;return _r(i,r),F(i,a-8,t.d()),F(i,a-4,e),i}var Wr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){var e=this.p.length>3?br(this.p):4;if(e>=this.p.length&&!t)return;this.p=this.p.subarray(e),this.v=0;}if(t){if(this.p.length<8)throw \"invalid gzip stream\";this.p=this.p.subarray(0,-8);}J.prototype.c.call(this,t);},n}(),Hn=function(){function n(r){this.ondata=r,zr([wr,Bn,function(){return [L,J,Wr]}],this,0,function(){var t=new Wr;onmessage=L(t);},9);}return n}();function Wn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,Bn,function(){return [Yr]}],function(e){return ar(Yr(e.data[0]))},3,t)}function Yr(n,r){return Fr(n.subarray(br(n),-8),r||new A(Gn(n)))}var on=function(){function n(r,t){this.c=$r(),this.v=1,rr.call(this,r,t);}return n.prototype.push=function(r,t){rr.prototype.push.call(this,r,t);},n.prototype.p=function(r,t){this.c.p(r);var e=sr(r,this.o,this.v&&2,t&&4,!t);this.v&&(nn(e,this.o),this.v=0),t&&F(e,e.length-4,this.c.d()),this.ondata(e,t);},n}(),nt=function(){function n(r,t){zr([yr,Tn,function(){return [L,rr,on]}],this,tn.call(this,r,t),function(e){var i=new on(e.data);onmessage=L(i);},10);}return n}();function tt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[yr,Tn,function(){return [fn]}],function(e){return ar(fn(e.data[0],e.data[1]))},4,t)}function fn(n,r){r||(r={});var t=$r();t.p(n);var e=sr(n,r,2,4);return nn(e,r),F(e,e.length-4,t.d()),e}var jr=function(){function n(r){this.v=1,J.call(this,r);}return n.prototype.push=function(r,t){if(J.prototype.e.call(this,r),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0;}if(t){if(this.p.length<4)throw \"invalid zlib stream\";this.p=this.p.subarray(0,-4);}J.prototype.c.call(this,t);},n}(),Yn=function(){function n(r){this.ondata=r,zr([wr,In,function(){return [L,J,jr]}],this,0,function(){var t=new jr;onmessage=L(t);},11);}return n}();function jn(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return mr(n,r,[wr,In,function(){return [Jr]}],function(e){return ar(Jr(e.data[0],Lr(e.data[1])))},5,t)}function Jr(n,r){return Fr((On(n),n.subarray(2,-4)),r)}var Jn=function(){function n(r){this.G=Wr,this.I=J,this.Z=jr,this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no stream handler\";if(this.s)this.s.push(r,t);else {if(this.p&&this.p.length){var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);}else this.p=r;if(this.p.length>2){var i=this,a=function(){i.ondata.apply(i,arguments);};this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(a):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(a):new this.Z(a),this.s.push(this.p,t),this.p=null;}}},n}(),et=function(){function n(r){this.G=Hn,this.I=en,this.Z=Yn,this.ondata=r;}return n.prototype.push=function(r,t){Jn.prototype.push.call(this,r,t);},n}();function it(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";return n[0]==31&&n[1]==139&&n[2]==8?Wn(n,r,t):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?an(n,r,t):jn(n,r,t)}function at(n,r){return n[0]==31&&n[1]==139&&n[2]==8?Yr(n,r):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?xr(n,r):Jr(n,r)}var sn=function(n,r,t,e){for(var i in n){var a=n[i],o=r+i;a instanceof A?t[o]=[a,e]:Array.isArray(a)?t[o]=[a[0],Zr(e,a[1])]:sn(a,o+\"/\",t,e);}},Kn=typeof TextEncoder!=\"undefined\"&&new TextEncoder,hn=typeof TextDecoder!=\"undefined\"&&new TextDecoder,Nn=0;try{hn.decode(er,{stream:!0}),Nn=1;}catch(n){}var Qn=function(n){for(var r=\"\",t=0;;){var e=n[t++],i=(e>127)+(e>223)+(e>239);if(t+i>n.length)return [r,$(n,t-1)];i?i==3?(e=((e&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,r+=String.fromCharCode(55296|e>>10,56320|e&1023)):i&1?r+=String.fromCharCode((e&31)<<6|n[t++]&63):r+=String.fromCharCode((e&15)<<12|(n[t++]&63)<<6|n[t++]&63):r+=String.fromCharCode(e);}},ot=function(){function n(r){this.ondata=r,Nn?this.t=new TextDecoder:this.p=er;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";if(t||(t=!1),this.t)return this.ondata(this.t.decode(r,{stream:!t}),t);var e=new A(this.p.length+r.length);e.set(this.p),e.set(r,this.p.length);var i=Qn(e),a=i[0],o=i[1];if(t&&o.length)throw \"invalid utf-8 data\";this.p=o,this.ondata(a,t);},n}(),ft=function(){function n(r){this.ondata=r;}return n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback\";this.ondata(or(r),t||!1);},n}();function or(n,r){if(r){for(var t=new A(n.length),e=0;e<n.length;++e)t[e]=n.charCodeAt(e);return t}if(Kn)return Kn.encode(n);for(var i=n.length,a=new A(n.length+(n.length>>1)),o=0,f=function(u){a[o++]=u;},e=0;e<i;++e){if(o+5>a.length){var h=new A(o+8+(i-e<<1));h.set(a),a=h;}var s=n.charCodeAt(e);s<128||r?f(s):s<2048?(f(192|s>>>6),f(128|s&63)):s>55295&&s<57344?(s=65536+(s&1023<<10)|n.charCodeAt(++e)&1023,f(240|s>>>18),f(128|s>>>12&63),f(128|s>>>6&63),f(128|s&63)):(f(224|s>>>12),f(128|s>>>6&63),f(128|s&63));}return $(a,0,o)}function un(n,r){if(r){for(var t=\"\",e=0;e<n.length;e+=16384)t+=String.fromCharCode.apply(null,n.subarray(e,e+16384));return t}else {if(hn)return hn.decode(n);var i=Qn(n),a=i[0],o=i[1];if(o.length)throw \"invalid utf-8 data\";return a}}var Vn=function(n){return n==1?3:n<6?2:n==9?1:0},Xn=function(n,r){return r+30+Y(n,r+26)+Y(n,r+28)},$n=function(n,r,t){var e=Y(n,r+28),i=un(n.subarray(r+46,r+46+e),!(Y(n,r+8)&2048)),a=r+46+e,o=P(n,r+20),f=t&&o==4294967295?Ln(n,a):[o,P(n,r+24),P(n,r+42)],h=f[0],s=f[1],u=f[2];return [Y(n,r+10),h,s,i,a+Y(n,r+30)+Y(n,r+32),u]},Ln=function(n,r){for(;Y(n,r)!=1;r+=4+Y(n,r+2));return [dr(n,r+12),dr(n,r+4),dr(n,r+20)]},fr=function(n){var r=0;if(n)for(var t in n){var e=n[t].length;if(e>65535)throw \"extra field too long\";r+=e+4;}return r},Ar=function(n,r,t,e,i,a,o,f){var h=e.length,s=t.extra,u=f&&f.length,l=fr(s);F(n,r,o!=null?33639248:67324752),r+=4,o!=null&&(n[r++]=20,n[r++]=t.os),n[r]=20,r+=2,n[r++]=t.flag<<1|(a==null&&8),n[r++]=i&&8,n[r++]=t.compression&255,n[r++]=t.compression>>8;var p=new Date(t.mtime==null?Date.now():t.mtime),y=p.getFullYear()-1980;if(y<0||y>119)throw \"date not in range 1980-2099\";if(F(n,r,(y<<24)*2|p.getMonth()+1<<21|p.getDate()<<16|p.getHours()<<11|p.getMinutes()<<5|p.getSeconds()>>>1),r+=4,a!=null&&(F(n,r,t.crc),F(n,r+4,a),F(n,r+8,t.size)),F(n,r+12,h),F(n,r+14,l),r+=16,o!=null&&(F(n,r,u),F(n,r+6,t.attrs),F(n,r+10,o),r+=14),n.set(e,r),r+=h,l)for(var c in s){var g=s[c],w=g.length;F(n,r,+c),F(n,r+2,w),n.set(g,r+4),r+=4+w;}return u&&(n.set(f,r),r+=u),r},ln=function(n,r,t,e,i){F(n,r,101010256),F(n,r+8,t),F(n,r+10,t),F(n,r+12,e),F(n,r+16,i);},Br=function(){function n(r){this.filename=r,this.c=gr(),this.size=0,this.compression=0;}return n.prototype.process=function(r,t){this.ondata(null,r,t);},n.prototype.push=function(r,t){if(!this.ondata)throw \"no callback - add to ZIP archive before pushing\";this.c.p(r),this.size+=r.length,t&&(this.crc=this.c.d()),this.process(r,t||!1);},n}(),st=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new rr(t,function(i,a){e.ondata(null,i,a);}),this.compression=8,this.flag=Vn(t.level);}return n.prototype.process=function(r,t){try{this.d.push(r,t);}catch(e){this.ondata(e,null,t);}},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ht=function(){function n(r,t){var e=this;t||(t={}),Br.call(this,r),this.d=new En(t,function(i,a,o){e.ondata(i,a,o);}),this.compression=8,this.flag=Vn(t.level),this.terminate=this.d.terminate;}return n.prototype.process=function(r,t){this.d.push(r,t);},n.prototype.push=function(r,t){Br.prototype.push.call(this,r,t);},n}(),ut=function(){function n(r){this.ondata=r,this.u=[],this.d=1;}return n.prototype.add=function(r){var t=this;if(this.d&2)throw \"stream finished\";var e=or(r.filename),i=e.length,a=r.comment,o=a&&or(a),f=i!=r.filename.length||o&&a.length!=o.length,h=i+fr(r.extra)+30;if(i>65535)throw \"filename too long\";var s=new A(h);Ar(s,0,r,e,f);var u=[s],l=function(){for(var w=0,M=u;w<M.length;w++){var z=M[w];t.ondata(null,z,!1);}u=[];},p=this.d;this.d=0;var y=this.u.length,c=Zr(r,{f:e,u:f,o,t:function(){r.terminate&&r.terminate();},r:function(){if(l(),p){var w=t.u[y+1];w?w.r():t.d=1;}p=1;}}),g=0;r.ondata=function(w,M,z){if(w)t.ondata(w,M,z),t.terminate();else if(g+=M.length,u.push(M),z){var m=new A(16);F(m,0,134695760),F(m,4,r.crc),F(m,8,g),F(m,12,r.size),u.push(m),c.c=g,c.b=h+g+16,c.crc=r.crc,c.size=r.size,p&&c.r(),p=1;}else p&&l();},this.u.push(c);},n.prototype.end=function(){var r=this;if(this.d&2)throw this.d&1?\"stream finishing\":\"stream finished\";this.d?this.e():this.u.push({r:function(){if(!(r.d&1))return;r.u.splice(-1,1),r.e();},t:function(){}}),this.d=3;},n.prototype.e=function(){for(var r=0,t=0,e=0,i=0,a=this.u;i<a.length;i++){var o=a[i];e+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0);}for(var f=new A(e+22),h=0,s=this.u;h<s.length;h++){var o=s[h];Ar(f,r,o,o.f,o.u,o.c,t,o.o),r+=46+o.f.length+fr(o.extra)+(o.o?o.o.length:0),t+=o.b;}ln(f,r,this.u.length,e,t),this.ondata(null,f,!0),this.d=2;},n.prototype.terminate=function(){for(var r=0,t=this.u;r<t.length;r++){var e=t[r];e.t();}this.d=2;},n}();function lt(n,r,t){if(t||(t=r,r={}),typeof t!=\"function\")throw \"no callback\";var e={};sn(n,\"\",e,r);var i=Object.keys(e),a=i.length,o=0,f=0,h=a,s=new Array(a),u=[],l=function(){for(var g=0;g<u.length;++g)u[g]();},p=function(){var g=new A(f+22),w=o,M=f-o;f=0;for(var z=0;z<h;++z){var m=s[z];try{var D=m.c.length;Ar(g,f,m,m.f,m.u,D);var C=30+m.f.length+fr(m.extra),U=f+C;g.set(m.c,U),Ar(g,o,m,m.f,m.u,D,f,m.m),o+=16+C+(m.m?m.m.length:0),f=U+D;}catch(x){return t(x,null)}}ln(g,o,s.length,M,w),t(null,g);};a||p();for(var y=function(g){var w=i[g],M=e[w],z=M[0],m=M[1],D=gr(),C=z.length;D.p(z);var U=or(w),x=U.length,v=m.comment,E=v&&or(v),S=E&&E.length,K=fr(m.extra),I=m.level==0?0:8,Z=function(B,G){if(B)l(),t(B,null);else {var k=G.length;s[g]=Zr(m,{size:C,crc:D.d(),c:G,f:U,m:E,u:x!=w.length||E&&v.length!=S,compression:I}),o+=30+x+K+k,f+=76+2*(x+K)+(S||0)+k,--a||p();}};if(x>65535&&Z(\"filename too long\",null),!I)Z(null,z);else if(C<16e4)try{Z(null,kr(z,m));}catch(B){Z(B,null);}else u.push(Pn(z,m,Z));},c=0;c<h;++c)y(c);return l}function vt(n,r){r||(r={});var t={},e=[];sn(n,\"\",t,r);var i=0,a=0;for(var o in t){var f=t[o],h=f[0],s=f[1],u=s.level==0?0:8,l=or(o),p=l.length,y=s.comment,c=y&&or(y),g=c&&c.length,w=fr(s.extra);if(p>65535)throw \"filename too long\";var M=u?kr(h,s):h,z=M.length,m=gr();m.p(h),e.push(Zr(s,{size:h.length,crc:m.d(),c:M,f:l,m:c,u:p!=o.length||c&&y.length!=g,o:i,compression:u})),i+=30+p+w+z,a+=76+2*(p+w)+(g||0)+z;}for(var D=new A(a+22),C=i,U=a-i,x=0;x<e.length;++x){var l=e[x];Ar(D,l.o,l,l.f,l.u,l.c.length);var v=30+l.f.length+fr(l.extra);D.set(l.c,l.o+v),Ar(D,i,l,l.f,l.u,l.c.length,l.o,l.m),i+=16+v+(l.m?l.m.length:0);}return ln(D,i,e.length,U,C),D}var dn=function(){function n(){}return n.prototype.push=function(r,t){this.ondata(null,r,t);},n.compression=0,n}(),ct=function(){function n(){var r=this;this.i=new J(function(t,e){r.ondata(null,t,e);});}return n.prototype.push=function(r,t){try{this.i.push(r,t);}catch(e){this.ondata(e,r,t);}},n.compression=8,n}(),pt=function(){function n(r,t){var e=this;t<32e4?this.i=new J(function(i,a){e.ondata(null,i,a);}):(this.i=new en(function(i,a,o){e.ondata(i,a,o);}),this.terminate=this.i.terminate);}return n.prototype.push=function(r,t){this.i.terminate&&(r=$(r,0)),this.i.push(r,t);},n.compression=8,n}(),gt=function(){function n(r){this.onfile=r,this.k=[],this.o={0:dn},this.p=er;}return n.prototype.push=function(r,t){var e=this;if(!this.onfile)throw \"no callback\";if(this.c>0){var i=Math.min(this.c,r.length),a=r.subarray(0,i);if(this.c-=i,this.d?this.d.push(a,!this.c):this.k[0].push(a),r=r.subarray(i),r.length)return this.push(r,t)}else {var o=0,f=0,h=void 0,s=void 0;this.p.length?r.length?(s=new A(this.p.length+r.length),s.set(this.p),s.set(r,this.p.length)):s=this.p:s=r;for(var u=s.length,l=this.c,p=l&&this.d,y=function(){var M,z=P(s,f);if(z==67324752){o=1,h=f,c.d=null,c.c=0;var m=Y(s,f+6),D=Y(s,f+8),C=m&2048,U=m&8,x=Y(s,f+26),v=Y(s,f+28);if(u>f+30+x+v){var E=[];c.k.unshift(E),o=2;var S=P(s,f+18),K=P(s,f+22),I=un(s.subarray(f+30,f+=30+x),!C);S==4294967295?(M=U?[-2]:Ln(s,f),S=M[0],K=M[1]):U&&(S=-1),f+=v,c.c=S;var Z={name:I,compression:D,start:function(){if(!Z.ondata)throw \"no callback\";if(!S)Z.ondata(null,er,!0);else {var B=e.o[D];if(!B)throw \"unknown compression type \"+D;var G=S<0?new B(I):new B(I,S,K);G.ondata=function(N,Q,W){Z.ondata(N,Q,W);};for(var k=0,O=E;k<O.length;k++){var H=O[k];G.push(H,!1);}e.k[0]==E?e.d=G:G.push(er,!0);}},terminate:function(){e.k[0]==E&&e.d.terminate&&e.d.terminate();}};S>=0&&(Z.size=S,Z.originalSize=K),c.onfile(Z);}return \"break\"}else if(l){if(z==134695760)return h=f+=12+(l==-2&&8),o=2,c.c=0,\"break\";if(z==33639248)return h=f-=4,o=2,c.c=0,\"break\"}},c=this;f<u-4;++f){var g=y();if(g===\"break\")break}if(this.p=er,l<0){var w=o?s.subarray(0,h-12-(l==-2&&8)-(P(s,h-16)==134695760&&4)):s.subarray(0,f);p?p.push(w,!!o):this.k[+(o==2)].push(w);}if(o&2)return this.push(s.subarray(f),t);this.p=s.subarray(f);}if(t&&this.c)throw \"invalid zip file\"},n.prototype.register=function(r){this.o[r.compression]=r;},n}();function wt(n,r){if(typeof r!=\"function\")throw \"no callback\";for(var t=[],e=function(){for(var p=0;p<t.length;++p)t[p]();},i={},a=n.length-22;P(n,a)!=101010256;--a)if(!a||n.length-a>65558){r(\"invalid zip file\",null);return}var o=Y(n,a+8);o||r(null,{});var f=o,h=P(n,a+16),s=h==4294967295;if(s){if(a=P(n,a-12),P(n,a)!=101075792){r(\"invalid zip file\",null);return}f=o=P(n,a+32),h=P(n,a+48);}for(var u=function(p){var y=$n(n,h,s),c=y[0],g=y[1],w=y[2],M=y[3],z=y[4],m=y[5],D=Xn(n,m);h=z;var C=function(x,v){x?(e(),r(x,null)):(i[M]=v,--o||r(null,i));};if(!c)C(null,$(n,D,D+g));else if(c==8){var U=n.subarray(D,D+g);if(g<32e4)try{C(null,xr(U,new A(w)));}catch(x){C(x,null);}else t.push(an(U,{size:w},C));}else C(\"unknown compression type \"+c,null);},l=0;l<f;++l)u();return e}function yt(n){for(var r={},t=n.length-22;P(n,t)!=101010256;--t)if(!t||n.length-t>65558)throw \"invalid zip file\";var e=Y(n,t+8);if(!e)return {};var i=P(n,t+16),a=i==4294967295;if(a){if(t=P(n,t-12),P(n,t)!=101075792)throw \"invalid zip file\";e=P(n,t+32),i=P(n,t+48);}for(var o=0;o<e;++o){var f=$n(n,i,a),h=f[0],s=f[1],u=f[2],l=f[3],p=f[4],y=f[5],c=Xn(n,y);if(i=p,!h)r[l]=$(n,c,c+s);else if(h==8)r[l]=xr(n.subarray(c,c+s),new A(u));else throw \"unknown compression type \"+h}return r}var fflate_module_min = null;\n\nvar fflate = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tAsyncCompress: Rn,\n\tAsyncDecompress: et,\n\tAsyncDeflate: En,\n\tAsyncGunzip: Hn,\n\tAsyncGzip: Rn,\n\tAsyncInflate: en,\n\tAsyncUnzipInflate: pt,\n\tAsyncUnzlib: Yn,\n\tAsyncZipDeflate: ht,\n\tAsyncZlib: nt,\n\tCompress: qr,\n\tDecodeUTF8: ot,\n\tDecompress: Jn,\n\tDeflate: rr,\n\tEncodeUTF8: ft,\n\tGunzip: Wr,\n\tGzip: qr,\n\tInflate: J,\n\tUnzip: gt,\n\tUnzipInflate: ct,\n\tUnzipPassThrough: dn,\n\tUnzlib: jr,\n\tZip: ut,\n\tZipDeflate: st,\n\tZipPassThrough: Br,\n\tZlib: on,\n\tcompress: qn,\n\tcompressSync: Hr,\n\tdecompress: it,\n\tdecompressSync: at,\n\tdeflate: Pn,\n\tdeflateSync: kr,\n\tgunzip: Wn,\n\tgunzipSync: Yr,\n\tgzip: qn,\n\tgzipSync: Hr,\n\tinflate: an,\n\tinflateSync: xr,\n\tstrFromU8: un,\n\tstrToU8: or,\n\tunzip: wt,\n\tunzipSync: yt,\n\tunzlib: jn,\n\tunzlibSync: Jr,\n\tzip: lt,\n\tzipSync: vt,\n\tzlib: tt,\n\tzlibSync: fn,\n\t'default': fflate_module_min\n});\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\nvar NURBSUtils = {\n\n\t/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\n\tfindSpan: function ( p, u, U ) {\n\n\t\tvar n = U.length - p - 1;\n\n\t\tif ( u >= U[ n ] ) {\n\n\t\t\treturn n - 1;\n\n\t\t}\n\n\t\tif ( u <= U[ p ] ) {\n\n\t\t\treturn p;\n\n\t\t}\n\n\t\tvar low = p;\n\t\tvar high = n;\n\t\tvar mid = Math.floor( ( low + high ) / 2 );\n\n\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\thigh = mid;\n\n\t\t\t} else {\n\n\t\t\t\tlow = mid;\n\n\t\t\t}\n\n\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t}\n\n\t\treturn mid;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\tcalcBasisFunctions: function ( span, u, p, U ) {\n\n\t\tvar N = [];\n\t\tvar left = [];\n\t\tvar right = [];\n\t\tN[ 0 ] = 1.0;\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tvar temp = N[ r ] / ( rv + lv );\n\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t }\n\n\t\t\t N[ j ] = saved;\n\n\t\t }\n\n\t\t return N;\n\n\t},\n\n\n\t/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\tcalcBSplinePoint: function ( p, U, P, u ) {\n\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar N = this.calcBasisFunctions( span, u, p, U );\n\t\tvar C = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tvar point = P[ span - p + j ];\n\t\t\tvar Nj = N[ j ];\n\t\t\tvar wNj = point.w * Nj;\n\t\t\tC.x += point.x * wNj;\n\t\t\tC.y += point.y * wNj;\n\t\t\tC.z += point.z * wNj;\n\t\t\tC.w += point.w * Nj;\n\n\t\t}\n\n\t\treturn C;\n\n\t},\n\n\n\t/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\tcalcBasisFunctionDerivatives: function ( span, u, p, n, U ) {\n\n\t\tvar zeroArr = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tzeroArr[ i ] = 0.0;\n\n\t\tvar ders = [];\n\t\tfor ( var i = 0; i <= n; ++ i )\n\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\tvar ndu = [];\n\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\tvar left = zeroArr.slice( 0 );\n\t\tvar right = zeroArr.slice( 0 );\n\n\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\tvar saved = 0.0;\n\n\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\tsaved = lv * temp;\n\n\t\t\t}\n\n\t\t\tndu[ j ][ j ] = saved;\n\n\t\t}\n\n\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t}\n\n\t\tfor ( var r = 0; r <= p; ++ r ) {\n\n\t\t\tvar s1 = 0;\n\t\t\tvar s2 = 1;\n\n\t\t\tvar a = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i ) {\n\n\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t}\n\n\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\tvar d = 0.0;\n\t\t\t\tvar rk = r - k;\n\t\t\t\tvar pk = p - k;\n\n\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t}\n\n\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\tvar j = s1;\n\t\t\t\ts1 = s2;\n\t\t\t\ts2 = j;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar r = p;\n\n\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t}\n\n\t\t\tr *= p - k;\n\n\t\t}\n\n\t\treturn ders;\n\n\t},\n\n\n\t/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\tcalcBSplineDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar du = nd < p ? nd : p;\n\t\tvar CK = [];\n\t\tvar span = this.findSpan( p, u, U );\n\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\tvar Pw = [];\n\n\t\tfor ( var i = 0; i < P.length; ++ i ) {\n\n\t\t\tvar point = P[ i ].clone();\n\t\t\tvar w = point.w;\n\n\t\t\tpoint.x *= w;\n\t\t\tpoint.y *= w;\n\t\t\tpoint.z *= w;\n\n\t\t\tPw[ i ] = point;\n\n\t\t}\n\n\t\tfor ( var k = 0; k <= du; ++ k ) {\n\n\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = point;\n\n\t\t}\n\n\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\tCK[ k ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\tcalcKoverI: function ( k, i ) {\n\n\t\tvar nom = 1;\n\n\t\tfor ( var j = 2; j <= k; ++ j ) {\n\n\t\t\tnom *= j;\n\n\t\t}\n\n\t\tvar denom = 1;\n\n\t\tfor ( var j = 2; j <= i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\tfor ( var j = 2; j <= k - i; ++ j ) {\n\n\t\t\tdenom *= j;\n\n\t\t}\n\n\t\treturn nom / denom;\n\n\t},\n\n\n\t/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\tcalcRationalCurveDerivatives: function ( Pders ) {\n\n\t\tvar nd = Pders.length;\n\t\tvar Aders = [];\n\t\tvar wders = [];\n\n\t\tfor ( var i = 0; i < nd; ++ i ) {\n\n\t\t\tvar point = Pders[ i ];\n\t\t\tAders[ i ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V( point.x, point.y, point.z );\n\t\t\twders[ i ] = point.w;\n\n\t\t}\n\n\t\tvar CK = [];\n\n\t\tfor ( var k = 0; k < nd; ++ k ) {\n\n\t\t\tvar v = Aders[ k ].clone();\n\n\t\t\tfor ( var i = 1; i <= k; ++ i ) {\n\n\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t}\n\n\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t}\n\n\t\treturn CK;\n\n\t},\n\n\n\t/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\tcalcNURBSDerivatives: function ( p, U, P, u, nd ) {\n\n\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t},\n\n\n\t/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\n\n\t\tvar uspan = this.findSpan( p, u, U );\n\t\tvar vspan = this.findSpan( q, v, V );\n\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\tvar temp = [];\n\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\ttemp[ l ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\t\tfor ( var k = 0; k <= p; ++ k ) {\n\n\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\tvar w = point.w;\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar Sw = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw( 0, 0, 0, 0 );\n\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t}\n\n\t\tSw.divideScalar( Sw.w );\n\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t}\n\n};\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nvar NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ax.call( this );\n\n\tthis.degree = degree;\n\tthis.knots = knots;\n\tthis.controlPoints = [];\n\t// Used by periodic NURBS to remove hidden spans\n\tthis.startKnot = startKnot || 0;\n\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t// ensure Vector4 for control points\n\t\tvar point = controlPoints[ i ];\n\t\tthis.controlPoints[ i ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw( point.x, point.y, point.z, point.w );\n\n\t}\n\n};\n\n\nNURBSCurve.prototype = Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ax.prototype );\nNURBSCurve.prototype.constructor = NURBSCurve;\n\n\nNURBSCurve.prototype.getPoint = function ( t, optionalTarget ) {\n\n\tvar point = optionalTarget || new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t// following results in (wx, wy, wz, w) homogeneous point\n\tvar hpoint = NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\tif ( hpoint.w != 1.0 ) {\n\n\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\thpoint.divideScalar( hpoint.w );\n\n\t}\n\n\treturn point.set( hpoint.x, hpoint.y, hpoint.z );\n\n};\n\n\nNURBSCurve.prototype.getTangent = function ( t, optionalTarget ) {\n\n\tvar tangent = optionalTarget || new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\tvar ders = NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\ttangent.copy( ders[ 1 ] ).normalize();\n\n\treturn tangent;\n\n};\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\nvar FBXLoader = ( function () {\n\n\tvar fbxTree;\n\tvar connections;\n\tvar sceneGraph;\n\n\tfunction FBXLoader( manager ) {\n\n\t\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t}\n\n\tFBXLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\t\tconstructor: FBXLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setRequestHeader( scope.requestHeader );\n\t\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( FBXBuffer, path ) {\n\n\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t}\n\n\t\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t\t}\n\n\t\t\t// console.log( fbxTree );\n\n\t\t\tvar textureLoader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.j( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t\t}\n\n\t} );\n\n\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\n\tfunction FBXTreeParser( textureLoader, manager ) {\n\n\t\tthis.textureLoader = textureLoader;\n\t\tthis.manager = manager;\n\n\t}\n\n\tFBXTreeParser.prototype = {\n\n\t\tconstructor: FBXTreeParser,\n\n\t\tparse: function () {\n\n\t\t\tconnections = this.parseConnections();\n\n\t\t\tvar images = this.parseImages();\n\t\t\tvar textures = this.parseTextures( images );\n\t\t\tvar materials = this.parseMaterials( textures );\n\t\t\tvar deformers = this.parseDeformers();\n\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\n\n\t\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\t\treturn sceneGraph;\n\n\t\t},\n\n\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t// and details the connection type\n\t\tparseConnections: function () {\n\n\t\t\tvar connectionMap = new Map();\n\n\t\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn connectionMap;\n\n\t\t},\n\n\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t// via FBXTree.Connections.\n\t\tparseImages: function () {\n\n\t\t\tvar images = {};\n\t\t\tvar blobs = {};\n\n\t\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\t\tvar image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var id in images ) {\n\n\t\t\t\tvar filename = images[ id ];\n\n\t\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t\t}\n\n\t\t\treturn images;\n\n\t\t},\n\n\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\tparseImage: function ( videoNode ) {\n\n\t\t\tvar content = videoNode.Content;\n\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\t\tvar type;\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'bmp':\n\n\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'jpg':\n\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'png':\n\n\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tif':\n\n\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tga':\n\n\t\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t\t} else { // Binary Format\n\n\t\t\t\tvar array = new Uint8Array( content );\n\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t// to images in FBXTree.Objects.Video\n\t\tparseTextures: function ( images ) {\n\n\t\t\tvar textureMap = new Map();\n\n\t\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\t\tvar texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn textureMap;\n\n\t\t},\n\n\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\tparseTexture: function ( textureNode, images ) {\n\n\t\t\tvar texture = this.loadTexture( textureNode, images );\n\n\t\t\ttexture.ID = textureNode.id;\n\n\t\t\ttexture.name = textureNode.attrName;\n\n\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\ttexture.wrapS = valueU === 0 ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\t\t\ttexture.wrapT = valueV === 0 ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.o : _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a5;\n\n\t\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t\t}\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\t\tloadTexture: function ( textureNode, images ) {\n\n\t\t\tvar fileName;\n\n\t\t\tvar currentPath = this.textureLoader.path;\n\n\t\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar texture;\n\n\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\t\tif ( extension === 'tga' ) {\n\n\t\t\t\tvar loader = this.manager.getHandler( '.tga' );\n\n\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\ttexture = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t\t}\n\n\t\t\t} else if ( extension === 'psd' ) {\n\n\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\ttexture = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ah();\n\n\t\t\t} else {\n\n\t\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t\t}\n\n\t\t\tthis.textureLoader.setPath( currentPath );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Material\n\t\tparseMaterials: function ( textureMap ) {\n\n\t\t\tvar materialMap = new Map();\n\n\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materialMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Material\n\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\tparseMaterial: function ( materialNode, textureMap ) {\n\n\t\t\tvar ID = materialNode.id;\n\t\t\tvar name = materialNode.attrName;\n\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\tif ( typeof type === 'object' ) {\n\n\t\t\t\ttype = type.value;\n\n\t\t\t}\n\n\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\t\tvar material;\n\n\t\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ak();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.setValues( parameters );\n\t\t\tmaterial.name = name;\n\n\t\t\treturn material;\n\n\t\t},\n\n\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t// Also parse the texture map and return any textures associated with the material\n\t\tparseParameters: function ( materialNode, textureMap, ID ) {\n\n\t\t\tvar parameters = {};\n\n\t\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Diffuse ) {\n\n\t\t\t\tparameters.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Diffuse.value );\n\n\t\t\t} else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\tparameters.color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.DiffuseColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Emissive ) {\n\n\t\t\t\tparameters.emissive = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Emissive.value );\n\n\t\t\t} else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {\n\n\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\tparameters.emissive = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.EmissiveColor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Opacity ) {\n\n\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t\t}\n\n\t\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\t\tparameters.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Shininess ) {\n\n\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t\t}\n\n\t\t\tif ( materialNode.Specular ) {\n\n\t\t\t\tparameters.specular = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.Specular.value );\n\n\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\tparameters.specular = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( materialNode.SpecularColor.value );\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\t\tvar type = child.relationship;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tparameters.bumpMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\tparameters.aoMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\tparameters.map = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.map.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\tparameters.displacementMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\tparameters.emissiveMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.emissiveMap.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\tparameters.normalMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\tparameters.envMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.envMap.mapping = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ay;\n\t\t\t\t\t\tparameters.envMap.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\tparameters.specularMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.specularMap.encoding = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.s;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tcase 'TransparencyFactor':\n\t\t\t\t\t\tparameters.alphaMap = scope.getTexture( textureMap, child.ID );\n\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn parameters;\n\n\t\t},\n\n\t\t// get a texture from the textureMap for use by a material.\n\t\tgetTexture: function ( textureMap, id ) {\n\n\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t\t}\n\n\t\t\treturn textureMap.get( id );\n\n\t\t},\n\n\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\tparseDeformers: function () {\n\n\t\t\tvar skeletons = {};\n\t\t\tvar morphTargets = {};\n\n\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\t\tvar skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\n\t\t\t\tskeletons: skeletons,\n\t\t\t\tmorphTargets: morphTargets,\n\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\tparseSkeleton: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawBones = [];\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\t\tvar rawBone = {\n\n\t\t\t\t\tID: child.ID,\n\t\t\t\t\tindices: [],\n\t\t\t\t\tweights: [],\n\t\t\t\t\ttransformLink: new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t\t// transform: new Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t};\n\n\t\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t\t}\n\n\t\t\t\trawBones.push( rawBone );\n\n\t\t\t} );\n\n\t\t\treturn {\n\n\t\t\t\trawBones: rawBones,\n\t\t\t\tbones: []\n\n\t\t\t};\n\n\t\t},\n\n\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\n\n\t\t\tvar rawMorphTargets = [];\n\n\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\t\tvar child = relationships.children[ i ];\n\n\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t};\n\n\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t\t}\n\n\t\t\treturn rawMorphTargets;\n\n\t\t},\n\n\t\t// create the main Group() to be returned by the loader\n\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\n\n\t\t\tsceneGraph = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\n\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tvar scope = this;\n\t\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\t\tscope.setLookAtProperties( model, modelNode );\n\n\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( model.parent === null ) {\n\n\t\t\t\t\tsceneGraph.add( model );\n\n\t\t\t\t}\n\n\n\t\t\t} );\n\n\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\t\tthis.createAmbientLight();\n\n\t\t\tthis.setupMorphMaterials();\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\t\tif ( node.parent ) {\n\n\t\t\t\t\t\tnode.userData.transformData.parentMatrix = node.parent.matrix;\n\t\t\t\t\t\tnode.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar transform = generateTransform( node.userData.transformData );\n\n\t\t\t\t\tnode.applyMatrix4( transform );\n\t\t\t\t\tnode.updateWorldMatrix();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t\t}\n\n\t\t\tsceneGraph.animations = animations;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.Model\n\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\n\t\t\tvar modelMap = new Map();\n\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\t\tvar id = parseInt( nodeID );\n\t\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\t\tvar relationships = connections.get( id );\n\n\t\t\t\tvar model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.G();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.name = node.attrName ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\t\tmodel.ID = id;\n\n\t\t\t\t}\n\n\t\t\t\tthis.getTransformData( model, node );\n\t\t\t\tmodelMap.set( id, model );\n\n\t\t\t}\n\n\t\t\treturn modelMap;\n\n\t\t},\n\n\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\n\n\t\t\tvar bone = null;\n\n\t\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\tbone = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.N();\n\n\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\t\tbone.name = name ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn bone;\n\n\t\t},\n\n\t\t// create a PerspectiveCamera or OrthographicCamera\n\t\tcreateCamera: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar cameraAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tcameraAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type = 0;\n\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\t\ttype = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t\t}\n\n\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t\t}\n\n\n\t\t\t\tvar width = window.innerWidth;\n\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar aspect = width / height;\n\n\t\t\t\tvar fov = 45;\n\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Perspective\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.A( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.O( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\t// Create a DirectionalLight, PointLight or SpotLight\n\t\tcreateLight: function ( relationships ) {\n\n\t\t\tvar model;\n\t\t\tvar lightAttribute;\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\tlightAttribute = attr;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( lightAttribute === undefined ) {\n\n\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U();\n\n\t\t\t} else {\n\n\t\t\t\tvar type;\n\n\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\t\ttype = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t\t}\n\n\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\t\tcolor = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C().fromArray( lightAttribute.Color.value );\n\n\t\t\t\t}\n\n\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t// light disabled\n\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\t\tintensity = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar distance = 0;\n\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\t\tdistance = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\tvar decay = 1;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 0: // Point\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity, distance, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1: // Directional\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__._( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2: // Spot\n\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\t\tangle = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\tpenumbra = _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Y( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );\n\t\t\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Z( color, intensity );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\t\tmodel.castShadow = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\n\n\t\t\tvar model;\n\t\t\tvar geometry = null;\n\t\t\tvar material = null;\n\t\t\tvar materials = [];\n\n\t\t\t// get geometry and materials(s) from connections\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( materials.length > 1 ) {\n\n\t\t\t\tmaterial = materials;\n\n\t\t\t} else if ( materials.length > 0 ) {\n\n\t\t\t\tmaterial = materials[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.al( { color: 0xcccccc } );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t} );\n\n\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.t( geometry, material );\n\t\t\t\tmodel.normalizeSkinWeights();\n\n\t\t\t} else {\n\n\t\t\t\tmodel = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.v( geometry, material );\n\n\t\t\t}\n\n\t\t\treturn model;\n\n\t\t},\n\n\t\tcreateCurve: function ( relationships, geometryMap ) {\n\n\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\t\treturn geo;\n\n\t\t\t}, null );\n\n\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\tvar material = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.q( { color: 0x3300ff, linewidth: 1 } );\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.x( geometry, material );\n\n\t\t},\n\n\t\t// parse the model node for transform data\n\t\tgetTransformData: function ( model, modelNode ) {\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\tmodel.userData.transformData = transformData;\n\n\t\t},\n\n\t\tsetLookAtProperties: function ( model, modelNode ) {\n\n\t\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\tmodel.lookAt( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V().fromArray( pos ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\n\n\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\t\tmodel.bind( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.X( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparsePoseNodes: function () {\n\n\t\t\tvar bindMatrices = {};\n\n\t\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bindMatrices;\n\n\t\t},\n\n\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\tcreateAmbientLight: function () {\n\n\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\tvar r = ambientColor[ 0 ];\n\t\t\t\tvar g = ambientColor[ 1 ];\n\t\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\tvar color = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.C( r, g, b );\n\t\t\t\t\tsceneGraph.add( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.am( color, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetupMorphMaterials: function () {\n\n\t\t\tvar scope = this;\n\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\t\tscope.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscope.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t},\n\n\t\tsetupMorphMaterial: function ( child, material, index ) {\n\n\t\t\tvar uuid = child.uuid;\n\t\t\tvar matUuid = material.uuid;\n\n\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\tvar sharedMat = false;\n\n\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\tif ( node.isMesh ) {\n\n\t\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tif ( sharedMat === true ) {\n\n\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t\t} else material.morphTargets = true;\n\n\t\t}\n\n\t};\n\n\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\tfunction GeometryParser() {}\n\n\tGeometryParser.prototype = {\n\n\t\tconstructor: GeometryParser,\n\n\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\tparse: function ( deformers ) {\n\n\t\t\tvar geometryMap = new Map();\n\n\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\t\tvar geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometryMap;\n\n\t\t},\n\n\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tswitch ( geoNode.attrType ) {\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\n\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\tvar skeletons = deformers.skeletons;\n\t\t\tvar morphTargets = [];\n\n\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t\t} );\n\n\t\t\t// don't create geometry if it is not associated with any models\n\t\t\tif ( modelNodes.length === 0 ) return;\n\n\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\t\treturn skeleton;\n\n\t\t\t}, null );\n\n\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\t// Assume one model and get the preRotation from that\n\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\t\tvar transformData = {};\n\n\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\tvar transform = generateTransform( transformData );\n\n\t\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t\t},\n\n\t\t// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\tgenGeometry: function ( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\t\tvar geo = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\t\tvar buffers = this.genBuffers( geoInfo );\n\n\t\t\tvar positionAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertex, 3 );\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\t\tgeo.setAttribute( 'color', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tgeo.setAttribute( 'skinIndex', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.az( buffers.weightsIndices, 4 ) );\n\n\t\t\t\tgeo.setAttribute( 'skinWeight', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.vertexWeights, 4 ) );\n\n\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t\t}\n\n\t\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\t\tvar normalMatrix = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA().getNormalMatrix( preTransform );\n\n\t\t\t\tvar normalAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.normal, 3 );\n\t\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t\t}\n\n\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tname = 'uv';\n\n\t\t\t\t}\n\n\t\t\t\tgeo.setAttribute( name, new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( buffers.uvs[ i ], 2 ) );\n\n\t\t\t} );\n\n\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\t\tvar startIndex = 0;\n\n\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t// using one of them\n\t\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\t\treturn geo;\n\n\t\t},\n\n\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\n\t\t\tvar geoInfo = {};\n\n\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t\t}\n\n\t\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\tvar i = 0;\n\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\t\tif ( geoNode.LayerElementUV[ i ].UV ) {\n\n\t\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeoInfo.weightTable = {};\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn geoInfo;\n\n\t\t},\n\n\t\tgenBuffers: function ( geoInfo ) {\n\n\t\t\tvar buffers = {\n\t\t\t\tvertex: [],\n\t\t\t\tnormal: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tmaterialIndex: [],\n\t\t\t\tvertexWeights: [],\n\t\t\t\tweightsIndices: [],\n\t\t\t};\n\n\t\t\tvar polygonIndex = 0;\n\t\t\tvar faceLength = 0;\n\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t// these will hold data for a single face\n\t\t\tvar facePositionIndexes = [];\n\t\t\tvar faceNormals = [];\n\t\t\tvar faceColors = [];\n\t\t\tvar faceUVs = [];\n\t\t\tvar faceWeights = [];\n\t\t\tvar faceWeightIndices = [];\n\n\t\t\tvar scope = this;\n\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t//  }\n\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\tendOfFace = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar weightIndices = [];\n\t\t\t\tvar weights = [];\n\n\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\tweights = Weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tfaceLength ++;\n\n\t\t\t\tif ( endOfFace ) {\n\n\t\t\t\t\tscope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\t\tpolygonIndex ++;\n\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\tfaceColors = [];\n\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn buffers;\n\n\t\t},\n\n\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\t\tif ( morphTargets.length === 0 ) return;\n\n\t\t\tparentGeo.morphTargetsRelative = true;\n\n\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\tvar scope = this;\n\t\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\t\tscope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t},\n\n\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\tvar morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\t\tvar length = parentGeo.attributes.position.count * 3;\n\t\t\tvar morphPositions = new Float32Array( length );\n\n\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t\t}\n\n\t\t\t// TODO: add morph normal support\n\t\t\tvar morphGeoInfo = {\n\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\tvertexPositions: morphPositions,\n\n\t\t\t};\n\n\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\t\tvar positionAttribute = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( morphBuffers.vertex, 3 );\n\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t\t},\n\n\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\tparseNormals: function ( NormalNode ) {\n\n\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 3,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\tparseUVs: function ( UVNode ) {\n\n\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\tvar buffer = UVNode.UV.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 2,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\tparseVertexColors: function ( ColorNode ) {\n\n\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\tvar indexBuffer = [];\n\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 4,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tindices: indexBuffer,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\tparseMaterialIndices: function ( MaterialNode ) {\n\n\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 1,\n\t\t\t\t\tbuffer: [ 0 ],\n\t\t\t\t\tindices: [ 0 ],\n\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\tvar materialIndices = [];\n\n\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\t\tmaterialIndices.push( i );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\tindices: materialIndices,\n\t\t\t\tmappingType: mappingType,\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\n\t\t},\n\n\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\tparseNurbsGeometry: function ( geoNode ) {\n\n\t\t\tif ( NURBSCurve === undefined ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar order = parseInt( geoNode.Order );\n\n\t\t\tif ( isNaN( order ) ) {\n\n\t\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\n\t\t\t}\n\n\t\t\tvar degree = order - 1;\n\n\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\tvar controlPoints = [];\n\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\t\tcontrolPoints.push( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aw().fromArray( pointsValues, i ) );\n\n\t\t\t}\n\n\t\t\tvar startKnot, endKnot;\n\n\t\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\t\tstartKnot = degree;\n\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t} );\n\n\t\t\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\t\t\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.c( positions, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t};\n\n\t// parse animation data from FBXTree\n\tfunction AnimationParser() {}\n\n\tAnimationParser.prototype = {\n\n\t\tconstructor: AnimationParser,\n\n\t\t// take raw animation clips and turn them into three.js animation clips\n\t\tparse: function () {\n\n\t\t\tvar animationClips = [];\n\n\t\t\tvar rawClips = this.parseClips();\n\n\t\t\tif ( rawClips !== undefined ) {\n\n\t\t\t\tfor ( var key in rawClips ) {\n\n\t\t\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\t\t\tvar clip = this.addClip( rawClip );\n\n\t\t\t\t\tanimationClips.push( clip );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn animationClips;\n\n\t\t},\n\n\t\tparseClips: function () {\n\n\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t// and is referenced by an AnimationLayer\n\t\tparseAnimationCurveNodes: function () {\n\n\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\tvar curveNodesMap = new Map();\n\n\t\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\tcurves: {},\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn curveNodesMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t// axis ( e.g. times and values of x rotation)\n\t\tparseAnimationCurves: function ( curveNodesMap ) {\n\n\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t// clearly, this should be optimised to\n\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t\t};\n\n\t\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\n\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\tvar layersMap = new Map();\n\n\t\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\t\tif ( rawModel === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.r.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn layersMap;\n\n\t\t},\n\n\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t// hierarchy. Each Stack node will be used to create a AnimationClip\n\t\tparseAnimStacks: function ( layersMap ) {\n\n\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t// connect the stacks (clips) up to the layers\n\t\t\tvar rawClips = {};\n\n\t\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\t\tlayer: layer,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn rawClips;\n\n\t\t},\n\n\t\taddClip: function ( rawClip ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar scope = this;\n\t\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\t\ttracks = tracks.concat( scope.generateTracks( rawTracks ) );\n\n\t\t\t} );\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.K( rawClip.name, - 1, tracks );\n\n\t\t},\n\n\t\tgenerateTracks: function ( rawTracks ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar initialPosition = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\t\t\tvar initialRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar initialScale = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\tinitialRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t\t}\n\n\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t},\n\n\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ac( modelName + '.' + type, times, values );\n\n\t\t},\n\n\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\t\tif ( curves.x !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.x );\n\t\t\t\tcurves.x.values = curves.x.values.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.y !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.y );\n\t\t\t\tcurves.y.values = curves.y.values.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tif ( curves.z !== undefined ) {\n\n\t\t\t\tthis.interpolateRotations( curves.z );\n\t\t\t\tcurves.z.values = curves.z.values.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\n\t\t\t}\n\n\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\tif ( preRotation !== undefined ) {\n\n\t\t\t\tpreRotation = preRotation.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\t\tpreRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( preRotation );\n\t\t\t\tpreRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( preRotation );\n\n\t\t\t}\n\n\t\t\tif ( postRotation !== undefined ) {\n\n\t\t\t\tpostRotation = postRotation.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\t\tpostRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj().fromArray( postRotation );\n\t\t\t\tpostRotation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q().setFromEuler( postRotation ).invert();\n\n\t\t\t}\n\n\t\t\tvar quaternion = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.Q();\n\t\t\tvar euler = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\n\t\t\tvar quaternionValues = [];\n\n\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t\t}\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ad( modelName + '.quaternion', times, quaternionValues );\n\n\t\t},\n\n\t\tgenerateMorphTrack: function ( rawTracks ) {\n\n\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\tvar values = curves.values.map( function ( val ) {\n\n\t\t\t\treturn val / 100;\n\n\t\t\t} );\n\n\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\t\treturn new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.ae( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t\t},\n\n\t\t// For all animated objects, times are defined separately for each axis\n\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\tgetTimesForAllAxes: function ( curves ) {\n\n\t\t\tvar times = [];\n\n\t\t\t// first join together the times for each axis, if defined\n\t\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t\t// then sort them\n\t\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\t\treturn a - b;\n\n\t\t\t} );\n\n\t\t\t// and remove duplicates\n\t\t\tif ( times.length > 1 ) {\n\n\t\t\t\tvar targetIndex = 1;\n\t\t\t\tvar lastValue = times[ 0 ];\n\t\t\t\tfor ( var i = 1; i < times.length; i ++ ) {\n\n\t\t\t\t\tvar currentValue = times[ i ];\n\t\t\t\t\tif ( currentValue !== lastValue ) {\n\n\t\t\t\t\t\ttimes[ targetIndex ] = currentValue;\n\t\t\t\t\t\tlastValue = currentValue;\n\t\t\t\t\t\ttargetIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttimes = times.slice( 0, targetIndex );\n\n\t\t\t}\n\n\t\t\treturn times;\n\n\t\t},\n\n\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\n\n\t\t\tvar prevValue = initialValue;\n\n\t\t\tvar values = [];\n\n\t\t\tvar xIndex = - 1;\n\t\t\tvar yIndex = - 1;\n\t\t\tvar zIndex = - 1;\n\n\t\t\ttimes.forEach( function ( time ) {\n\n\t\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\t\tvalues.push( xValue );\n\t\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\t\tvalues.push( yValue );\n\t\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\t\tvalues.push( zValue );\n\t\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn values;\n\n\t\t},\n\n\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t// These will be converted to quaternions which don't support values greater than\n\t\t// PI, so we'll interpolate large rotations\n\t\tinterpolateRotations: function ( curve ) {\n\n\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\t\tnextValue += step;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t};\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tTextParser.prototype = {\n\n\t\tconstructor: TextParser,\n\n\t\tgetPrevNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t},\n\n\t\tgetCurrentNode: function () {\n\n\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t},\n\n\t\tgetCurrentProp: function () {\n\n\t\t\treturn this.currentProp;\n\n\t\t},\n\n\t\tpushStack: function ( node ) {\n\n\t\t\tthis.nodeStack.push( node );\n\t\t\tthis.currentIndent += 1;\n\n\t\t},\n\n\t\tpopStack: function () {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\n\t\t},\n\n\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tthis.currentIndent = 0;\n\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar scope = this;\n\n\t\t\tvar split = text.split( /[\\r\\n]+/ );\n\n\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( scope.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( scope.currentIndent - 1 ) + '}}' );\n\n\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\tscope.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\tscope.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\tscope.popStack();\n\n\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tscope.parseNodePropertyContinued( line );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.allNodes;\n\n\t\t},\n\n\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t} );\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t} else { // a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\tthis.pushStack( node );\n\n\t\t},\n\n\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\tvar id = attrs[ 0 ];\n\n\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = '', type = '';\n\n\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\n\t\t},\n\n\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [ from, to ];\n\t\t\t\tappend( propValue, rest );\n\n\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t} else {\n\n\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t}\n\n\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t} );\n\n\t\t\tvar innerPropName = props[ 0 ];\n\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t},\n\n\t};\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tBinaryParser.prototype = {\n\n\t\tconstructor: BinaryParser,\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tif ( version < 6400 ) {\n\n\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version );\n\n\t\t\t}\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t}\n\n\t\t\treturn allNodes;\n\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function ( reader ) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t}\n\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function ( reader, version ) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\treturn node;\n\n\t\t},\n\n\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t}\n\n\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push( array );\n\n\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t} );\n\n\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseProperty: function ( reader ) {\n\n\t\t\tvar type = reader.getString( 1 );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( typeof fflate === 'undefined' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library fflate.min.js required.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = Jr( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader( data.buffer );\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t}\n\n\tBinaryReader.prototype = {\n\n\t\tconstructor: BinaryReader,\n\n\t\tgetOffset: function () {\n\n\t\t\treturn this.offset;\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function () {\n\n\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t},\n\n\t\tgetBooleanArray: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt16: function () {\n\n\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetInt64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( a ) );\n\n\t\t}\n\n\t};\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tFBXTree.prototype = {\n\n\t\tconstructor: FBXTree,\n\n\t\tadd: function ( key, val ) {\n\n\t\t\tthis[ key ] = val;\n\n\t\t},\n\n\t};\n\n\t// ************** UTILITY FUNCTIONS **************\n\n\tfunction isFbxFormatBinary( buffer ) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t}\n\n\tfunction isFbxFormatASCII( text ) {\n\n\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read( offset ) {\n\n\t\t\tvar result = text[ offset - 1 ];\n\t\t\ttext = text.slice( cursor + offset );\n\t\t\tcursor ++;\n\t\t\treturn result;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\tvar num = read( 1 );\n\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getFbxVersion( text ) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match( versionRegExp );\n\n\t\tif ( match ) {\n\n\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\treturn version;\n\n\t\t}\n\n\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\treturn time / 46186158000;\n\n\t}\n\n\tvar dataArray = [];\n\n\t// extracts the data from the correct position in the FBX array based on indexing type\n\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\tvar index;\n\n\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon' :\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice' :\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame' :\n\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t}\n\n\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t}\n\n\tvar tempEuler = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aj();\n\tvar tempVec = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t// generate transformation from FBX transform data\n\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\tfunction generateTransform( transformData ) {\n\n\t\tvar lTranslationM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPreRotationM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lPostRotationM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lScalingM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingPivotM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lScalingOffsetM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationOffsetM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lRotationPivotM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar lParentGX = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentLX = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lGlobalT = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tvar inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\t\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t\tif ( transformData.preRotation ) {\n\n\t\t\tvar array = transformData.preRotation.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.rotation ) {\n\n\t\t\tvar array = transformData.rotation.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t}\n\n\t\tif ( transformData.postRotation ) {\n\n\t\t\tvar array = transformData.postRotation.map( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.H.degToRad );\n\t\t\tarray.push( transformData.eulerOrder );\n\t\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\t\t\tlPostRotationM.invert();\n\n\t\t}\n\n\t\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t\t// Pivots and offsets\n\t\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\t\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\t\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\t\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t\t// parent transform\n\t\tif ( transformData.parentMatrixWorld ) {\n\n\t\t\tlParentLX.copy( transformData.parentMatrix );\n\t\t\tlParentGX.copy( transformData.parentMatrixWorld );\n\n\t\t}\n\n\t\tvar lLRM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM );\n\t\t// Global Rotation\n\t\tvar lParentGRM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentGRM.extractRotation( lParentGX );\n\n\t\t// Global Shear*Scaling\n\t\tvar lParentTM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlParentTM.copyPosition( lParentGX );\n\n\t\tvar lParentGSM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tvar lParentGRSM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentTM ).invert().multiply( lParentGX );\n\t\tlParentGSM.copy( lParentGRM ).invert().multiply( lParentGRSM );\n\t\tvar lLSM = lScalingM;\n\n\t\tvar lGlobalRS = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\n\t\tif ( inheritType === 0 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t\t} else if ( inheritType === 1 ) {\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t\t} else {\n\n\t\t\tvar lParentLSM = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().scale( new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V().setFromMatrixScale( lParentLX ) );\n\t\t\tvar lParentLSM_inv = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentLSM ).invert();\n\t\t\tvar lParentGSM_noLocal = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGSM ).multiply( lParentLSM_inv );\n\n\t\t\tlGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t\t}\n\n\t\tvar lRotationPivotM_inv = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlRotationPivotM_inv.copy( lRotationPivotM ).invert();\n\t\tvar lScalingPivotM_inv = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlScalingPivotM_inv.copy( lScalingPivotM ).invert();\n\t\t// Calculate the local transform matrix\n\t\tvar lTransform = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W();\n\t\tlTransform.copy( lTranslationM ).multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );\n\n\t\tvar lLocalTWithAllPivotAndOffsetInfo = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copyPosition( lTransform );\n\n\t\tvar lGlobalTranslation = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lParentGX ).multiply( lLocalTWithAllPivotAndOffsetInfo );\n\t\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\t\tlTransform = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.W().copy( lGlobalT ).multiply( lGlobalRS );\n\n\t\t// from global to local\n\t\tlTransform.premultiply( lParentGX.invert() );\n\n\t\treturn lTransform;\n\n\t}\n\n\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\tfunction getEulerOrder( order ) {\n\n\t\torder = order || 0;\n\n\t\tvar enums = [\n\t\t\t'ZYX', // -> XYZ extrinsic\n\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t'XYZ', // -> ZYX extrinsic\n\t\t\t//'SphericXYZ', // not possible to support\n\t\t];\n\n\t\tif ( order === 6 ) {\n\n\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\t\treturn enums[ 0 ];\n\n\t\t}\n\n\t\treturn enums[ order ];\n\n\t}\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray( value ) {\n\n\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\treturn parseFloat( val );\n\n\t\t} );\n\n\t\treturn array;\n\n\t}\n\n\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\tif ( from === undefined ) from = 0;\n\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\treturn _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.f.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t}\n\n\tfunction append( a, b ) {\n\n\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t}\n\n\tfunction slice( a, b, from, to ) {\n\n\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\ta[ j ] = b[ i ];\n\n\t\t}\n\n\t\treturn a;\n\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject( a1, index, a2 ) {\n\n\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t}\n\n\treturn FBXLoader;\n\n} )();\n\nvar SVGLoader = function ( manager ) {\n\n\t_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = 'px';\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.L.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.F( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar traverseChildNodes = true;\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\ttraverseChildNodes = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tvar usedNodeId = node.href.baseVal.substring( 1 );\n\t\t\t\t\tvar usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tif ( traverseChildNodes ) {\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar point = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar control = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\t\t\tvar firstPoint = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tvar selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aC();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aB();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tvar stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tvar RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i\n\t\t\t};\n\n\t\t\t// States\n\t\t\tvar SEP = 0;\n\t\t\tvar INT = 1;\n\t\t\tvar FLOAT = 2;\n\t\t\tvar EXP = 3;\n\n\t\t\tvar state = SEP;\n\t\t\tvar seenComma = true;\n\t\t\tvar result = [], number = '', exponent = '';\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tvar error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tvar current, i = 0, length = input.length;\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state == EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\t\tvar currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tvar tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tvar ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\t\tvar stylesheets = {};\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform1 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform2 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempTransform3 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\t\tvar tempV2 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\t\tvar tempV3 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.V();\n\n\t\tvar currentTransform = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aA();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.B();\n\tgeometry.setAttribute( 'position', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.d( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_2 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_3 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_4 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_5 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_6 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar tempV2_7 = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointL = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar lastPointR = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0L = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar point0R = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointL = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar currentPointR = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointL = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar nextPointR = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar innerPoint = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\tvar outerPoint = new _index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.a();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\n_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.U.DefaultUp.set(0, 0, 1);\nvar defaultColor = 'hotpink';\nvar traverseChildren = function (child, opacity, shadow) {\n    // console.log(child.uuid)\n    if (child.isMesh) {\n        console.log(child.material);\n        if (child.material.type === 'Array') {\n            child.material.forEach(function (mat) {\n                mat = mat.clone();\n            });\n        }\n        else {\n            child.material = child.material.clone();\n        }\n        child.material = child.material.clone();\n        if (shadow) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n        }\n        // console.log(child.material.uuid)\n        if (opacity !== 1.0) {\n            if (child.material.isMaterial) {\n                child.material.transparent = true;\n                child.material.opacity = opacity;\n            }\n            else if (Array.isArray(child.material)) {\n                child.material.forEach(function (mat) {\n                    mat.transparent = true;\n                    mat.opacity = opacity;\n                });\n            }\n        }\n    }\n    else if (child.type === 'PointLight') {\n        child.visible = false;\n    }\n    else if (child.isObject3D || child.isGroup) {\n        child.children.forEach(function (child2) {\n            traverseChildren(child2, opacity, shadow);\n        });\n    }\n};\nvar STLAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(STLLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.clone(); }, [model]);\n    // console.log('Loading: ')\n    // console.log(props)\n    // useEffect(() => {\n    //     // scene.children.forEach((child) => {\n    //     //     traverseChildren(child, props.opacity, true)\n    //     // })\n    //     scene.name = 'loaded'\n    // })\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true, name: 'loaded' },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar GLTFAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(GLTFLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model.scene, opacity: props.opacity, castShadow: true, receiveShadow: true })));\n};\nvar ColladaAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ColladaLoader, props.url);\n    var scene = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () { return model.scene.clone(true); }, [model.scene]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        scene.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n        scene.name = 'loaded';\n    }, [scene]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: scene, position: props.t, scale: props.scale, quaternion: props.q }));\n};\nvar OBJAsset = function (props) {\n    var mtlurl = props.url.slice(0, props.url.length - 3) + 'mtl';\n    var materials = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(MTLLoader, mtlurl);\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(OBJLoader, props.url, function (loader) {\n        materials.preload();\n        // loader.setMaterials(materials)\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar VRMLAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(VRMLLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PCDAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PCDLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        // model.material.color = props.color\n        //     ? new THREE.Color(props.color)\n        //     : new THREE.Color(defaultColor)\n        // model.material.transparent = props.opacity !== 1.0 ? true : false\n        // model.material.opacity = props.opacity ? props.opacity : 1.0\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar PLYAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(PLYLoader, props.url);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model, attach: \"geometry\" }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshStandardMaterial\", { color: props.color ? props.color : defaultColor, transparent: props.opacity !== 1.0 ? true : false, opacity: props.opacity ? props.opacity : 1.0 })));\n};\nvar FBXAsset = function (props) {\n    var model = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(FBXLoader, props.url);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        model.children.forEach(function (child) {\n            traverseChildren(child, props.opacity, true);\n        });\n    });\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", { position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]], scale: [props.scale[0], props.scale[1], props.scale[2]], castShadow: true, receiveShadow: true },\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", { object: model })));\n};\nvar SVGShape = function (_a) {\n    var shape = _a.shape, color = _a.color, index = _a.index, opacity = _a.opacity;\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", null,\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshLambertMaterial\", { attach: \"material\", color: color, polygonOffset: true, polygonOffsetFactor: index * -0.1, transparent: opacity !== 1.0 ? true : false, opacity: opacity ? opacity : 1.0 }),\n        react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"shapeBufferGeometry\", { attach: \"geometry\", args: [shape] })));\n};\nvar SVGAsset = react__WEBPACK_IMPORTED_MODULE_1__.memo(function (props) {\n    var paths = (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aD)(SVGLoader, props.url).paths;\n    var shapes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return paths.flatMap(function (path, index) {\n            return path\n                .toShapes(true)\n                .map(function (shape) { return ({ index: index, shape: shape, color: path.color }); });\n        });\n    }, [paths]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", { children: shapes.map(function (newProps, key) { return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGShape, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ key: key, opacity: props.opacity }, newProps))); }), scale: [\n            -0.01 * props.scale[0],\n            0.01 * props.scale[1],\n            0.01 * props.scale[2],\n        ], position: [props.t[0], props.t[1], props.t[2]], quaternion: [props.q[0], props.q[1], props.q[2], props.q[3]] }));\n});\nvar Loader = function (props) {\n    var ext = props.filename.split('.').pop().toLowerCase();\n    var url = props.filename;\n    url = \"retrieve/\" + url;\n    switch (ext) {\n        case 'stl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(STLAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'gltf':\n        case 'glb':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(GLTFAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'dae':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'obj':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(OBJAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'wrl':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(VRMLAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'pcd':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PCDAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'ply':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(PLYAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'fbx':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(FBXAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        case 'svg':\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(SVGAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n        default:\n            return react__WEBPACK_IMPORTED_MODULE_1__.createElement(ColladaAsset, (0,_index_33fa60bf_js__WEBPACK_IMPORTED_MODULE_0__.aE)({ url: url }, props));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\n//# sourceMappingURL=Loader-2b9cd294.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3JlYWN0LXN3aWZ0L2Rpc3QvTG9hZGVyLTJiOWNkMjk0LmpzPzMyYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUF3ekQ7QUFDN3ZEO0FBQ3hDOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4Q0FBOEM7QUFDNUYsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsQ0FBQyxzREFBYTs7QUFFZDs7QUFFQSxvREFBb0QsMkRBQWtCOztBQUV0RTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsNERBQXNCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7O0FBRWxDLHNCQUFzQixhQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBLGNBQWMsaURBQWE7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLE9BQU87O0FBRXpDLGlDQUFpQztBQUNqQzs7QUFFQSxnQkFBZ0IsZ0JBQWdCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHVDQUF1Qzs7QUFFbEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixpREFBTzs7QUFFbEMsSUFBSTs7QUFFSiwyQkFBMkIsaURBQU87O0FBRWxDOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDtBQUNBLDBCQUEwQixpREFBTzs7QUFFakMsd0JBQXdCLHVDQUF1Qzs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztBQUVyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxPQUFPOztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxTQUFTOztBQUV6RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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LHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBLDRCQUE0QixpREFBUTs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLGlEQUFLOztBQUUxQjs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztB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O0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFXOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFZOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixrREFBZ0I7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsa0RBQWM7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrREFBTzs7QUFFckIsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsUUFBUTs7QUFFMUI7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLFFBQVE7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7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LEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtGQUFrRjtBQUNsRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsd0RBQXdEO0FBQ3hEOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsNERBQXNCOztBQUVoQzs7QUFFQTs7QUFFQTtB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0NBQWdDOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCOztBQUU3QztBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixrREFBUzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrREFBSTtBQUN6Qjs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGtEQUFJO0FBQ3pCOztBQUVBLGtCQUFrQixrREFBUztBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0RBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixVQUFVOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLGtEQUFPO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELGFBQWE7O0FBRS9EOztBQUVB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixvQkFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7OztBQUdBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELCtEQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBLG1CQUFtQixnREFBNEIsWUFBWSxzREFBUSxFQUFFLFdBQVc7QUFDaEY7QUFDQSxtQkFBbUIsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxXQUFXO0FBQy9FO0FBQ0EsbUJBQW1CLGdEQUE0QixXQUFXLHNEQUFRLEVBQUUsV0FBVztBQUMvRTtBQUNBLG1CQUFtQixnREFBNEIsV0FBVyxzREFBUSxFQUFFLFdBQVc7QUFDL0U7QUFDQSxtQkFBbUIsZ0RBQTRCLFdBQVcsc0RBQVEsRUFBRSxXQUFXO0FBQy9FO0FBQ0EsbUJBQW1CLGdEQUE0QixlQUFlLHNEQUFRLEVBQUUsV0FBVztBQUNuRjtBQUNBOztBQUVBLCtEQUFlLE1BQU0sRUFBQztBQUN0QiIsImZpbGUiOiIuLi8uLi9yZWFjdC1zd2lmdC9kaXN0L0xvYWRlci0yYjljZDI5NC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEwgYXMgTG9hZGVyJDEsIEYgYXMgRmlsZUxvYWRlciwgQiBhcyBCdWZmZXJHZW9tZXRyeSwgYyBhcyBCdWZmZXJBdHRyaWJ1dGUsIFYgYXMgVmVjdG9yMywgZCBhcyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBmIGFzIExvYWRlclV0aWxzLCBnIGFzIE1lc2hCYXNpY01hdGVyaWFsLCBDIGFzIENvbG9yLCBoIGFzIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBpIGFzIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCwgSSBhcyBJbWFnZUJpdG1hcExvYWRlciwgaiBhcyBUZXh0dXJlTG9hZGVyLCBrIGFzIEludGVybGVhdmVkQnVmZmVyLCBsIGFzIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBSIGFzIFJHQkZvcm1hdCwgbSBhcyBMaW5lYXJGaWx0ZXIsIG4gYXMgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBvIGFzIFJlcGVhdFdyYXBwaW5nLCBQIGFzIFBvaW50c01hdGVyaWFsLCBwIGFzIE1hdGVyaWFsLCBxIGFzIExpbmVCYXNpY01hdGVyaWFsLCBEIGFzIERvdWJsZVNpZGUsIGEgYXMgVmVjdG9yMiwgcyBhcyBzUkdCRW5jb2RpbmcsIHIgYXMgUHJvcGVydHlCaW5kaW5nLCB0IGFzIFNraW5uZWRNZXNoLCB2IGFzIE1lc2gsIHcgYXMgTGluZVNlZ21lbnRzLCB4IGFzIExpbmUsIHkgYXMgTGluZUxvb3AsIHogYXMgUG9pbnRzLCBHIGFzIEdyb3VwLCBBIGFzIFBlcnNwZWN0aXZlQ2FtZXJhLCBIIGFzIE1hdGhVdGlscywgTyBhcyBPcnRob2dyYXBoaWNDYW1lcmEsIEogYXMgSW50ZXJwb2xhdGVMaW5lYXIsIEsgYXMgQW5pbWF0aW9uQ2xpcCwgTiBhcyBCb25lLCBVIGFzIE9iamVjdDNELCBXIGFzIE1hdHJpeDQsIFggYXMgU2tlbGV0b24sIFkgYXMgU3BvdExpZ2h0LCBaIGFzIFBvaW50TGlnaHQsIF8gYXMgRGlyZWN0aW9uYWxMaWdodCwgJCBhcyBNZXNoUGh5c2ljYWxNYXRlcmlhbCwgYTAgYXMgSW50ZXJwb2xhbnQsIGExIGFzIE5lYXJlc3RGaWx0ZXIsIGEyIGFzIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBhMyBhcyBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBhNCBhcyBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBhNSBhcyBDbGFtcFRvRWRnZVdyYXBwaW5nLCBhNiBhcyBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBhNyBhcyBJbnRlcnBvbGF0ZURpc2NyZXRlLCBhOCBhcyBGcm9udFNpZGUsIGE5IGFzIENhbnZhc1RleHR1cmUsIGFhIGFzIFRyaWFuZ2xlRmFuRHJhd01vZGUsIGFiIGFzIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgYWMgYXMgVmVjdG9yS2V5ZnJhbWVUcmFjaywgYWQgYXMgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGFlIGFzIE51bWJlcktleWZyYW1lVHJhY2ssIGFmIGFzIEJveDMsIGFnIGFzIFNwaGVyZSwgYWggYXMgVGV4dHVyZSwgUSBhcyBRdWF0ZXJuaW9uLCBhaSBhcyBTY2VuZSwgYWogYXMgRXVsZXIsIGFrIGFzIE1lc2hMYW1iZXJ0TWF0ZXJpYWwsIGFsIGFzIE1lc2hQaG9uZ01hdGVyaWFsLCBhbSBhcyBBbWJpZW50TGlnaHQsIGFuIGFzIERlZmF1bHRMb2FkaW5nTWFuYWdlciwgYW8gYXMgU3BoZXJlR2VvbWV0cnksIGFwIGFzIEJhY2tTaWRlLCBhcSBhcyBEYXRhVGV4dHVyZSwgYXIgYXMgUkdCQUZvcm1hdCwgYXMgYXMgQm94R2VvbWV0cnksIGF0IGFzIENvbmVHZW9tZXRyeSwgYXUgYXMgQ3lsaW5kZXJHZW9tZXRyeSwgYXYgYXMgU2hhcGVVdGlscywgYXcgYXMgVmVjdG9yNCwgYXggYXMgQ3VydmUsIGF5IGFzIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBheiBhcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUsIGFBIGFzIE1hdHJpeDMsIGFCIGFzIFNoYXBlUGF0aCwgYUMgYXMgUGF0aCwgYUQgYXMgdXNlTG9hZGVyLCBhRSBhcyBfX2Fzc2lnbiB9IGZyb20gJy4vaW5kZXgtMzNmYTYwYmYuanMnO1xuaW1wb3J0IFJlYWN0X19kZWZhdWx0LCB7IHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBEZXNjcmlwdGlvbjogQSBUSFJFRSBsb2FkZXIgZm9yIFNUTCBBU0NJSSBmaWxlcywgYXMgY3JlYXRlZCBieSBTb2xpZHdvcmtzIGFuZCBvdGhlciBDQUQgcHJvZ3JhbXMuXG4gKlxuICogU3VwcG9ydHMgYm90aCBiaW5hcnkgYW5kIEFTQ0lJIGVuY29kZWQgZmlsZXMsIHdpdGggYXV0b21hdGljIGRldGVjdGlvbiBvZiB0eXBlLlxuICpcbiAqIFRoZSBsb2FkZXIgcmV0dXJucyBhIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeS5cbiAqXG4gKiBMaW1pdGF0aW9uczpcbiAqICBCaW5hcnkgZGVjb2Rpbmcgc3VwcG9ydHMgXCJNYWdpY3NcIiBjb2xvciBmb3JtYXQgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1RMXyhmaWxlX2Zvcm1hdCkjQ29sb3JfaW5fYmluYXJ5X1NUTCkuXG4gKiAgVGhlcmUgaXMgcGVyaGFwcyBzb21lIHF1ZXN0aW9uIGFzIHRvIGhvdyB2YWxpZCBpdCBpcyB0byBhbHdheXMgYXNzdW1lIGxpdHRsZS1lbmRpYW4tbmVzcy5cbiAqICBBU0NJSSBkZWNvZGluZyBhc3N1bWVzIGZpbGUgaXMgVVRGLTguXG4gKlxuICogVXNhZ2U6XG4gKiAgdmFyIGxvYWRlciA9IG5ldyBTVExMb2FkZXIoKTtcbiAqICBsb2FkZXIubG9hZCggJy4vbW9kZWxzL3N0bC9zbG90dGVkX2Rpc2suc3RsJywgZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcbiAqICAgIHNjZW5lLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5ICkgKTtcbiAqICB9KTtcbiAqXG4gKiBGb3IgYmluYXJ5IFNUTHMgZ2VvbWV0cnkgbWlnaHQgY29udGFpbiBjb2xvcnMgZm9yIHZlcnRpY2VzLiBUbyB1c2UgaXQ6XG4gKiAgLy8gdXNlIHRoZSBzYW1lIGNvZGUgdG8gbG9hZCBTVEwgYXMgYWJvdmVcbiAqICBpZiAoZ2VvbWV0cnkuaGFzQ29sb3JzKSB7XG4gKiAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7IG9wYWNpdHk6IGdlb21ldHJ5LmFscGhhLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSk7XG4gKiAgfSBlbHNlIHsgLi4uLiB9XG4gKiAgdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gKlxuICogRm9yIEFTQ0lJIFNUTHMgY29udGFpbmluZyBtdWx0aXBsZSBzb2xpZHMsIGVhY2ggc29saWQgaXMgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgZ3JvdXAuXG4gKiBHcm91cHMgY2FuIGJlIHVzZWQgdG8gYXNzaWduIGEgZGlmZmVyZW50IGNvbG9yIGJ5IGRlZmluaW5nIGFuIGFycmF5IG9mIG1hdGVyaWFscyB3aXRoIHRoZSBzYW1lIGxlbmd0aCBvZlxuICogZ2VvbWV0cnkuZ3JvdXBzIGFuZCBwYXNzaW5nIGl0IHRvIHRoZSBNZXNoIGNvbnN0cnVjdG9yOlxuICpcbiAqIHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgbWF0ZXJpYWxzID0gW107XG4gKiAgdmFyIG5HZW9tZXRyeUdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGg7XG4gKlxuICogIHZhciBjb2xvck1hcCA9IC4uLjsgLy8gU29tZSBsb2dpYyB0byBpbmRleCBjb2xvcnMuXG4gKlxuICogIGZvciAodmFyIGkgPSAwOyBpIDwgbkdlb21ldHJ5R3JvdXBzOyBpKyspIHtcbiAqXG4gKlx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICpcdFx0XHRjb2xvcjogY29sb3JNYXBbaV0sXG4gKlx0XHRcdHdpcmVmcmFtZTogZmFsc2VcbiAqXHRcdH0pO1xuICpcbiAqICB9XG4gKlxuICogIG1hdGVyaWFscy5wdXNoKG1hdGVyaWFsKTtcbiAqICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbHMpO1xuICovXG5cblxudmFyIFNUTExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cbn07XG5cblNUTExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBTVExMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRmdW5jdGlvbiBpc0JpbmFyeSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGV4cGVjdCwgZmFjZV9zaXplLCBuX2ZhY2VzLCByZWFkZXI7XG5cdFx0XHRyZWFkZXIgPSBuZXcgRGF0YVZpZXcoIGRhdGEgKTtcblx0XHRcdGZhY2Vfc2l6ZSA9ICggMzIgLyA4ICogMyApICsgKCAoIDMyIC8gOCAqIDMgKSAqIDMgKSArICggMTYgLyA4ICk7XG5cdFx0XHRuX2ZhY2VzID0gcmVhZGVyLmdldFVpbnQzMiggODAsIHRydWUgKTtcblx0XHRcdGV4cGVjdCA9IDgwICsgKCAzMiAvIDggKSArICggbl9mYWNlcyAqIGZhY2Vfc2l6ZSApO1xuXG5cdFx0XHRpZiAoIGV4cGVjdCA9PT0gcmVhZGVyLmJ5dGVMZW5ndGggKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQW4gQVNDSUkgU1RMIGRhdGEgbXVzdCBiZWdpbiB3aXRoICdzb2xpZCAnIGFzIHRoZSBmaXJzdCBzaXggYnl0ZXMuXG5cdFx0XHQvLyBIb3dldmVyLCBBU0NJSSBTVExzIGxhY2tpbmcgdGhlIFNQQUNFIGFmdGVyIHRoZSAnZCcgYXJlIGtub3duIHRvIGJlXG5cdFx0XHQvLyBwbGVudGlmdWwuICBTbywgY2hlY2sgdGhlIGZpcnN0IDUgYnl0ZXMgZm9yICdzb2xpZCcuXG5cblx0XHRcdC8vIFNldmVyYWwgZW5jb2RpbmdzLCBzdWNoIGFzIFVURi04LCBwcmVjZWRlIHRoZSB0ZXh0IHdpdGggdXAgdG8gNSBieXRlczpcblx0XHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNCeXRlX29yZGVyX21hcmtzX2J5X2VuY29kaW5nXG5cdFx0XHQvLyBTZWFyY2ggZm9yIFwic29saWRcIiB0byBzdGFydCBhbnl3aGVyZSBhZnRlciB0aG9zZSBwcmVmaXhlcy5cblxuXHRcdFx0Ly8gVVMtQVNDSUkgb3JkaW5hbCB2YWx1ZXMgZm9yICdzJywgJ28nLCAnbCcsICdpJywgJ2QnXG5cblx0XHRcdHZhciBzb2xpZCA9IFsgMTE1LCAxMTEsIDEwOCwgMTA1LCAxMDAgXTtcblxuXHRcdFx0Zm9yICggdmFyIG9mZiA9IDA7IG9mZiA8IDU7IG9mZiArKyApIHtcblxuXHRcdFx0XHQvLyBJZiBcInNvbGlkXCIgdGV4dCBpcyBtYXRjaGVkIHRvIHRoZSBjdXJyZW50IG9mZnNldCwgZGVjbGFyZSBpdCB0byBiZSBhbiBBU0NJSSBTVEwuXG5cblx0XHRcdFx0aWYgKCBtYXRjaERhdGFWaWV3QXQoIHNvbGlkLCByZWFkZXIsIG9mZiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENvdWxkbid0IGZpbmQgXCJzb2xpZFwiIHRleHQgYXQgdGhlIGJlZ2lubmluZzsgaXQgaXMgYmluYXJ5IFNUTC5cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYXRjaERhdGFWaWV3QXQoIHF1ZXJ5LCByZWFkZXIsIG9mZnNldCApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZWFjaCBieXRlIGluIHF1ZXJ5IG1hdGNoZXMgdGhlIGNvcnJlc3BvbmRpbmcgYnl0ZSBmcm9tIHRoZSBjdXJyZW50IG9mZnNldFxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcXVlcnkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBxdWVyeVsgaSBdICE9PSByZWFkZXIuZ2V0VWludDgoIG9mZnNldCArIGksIGZhbHNlICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUJpbmFyeSggZGF0YSApIHtcblxuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyggZGF0YSApO1xuXHRcdFx0dmFyIGZhY2VzID0gcmVhZGVyLmdldFVpbnQzMiggODAsIHRydWUgKTtcblxuXHRcdFx0dmFyIHIsIGcsIGIsIGhhc0NvbG9ycyA9IGZhbHNlLCBjb2xvcnM7XG5cdFx0XHR2YXIgZGVmYXVsdFIsIGRlZmF1bHRHLCBkZWZhdWx0QiwgYWxwaGE7XG5cblx0XHRcdC8vIHByb2Nlc3MgU1RMIGhlYWRlclxuXHRcdFx0Ly8gY2hlY2sgZm9yIGRlZmF1bHQgY29sb3IgaW4gaGVhZGVyIChcIkNPTE9SPXJnYmFcIiBzZXF1ZW5jZSkuXG5cblx0XHRcdGZvciAoIHZhciBpbmRleCA9IDA7IGluZGV4IDwgODAgLSAxMDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0aWYgKCAoIHJlYWRlci5nZXRVaW50MzIoIGluZGV4LCBmYWxzZSApID09IDB4NDM0RjRDNEYgLypDT0xPKi8gKSAmJlxuXHRcdFx0XHRcdCggcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDQgKSA9PSAweDUyIC8qJ1InKi8gKSAmJlxuXHRcdFx0XHRcdCggcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDUgKSA9PSAweDNEIC8qJz0nKi8gKSApIHtcblxuXHRcdFx0XHRcdGhhc0NvbG9ycyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdFIgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgNiApIC8gMjU1O1xuXHRcdFx0XHRcdGRlZmF1bHRHID0gcmVhZGVyLmdldFVpbnQ4KCBpbmRleCArIDcgKSAvIDI1NTtcblx0XHRcdFx0XHRkZWZhdWx0QiA9IHJlYWRlci5nZXRVaW50OCggaW5kZXggKyA4ICkgLyAyNTU7XG5cdFx0XHRcdFx0YWxwaGEgPSByZWFkZXIuZ2V0VWludDgoIGluZGV4ICsgOSApIC8gMjU1O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YU9mZnNldCA9IDg0O1xuXHRcdFx0dmFyIGZhY2VMZW5ndGggPSAxMiAqIDQgKyAyO1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZmFjZXMgKiAzICogMyApO1xuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlcyAqIDMgKiAzICk7XG5cblx0XHRcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VzOyBmYWNlICsrICkge1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IGRhdGFPZmZzZXQgKyBmYWNlICogZmFjZUxlbmd0aDtcblx0XHRcdFx0dmFyIG5vcm1hbFggPSByZWFkZXIuZ2V0RmxvYXQzMiggc3RhcnQsIHRydWUgKTtcblx0XHRcdFx0dmFyIG5vcm1hbFkgPSByZWFkZXIuZ2V0RmxvYXQzMiggc3RhcnQgKyA0LCB0cnVlICk7XG5cdFx0XHRcdHZhciBub3JtYWxaID0gcmVhZGVyLmdldEZsb2F0MzIoIHN0YXJ0ICsgOCwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggaGFzQ29sb3JzICkge1xuXG5cdFx0XHRcdFx0dmFyIHBhY2tlZENvbG9yID0gcmVhZGVyLmdldFVpbnQxNiggc3RhcnQgKyA0OCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCAoIHBhY2tlZENvbG9yICYgMHg4MDAwICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZhY2V0IGhhcyBpdHMgb3duIHVuaXF1ZSBjb2xvclxuXG5cdFx0XHRcdFx0XHRyID0gKCBwYWNrZWRDb2xvciAmIDB4MUYgKSAvIDMxO1xuXHRcdFx0XHRcdFx0ZyA9ICggKCBwYWNrZWRDb2xvciA+PiA1ICkgJiAweDFGICkgLyAzMTtcblx0XHRcdFx0XHRcdGIgPSAoICggcGFja2VkQ29sb3IgPj4gMTAgKSAmIDB4MUYgKSAvIDMxO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ciA9IGRlZmF1bHRSO1xuXHRcdFx0XHRcdFx0ZyA9IGRlZmF1bHRHO1xuXHRcdFx0XHRcdFx0YiA9IGRlZmF1bHRCO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXhzdGFydCA9IHN0YXJ0ICsgaSAqIDEyO1xuXHRcdFx0XHRcdHZhciBjb21wb25lbnRJZHggPSAoIGZhY2UgKiAzICogMyApICsgKCAoIGkgLSAxICkgKiAzICk7XG5cblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4IF0gPSByZWFkZXIuZ2V0RmxvYXQzMiggdmVydGV4c3RhcnQsIHRydWUgKTtcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgY29tcG9uZW50SWR4ICsgMSBdID0gcmVhZGVyLmdldEZsb2F0MzIoIHZlcnRleHN0YXJ0ICsgNCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHZlcnRpY2VzWyBjb21wb25lbnRJZHggKyAyIF0gPSByZWFkZXIuZ2V0RmxvYXQzMiggdmVydGV4c3RhcnQgKyA4LCB0cnVlICk7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBjb21wb25lbnRJZHggXSA9IG5vcm1hbFg7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY29tcG9uZW50SWR4ICsgMSBdID0gbm9ybWFsWTtcblx0XHRcdFx0XHRub3JtYWxzWyBjb21wb25lbnRJZHggKyAyIF0gPSBub3JtYWxaO1xuXG5cdFx0XHRcdFx0aWYgKCBoYXNDb2xvcnMgKSB7XG5cblx0XHRcdFx0XHRcdGNvbG9yc1sgY29tcG9uZW50SWR4IF0gPSByO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAxIF0gPSBnO1xuXHRcdFx0XHRcdFx0Y29sb3JzWyBjb21wb25lbnRJZHggKyAyIF0gPSBiO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRpZiAoIGhhc0NvbG9ycyApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XG5cdFx0XHRcdGdlb21ldHJ5Lmhhc0NvbG9ycyA9IHRydWU7XG5cdFx0XHRcdGdlb21ldHJ5LmFscGhhID0gYWxwaGE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHR2YXIgcGF0dGVyblNvbGlkID0gL3NvbGlkKFtcXHNcXFNdKj8pZW5kc29saWQvZztcblx0XHRcdHZhciBwYXR0ZXJuRmFjZSA9IC9mYWNldChbXFxzXFxTXSo/KWVuZGZhY2V0L2c7XG5cdFx0XHR2YXIgZmFjZUNvdW50ZXIgPSAwO1xuXG5cdFx0XHR2YXIgcGF0dGVybkZsb2F0ID0gL1tcXHNdKyhbKy1dPyg/OlxcZCopKD86XFwuXFxkKik/KD86W2VFXVsrLV0/XFxkKyk/KS8uc291cmNlO1xuXHRcdFx0dmFyIHBhdHRlcm5WZXJ0ZXggPSBuZXcgUmVnRXhwKCAndmVydGV4JyArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCArIHBhdHRlcm5GbG9hdCwgJ2cnICk7XG5cdFx0XHR2YXIgcGF0dGVybk5vcm1hbCA9IG5ldyBSZWdFeHAoICdub3JtYWwnICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0LCAnZycgKTtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gW107XG5cdFx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXG5cdFx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXHRcdFx0dmFyIHN0YXJ0VmVydGV4ID0gMDtcblx0XHRcdHZhciBlbmRWZXJ0ZXggPSAwO1xuXG5cdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVyblNvbGlkLmV4ZWMoIGRhdGEgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHN0YXJ0VmVydGV4ID0gZW5kVmVydGV4O1xuXG5cdFx0XHRcdHZhciBzb2xpZCA9IHJlc3VsdFsgMCBdO1xuXG5cdFx0XHRcdHdoaWxlICggKCByZXN1bHQgPSBwYXR0ZXJuRmFjZS5leGVjKCBzb2xpZCApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmVydGV4Q291bnRQZXJGYWNlID0gMDtcblx0XHRcdFx0XHR2YXIgbm9ybWFsQ291bnRQZXJGYWNlID0gMDtcblxuXHRcdFx0XHRcdHZhciB0ZXh0ID0gcmVzdWx0WyAwIF07XG5cblx0XHRcdFx0XHR3aGlsZSAoICggcmVzdWx0ID0gcGF0dGVybk5vcm1hbC5leGVjKCB0ZXh0ICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0bm9ybWFsLnggPSBwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApO1xuXHRcdFx0XHRcdFx0bm9ybWFsLnkgPSBwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApO1xuXHRcdFx0XHRcdFx0bm9ybWFsLnogPSBwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApO1xuXHRcdFx0XHRcdFx0bm9ybWFsQ291bnRQZXJGYWNlICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2hpbGUgKCAoIHJlc3VsdCA9IHBhdHRlcm5WZXJ0ZXguZXhlYyggdGV4dCApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICksIHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdICksIHBhcnNlRmxvYXQoIHJlc3VsdFsgMyBdICkgKTtcblx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXHRcdFx0XHRcdFx0dmVydGV4Q291bnRQZXJGYWNlICsrO1xuXHRcdFx0XHRcdFx0ZW5kVmVydGV4ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXZlcnkgZmFjZSBoYXZlIHRvIG93biBPTkUgdmFsaWQgbm9ybWFsXG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbENvdW50UGVyRmFjZSAhPT0gMSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNUTExvYWRlcjogU29tZXRoaW5nIGlzblxcJ3QgcmlnaHQgd2l0aCB0aGUgbm9ybWFsIG9mIGZhY2UgbnVtYmVyICcgKyBmYWNlQ291bnRlciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZWFjaCBmYWNlIGhhdmUgdG8gb3duIFRIUkVFIHZhbGlkIHZlcnRpY2VzXG5cblx0XHRcdFx0XHRpZiAoIHZlcnRleENvdW50UGVyRmFjZSAhPT0gMyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNUTExvYWRlcjogU29tZXRoaW5nIGlzblxcJ3QgcmlnaHQgd2l0aCB0aGUgdmVydGljZXMgb2YgZmFjZSBudW1iZXIgJyArIGZhY2VDb3VudGVyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmYWNlQ291bnRlciArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHN0YXJ0ID0gc3RhcnRWZXJ0ZXg7XG5cdFx0XHRcdHZhciBjb3VudCA9IGVuZFZlcnRleCAtIHN0YXJ0VmVydGV4O1xuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCBzdGFydCwgY291bnQsIGdyb3VwQ291bnQgKTtcblx0XHRcdFx0Z3JvdXBDb3VudCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuc3VyZVN0cmluZyggYnVmZmVyICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBidWZmZXIgIT09ICdzdHJpbmcnICkge1xuXG5cdFx0XHRcdHJldHVybiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggYnVmZmVyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVmZmVyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5zdXJlQmluYXJ5KCBidWZmZXIgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5X2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIubGVuZ3RoICk7XG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheV9idWZmZXJbIGkgXSA9IGJ1ZmZlci5jaGFyQ29kZUF0KCBpICkgJiAweGZmOyAvLyBpbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhblxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYXJyYXlfYnVmZmVyLmJ1ZmZlciB8fCBhcnJheV9idWZmZXI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGJ1ZmZlcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnRcblxuXHRcdHZhciBiaW5EYXRhID0gZW5zdXJlQmluYXJ5KCBkYXRhICk7XG5cblx0XHRyZXR1cm4gaXNCaW5hcnkoIGJpbkRhdGEgKSA/IHBhcnNlQmluYXJ5KCBiaW5EYXRhICkgOiBwYXJzZUFTQ0lJKCBlbnN1cmVTdHJpbmcoIGRhdGEgKSApO1xuXG5cdH1cblxufSApO1xuXG52YXIgR0xURkxvYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGZ1bmN0aW9uIEdMVEZMb2FkZXIoIG1hbmFnZXIgKSB7XG5cblx0XHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cblx0XHR0aGlzLmRyYWNvTG9hZGVyID0gbnVsbDtcblx0XHR0aGlzLmt0eDJMb2FkZXIgPSBudWxsO1xuXHRcdHRoaXMubWVzaG9wdERlY29kZXIgPSBudWxsO1xuXG5cdFx0dGhpcy5wbHVnaW5DYWxsYmFja3MgPSBbXTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMucmVnaXN0ZXIoIGZ1bmN0aW9uICggcGFyc2VyICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24oIHBhcnNlciApO1xuXG5cdFx0fSApO1xuXG5cdFx0dGhpcy5yZWdpc3RlciggZnVuY3Rpb24gKCBwYXJzZXIgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbiggcGFyc2VyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyKCBmdW5jdGlvbiAoIHBhcnNlciApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBHTFRGTWVzaG9wdENvbXByZXNzaW9uKCBwYXJzZXIgKTtcblxuXHRcdH0gKTtcblxuXHR9XG5cblx0R0xURkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdFx0Y29uc3RydWN0b3I6IEdMVEZMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmVzb3VyY2VQYXRoO1xuXG5cdFx0XHRpZiAoIHRoaXMucmVzb3VyY2VQYXRoICE9PSAnJyApIHtcblxuXHRcdFx0XHRyZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcblxuXHRcdFx0fSBlbHNlIGlmICggdGhpcy5wYXRoICE9PSAnJyApIHtcblxuXHRcdFx0XHRyZXNvdXJjZVBhdGggPSB0aGlzLnBhdGg7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRlbGxzIHRoZSBMb2FkaW5nTWFuYWdlciB0byB0cmFjayBhbiBleHRyYSBpdGVtLCB3aGljaCByZXNvbHZlcyBhZnRlclxuXHRcdFx0Ly8gdGhlIG1vZGVsIGlzIGZ1bGx5IGxvYWRlZC4gVGhpcyBtZWFucyB0aGUgY291bnQgb2YgaXRlbXMgbG9hZGVkIHdpbGxcblx0XHRcdC8vIGJlIGluY29ycmVjdCwgYnV0IGVuc3VyZXMgbWFuYWdlci5vbkxvYWQoKSBkb2VzIG5vdCBmaXJlIGVhcmx5LlxuXHRcdFx0dGhpcy5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHZhciBfb25FcnJvciA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRvbkVycm9yKCBlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdHNjb3BlLnBhcnNlKCBkYXRhLCByZXNvdXJjZVBhdGgsIGZ1bmN0aW9uICggZ2x0ZiApIHtcblxuXHRcdFx0XHRcdFx0b25Mb2FkKCBnbHRmICk7XG5cblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdFx0XHR9LCBfb25FcnJvciApO1xuXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0X29uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIF9vbkVycm9yICk7XG5cblx0XHR9LFxuXG5cdFx0c2V0RFJBQ09Mb2FkZXI6IGZ1bmN0aW9uICggZHJhY29Mb2FkZXIgKSB7XG5cblx0XHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHNldEREU0xvYWRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cblx0XHRcdFx0J1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nXG5cblx0XHRcdCk7XG5cblx0XHR9LFxuXG5cdFx0c2V0S1RYMkxvYWRlcjogZnVuY3Rpb24gKCBrdHgyTG9hZGVyICkge1xuXG5cdFx0XHR0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0c2V0TWVzaG9wdERlY29kZXI6IGZ1bmN0aW9uICggbWVzaG9wdERlY29kZXIgKSB7XG5cblx0XHRcdHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2Rlcjtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHJlZ2lzdGVyOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0XHRpZiAoIHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoIGNhbGxiYWNrICkgPT09IC0gMSApIHtcblxuXHRcdFx0XHR0aGlzLnBsdWdpbkNhbGxiYWNrcy5wdXNoKCBjYWxsYmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHVucmVnaXN0ZXI6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHRoaXMucGx1Z2luQ2FsbGJhY2tzLnNwbGljZSggdGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZiggY2FsbGJhY2sgKSwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEsIHBhdGgsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdFx0dmFyIGNvbnRlbnQ7XG5cdFx0XHR2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXHRcdFx0dmFyIHBsdWdpbnMgPSB7fTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdFx0Y29udGVudCA9IGRhdGE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIG1hZ2ljID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIDAsIDQgKSApO1xuXG5cdFx0XHRcdGlmICggbWFnaWMgPT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDICkge1xuXG5cdFx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXSA9IG5ldyBHTFRGQmluYXJ5RXh0ZW5zaW9uKCBkYXRhICk7XG5cblx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGVycm9yICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb250ZW50ID0gZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXS5jb250ZW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb250ZW50ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGRhdGEgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIGNvbnRlbnQgKTtcblxuXHRcdFx0aWYgKCBqc29uLmFzc2V0ID09PSB1bmRlZmluZWQgfHwganNvbi5hc3NldC52ZXJzaW9uWyAwIF0gPCAyICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuJyApICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoIGpzb24sIHtcblxuXHRcdFx0XHRwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8ICcnLFxuXHRcdFx0XHRjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcblx0XHRcdFx0cmVxdWVzdEhlYWRlcjogdGhpcy5yZXF1ZXN0SGVhZGVyLFxuXHRcdFx0XHRtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG5cdFx0XHRcdGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcblx0XHRcdFx0bWVzaG9wdERlY29kZXI6IHRoaXMubWVzaG9wdERlY29kZXJcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwYXJzZXIuZmlsZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1sgaSBdKCBwYXJzZXIgKTtcblx0XHRcdFx0cGx1Z2luc1sgcGx1Z2luLm5hbWUgXSA9IHBsdWdpbjtcblxuXHRcdFx0XHQvLyBXb3JrYXJvdW5kIHRvIGF2b2lkIGRldGVybWluaW5nIGFzIHVua25vd24gZXh0ZW5zaW9uXG5cdFx0XHRcdC8vIGluIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSgpLlxuXHRcdFx0XHQvLyBSZW1vdmUgdGhpcyB3b3JrYXJvdW5kIGlmIHdlIG1vdmUgYWxsIHRoZSBleGlzdGluZ1xuXHRcdFx0XHQvLyBleHRlbnNpb24gaGFuZGxlcnMgdG8gcGx1Z2luIHN5c3RlbVxuXHRcdFx0XHRleHRlbnNpb25zWyBwbHVnaW4ubmFtZSBdID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1VzZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uTmFtZSA9IGpzb24uZXh0ZW5zaW9uc1VzZWRbIGkgXTtcblx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBleHRlbnNpb25OYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1M6XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGTWF0ZXJpYWxzUGJyU3BlY3VsYXJHbG9zc2luZXNzRXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24oIGpzb24sIHRoaXMuZHJhY29Mb2FkZXIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbnNbIGV4dGVuc2lvbk5hbWUgXSA9IG5ldyBHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbigpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjpcblx0XHRcdFx0XHRcdFx0ZXh0ZW5zaW9uc1sgZXh0ZW5zaW9uTmFtZSBdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRcdGlmICggZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIGV4dGVuc2lvbk5hbWUgKSA+PSAwICYmIHBsdWdpbnNbIGV4dGVuc2lvbk5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRwYXJzZXIuc2V0RXh0ZW5zaW9ucyggZXh0ZW5zaW9ucyApO1xuXHRcdFx0cGFyc2VyLnNldFBsdWdpbnMoIHBsdWdpbnMgKTtcblx0XHRcdHBhcnNlci5wYXJzZSggb25Mb2FkLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0fSApO1xuXG5cdC8qIEdMVEZSRUdJU1RSWSAqL1xuXG5cdGZ1bmN0aW9uIEdMVEZSZWdpc3RyeSgpIHtcblxuXHRcdHZhciBvYmplY3RzID0ge307XG5cblx0XHRyZXR1cm5cdHtcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0c1sga2V5IF07XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZDogZnVuY3Rpb24gKCBrZXksIG9iamVjdCApIHtcblxuXHRcdFx0XHRvYmplY3RzWyBrZXkgXSA9IG9iamVjdDtcblxuXHRcdFx0fSxcblxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdFx0XHRkZWxldGUgb2JqZWN0c1sga2V5IF07XG5cblx0XHRcdH0sXG5cblx0XHRcdHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdG9iamVjdHMgPSB7fTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKiogRVhURU5TSU9OUyAqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHR2YXIgRVhURU5TSU9OUyA9IHtcblx0XHRLSFJfQklOQVJZX0dMVEY6ICdLSFJfYmluYXJ5X2dsVEYnLFxuXHRcdEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOiAnS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb24nLFxuXHRcdEtIUl9MSUdIVFNfUFVOQ1RVQUw6ICdLSFJfbGlnaHRzX3B1bmN0dWFsJyxcblx0XHRLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogJ0tIUl9tYXRlcmlhbHNfY2xlYXJjb2F0Jyxcblx0XHRLSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTOiAnS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3MnLFxuXHRcdEtIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OOiAnS0hSX21hdGVyaWFsc190cmFuc21pc3Npb24nLFxuXHRcdEtIUl9NQVRFUklBTFNfVU5MSVQ6ICdLSFJfbWF0ZXJpYWxzX3VubGl0Jyxcblx0XHRLSFJfVEVYVFVSRV9CQVNJU1U6ICdLSFJfdGV4dHVyZV9iYXNpc3UnLFxuXHRcdEtIUl9URVhUVVJFX1RSQU5TRk9STTogJ0tIUl90ZXh0dXJlX3RyYW5zZm9ybScsXG5cdFx0S0hSX01FU0hfUVVBTlRJWkFUSU9OOiAnS0hSX21lc2hfcXVhbnRpemF0aW9uJyxcblx0XHRFWFRfVEVYVFVSRV9XRUJQOiAnRVhUX3RleHR1cmVfd2VicCcsXG5cdFx0RVhUX01FU0hPUFRfQ09NUFJFU1NJT046ICdFWFRfbWVzaG9wdF9jb21wcmVzc2lvbidcblx0fTtcblxuXHQvKipcblx0ICogUHVuY3R1YWwgTGlnaHRzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbGlnaHRzX3B1bmN0dWFsXG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTGlnaHRzRXh0ZW5zaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUw7XG5cblx0XHQvLyBPYmplY3QzRCBpbnN0YW5jZSBjYWNoZXNcblx0XHR0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblxuXHR9XG5cblx0R0xURkxpZ2h0c0V4dGVuc2lvbi5wcm90b3R5cGUuX21hcmtEZWZzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG5cblx0XHRmb3IgKCB2YXIgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4ICsrICkge1xuXG5cdFx0XHR2YXIgbm9kZURlZiA9IG5vZGVEZWZzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLmV4dGVuc2lvbnNcblx0XHRcdFx0JiYgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXVxuXHRcdFx0XHQmJiBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGFyc2VyLl9hZGROb2RlUmVmKCB0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmxpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdEdMVEZMaWdodHNFeHRlbnNpb24ucHJvdG90eXBlLl9sb2FkTGlnaHQgPSBmdW5jdGlvbiAoIGxpZ2h0SW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIGNhY2hlS2V5ID0gJ2xpZ2h0OicgKyBsaWdodEluZGV4O1xuXHRcdHZhciBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdGlmICggZGVwZW5kZW5jeSApIHJldHVybiBkZXBlbmRlbmN5O1xuXG5cdFx0dmFyIGpzb24gPSBwYXJzZXIuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9ICgganNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0gKSB8fCB7fTtcblx0XHR2YXIgbGlnaHREZWZzID0gZXh0ZW5zaW9ucy5saWdodHMgfHwgW107XG5cdFx0dmFyIGxpZ2h0RGVmID0gbGlnaHREZWZzWyBsaWdodEluZGV4IF07XG5cdFx0dmFyIGxpZ2h0Tm9kZTtcblxuXHRcdHZhciBjb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcblxuXHRcdGlmICggbGlnaHREZWYuY29sb3IgIT09IHVuZGVmaW5lZCApIGNvbG9yLmZyb21BcnJheSggbGlnaHREZWYuY29sb3IgKTtcblxuXHRcdHZhciByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5yYW5nZSA6IDA7XG5cblx0XHRzd2l0Y2ggKCBsaWdodERlZi50eXBlICkge1xuXG5cdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciApO1xuXHRcdFx0XHRsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCggMCwgMCwgLSAxICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5hZGQoIGxpZ2h0Tm9kZS50YXJnZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0bGlnaHROb2RlID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuXHRcdFx0XHQvLyBIYW5kbGUgc3BvdGxpZ2h0IHByb3BlcnRpZXMuXG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuXHRcdFx0XHRsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdW5kZWZpbmVkID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG5cdFx0XHRcdGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB1bmRlZmluZWQgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQuMDtcblx0XHRcdFx0bGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcblx0XHRcdFx0bGlnaHROb2RlLnBlbnVtYnJhID0gMS4wIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG5cdFx0XHRcdGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcblx0XHRcdFx0bGlnaHROb2RlLmFkZCggbGlnaHROb2RlLnRhcmdldCApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiAnICsgbGlnaHREZWYudHlwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU29tZSBsaWdodHMgKGUuZy4gc3BvdCkgZGVmYXVsdCB0byBhIHBvc2l0aW9uIG90aGVyIHRoYW4gdGhlIG9yaWdpbi4gUmVzZXQgdGhlIHBvc2l0aW9uXG5cdFx0Ly8gaGVyZSwgYmVjYXVzZSBub2RlLWxldmVsIHBhcnNpbmcgd2lsbCBvbmx5IG92ZXJyaWRlIHBvc2l0aW9uIGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxuXHRcdGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG5cblx0XHRpZiAoIGxpZ2h0RGVmLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbGlnaHROb2RlLmludGVuc2l0eSA9IGxpZ2h0RGVmLmludGVuc2l0eTtcblxuXHRcdGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoIGxpZ2h0RGVmLm5hbWUgfHwgKCAnbGlnaHRfJyArIGxpZ2h0SW5kZXggKSApO1xuXG5cdFx0ZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZSggbGlnaHROb2RlICk7XG5cblx0XHRwYXJzZXIuY2FjaGUuYWRkKCBjYWNoZUtleSwgZGVwZW5kZW5jeSApO1xuXG5cdFx0cmV0dXJuIGRlcGVuZGVuY3k7XG5cblx0fTtcblxuXHRHTFRGTGlnaHRzRXh0ZW5zaW9uLnByb3RvdHlwZS5jcmVhdGVOb2RlQXR0YWNobWVudCA9IGZ1bmN0aW9uICggbm9kZUluZGV4ICkge1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIganNvbiA9IHBhcnNlci5qc29uO1xuXHRcdHZhciBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUluZGV4IF07XG5cdFx0dmFyIGxpZ2h0RGVmID0gKCBub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHx8IHt9O1xuXHRcdHZhciBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG5cblx0XHRpZiAoIGxpZ2h0SW5kZXggPT09IHVuZGVmaW5lZCApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRMaWdodCggbGlnaHRJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoIHNlbGYuY2FjaGUsIGxpZ2h0SW5kZXgsIGxpZ2h0ICk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogVW5saXQgTWF0ZXJpYWxzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX3VubGl0XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG5cblx0fVxuXG5cdEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxUeXBlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xuXG5cdH07XG5cblx0R0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uLnByb3RvdHlwZS5leHRlbmRQYXJhbXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkge1xuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDEuMDtcblxuXHRcdHZhciBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuXG5cdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcyApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IgKSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG5cblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbIDMgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21hcCcsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcmNvYXQgTWF0ZXJpYWxzIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfbWF0ZXJpYWxzX2NsZWFyY29hdFxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcblxuXHR9XG5cblx0R0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbi5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxUeXBlID0gZnVuY3Rpb24gKCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuXG5cdH07XG5cblx0R0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbi5wcm90b3R5cGUuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXMucGFyc2VyO1xuXHRcdHZhciBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0aWYgKCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgISBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdHZhciBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdE1hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2NsZWFyY29hdFJvdWdobmVzc01hcCcsIGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdjbGVhcmNvYXROb3JtYWxNYXAnLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSApICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcblxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xMTQzOCNpc3N1ZWNvbW1lbnQtNTA3MDAzOTk1XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIHNjYWxlLCAtIHNjYWxlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zbWlzc2lvbiBNYXRlcmlhbHMgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tYXRlcmlhbHNfdHJhbnNtaXNzaW9uXG5cdCAqIERyYWZ0OiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvcHVsbC8xNjk4XG5cdCAqL1xuXHRmdW5jdGlvbiBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLnBhcnNlciA9IHBhcnNlcjtcblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuXG5cdH1cblxuXHRHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uLnByb3RvdHlwZS5nZXRNYXRlcmlhbFR5cGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkgcmV0dXJuIG51bGw7XG5cblx0XHRyZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG5cblx0fTtcblxuXHRHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uLnByb3RvdHlwZS5leHRlbmRNYXRlcmlhbFBhcmFtcyA9IGZ1bmN0aW9uICggbWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzWyBtYXRlcmlhbEluZGV4IF07XG5cblx0XHRpZiAoICEgbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cblx0XHR9XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0dmFyIGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXG5cdFx0aWYgKCBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG5cblx0XHR9XG5cblx0XHRpZiAoIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAndHJhbnNtaXNzaW9uTWFwJywgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogQmFzaXNVIFRleHR1cmUgRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl90ZXh0dXJlX2Jhc2lzdVxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24oIHBhcnNlciApIHtcblxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRcdHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX1RFWFRVUkVfQkFTSVNVO1xuXG5cdH1cblxuXHRHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbi5wcm90b3R5cGUubG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcblx0XHR2YXIganNvbiA9IHBhcnNlci5qc29uO1xuXG5cdFx0dmFyIHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzWyB0ZXh0dXJlSW5kZXggXTtcblxuXHRcdGlmICggISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgISB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHZhciBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdO1xuXHRcdHZhciBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXHRcdHZhciBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuXG5cdFx0aWYgKCAhIGxvYWRlciApIHtcblxuXHRcdFx0aWYgKCBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKCB0aGlzLm5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IHNldEtUWDJMb2FkZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgS1RYMiB0ZXh0dXJlcycgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgdGhlIGV4dGVuc2lvbiBpcyBvcHRpb25hbCBhbmQgdGhhdCBhIGZhbGxiYWNrIHRleHR1cmUgaXMgcHJlc2VudFxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5sb2FkVGV4dHVyZUltYWdlKCB0ZXh0dXJlSW5kZXgsIHNvdXJjZSwgbG9hZGVyICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogV2ViUCBUZXh0dXJlIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvVmVuZG9yL0VYVF90ZXh0dXJlX3dlYnBcblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiggcGFyc2VyICkge1xuXG5cdFx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfVEVYVFVSRV9XRUJQO1xuXHRcdHRoaXMuaXNTdXBwb3J0ZWQgPSBudWxsO1xuXG5cdH1cblxuXHRHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ucHJvdG90eXBlLmxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlSW5kZXggKSB7XG5cblx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZTtcblx0XHR2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG5cdFx0dmFyIGpzb24gPSBwYXJzZXIuanNvbjtcblxuXHRcdHZhciB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cblx0XHRpZiAoICEgdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICEgdGV4dHVyZURlZi5leHRlbnNpb25zWyBuYW1lIF0gKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGV4dGVuc2lvbiA9IHRleHR1cmVEZWYuZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXHRcdHZhciBzb3VyY2UgPSBqc29uLmltYWdlc1sgZXh0ZW5zaW9uLnNvdXJjZSBdO1xuXG5cdFx0dmFyIGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0dmFyIGhhbmRsZXIgPSBwYXJzZXIub3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoIHNvdXJjZS51cmkgKTtcblx0XHRcdGlmICggaGFuZGxlciAhPT0gbnVsbCApIGxvYWRlciA9IGhhbmRsZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbiggZnVuY3Rpb24gKCBpc1N1cHBvcnRlZCApIHtcblxuXHRcdFx0aWYgKCBpc1N1cHBvcnRlZCApIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSggdGV4dHVyZUluZGV4LCBzb3VyY2UsIGxvYWRlciApO1xuXG5cdFx0XHRpZiAoIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YoIG5hbWUgKSA+PSAwICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIGJhY2sgdG8gUE5HIG9yIEpQRUcuXG5cdFx0XHRyZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKCB0ZXh0dXJlSW5kZXggKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbi5wcm90b3R5cGUuZGV0ZWN0U3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggISB0aGlzLmlzU3VwcG9ydGVkICkge1xuXG5cdFx0XHR0aGlzLmlzU3VwcG9ydGVkID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uICggcmVzb2x2ZSApIHtcblxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblxuXHRcdFx0XHQvLyBMb3NzeSB0ZXN0IGltYWdlLiBTdXBwb3J0IGZvciBsb3NzeSBpbWFnZXMgZG9lc24ndCBndWFyYW50ZWUgc3VwcG9ydCBmb3IgYWxsXG5cdFx0XHRcdC8vIFdlYlAgaW1hZ2VzLCB1bmZvcnR1bmF0ZWx5LlxuXHRcdFx0XHRpbWFnZS5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmlJQUFBQlhSVUpRVmxBNElCWUFBQUF3QVFDZEFTb0JBQUVBRHNEK0phUUFBM0FBQUFBQSc7XG5cblx0XHRcdFx0aW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJlc29sdmUoIGltYWdlLmhlaWdodCA9PT0gMSApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuXG5cdH07XG5cblx0LyoqXG5cdCogbWVzaG9wdCBCdWZmZXJWaWV3IENvbXByZXNzaW9uIEV4dGVuc2lvblxuXHQqXG5cdCogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL1ZlbmRvci9FWFRfbWVzaG9wdF9jb21wcmVzc2lvblxuXHQqL1xuXHRmdW5jdGlvbiBHTFRGTWVzaG9wdENvbXByZXNzaW9uKCBwYXJzZXIgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OO1xuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXG5cdH1cblxuXHRHTFRGTWVzaG9wdENvbXByZXNzaW9uLnByb3RvdHlwZS5sb2FkQnVmZmVyVmlldyA9IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHR2YXIganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG5cdFx0dmFyIGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzWyBpbmRleCBdO1xuXG5cdFx0aWYgKCBidWZmZXJWaWV3LmV4dGVuc2lvbnMgJiYgYnVmZmVyVmlldy5leHRlbnNpb25zWyB0aGlzLm5hbWUgXSApIHtcblxuXHRcdFx0dmFyIGV4dGVuc2lvbkRlZiA9IGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF07XG5cblx0XHRcdHZhciBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyJywgZXh0ZW5zaW9uRGVmLmJ1ZmZlciApO1xuXHRcdFx0dmFyIGRlY29kZXIgPSB0aGlzLnBhcnNlci5vcHRpb25zLm1lc2hvcHREZWNvZGVyO1xuXG5cdFx0XHRpZiAoICEgZGVjb2RlciB8fCAhIGRlY29kZXIuc3VwcG9ydGVkICkge1xuXG5cdFx0XHRcdGlmICgganNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZiggdGhpcy5uYW1lICkgPj0gMCApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IHNldE1lc2hvcHREZWNvZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIGNvbXByZXNzZWQgZmlsZXMnICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEFzc3VtZXMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIG9wdGlvbmFsIGFuZCB0aGF0IGZhbGxiYWNrIGJ1ZmZlciBkYXRhIGlzIHByZXNlbnRcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBbIGJ1ZmZlciwgZGVjb2Rlci5yZWFkeSBdICkudGhlbiggZnVuY3Rpb24gKCByZXMgKSB7XG5cblx0XHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBleHRlbnNpb25EZWYuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0XHR2YXIgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cblx0XHRcdFx0dmFyIGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuXHRcdFx0XHR2YXIgc3RyaWRlID0gZXh0ZW5zaW9uRGVmLmJ5dGVTdHJpZGU7XG5cblx0XHRcdFx0dmFyIHJlc3VsdCA9IG5ldyBBcnJheUJ1ZmZlciggY291bnQgKiBzdHJpZGUgKTtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KCByZXNbIDAgXSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCApO1xuXG5cdFx0XHRcdGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlciggbmV3IFVpbnQ4QXJyYXkoIHJlc3VsdCApLCBjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0LyogQklOQVJZIEVYVEVOU0lPTiAqL1xuXHR2YXIgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgPSAnZ2xURic7XG5cdHZhciBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggPSAxMjtcblx0dmFyIEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMgPSB7IEpTT046IDB4NEU0RjUzNEEsIEJJTjogMHgwMDRFNDk0MiB9O1xuXG5cdGZ1bmN0aW9uIEdMVEZCaW5hcnlFeHRlbnNpb24oIGRhdGEgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURjtcblx0XHR0aGlzLmNvbnRlbnQgPSBudWxsO1xuXHRcdHRoaXMuYm9keSA9IG51bGw7XG5cblx0XHR2YXIgaGVhZGVyVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cblx0XHR0aGlzLmhlYWRlciA9IHtcblx0XHRcdG1hZ2ljOiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KCBuZXcgVWludDhBcnJheSggZGF0YS5zbGljZSggMCwgNCApICkgKSxcblx0XHRcdHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKCA0LCB0cnVlICksXG5cdFx0XHRsZW5ndGg6IGhlYWRlclZpZXcuZ2V0VWludDMyKCA4LCB0cnVlIClcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci4nICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0aGlzLmhlYWRlci52ZXJzaW9uIDwgMi4wICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGNodW5rQ29udGVudHNMZW5ndGggPSB0aGlzLmhlYWRlci5sZW5ndGggLSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEg7XG5cdFx0dmFyIGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICk7XG5cdFx0dmFyIGNodW5rSW5kZXggPSAwO1xuXG5cdFx0d2hpbGUgKCBjaHVua0luZGV4IDwgY2h1bmtDb250ZW50c0xlbmd0aCApIHtcblxuXHRcdFx0dmFyIGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMiggY2h1bmtJbmRleCwgdHJ1ZSApO1xuXHRcdFx0Y2h1bmtJbmRleCArPSA0O1xuXG5cdFx0XHR2YXIgY2h1bmtUeXBlID0gY2h1bmtWaWV3LmdldFVpbnQzMiggY2h1bmtJbmRleCwgdHJ1ZSApO1xuXHRcdFx0Y2h1bmtJbmRleCArPSA0O1xuXG5cdFx0XHRpZiAoIGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5KU09OICkge1xuXG5cdFx0XHRcdHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheSggZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGggKTtcblx0XHRcdFx0dGhpcy5jb250ZW50ID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggY29udGVudEFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4gKSB7XG5cblx0XHRcdFx0dmFyIGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuXHRcdFx0XHR0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgY2h1bmtMZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGllbnRzIG11c3QgaWdub3JlIGNodW5rcyB3aXRoIHVua25vd24gdHlwZXMuXG5cblx0XHRcdGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY29udGVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogSlNPTiBjb250ZW50IG5vdCBmb3VuZC4nICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBEUkFDTyBNZXNoIENvbXByZXNzaW9uIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfZHJhY29fbWVzaF9jb21wcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKCBqc29uLCBkcmFjb0xvYWRlciApIHtcblxuXHRcdGlmICggISBkcmFjb0xvYWRlciApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjtcblx0XHR0aGlzLmpzb24gPSBqc29uO1xuXHRcdHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcblx0XHR0aGlzLmRyYWNvTG9hZGVyLnByZWxvYWQoKTtcblxuXHR9XG5cblx0R0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uLnByb3RvdHlwZS5kZWNvZGVQcmltaXRpdmUgPSBmdW5jdGlvbiAoIHByaW1pdGl2ZSwgcGFyc2VyICkge1xuXG5cdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0dmFyIGRyYWNvTG9hZGVyID0gdGhpcy5kcmFjb0xvYWRlcjtcblx0XHR2YXIgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbIHRoaXMubmFtZSBdLmJ1ZmZlclZpZXc7XG5cdFx0dmFyIGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1sgdGhpcy5uYW1lIF0uYXR0cmlidXRlcztcblx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcblx0XHR2YXIgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuXHRcdHZhciBhdHRyaWJ1dGVUeXBlTWFwID0ge307XG5cblx0XHRmb3IgKCB2YXIgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwICkge1xuXG5cdFx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgYXR0cmlidXRlTmFtZSBdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dGhyZWVBdHRyaWJ1dGVNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gZ2x0ZkF0dHJpYnV0ZU1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggYXR0cmlidXRlTmFtZSBpbiBwcmltaXRpdmUuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbIGF0dHJpYnV0ZU5hbWUgXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggZ2x0ZkF0dHJpYnV0ZU1hcFsgYXR0cmlidXRlTmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGFjY2Vzc29yRGVmID0ganNvbi5hY2Nlc3NvcnNbIHByaW1pdGl2ZS5hdHRyaWJ1dGVzWyBhdHRyaWJ1dGVOYW1lIF0gXTtcblx0XHRcdFx0dmFyIGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbIGFjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGUgXTtcblxuXHRcdFx0XHRhdHRyaWJ1dGVUeXBlTWFwWyB0aHJlZUF0dHJpYnV0ZU5hbWUgXSA9IGNvbXBvbmVudFR5cGU7XG5cdFx0XHRcdGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbIHRocmVlQXR0cmlidXRlTmFtZSBdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGJ1ZmZlclZpZXdJbmRleCApLnRoZW4oIGZ1bmN0aW9uICggYnVmZmVyVmlldyApIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKCBmdW5jdGlvbiAoIHJlc29sdmUgKSB7XG5cblx0XHRcdFx0ZHJhY29Mb2FkZXIuZGVjb2RlRHJhY29GaWxlKCBidWZmZXJWaWV3LCBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGF0dHJpYnV0ZU5hbWUgXTtcblx0XHRcdFx0XHRcdHZhciBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFsgYXR0cmlidXRlTmFtZSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgIT09IHVuZGVmaW5lZCApIGF0dHJpYnV0ZS5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUoIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fSwgdGhyZWVBdHRyaWJ1dGVNYXAsIGF0dHJpYnV0ZVR5cGVNYXAgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFRleHR1cmUgVHJhbnNmb3JtIEV4dGVuc2lvblxuXHQgKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvZXh0ZW5zaW9ucy8yLjAvS2hyb25vcy9LSFJfdGV4dHVyZV90cmFuc2Zvcm1cblx0ICovXG5cdGZ1bmN0aW9uIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCkge1xuXG5cdFx0dGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk07XG5cblx0fVxuXG5cdEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uLnByb3RvdHlwZS5leHRlbmRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKSB7XG5cblx0XHR0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggdHJhbnNmb3JtLm9mZnNldCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFuc2Zvcm0ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggdHJhbnNmb3JtLnNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBDdXN0b20gVVYgc2V0cyBpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgZXh0ZW5zaW9uIG5vdCB5ZXQgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY3VsYXItR2xvc3NpbmVzcyBFeHRlbnNpb25cblx0ICpcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL2V4dGVuc2lvbnMvMi4wL0tocm9ub3MvS0hSX21hdGVyaWFsc19wYnJTcGVjdWxhckdsb3NzaW5lc3Ncblx0ICovXG5cblx0LyoqXG5cdCAqIEEgc3ViIGNsYXNzIG9mIFN0YW5kYXJkTWF0ZXJpYWwgd2l0aCBzb21lIG9mIHRoZSBmdW5jdGlvbmFsaXR5XG5cdCAqIGNoYW5nZWQgdmlhIHRoZSBgb25CZWZvcmVDb21waWxlYCBjYWxsYmFja1xuXHQgKiBAcGFpbGhlYWRcblx0ICovXG5cblx0ZnVuY3Rpb24gR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwoIHBhcmFtcyApIHtcblxuXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMuaXNHTFRGU3BlY3VsYXJHbG9zc2luZXNzTWF0ZXJpYWwgPSB0cnVlO1xuXG5cdFx0Ly92YXJpb3VzIGNodW5rcyB0aGF0IG5lZWQgcmVwbGFjaW5nXG5cdFx0dmFyIHNwZWN1bGFyTWFwUGFyc0ZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQnI2lmZGVmIFVTRV9TUEVDVUxBUk1BUCcsXG5cdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDsnLFxuXHRcdFx0JyNlbmRpZidcblx0XHRdLmpvaW4oICdcXG4nICk7XG5cblx0XHR2YXIgZ2xvc3NpbmVzc01hcFBhcnNGcmFnbWVudENodW5rID0gW1xuXHRcdFx0JyNpZmRlZiBVU0VfR0xPU1NJTkVTU01BUCcsXG5cdFx0XHQnXHR1bmlmb3JtIHNhbXBsZXIyRCBnbG9zc2luZXNzTWFwOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdHZhciBzcGVjdWxhck1hcEZyYWdtZW50Q2h1bmsgPSBbXG5cdFx0XHQndmVjMyBzcGVjdWxhckZhY3RvciA9IHNwZWN1bGFyOycsXG5cdFx0XHQnI2lmZGVmIFVTRV9TUEVDVUxBUk1BUCcsXG5cdFx0XHQnXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTsnLFxuXHRcdFx0J1x0dGV4ZWxTcGVjdWxhciA9IHNSR0JUb0xpbmVhciggdGV4ZWxTcGVjdWxhciApOycsXG5cdFx0XHQnXHQvLyByZWFkcyBjaGFubmVsIFJHQiwgY29tcGF0aWJsZSB3aXRoIGEgZ2xURiBTcGVjdWxhci1HbG9zc2luZXNzIChSR0JBKSB0ZXh0dXJlJyxcblx0XHRcdCdcdHNwZWN1bGFyRmFjdG9yICo9IHRleGVsU3BlY3VsYXIucmdiOycsXG5cdFx0XHQnI2VuZGlmJ1xuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdHZhciBnbG9zc2luZXNzTWFwRnJhZ21lbnRDaHVuayA9IFtcblx0XHRcdCdmbG9hdCBnbG9zc2luZXNzRmFjdG9yID0gZ2xvc3NpbmVzczsnLFxuXHRcdFx0JyNpZmRlZiBVU0VfR0xPU1NJTkVTU01BUCcsXG5cdFx0XHQnXHR2ZWM0IHRleGVsR2xvc3NpbmVzcyA9IHRleHR1cmUyRCggZ2xvc3NpbmVzc01hcCwgdlV2ICk7Jyxcblx0XHRcdCdcdC8vIHJlYWRzIGNoYW5uZWwgQSwgY29tcGF0aWJsZSB3aXRoIGEgZ2xURiBTcGVjdWxhci1HbG9zc2luZXNzIChSR0JBKSB0ZXh0dXJlJyxcblx0XHRcdCdcdGdsb3NzaW5lc3NGYWN0b3IgKj0gdGV4ZWxHbG9zc2luZXNzLmE7Jyxcblx0XHRcdCcjZW5kaWYnXG5cdFx0XS5qb2luKCAnXFxuJyApO1xuXG5cdFx0dmFyIGxpZ2h0UGh5c2ljYWxGcmFnbWVudENodW5rID0gW1xuXHRcdFx0J1BoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWw7Jyxcblx0XHRcdCdtYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiICogKCAxLiAtIG1heCggc3BlY3VsYXJGYWN0b3IuciwgbWF4KCBzcGVjdWxhckZhY3Rvci5nLCBzcGVjdWxhckZhY3Rvci5iICkgKSApOycsXG5cdFx0XHQndmVjMyBkeHkgPSBtYXgoIGFicyggZEZkeCggZ2VvbWV0cnlOb3JtYWwgKSApLCBhYnMoIGRGZHkoIGdlb21ldHJ5Tm9ybWFsICkgKSApOycsXG5cdFx0XHQnZmxvYXQgZ2VvbWV0cnlSb3VnaG5lc3MgPSBtYXgoIG1heCggZHh5LngsIGR4eS55ICksIGR4eS56ICk7Jyxcblx0XHRcdCdtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IG1heCggMS4wIC0gZ2xvc3NpbmVzc0ZhY3RvciwgMC4wNTI1ICk7IC8vIDAuMDUyNSBjb3JyZXNwb25kcyB0byB0aGUgYmFzZSBtaXAgb2YgYSAyNTYgY3ViZW1hcC4nLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzOycsXG5cdFx0XHQnbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBtaW4oIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzLCAxLjAgKTsnLFxuXHRcdFx0J21hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhckZhY3RvcjsnLFxuXHRcdF0uam9pbiggJ1xcbicgKTtcblxuXHRcdHZhciB1bmlmb3JtcyA9IHtcblx0XHRcdHNwZWN1bGFyOiB7IHZhbHVlOiBuZXcgQ29sb3IoKS5zZXRIZXgoIDB4ZmZmZmZmICkgfSxcblx0XHRcdGdsb3NzaW5lc3M6IHsgdmFsdWU6IDEgfSxcblx0XHRcdHNwZWN1bGFyTWFwOiB7IHZhbHVlOiBudWxsIH0sXG5cdFx0XHRnbG9zc2luZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fZXh0cmFVbmlmb3JtcyA9IHVuaWZvcm1zO1xuXG5cdFx0dGhpcy5vbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoIHNoYWRlciApIHtcblxuXHRcdFx0Zm9yICggdmFyIHVuaWZvcm1OYW1lIGluIHVuaWZvcm1zICkge1xuXG5cdFx0XHRcdHNoYWRlci51bmlmb3Jtc1sgdW5pZm9ybU5hbWUgXSA9IHVuaWZvcm1zWyB1bmlmb3JtTmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNoYWRlci5mcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXHRcdFx0XHQucmVwbGFjZSggJ3VuaWZvcm0gZmxvYXQgcm91Z2huZXNzOycsICd1bmlmb3JtIHZlYzMgc3BlY3VsYXI7JyApXG5cdFx0XHRcdC5yZXBsYWNlKCAndW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7JywgJ3VuaWZvcm0gZmxvYXQgZ2xvc3NpbmVzczsnIClcblx0XHRcdFx0LnJlcGxhY2UoICcjaW5jbHVkZSA8cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ+Jywgc3BlY3VsYXJNYXBQYXJzRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PicsIGdsb3NzaW5lc3NNYXBQYXJzRnJhZ21lbnRDaHVuayApXG5cdFx0XHRcdC5yZXBsYWNlKCAnI2luY2x1ZGUgPHJvdWdobmVzc21hcF9mcmFnbWVudD4nLCBzcGVjdWxhck1hcEZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+JywgZ2xvc3NpbmVzc01hcEZyYWdtZW50Q2h1bmsgKVxuXHRcdFx0XHQucmVwbGFjZSggJyNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+JywgbGlnaHRQaHlzaWNhbEZyYWdtZW50Q2h1bmsgKTtcblxuXHRcdH07XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG5cdFx0XHRzcGVjdWxhcjoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gdjtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRzcGVjdWxhck1hcDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gdjtcblxuXHRcdFx0XHRcdGlmICggdiApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5kZWZpbmVzLlVTRV9TUEVDVUxBUk1BUCA9ICcnOyAvLyBVU0VfVVYgaXMgc2V0IGJ5IHRoZSByZW5kZXJlciBmb3Igc3BlY3VsYXIgbWFwc1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfU1BFQ1VMQVJNQVA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2xvc3NpbmVzczoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5nbG9zc2luZXNzLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzcy52YWx1ZSA9IHY7XG5cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2xvc3NpbmVzc01hcDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdHJldHVybiB1bmlmb3Jtcy5nbG9zc2luZXNzTWFwLnZhbHVlO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuZ2xvc3NpbmVzc01hcC52YWx1ZSA9IHY7XG5cblx0XHRcdFx0XHRpZiAoIHYgKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuZGVmaW5lcy5VU0VfR0xPU1NJTkVTU01BUCA9ICcnO1xuXHRcdFx0XHRcdFx0dGhpcy5kZWZpbmVzLlVTRV9VViA9ICcnO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmaW5lcy5VU0VfR0xPU1NJTkVTU01BUDtcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmRlZmluZXMuVVNFX1VWO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdGRlbGV0ZSB0aGlzLm1ldGFsbmVzcztcblx0XHRkZWxldGUgdGhpcy5yb3VnaG5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzTWFwO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzc01hcDtcblxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbXMgKTtcblxuXHR9XG5cblx0R0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlICk7XG5cdEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsO1xuXG5cdEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXHRcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XG5cdFx0dGhpcy5nbG9zc2luZXNzTWFwID0gc291cmNlLmdsb3NzaW5lc3NNYXA7XG5cdFx0dGhpcy5nbG9zc2luZXNzID0gc291cmNlLmdsb3NzaW5lc3M7XG5cdFx0ZGVsZXRlIHRoaXMubWV0YWxuZXNzO1xuXHRcdGRlbGV0ZSB0aGlzLnJvdWdobmVzcztcblx0XHRkZWxldGUgdGhpcy5tZXRhbG5lc3NNYXA7XG5cdFx0ZGVsZXRlIHRoaXMucm91Z2huZXNzTWFwO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gR0xURk1hdGVyaWFsc1BiclNwZWN1bGFyR2xvc3NpbmVzc0V4dGVuc2lvbigpIHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdG5hbWU6IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyxcblxuXHRcdFx0c3BlY3VsYXJHbG9zc2luZXNzUGFyYW1zOiBbXG5cdFx0XHRcdCdjb2xvcicsXG5cdFx0XHRcdCdtYXAnLFxuXHRcdFx0XHQnbGlnaHRNYXAnLFxuXHRcdFx0XHQnbGlnaHRNYXBJbnRlbnNpdHknLFxuXHRcdFx0XHQnYW9NYXAnLFxuXHRcdFx0XHQnYW9NYXBJbnRlbnNpdHknLFxuXHRcdFx0XHQnZW1pc3NpdmUnLFxuXHRcdFx0XHQnZW1pc3NpdmVJbnRlbnNpdHknLFxuXHRcdFx0XHQnZW1pc3NpdmVNYXAnLFxuXHRcdFx0XHQnYnVtcE1hcCcsXG5cdFx0XHRcdCdidW1wU2NhbGUnLFxuXHRcdFx0XHQnbm9ybWFsTWFwJyxcblx0XHRcdFx0J25vcm1hbE1hcFR5cGUnLFxuXHRcdFx0XHQnZGlzcGxhY2VtZW50TWFwJyxcblx0XHRcdFx0J2Rpc3BsYWNlbWVudFNjYWxlJyxcblx0XHRcdFx0J2Rpc3BsYWNlbWVudEJpYXMnLFxuXHRcdFx0XHQnc3BlY3VsYXJNYXAnLFxuXHRcdFx0XHQnc3BlY3VsYXInLFxuXHRcdFx0XHQnZ2xvc3NpbmVzc01hcCcsXG5cdFx0XHRcdCdnbG9zc2luZXNzJyxcblx0XHRcdFx0J2FscGhhTWFwJyxcblx0XHRcdFx0J2Vudk1hcCcsXG5cdFx0XHRcdCdlbnZNYXBJbnRlbnNpdHknLFxuXHRcdFx0XHQncmVmcmFjdGlvblJhdGlvJyxcblx0XHRcdF0sXG5cblx0XHRcdGdldE1hdGVyaWFsVHlwZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHJldHVybiBHTFRGTWVzaFN0YW5kYXJkU0dNYXRlcmlhbDtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZXh0ZW5kUGFyYW1zOiBmdW5jdGlvbiAoIG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyICkge1xuXG5cdFx0XHRcdHZhciBwYnJTcGVjdWxhckdsb3NzaW5lc3MgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zWyB0aGlzLm5hbWUgXTtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvciggMS4wLCAxLjAsIDEuMCApO1xuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMS4wO1xuXG5cdFx0XHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZGlmZnVzZUZhY3RvciApICkge1xuXG5cdFx0XHRcdFx0dmFyIGFycmF5ID0gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VGYWN0b3I7XG5cblx0XHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcGJyU3BlY3VsYXJHbG9zc2luZXNzLmRpZmZ1c2VUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21hcCcsIHBiclNwZWN1bGFyR2xvc3NpbmVzcy5kaWZmdXNlVGV4dHVyZSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCAwLjAsIDAuMCwgMC4wICk7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3MgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3MuZ2xvc3NpbmVzc0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gcGJyU3BlY3VsYXJHbG9zc2luZXNzLmdsb3NzaW5lc3NGYWN0b3IgOiAxLjA7XG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyID0gbmV3IENvbG9yKCAxLjAsIDEuMCwgMS4wICk7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJGYWN0b3IgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyLmZyb21BcnJheSggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyRmFjdG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcGJyU3BlY3VsYXJHbG9zc2luZXNzLnNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBzcGVjR2xvc3NNYXBEZWYgPSBwYnJTcGVjdWxhckdsb3NzaW5lc3Muc3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZTtcblx0XHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2dsb3NzaW5lc3NNYXAnLCBzcGVjR2xvc3NNYXBEZWYgKSApO1xuXHRcdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnc3BlY3VsYXJNYXAnLCBzcGVjR2xvc3NNYXBEZWYgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0Y3JlYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uICggbWF0ZXJpYWxQYXJhbXMgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IEdMVEZNZXNoU3RhbmRhcmRTR01hdGVyaWFsKCBtYXRlcmlhbFBhcmFtcyApO1xuXHRcdFx0XHRtYXRlcmlhbC5mb2cgPSB0cnVlO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmNvbG9yID0gbWF0ZXJpYWxQYXJhbXMuY29sb3I7XG5cblx0XHRcdFx0bWF0ZXJpYWwubWFwID0gbWF0ZXJpYWxQYXJhbXMubWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMubWFwO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmxpZ2h0TWFwID0gbnVsbDtcblx0XHRcdFx0bWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHRcdFx0bWF0ZXJpYWwuYW9NYXAgPSBtYXRlcmlhbFBhcmFtcy5hb01hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmFvTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHRcdFx0XHRtYXRlcmlhbC5lbWlzc2l2ZSA9IG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlO1xuXHRcdFx0XHRtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcblx0XHRcdFx0bWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZU1hcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlTWFwO1xuXG5cdFx0XHRcdG1hdGVyaWFsLmJ1bXBNYXAgPSBtYXRlcmlhbFBhcmFtcy5idW1wTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuYnVtcE1hcDtcblx0XHRcdFx0bWF0ZXJpYWwuYnVtcFNjYWxlID0gMTtcblxuXHRcdFx0XHRtYXRlcmlhbC5ub3JtYWxNYXAgPSBtYXRlcmlhbFBhcmFtcy5ub3JtYWxNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5ub3JtYWxNYXA7XG5cdFx0XHRcdG1hdGVyaWFsLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZSApIG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGU7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcblx0XHRcdFx0bWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHRcdFx0XHRtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuXHRcdFx0XHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyTWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJNYXA7XG5cdFx0XHRcdG1hdGVyaWFsLnNwZWN1bGFyID0gbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXI7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZ2xvc3NpbmVzc01hcCA9IG1hdGVyaWFsUGFyYW1zLmdsb3NzaW5lc3NNYXAgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBtYXRlcmlhbFBhcmFtcy5nbG9zc2luZXNzTWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5nbG9zc2luZXNzID0gbWF0ZXJpYWxQYXJhbXMuZ2xvc3NpbmVzcztcblxuXHRcdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IG51bGw7XG5cblx0XHRcdFx0bWF0ZXJpYWwuZW52TWFwID0gbWF0ZXJpYWxQYXJhbXMuZW52TWFwID09PSB1bmRlZmluZWQgPyBudWxsIDogbWF0ZXJpYWxQYXJhbXMuZW52TWFwO1xuXHRcdFx0XHRtYXRlcmlhbC5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0XHRcdFx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHRcdH0sXG5cblx0XHR9O1xuXG5cdH1cblxuXHQvKipcblx0ICogTWVzaCBRdWFudGl6YXRpb24gRXh0ZW5zaW9uXG5cdCAqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9leHRlbnNpb25zLzIuMC9LaHJvbm9zL0tIUl9tZXNoX3F1YW50aXphdGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24oKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKiogSU5URVJQT0xBVElPTiAqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvLyBTcGxpbmUgSW50ZXJwb2xhdGlvblxuXHQvLyBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FwcGVuZGl4LWMtc3BsaW5lLWludGVycG9sYXRpb25cblx0ZnVuY3Rpb24gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0XHRJbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cblx0fVxuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApO1xuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyA9IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHQvLyBDb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXIuIFNlZSBkZXNjcmlwdGlvbiBvZiBnbFRGXG5cdFx0Ly8gQ1VCSUNTUExJTkUgdmFsdWVzIGxheW91dCBpbiBpbnRlcnBvbGF0ZV8oKSBmdW5jdGlvbiBiZWxvdy5cblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0dmFsdWVTaXplID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBpbmRleCAqIHZhbHVlU2l6ZSAqIDMgKyB2YWx1ZVNpemU7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHZhbHVlU2l6ZTsgaSArKyApIHtcblxuXHRcdFx0cmVzdWx0WyBpIF0gPSB2YWx1ZXNbIG9mZnNldCArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fTtcblxuXHRHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudC5wcm90b3R5cGUuYmVmb3JlU3RhcnRfID0gR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV87XG5cblx0R0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQucHJvdG90eXBlLmFmdGVyRW5kXyA9IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfO1xuXG5cdEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50LnByb3RvdHlwZS5pbnRlcnBvbGF0ZV8gPSBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuXHRcdHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcblxuXHRcdHZhciBzdHJpZGUyID0gc3RyaWRlICogMjtcblx0XHR2YXIgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG5cblx0XHR2YXIgdGQgPSB0MSAtIHQwO1xuXG5cdFx0dmFyIHAgPSAoIHQgLSB0MCApIC8gdGQ7XG5cdFx0dmFyIHBwID0gcCAqIHA7XG5cdFx0dmFyIHBwcCA9IHBwICogcDtcblxuXHRcdHZhciBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuXHRcdHZhciBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZTM7XG5cblx0XHR2YXIgczIgPSAtIDIgKiBwcHAgKyAzICogcHA7XG5cdFx0dmFyIHMzID0gcHBwIC0gcHA7XG5cdFx0dmFyIHMwID0gMSAtIHMyO1xuXHRcdHZhciBzMSA9IHMzIC0gcHAgKyBwO1xuXG5cdFx0Ly8gTGF5b3V0IG9mIGtleWZyYW1lIG91dHB1dCB2YWx1ZXMgZm9yIENVQklDU1BMSU5FIGFuaW1hdGlvbnM6XG5cdFx0Ly8gICBbIGluVGFuZ2VudF8xLCBzcGxpbmVWZXJ0ZXhfMSwgb3V0VGFuZ2VudF8xLCBpblRhbmdlbnRfMiwgc3BsaW5lVmVydGV4XzIsIC4uLiBdXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUgXTsgLy8gc3BsaW5lVmVydGV4X2tcblx0XHRcdHZhciBtMCA9IHZhbHVlc1sgb2Zmc2V0MCArIGkgKyBzdHJpZGUyIF0gKiB0ZDsgLy8gb3V0VGFuZ2VudF9rICogKHRfaysxIC0gdF9rKVxuXHRcdFx0dmFyIHAxID0gdmFsdWVzWyBvZmZzZXQxICsgaSArIHN0cmlkZSBdOyAvLyBzcGxpbmVWZXJ0ZXhfaysxXG5cdFx0XHR2YXIgbTEgPSB2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB0ZDsgLy8gaW5UYW5nZW50X2srMSAqICh0X2srMSAtIHRfaylcblxuXHRcdFx0cmVzdWx0WyBpIF0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqIElOVEVSTkFMUyAqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyogQ09OU1RBTlRTICovXG5cblx0dmFyIFdFQkdMX0NPTlNUQU5UUyA9IHtcblx0XHRGTE9BVDogNTEyNixcblx0XHQvL0ZMT0FUX01BVDI6IDM1Njc0LFxuXHRcdEZMT0FUX01BVDM6IDM1Njc1LFxuXHRcdEZMT0FUX01BVDQ6IDM1Njc2LFxuXHRcdEZMT0FUX1ZFQzI6IDM1NjY0LFxuXHRcdEZMT0FUX1ZFQzM6IDM1NjY1LFxuXHRcdEZMT0FUX1ZFQzQ6IDM1NjY2LFxuXHRcdExJTkVBUjogOTcyOSxcblx0XHRSRVBFQVQ6IDEwNDk3LFxuXHRcdFNBTVBMRVJfMkQ6IDM1Njc4LFxuXHRcdFBPSU5UUzogMCxcblx0XHRMSU5FUzogMSxcblx0XHRMSU5FX0xPT1A6IDIsXG5cdFx0TElORV9TVFJJUDogMyxcblx0XHRUUklBTkdMRVM6IDQsXG5cdFx0VFJJQU5HTEVfU1RSSVA6IDUsXG5cdFx0VFJJQU5HTEVfRkFOOiA2LFxuXHRcdFVOU0lHTkVEX0JZVEU6IDUxMjEsXG5cdFx0VU5TSUdORURfU0hPUlQ6IDUxMjNcblx0fTtcblxuXHR2YXIgV0VCR0xfQ09NUE9ORU5UX1RZUEVTID0ge1xuXHRcdDUxMjA6IEludDhBcnJheSxcblx0XHQ1MTIxOiBVaW50OEFycmF5LFxuXHRcdDUxMjI6IEludDE2QXJyYXksXG5cdFx0NTEyMzogVWludDE2QXJyYXksXG5cdFx0NTEyNTogVWludDMyQXJyYXksXG5cdFx0NTEyNjogRmxvYXQzMkFycmF5XG5cdH07XG5cblx0dmFyIFdFQkdMX0ZJTFRFUlMgPSB7XG5cdFx0OTcyODogTmVhcmVzdEZpbHRlcixcblx0XHQ5NzI5OiBMaW5lYXJGaWx0ZXIsXG5cdFx0OTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG5cdFx0OTk4NTogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcblx0XHQ5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuXHRcdDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxuXHR9O1xuXG5cdHZhciBXRUJHTF9XUkFQUElOR1MgPSB7XG5cdFx0MzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG5cdFx0MzM2NDg6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG5cdFx0MTA0OTc6IFJlcGVhdFdyYXBwaW5nXG5cdH07XG5cblx0dmFyIFdFQkdMX1RZUEVfU0laRVMgPSB7XG5cdFx0J1NDQUxBUic6IDEsXG5cdFx0J1ZFQzInOiAyLFxuXHRcdCdWRUMzJzogMyxcblx0XHQnVkVDNCc6IDQsXG5cdFx0J01BVDInOiA0LFxuXHRcdCdNQVQzJzogOSxcblx0XHQnTUFUNCc6IDE2XG5cdH07XG5cblx0dmFyIEFUVFJJQlVURVMgPSB7XG5cdFx0UE9TSVRJT046ICdwb3NpdGlvbicsXG5cdFx0Tk9STUFMOiAnbm9ybWFsJyxcblx0XHRUQU5HRU5UOiAndGFuZ2VudCcsXG5cdFx0VEVYQ09PUkRfMDogJ3V2Jyxcblx0XHRURVhDT09SRF8xOiAndXYyJyxcblx0XHRDT0xPUl8wOiAnY29sb3InLFxuXHRcdFdFSUdIVFNfMDogJ3NraW5XZWlnaHQnLFxuXHRcdEpPSU5UU18wOiAnc2tpbkluZGV4Jyxcblx0fTtcblxuXHR2YXIgUEFUSF9QUk9QRVJUSUVTID0ge1xuXHRcdHNjYWxlOiAnc2NhbGUnLFxuXHRcdHRyYW5zbGF0aW9uOiAncG9zaXRpb24nLFxuXHRcdHJvdGF0aW9uOiAncXVhdGVybmlvbicsXG5cdFx0d2VpZ2h0czogJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcydcblx0fTtcblxuXHR2YXIgSU5URVJQT0xBVElPTiA9IHtcblx0XHRDVUJJQ1NQTElORTogdW5kZWZpbmVkLCAvLyBXZSB1c2UgYSBjdXN0b20gaW50ZXJwb2xhbnQgKEdMVEZDdWJpY1NwbGluZUludGVycG9sYXRpb24pIGZvciBDVUJJQ1NQTElORSB0cmFja3MuIEVhY2hcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cblx0XHRMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuXHRcdFNURVA6IEludGVycG9sYXRlRGlzY3JldGVcblx0fTtcblxuXHR2YXIgQUxQSEFfTU9ERVMgPSB7XG5cdFx0T1BBUVVFOiAnT1BBUVVFJyxcblx0XHRNQVNLOiAnTUFTSycsXG5cdFx0QkxFTkQ6ICdCTEVORCdcblx0fTtcblxuXHQvKiBVVElMSVRZIEZVTkNUSU9OUyAqL1xuXG5cdGZ1bmN0aW9uIHJlc29sdmVVUkwoIHVybCwgcGF0aCApIHtcblxuXHRcdC8vIEludmFsaWQgVVJMXG5cdFx0aWYgKCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJyB8fCB1cmwgPT09ICcnICkgcmV0dXJuICcnO1xuXG5cdFx0Ly8gSG9zdCBSZWxhdGl2ZSBVUkxcblx0XHRpZiAoIC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoIHBhdGggKSAmJiAvXlxcLy8udGVzdCggdXJsICkgKSB7XG5cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoIC8oXmh0dHBzPzpcXC9cXC9bXlxcL10rKS4qL2ksICckMScgKTtcblxuXHRcdH1cblxuXHRcdC8vIEFic29sdXRlIFVSTCBodHRwOi8vLGh0dHBzOi8vLC8vXG5cdFx0aWYgKCAvXihodHRwcz86KT9cXC9cXC8vaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHQvLyBEYXRhIFVSSVxuXHRcdGlmICggL15kYXRhOi4qLC4qJC9pLnRlc3QoIHVybCApICkgcmV0dXJuIHVybDtcblxuXHRcdC8vIEJsb2IgVVJMXG5cdFx0aWYgKCAvXmJsb2I6LiokL2kudGVzdCggdXJsICkgKSByZXR1cm4gdXJsO1xuXG5cdFx0Ly8gUmVsYXRpdmUgVVJMXG5cdFx0cmV0dXJuIHBhdGggKyB1cmw7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2RlZmF1bHQtbWF0ZXJpYWxcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNYXRlcmlhbCggY2FjaGUgKSB7XG5cblx0XHRpZiAoIGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKCB7XG5cdFx0XHRcdGNvbG9yOiAweEZGRkZGRixcblx0XHRcdFx0ZW1pc3NpdmU6IDB4MDAwMDAwLFxuXHRcdFx0XHRtZXRhbG5lc3M6IDEsXG5cdFx0XHRcdHJvdWdobmVzczogMSxcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IGZhbHNlLFxuXHRcdFx0XHRkZXB0aFRlc3Q6IHRydWUsXG5cdFx0XHRcdHNpZGU6IEZyb250U2lkZVxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhY2hlWyAnRGVmYXVsdE1hdGVyaWFsJyBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGtub3duRXh0ZW5zaW9ucywgb2JqZWN0LCBvYmplY3REZWYgKSB7XG5cblx0XHQvLyBBZGQgdW5rbm93biBnbFRGIGV4dGVuc2lvbnMgdG8gYW4gb2JqZWN0J3MgdXNlckRhdGEuXG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucyApIHtcblxuXHRcdFx0aWYgKCBrbm93bkV4dGVuc2lvbnNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyA9IG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyB8fCB7fTtcblx0XHRcdFx0b2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zWyBuYW1lIF0gPSBvYmplY3REZWYuZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdDNEfE1hdGVyaWFsfEJ1ZmZlckdlb21ldHJ5fSBvYmplY3Rcblx0ICogQHBhcmFtIHtHTFRGLmRlZmluaXRpb259IGdsdGZEZWZcblx0ICovXG5cdGZ1bmN0aW9uIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG9iamVjdCwgZ2x0ZkRlZiApIHtcblxuXHRcdGlmICggZ2x0ZkRlZi5leHRyYXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09ICdvYmplY3QnICkge1xuXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24oIG9iamVjdC51c2VyRGF0YSwgZ2x0ZkRlZi5leHRyYXMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCAnICsgZ2x0ZkRlZi5leHRyYXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtb3JwaC10YXJnZXRzXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdCAqIEBwYXJhbSB7QXJyYXk8R0xURi5UYXJnZXQ+fSB0YXJnZXRzXG5cdCAqIEBwYXJhbSB7R0xURlBhcnNlcn0gcGFyc2VyXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyR2VvbWV0cnk+fVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKCBnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyICkge1xuXG5cdFx0dmFyIGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcblx0XHR2YXIgaGFzTW9ycGhOb3JtYWwgPSBmYWxzZTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRpZiAoIHRhcmdldC5QT1NJVElPTiAhPT0gdW5kZWZpbmVkICkgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG5cdFx0XHRpZiAoIHRhcmdldC5OT1JNQUwgIT09IHVuZGVmaW5lZCApIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICkgYnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgaGFzTW9ycGhQb3NpdGlvbiAmJiAhIGhhc01vcnBoTm9ybWFsICkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSggZ2VvbWV0cnkgKTtcblxuXHRcdHZhciBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB0YXJnZXQgPSB0YXJnZXRzWyBpIF07XG5cblx0XHRcdGlmICggaGFzTW9ycGhQb3NpdGlvbiApIHtcblxuXHRcdFx0XHR2YXIgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IHBhcnNlci5nZXREZXBlbmRlbmN5KCAnYWNjZXNzb3InLCB0YXJnZXQuUE9TSVRJT04gKVxuXHRcdFx0XHRcdDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMucHVzaCggcGVuZGluZ0FjY2Vzc29yICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHR2YXIgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0PyBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgdGFyZ2V0Lk5PUk1BTCApXG5cdFx0XHRcdFx0OiBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0XHRwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2goIHBlbmRpbmdBY2Nlc3NvciApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzIClcblx0XHRdICkudGhlbiggZnVuY3Rpb24gKCBhY2Nlc3NvcnMgKSB7XG5cblx0XHRcdHZhciBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1sgMCBdO1xuXHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sgMSBdO1xuXG5cdFx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcblx0XHRcdGlmICggaGFzTW9ycGhOb3JtYWwgKSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuXHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge01lc2h9IG1lc2hcblx0ICogQHBhcmFtIHtHTFRGLk1lc2h9IG1lc2hEZWZcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyggbWVzaCwgbWVzaERlZiApIHtcblxuXHRcdG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cblx0XHRpZiAoIG1lc2hEZWYud2VpZ2h0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWVzaERlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBtZXNoRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gLmV4dHJhcyBoYXMgdXNlci1kZWZpbmVkIGRhdGEsIHNvIGNoZWNrIHRoYXQgLmV4dHJhcy50YXJnZXROYW1lcyBpcyBhbiBhcnJheS5cblx0XHRpZiAoIG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkoIG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzICkgKSB7XG5cblx0XHRcdHZhciB0YXJnZXROYW1lcyA9IG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzO1xuXG5cdFx0XHRpZiAoIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRhcmdldE5hbWVzWyBpIF0gXSA9IGk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleSggcHJpbWl0aXZlRGVmICkge1xuXG5cdFx0dmFyIGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXTtcblx0XHR2YXIgZ2VvbWV0cnlLZXk7XG5cblx0XHRpZiAoIGRyYWNvRXh0ZW5zaW9uICkge1xuXG5cdFx0XHRnZW9tZXRyeUtleSA9ICdkcmFjbzonICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlld1xuXHRcdFx0XHQrICc6JyArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXNcblx0XHRcdFx0KyAnOicgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRnZW9tZXRyeUtleSA9IHByaW1pdGl2ZURlZi5pbmRpY2VzICsgJzonICsgY3JlYXRlQXR0cmlidXRlc0tleSggcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMgKSArICc6JyArIHByaW1pdGl2ZURlZi5tb2RlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5S2V5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVzS2V5KCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXNLZXkgPSAnJztcblxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIGF0dHJpYnV0ZXMgKS5zb3J0KCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0YXR0cmlidXRlc0tleSArPSBrZXlzWyBpIF0gKyAnOicgKyBhdHRyaWJ1dGVzWyBrZXlzWyBpIF0gXSArICc7JztcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzS2V5O1xuXG5cdH1cblxuXHQvKiBHTFRGIFBBUlNFUiAqL1xuXG5cdGZ1bmN0aW9uIEdMVEZQYXJzZXIoIGpzb24sIG9wdGlvbnMgKSB7XG5cblx0XHR0aGlzLmpzb24gPSBqc29uIHx8IHt9O1xuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuXHRcdHRoaXMucGx1Z2lucyA9IHt9O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBsb2FkZXIgb2JqZWN0IGNhY2hlXG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcblxuXHRcdC8vIGFzc29jaWF0aW9ucyBiZXR3ZWVuIFRocmVlLmpzIG9iamVjdHMgYW5kIGdsVEYgZWxlbWVudHNcblx0XHR0aGlzLmFzc29jaWF0aW9ucyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEJ1ZmZlckdlb21ldHJ5IGNhY2hpbmdcblx0XHR0aGlzLnByaW1pdGl2ZUNhY2hlID0ge307XG5cblx0XHQvLyBPYmplY3QzRCBpbnN0YW5jZSBjYWNoZXNcblx0XHR0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG5cdFx0dGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcblxuXHRcdC8vIFRyYWNrIG5vZGUgbmFtZXMsIHRvIGVuc3VyZSBubyBkdXBsaWNhdGVzXG5cdFx0dGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG5cblx0XHQvLyBVc2UgYW4gSW1hZ2VCaXRtYXBMb2FkZXIgaWYgaW1hZ2VCaXRtYXBzIGFyZSBzdXBwb3J0ZWQuIE1vdmVzIG11Y2ggb2YgdGhlXG5cdFx0Ly8gZXhwZW5zaXZlIHdvcmsgb2YgdXBsb2FkaW5nIGEgdGV4dHVyZSB0byB0aGUgR1BVIG9mZiB0aGUgbWFpbiB0aHJlYWQuXG5cdFx0aWYgKCB0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIC9GaXJlZm94Ly50ZXN0KCBuYXZpZ2F0b3IudXNlckFnZW50ICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgSW1hZ2VCaXRtYXBMb2FkZXIoIHRoaXMub3B0aW9ucy5tYW5hZ2VyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5vcHRpb25zLm1hbmFnZXIgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luICk7XG5cdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVyICk7XG5cblx0XHR0aGlzLmZpbGVMb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5vcHRpb25zLm1hbmFnZXIgKTtcblx0XHR0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycgKSB7XG5cblx0XHRcdHRoaXMuZmlsZUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRydWUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0R0xURlBhcnNlci5wcm90b3R5cGUuc2V0RXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICggZXh0ZW5zaW9ucyApIHtcblxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5zZXRQbHVnaW5zID0gZnVuY3Rpb24gKCBwbHVnaW5zICkge1xuXG5cdFx0dGhpcy5wbHVnaW5zID0gcGx1Z2lucztcblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdC8vIENsZWFyIHRoZSBsb2FkZXIgY2FjaGVcblx0XHR0aGlzLmNhY2hlLnJlbW92ZUFsbCgpO1xuXG5cdFx0Ly8gTWFyayB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlXG5cdFx0dGhpcy5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dC5fbWFya0RlZnMgJiYgZXh0Ll9tYXJrRGVmcygpO1xuXG5cdFx0fSApO1xuXG5cdFx0UHJvbWlzZS5hbGwoIHRoaXMuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuXG5cdFx0fSApICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0XHRwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKCAnc2NlbmUnICksXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdhbmltYXRpb24nICksXG5cdFx0XHRcdHBhcnNlci5nZXREZXBlbmRlbmNpZXMoICdjYW1lcmEnICksXG5cblx0XHRcdF0gKTtcblxuXHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdFx0c2NlbmU6IGRlcGVuZGVuY2llc1sgMCBdWyBqc29uLnNjZW5lIHx8IDAgXSxcblx0XHRcdFx0c2NlbmVzOiBkZXBlbmRlbmNpZXNbIDAgXSxcblx0XHRcdFx0YW5pbWF0aW9uczogZGVwZW5kZW5jaWVzWyAxIF0sXG5cdFx0XHRcdGNhbWVyYXM6IGRlcGVuZGVuY2llc1sgMiBdLFxuXHRcdFx0XHRhc3NldDoganNvbi5hc3NldCxcblx0XHRcdFx0cGFyc2VyOiBwYXJzZXIsXG5cdFx0XHRcdHVzZXJEYXRhOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0YWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCByZXN1bHQsIGpzb24gKTtcblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggcmVzdWx0LCBqc29uICk7XG5cblx0XHRcdFByb21pc2UuYWxsKCBwYXJzZXIuX2ludm9rZUFsbCggZnVuY3Rpb24gKCBleHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdCggcmVzdWx0ICk7XG5cblx0XHRcdH0gKSApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRvbkxvYWQoIHJlc3VsdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICkuY2F0Y2goIG9uRXJyb3IgKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXJrcyB0aGUgc3BlY2lhbCBub2Rlcy9tZXNoZXMgaW4ganNvbiBmb3IgZWZmaWNpZW50IHBhcnNlLlxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuX21hcmtEZWZzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG5vZGVEZWZzID0gdGhpcy5qc29uLm5vZGVzIHx8IFtdO1xuXHRcdHZhciBza2luRGVmcyA9IHRoaXMuanNvbi5za2lucyB8fCBbXTtcblx0XHR2YXIgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuXG5cdFx0Ly8gTm90aGluZyBpbiB0aGUgbm9kZSBkZWZpbml0aW9uIGluZGljYXRlcyB3aGV0aGVyIGl0IGlzIGEgQm9uZSBvciBhblxuXHRcdC8vIE9iamVjdDNELiBVc2UgdGhlIHNraW5zJyBqb2ludCByZWZlcmVuY2VzIHRvIG1hcmsgYm9uZXMuXG5cdFx0Zm9yICggdmFyIHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCArKyApIHtcblxuXHRcdFx0dmFyIGpvaW50cyA9IHNraW5EZWZzWyBza2luSW5kZXggXS5qb2ludHM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBqb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bm9kZURlZnNbIGpvaW50c1sgaSBdIF0uaXNCb25lID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgbWFya2luZyByZWZlcmVuY2VzIHRvIHNoYXJlZCByZXNvdXJjZXMsXG5cdFx0Ly8gYXMgd2VsbCBhcyBza2VsZXRvbiBqb2ludHMuXG5cdFx0Zm9yICggdmFyIG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCArKyApIHtcblxuXHRcdFx0dmFyIG5vZGVEZWYgPSBub2RlRGVmc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdGlmICggbm9kZURlZi5tZXNoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fYWRkTm9kZVJlZiggdGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCApO1xuXG5cdFx0XHRcdC8vIE5vdGhpbmcgaW4gdGhlIG1lc2ggZGVmaW5pdGlvbiBpbmRpY2F0ZXMgd2hldGhlciBpdCBpc1xuXHRcdFx0XHQvLyBhIFNraW5uZWRNZXNoIG9yIE1lc2guIFVzZSB0aGUgbm9kZSdzIG1lc2ggcmVmZXJlbmNlXG5cdFx0XHRcdC8vIHRvIG1hcmsgU2tpbm5lZE1lc2ggaWYgbm9kZSBoYXMgc2tpbi5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnNraW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG1lc2hEZWZzWyBub2RlRGVmLm1lc2ggXS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlRGVmLmNhbWVyYSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuX2FkZE5vZGVSZWYoIHRoaXMuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb3VudHMgcmVmZXJlbmNlcyB0byBzaGFyZWQgbm9kZSAvIE9iamVjdDNEIHJlc291cmNlcy4gVGhlc2UgcmVzb3VyY2VzXG5cdCAqIGNhbiBiZSByZXVzZWQsIG9yIFwiaW5zdGFudGlhdGVkXCIsIGF0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBzY2VuZVxuXHQgKiBoaWVyYXJjaHkuIE1lc2gsIENhbWVyYSwgYW5kIExpZ2h0IGluc3RhbmNlcyBhcmUgaW5zdGFudGlhdGVkIGFuZCBtdXN0XG5cdCAqIGJlIG1hcmtlZC4gTm9uLXNjZW5lZ3JhcGggcmVzb3VyY2VzIChsaWtlIE1hdGVyaWFscywgR2VvbWV0cmllcywgYW5kXG5cdCAqIFRleHR1cmVzKSBjYW4gYmUgcmV1c2VkIGRpcmVjdGx5IGFuZCBhcmUgbm90IG1hcmtlZCBoZXJlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOiBDZXNpdW1NaWxrVHJ1Y2sgc2FtcGxlIG1vZGVsIHJldXNlcyBcIldoZWVsXCIgbWVzaGVzLlxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuX2FkZE5vZGVSZWYgPSBmdW5jdGlvbiAoIGNhY2hlLCBpbmRleCApIHtcblxuXHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdGlmICggY2FjaGUucmVmc1sgaW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjYWNoZS5yZWZzWyBpbmRleCBdID0gY2FjaGUudXNlc1sgaW5kZXggXSA9IDA7XG5cblx0XHR9XG5cblx0XHRjYWNoZS5yZWZzWyBpbmRleCBdICsrO1xuXG5cdH07XG5cblx0LyoqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gYSBzaGFyZWQgcmVzb3VyY2UsIGNsb25pbmcgaXQgaWYgbmVjZXNzYXJ5LiAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5fZ2V0Tm9kZVJlZiA9IGZ1bmN0aW9uICggY2FjaGUsIGluZGV4LCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGNhY2hlLnJlZnNbIGluZGV4IF0gPD0gMSApIHJldHVybiBvYmplY3Q7XG5cblx0XHR2YXIgcmVmID0gb2JqZWN0LmNsb25lKCk7XG5cblx0XHRyZWYubmFtZSArPSAnX2luc3RhbmNlXycgKyAoIGNhY2hlLnVzZXNbIGluZGV4IF0gKysgKTtcblxuXHRcdHJldHVybiByZWY7XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5faW52b2tlT25lID0gZnVuY3Rpb24gKCBmdW5jICkge1xuXG5cdFx0dmFyIGV4dGVuc2lvbnMgPSBPYmplY3QudmFsdWVzKCB0aGlzLnBsdWdpbnMgKTtcblx0XHRleHRlbnNpb25zLnB1c2goIHRoaXMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyggZXh0ZW5zaW9uc1sgaSBdICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLl9pbnZva2VBbGwgPSBmdW5jdGlvbiAoIGZ1bmMgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXMoIHRoaXMucGx1Z2lucyApO1xuXHRcdGV4dGVuc2lvbnMudW5zaGlmdCggdGhpcyApO1xuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gZnVuYyggZXh0ZW5zaW9uc1sgaSBdICk7XG5cblx0XHRcdGlmICggcmVzdWx0ICkgcGVuZGluZy5wdXNoKCByZXN1bHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwZW5kaW5nO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBhc3luY2hyb25vdXNseSwgd2l0aCBjYWNoaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRHxNYXRlcmlhbHxUSFJFRS5UZXh0dXJlfEFuaW1hdGlvbkNsaXB8QXJyYXlCdWZmZXJ8T2JqZWN0Pn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmdldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoIHR5cGUsIGluZGV4ICkge1xuXG5cdFx0dmFyIGNhY2hlS2V5ID0gdHlwZSArICc6JyArIGluZGV4O1xuXHRcdHZhciBkZXBlbmRlbmN5ID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRpZiAoICEgZGVwZW5kZW5jeSApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdzY2VuZSc6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ25vZGUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWROb2RlKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21lc2gnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaCggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhY2Nlc3Nvcic6XG5cdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2J1ZmZlclZpZXcnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRCdWZmZXJWaWV3ICYmIGV4dC5sb2FkQnVmZmVyVmlldyggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdidWZmZXInOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWwnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRNYXRlcmlhbCAmJiBleHQubG9hZE1hdGVyaWFsKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXh0LmxvYWRUZXh0dXJlICYmIGV4dC5sb2FkVGV4dHVyZSggaW5kZXggKTtcblxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdza2luJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbiggaW5kZXggKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdhbmltYXRpb24nOlxuXHRcdFx0XHRcdGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBbmltYXRpb24oIGluZGV4ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnY2FtZXJhJzpcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gdGhpcy5sb2FkQ2FtZXJhKCBpbmRleCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5rbm93biB0eXBlOiAnICsgdHlwZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgZGVwZW5kZW5jeSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlcGVuZGVuY3k7XG5cblx0fTtcblxuXHQvKipcblx0ICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmdldERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uICggdHlwZSApIHtcblxuXHRcdHZhciBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCggdHlwZSApO1xuXG5cdFx0aWYgKCAhIGRlcGVuZGVuY2llcyApIHtcblxuXHRcdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0XHR2YXIgZGVmcyA9IHRoaXMuanNvblsgdHlwZSArICggdHlwZSA9PT0gJ21lc2gnID8gJ2VzJyA6ICdzJyApIF0gfHwgW107XG5cblx0XHRcdGRlcGVuZGVuY2llcyA9IFByb21pc2UuYWxsKCBkZWZzLm1hcCggZnVuY3Rpb24gKCBkZWYsIGluZGV4ICkge1xuXG5cdFx0XHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggdHlwZSwgaW5kZXggKTtcblxuXHRcdFx0fSApICk7XG5cblx0XHRcdHRoaXMuY2FjaGUuYWRkKCB0eXBlLCBkZXBlbmRlbmNpZXMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkZXBlbmRlbmNpZXM7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3Ncblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZEJ1ZmZlciA9IGZ1bmN0aW9uICggYnVmZmVySW5kZXggKSB7XG5cblx0XHR2YXIgYnVmZmVyRGVmID0gdGhpcy5qc29uLmJ1ZmZlcnNbIGJ1ZmZlckluZGV4IF07XG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuZmlsZUxvYWRlcjtcblxuXHRcdGlmICggYnVmZmVyRGVmLnR5cGUgJiYgYnVmZmVyRGVmLnR5cGUgIT09ICdhcnJheWJ1ZmZlcicgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6ICcgKyBidWZmZXJEZWYudHlwZSArICcgYnVmZmVyIHR5cGUgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHQvLyBJZiBwcmVzZW50LCBHTEIgY29udGFpbmVyIGlzIHJlcXVpcmVkIHRvIGJlIHRoZSBmaXJzdCBidWZmZXIuXG5cdFx0aWYgKCBidWZmZXJEZWYudXJpID09PSB1bmRlZmluZWQgJiYgYnVmZmVySW5kZXggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIHRoaXMuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEYgXS5ib2R5ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCByZXNvbHZlVVJMKCBidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGggKSwgcmVzb2x2ZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmVqZWN0KCBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nICkgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkQnVmZmVyVmlldyA9IGZ1bmN0aW9uICggYnVmZmVyVmlld0luZGV4ICkge1xuXG5cdFx0dmFyIGJ1ZmZlclZpZXdEZWYgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbIGJ1ZmZlclZpZXdJbmRleCBdO1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlcicsIGJ1ZmZlclZpZXdEZWYuYnVmZmVyICkudGhlbiggZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHZhciBieXRlTGVuZ3RoID0gYnVmZmVyVmlld0RlZi5ieXRlTGVuZ3RoIHx8IDA7XG5cdFx0XHR2YXIgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci5zbGljZSggYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkQWNjZXNzb3IgPSBmdW5jdGlvbiAoIGFjY2Vzc29ySW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblxuXHRcdHZhciBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbIGFjY2Vzc29ySW5kZXggXTtcblxuXHRcdGlmICggYWNjZXNzb3JEZWYuYnVmZmVyVmlldyA9PT0gdW5kZWZpbmVkICYmIGFjY2Vzc29yRGVmLnNwYXJzZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBJZ25vcmUgZW1wdHkgYWNjZXNzb3JzLCB3aGljaCBtYXkgYmUgdXNlZCB0byBkZWNsYXJlIHJ1bnRpbWVcblx0XHRcdC8vIGluZm9ybWF0aW9uIGFib3V0IGF0dHJpYnV0ZXMgY29taW5nIGZyb20gYW5vdGhlciBzb3VyY2UgKGUuZy4gRHJhY29cblx0XHRcdC8vIGNvbXByZXNzaW9uIGV4dGVuc2lvbikuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBudWxsICk7XG5cblx0XHR9XG5cblx0XHR2YXIgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKCBudWxsICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwZW5kaW5nQnVmZmVyVmlld3MucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnYnVmZmVyVmlldycsIGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ1ZmZlclZpZXcgKSApO1xuXHRcdFx0cGVuZGluZ0J1ZmZlclZpZXdzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2J1ZmZlclZpZXcnLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nQnVmZmVyVmlld3MgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXdzICkge1xuXG5cdFx0XHR2YXIgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWyAwIF07XG5cblx0XHRcdHZhciBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbIGFjY2Vzc29yRGVmLnR5cGUgXTtcblx0XHRcdHZhciBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdC8vIEZvciBWRUMzOiBpdGVtU2l6ZSBpcyAzLCBlbGVtZW50Qnl0ZXMgaXMgNCwgaXRlbUJ5dGVzIGlzIDEyLlxuXHRcdFx0dmFyIGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG5cdFx0XHR2YXIgaXRlbUJ5dGVzID0gZWxlbWVudEJ5dGVzICogaXRlbVNpemU7XG5cdFx0XHR2YXIgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcblx0XHRcdHZhciBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdW5kZWZpbmVkID8ganNvbi5idWZmZXJWaWV3c1sgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyBdLmJ5dGVTdHJpZGUgOiB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG5cdFx0XHR2YXIgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdFx0Ly8gVGhlIGJ1ZmZlciBpcyBub3QgaW50ZXJsZWF2ZWQgaWYgdGhlIHN0cmlkZSBpcyB0aGUgaXRlbSBzaXplIGluIGJ5dGVzLlxuXHRcdFx0aWYgKCBieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcyApIHtcblxuXHRcdFx0XHQvLyBFYWNoIFwic2xpY2VcIiBvZiB0aGUgYnVmZmVyLCBhcyBkZWZpbmVkIGJ5ICdjb3VudCcgZWxlbWVudHMgb2YgJ2J5dGVTdHJpZGUnIGJ5dGVzLCBnZXRzIGl0cyBvd24gSW50ZXJsZWF2ZWRCdWZmZXJcblx0XHRcdFx0Ly8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgSUJBLmNvdW50IHJlZmxlY3RzIGFjY2Vzc29yLmNvdW50IHByb3Blcmx5XG5cdFx0XHRcdHZhciBpYlNsaWNlID0gTWF0aC5mbG9vciggYnl0ZU9mZnNldCAvIGJ5dGVTdHJpZGUgKTtcblx0XHRcdFx0dmFyIGliQ2FjaGVLZXkgPSAnSW50ZXJsZWF2ZWRCdWZmZXI6JyArIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgKyAnOicgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlICsgJzonICsgaWJTbGljZSArICc6JyArIGFjY2Vzc29yRGVmLmNvdW50O1xuXHRcdFx0XHR2YXIgaWIgPSBwYXJzZXIuY2FjaGUuZ2V0KCBpYkNhY2hlS2V5ICk7XG5cblx0XHRcdFx0aWYgKCAhIGliICkge1xuXG5cdFx0XHRcdFx0YXJyYXkgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlldywgaWJTbGljZSAqIGJ5dGVTdHJpZGUsIGFjY2Vzc29yRGVmLmNvdW50ICogYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyApO1xuXG5cdFx0XHRcdFx0Ly8gSW50ZWdlciBwYXJhbWV0ZXJzIHRvIElCL0lCQSBhcmUgaW4gYXJyYXkgZWxlbWVudHMsIG5vdCBieXRlcy5cblx0XHRcdFx0XHRpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMgKTtcblxuXHRcdFx0XHRcdHBhcnNlci5jYWNoZS5hZGQoIGliQ2FjaGVLZXksIGliICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaWIsIGl0ZW1TaXplLCAoIGJ5dGVPZmZzZXQgJSBieXRlU3RyaWRlICkgLyBlbGVtZW50Qnl0ZXMsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGJ1ZmZlclZpZXcgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRhcnJheSA9IG5ldyBUeXBlZEFycmF5KCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoIGJ1ZmZlclZpZXcsIGJ5dGVPZmZzZXQsIGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNzcGFyc2UtYWNjZXNzb3JzXG5cdFx0XHRpZiAoIGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBpdGVtU2l6ZUluZGljZXMgPSBXRUJHTF9UWVBFX1NJWkVTLlNDQUxBUjtcblx0XHRcdFx0dmFyIFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTWyBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlIF07XG5cblx0XHRcdFx0dmFyIGJ5dGVPZmZzZXRJbmRpY2VzID0gYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnl0ZU9mZnNldCB8fCAwO1xuXHRcdFx0XHR2YXIgYnl0ZU9mZnNldFZhbHVlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnl0ZU9mZnNldCB8fCAwO1xuXG5cdFx0XHRcdHZhciBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKCBidWZmZXJWaWV3c1sgMSBdLCBieXRlT2Zmc2V0SW5kaWNlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemVJbmRpY2VzICk7XG5cdFx0XHRcdHZhciBzcGFyc2VWYWx1ZXMgPSBuZXcgVHlwZWRBcnJheSggYnVmZmVyVmlld3NbIDIgXSwgYnl0ZU9mZnNldFZhbHVlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemUgKTtcblxuXHRcdFx0XHRpZiAoIGJ1ZmZlclZpZXcgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHQvLyBBdm9pZCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyLCBpZiB0aGUgYnVmZmVyVmlldyB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCB6ZXJvZXMuXG5cdFx0XHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksIGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSwgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNwYXJzZUluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSBzcGFyc2VJbmRpY2VzWyBpIF07XG5cblx0XHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUuc2V0WCggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDIgKSBidWZmZXJBdHRyaWJ1dGUuc2V0WSggaW5kZXgsIHNwYXJzZVZhbHVlc1sgaSAqIGl0ZW1TaXplICsgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAzICkgYnVmZmVyQXR0cmlidXRlLnNldFooIGluZGV4LCBzcGFyc2VWYWx1ZXNbIGkgKiBpdGVtU2l6ZSArIDIgXSApO1xuXHRcdFx0XHRcdGlmICggaXRlbVNpemUgPj0gNCApIGJ1ZmZlckF0dHJpYnV0ZS5zZXRXKCBpbmRleCwgc3BhcnNlVmFsdWVzWyBpICogaXRlbVNpemUgKyAzIF0gKTtcblx0XHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDUgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLicgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmU+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmVJbmRleCApIHtcblxuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cdFx0dmFyIHNvdXJjZSA9IGpzb24uaW1hZ2VzWyB0ZXh0dXJlRGVmLnNvdXJjZSBdO1xuXG5cdFx0dmFyIGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcblxuXHRcdGlmICggc291cmNlLnVyaSApIHtcblxuXHRcdFx0dmFyIGhhbmRsZXIgPSBvcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlciggc291cmNlLnVyaSApO1xuXHRcdFx0aWYgKCBoYW5kbGVyICE9PSBudWxsICkgbG9hZGVyID0gaGFuZGxlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKTtcblxuXHR9O1xuXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRUZXh0dXJlSW1hZ2UgPSBmdW5jdGlvbiAoIHRleHR1cmVJbmRleCwgc291cmNlLCBsb2FkZXIgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdHZhciB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1sgdGV4dHVyZUluZGV4IF07XG5cblx0XHR2YXIgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG5cblx0XHR2YXIgc291cmNlVVJJID0gc291cmNlLnVyaTtcblx0XHR2YXIgaXNPYmplY3RVUkwgPSBmYWxzZTtcblx0XHR2YXIgaGFzQWxwaGEgPSB0cnVlO1xuXG5cdFx0aWYgKCBzb3VyY2UubWltZVR5cGUgPT09ICdpbWFnZS9qcGVnJyApIGhhc0FscGhhID0gZmFsc2U7XG5cblx0XHRpZiAoIHNvdXJjZS5idWZmZXJWaWV3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIExvYWQgYmluYXJ5IGltYWdlIGRhdGEgZnJvbSBidWZmZXJWaWV3LCBpZiBwcm92aWRlZC5cblxuXHRcdFx0c291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koICdidWZmZXJWaWV3Jywgc291cmNlLmJ1ZmZlclZpZXcgKS50aGVuKCBmdW5jdGlvbiAoIGJ1ZmZlclZpZXcgKSB7XG5cblx0XHRcdFx0aWYgKCBzb3VyY2UubWltZVR5cGUgPT09ICdpbWFnZS9wbmcnICkge1xuXG5cdFx0XHRcdFx0Ly8gSW5zcGVjdCB0aGUgUE5HICdJSERSJyBjaHVuayB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW1hZ2UgY291bGQgaGF2ZSBhblxuXHRcdFx0XHRcdC8vIGFscGhhIGNoYW5uZWwuIFRoaXMgY2hlY2sgaXMgY29uc2VydmF0aXZlIOKAlCB0aGUgaW1hZ2UgY291bGQgaGF2ZSBhbiBhbHBoYVxuXHRcdFx0XHRcdC8vIGNoYW5uZWwgd2l0aCBhbGwgdmFsdWVzID09IDEsIGFuZCB0aGUgaW5kZXhlZCB0eXBlIChjb2xvclR5cGUgPT0gMykgb25seVxuXHRcdFx0XHRcdC8vIHNvbWV0aW1lcyBjb250YWlucyBhbHBoYS5cblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvcnRhYmxlX05ldHdvcmtfR3JhcGhpY3MjRmlsZV9oZWFkZXJcblx0XHRcdFx0XHR2YXIgY29sb3JUeXBlID0gbmV3IERhdGFWaWV3KCBidWZmZXJWaWV3LCAyNSwgMSApLmdldFVpbnQ4KCAwLCBmYWxzZSApO1xuXHRcdFx0XHRcdGhhc0FscGhhID0gY29sb3JUeXBlID09PSA2IHx8IGNvbG9yVHlwZSA9PT0gNCB8fCBjb2xvclR5cGUgPT09IDM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlzT2JqZWN0VVJMID0gdHJ1ZTtcblx0XHRcdFx0dmFyIGJsb2IgPSBuZXcgQmxvYiggWyBidWZmZXJWaWV3IF0sIHsgdHlwZTogc291cmNlLm1pbWVUeXBlIH0gKTtcblx0XHRcdFx0c291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTCggYmxvYiApO1xuXHRcdFx0XHRyZXR1cm4gc291cmNlVVJJO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBzb3VyY2UudXJpID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkdMVEZMb2FkZXI6IEltYWdlICcgKyB0ZXh0dXJlSW5kZXggKyAnIGlzIG1pc3NpbmcgVVJJIGFuZCBidWZmZXJWaWV3JyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSggc291cmNlVVJJICkudGhlbiggZnVuY3Rpb24gKCBzb3VyY2VVUkkgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSggZnVuY3Rpb24gKCByZXNvbHZlLCByZWplY3QgKSB7XG5cblx0XHRcdFx0dmFyIG9uTG9hZCA9IHJlc29sdmU7XG5cblx0XHRcdFx0aWYgKCBsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdG9uTG9hZCA9IGZ1bmN0aW9uICggaW1hZ2VCaXRtYXAgKSB7XG5cblx0XHRcdFx0XHRcdHJlc29sdmUoIG5ldyBDYW52YXNUZXh0dXJlKCBpbWFnZUJpdG1hcCApICk7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb2FkZXIubG9hZCggcmVzb2x2ZVVSTCggc291cmNlVVJJLCBvcHRpb25zLnBhdGggKSwgb25Mb2FkLCB1bmRlZmluZWQsIHJlamVjdCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9ICkudGhlbiggZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdFx0XHQvLyBDbGVhbiB1cCByZXNvdXJjZXMgYW5kIGNvbmZpZ3VyZSBUZXh0dXJlLlxuXG5cdFx0XHRpZiAoIGlzT2JqZWN0VVJMID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoIHNvdXJjZVVSSSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlRGVmLm5hbWUgKSB0ZXh0dXJlLm5hbWUgPSB0ZXh0dXJlRGVmLm5hbWU7XG5cblx0XHRcdC8vIFdoZW4gdGhlcmUgaXMgZGVmaW5pdGVseSBubyBhbHBoYSBjaGFubmVsIGluIHRoZSB0ZXh0dXJlLCBzZXQgUkdCRm9ybWF0IHRvIHNhdmUgc3BhY2UuXG5cdFx0XHRpZiAoICEgaGFzQWxwaGEgKSB0ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcblxuXHRcdFx0dmFyIHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcblx0XHRcdHZhciBzYW1wbGVyID0gc2FtcGxlcnNbIHRleHR1cmVEZWYuc2FtcGxlciBdIHx8IHt9O1xuXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbIHNhbXBsZXIubWFnRmlsdGVyIF0gfHwgTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBXRUJHTF9GSUxURVJTWyBzYW1wbGVyLm1pbkZpbHRlciBdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcblx0XHRcdHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFMgXSB8fCBSZXBlYXRXcmFwcGluZztcblx0XHRcdHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1NbIHNhbXBsZXIud3JhcFQgXSB8fCBSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0cGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoIHRleHR1cmUsIHtcblx0XHRcdFx0dHlwZTogJ3RleHR1cmVzJyxcblx0XHRcdFx0aW5kZXg6IHRleHR1cmVJbmRleFxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSBhc3NpZ25zIGEgdGV4dHVyZSB0byB0aGUgZ2l2ZW4gbWF0ZXJpYWwgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsUGFyYW1zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXBEZWZcblx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmFzc2lnblRleHR1cmUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICd0ZXh0dXJlJywgbWFwRGVmLmluZGV4ICkudGhlbiggZnVuY3Rpb24gKCB0ZXh0dXJlICkge1xuXG5cdFx0XHQvLyBNYXRlcmlhbHMgc2FtcGxlIGFvTWFwIGZyb20gVVYgc2V0IDEgYW5kIG90aGVyIG1hcHMgZnJvbSBVViBzZXQgMCAtIHRoaXMgY2FuJ3QgYmUgY29uZmlndXJlZFxuXHRcdFx0Ly8gSG93ZXZlciwgd2Ugd2lsbCBjb3B5IFVWIHNldCAwIHRvIFVWIHNldCAxIG9uIGRlbWFuZCBmb3IgYW9NYXBcblx0XHRcdGlmICggbWFwRGVmLnRleENvb3JkICE9PSB1bmRlZmluZWQgJiYgbWFwRGVmLnRleENvb3JkICE9IDAgJiYgISAoIG1hcE5hbWUgPT09ICdhb01hcCcgJiYgbWFwRGVmLnRleENvb3JkID09IDEgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBDdXN0b20gVVYgc2V0ICcgKyBtYXBEZWYudGV4Q29vcmQgKyAnIGZvciB0ZXh0dXJlICcgKyBtYXBOYW1lICsgJyBub3QgeWV0IHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJzZXIuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXSApIHtcblxuXHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCA/IG1hcERlZi5leHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STSBdIDogdW5kZWZpbmVkO1xuXG5cdFx0XHRcdGlmICggdHJhbnNmb3JtICkge1xuXG5cdFx0XHRcdFx0dmFyIGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCggdGV4dHVyZSApO1xuXHRcdFx0XHRcdHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk0gXS5leHRlbmRUZXh0dXJlKCB0ZXh0dXJlLCB0cmFuc2Zvcm0gKTtcblx0XHRcdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggdGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtc1sgbWFwTmFtZSBdID0gdGV4dHVyZTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2Vcblx0ICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcblx0ICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcblx0ICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcblx0ICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuXHQgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5hc3NpZ25GaW5hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBtZXNoICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHR2YXIgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuXG5cdFx0dmFyIHVzZVZlcnRleFRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkO1xuXHRcdHZhciB1c2VTa2lubmluZyA9IG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZTtcblx0XHR2YXIgdXNlTW9ycGhUYXJnZXRzID0gT2JqZWN0LmtleXMoIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyApLmxlbmd0aCA+IDA7XG5cdFx0dmFyIHVzZU1vcnBoTm9ybWFscyA9IHVzZU1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIG1lc2guaXNQb2ludHMgKSB7XG5cblx0XHRcdHZhciBjYWNoZUtleSA9ICdQb2ludHNNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZDtcblxuXHRcdFx0dmFyIHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBwb2ludHNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuXHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuXHRcdFx0XHRwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTsgLy8gZ2xURiBzcGVjIHNheXMgcG9pbnRzIHNob3VsZCBiZSAxcHhcblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIHBvaW50c01hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcblxuXHRcdH0gZWxzZSBpZiAoIG1lc2guaXNMaW5lICkge1xuXG5cdFx0XHR2YXIgY2FjaGVLZXkgPSAnTGluZUJhc2ljTWF0ZXJpYWw6JyArIG1hdGVyaWFsLnV1aWQ7XG5cblx0XHRcdHZhciBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldCggY2FjaGVLZXkgKTtcblxuXHRcdFx0aWYgKCAhIGxpbmVNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcblx0XHRcdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggbGluZU1hdGVyaWFsLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRsaW5lTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblxuXHRcdFx0XHR0aGlzLmNhY2hlLmFkZCggY2FjaGVLZXksIGxpbmVNYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsID0gbGluZU1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgdGhlIG1hdGVyaWFsIGlmIGl0IHdpbGwgYmUgbW9kaWZpZWRcblx0XHRpZiAoIHVzZVZlcnRleFRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZyB8fCB1c2VTa2lubmluZyB8fCB1c2VNb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdHZhciBjYWNoZUtleSA9ICdDbG9uZWRNYXRlcmlhbDonICsgbWF0ZXJpYWwudXVpZCArICc6JztcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pc0dMVEZTcGVjdWxhckdsb3NzaW5lc3NNYXRlcmlhbCApIGNhY2hlS2V5ICs9ICdzcGVjdWxhci1nbG9zc2luZXNzOic7XG5cdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgY2FjaGVLZXkgKz0gJ3NraW5uaW5nOic7XG5cdFx0XHRpZiAoIHVzZVZlcnRleFRhbmdlbnRzICkgY2FjaGVLZXkgKz0gJ3ZlcnRleC10YW5nZW50czonO1xuXHRcdFx0aWYgKCB1c2VWZXJ0ZXhDb2xvcnMgKSBjYWNoZUtleSArPSAndmVydGV4LWNvbG9yczonO1xuXHRcdFx0aWYgKCB1c2VGbGF0U2hhZGluZyApIGNhY2hlS2V5ICs9ICdmbGF0LXNoYWRpbmc6Jztcblx0XHRcdGlmICggdXNlTW9ycGhUYXJnZXRzICkgY2FjaGVLZXkgKz0gJ21vcnBoLXRhcmdldHM6Jztcblx0XHRcdGlmICggdXNlTW9ycGhOb3JtYWxzICkgY2FjaGVLZXkgKz0gJ21vcnBoLW5vcm1hbHM6JztcblxuXHRcdFx0dmFyIGNhY2hlZE1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoIGNhY2hlS2V5ICk7XG5cblx0XHRcdGlmICggISBjYWNoZWRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsLmNsb25lKCk7XG5cblx0XHRcdFx0aWYgKCB1c2VTa2lubmluZyApIGNhY2hlZE1hdGVyaWFsLnNraW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB1c2VWZXJ0ZXhDb2xvcnMgKSBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHVzZUZsYXRTaGFkaW5nICkgY2FjaGVkTWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIHVzZU1vcnBoVGFyZ2V0cyApIGNhY2hlZE1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRydWU7XG5cdFx0XHRcdGlmICggdXNlTW9ycGhOb3JtYWxzICkgY2FjaGVkTWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIHVzZVZlcnRleFRhbmdlbnRzICkge1xuXG5cdFx0XHRcdFx0Y2FjaGVkTWF0ZXJpYWwudmVydGV4VGFuZ2VudHMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTE0MzgjaXNzdWVjb21tZW50LTUwNzAwMzk5NVxuXHRcdFx0XHRcdGlmICggY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUgKSBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZS55ICo9IC0gMTtcblx0XHRcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlICkgY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSAqPSAtIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuY2FjaGUuYWRkKCBjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR0aGlzLmFzc29jaWF0aW9ucy5zZXQoIGNhY2hlZE1hdGVyaWFsLCB0aGlzLmFzc29jaWF0aW9ucy5nZXQoIG1hdGVyaWFsICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0Ly8gd29ya2Fyb3VuZHMgZm9yIG1lc2ggYW5kIGdlb21ldHJ5XG5cblx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMudXYyID09PSB1bmRlZmluZWQgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1djInLCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2ICk7XG5cblx0XHR9XG5cblx0XHRtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cblx0fTtcblxuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5nZXRNYXRlcmlhbFR5cGUgPSBmdW5jdGlvbiAoIC8qIG1hdGVyaWFsSW5kZXggKi8gKSB7XG5cblx0XHRyZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHR2YXIgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0dmFyIG1hdGVyaWFsVHlwZTtcblx0XHR2YXIgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcblx0XHR2YXIgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcblxuXHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRpZiAoIG1hdGVyaWFsRXh0ZW5zaW9uc1sgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1BCUl9TUEVDVUxBUl9HTE9TU0lORVNTIF0gKSB7XG5cblx0XHRcdHZhciBzZ0V4dGVuc2lvbiA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19QQlJfU1BFQ1VMQVJfR0xPU1NJTkVTUyBdO1xuXHRcdFx0bWF0ZXJpYWxUeXBlID0gc2dFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG5cdFx0XHRwZW5kaW5nLnB1c2goIHNnRXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyggbWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIgKSApO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxFeHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQgXSApIHtcblxuXHRcdFx0dmFyIGttdUV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVCBdO1xuXHRcdFx0bWF0ZXJpYWxUeXBlID0ga211RXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuXHRcdFx0cGVuZGluZy5wdXNoKCBrbXVFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKCBtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlciApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTcGVjaWZpY2F0aW9uOlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI21ldGFsbGljLXJvdWdobmVzcy1tYXRlcmlhbFxuXG5cdFx0XHR2YXIgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoIDEuMCwgMS4wLCAxLjAgKTtcblx0XHRcdG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxLjA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yICkgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmNvbG9yLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0bWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WyAzIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIuYXNzaWduVGV4dHVyZSggbWF0ZXJpYWxQYXJhbXMsICdtYXAnLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdW5kZWZpbmVkID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxLjA7XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5yb3VnaG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgIT09IHVuZGVmaW5lZCA/IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciA6IDEuMDtcblxuXHRcdFx0aWYgKCBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ21ldGFsbmVzc01hcCcsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSApICk7XG5cdFx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAncm91Z2huZXNzTWFwJywgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUoIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIFByb21pc2UuYWxsKCB0aGlzLl9pbnZva2VBbGwoIGZ1bmN0aW9uICggZXh0ICkge1xuXG5cdFx0XHRcdHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKCBtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcyApO1xuXG5cdFx0XHR9ICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG5cblx0XHR9XG5cblx0XHR2YXIgYWxwaGFNb2RlID0gbWF0ZXJpYWxEZWYuYWxwaGFNb2RlIHx8IEFMUEhBX01PREVTLk9QQVFVRTtcblxuXHRcdGlmICggYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5CTEVORCApIHtcblxuXHRcdFx0bWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE3NzA2XG5cdFx0XHRtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuTUFTSyApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5hbHBoYVRlc3QgPSBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgOiAwLjU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggcGFyc2VyLmFzc2lnblRleHR1cmUoIG1hdGVyaWFsUGFyYW1zLCAnbm9ybWFsTWFwJywgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSApICk7XG5cblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzExNDM4I2lzc3VlY29tbWVudC01MDcwMDM5OTVcblx0XHRcdG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIC0gMSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZS5zZXQoIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUuc2NhbGUsIC0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2FvTWFwJywgbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSApICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUGFyYW1zLmFvTWFwSW50ZW5zaXR5ID0gbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsICkge1xuXG5cdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5hc3NpZ25UZXh0dXJlKCBtYXRlcmlhbFBhcmFtcywgJ2VtaXNzaXZlTWFwJywgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsVHlwZSA9PT0gR0xURk1lc2hTdGFuZGFyZFNHTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWwgPSBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MgXS5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxQYXJhbXMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUoIG1hdGVyaWFsUGFyYW1zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbERlZi5uYW1lICkgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG5cblx0XHRcdC8vIGJhc2VDb2xvclRleHR1cmUsIGVtaXNzaXZlVGV4dHVyZSwgYW5kIHNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUgdXNlIHNSR0IgZW5jb2RpbmcuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIG1hdGVyaWFsLm1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblxuXHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbWF0ZXJpYWwsIG1hdGVyaWFsRGVmICk7XG5cblx0XHRcdHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KCBtYXRlcmlhbCwgeyB0eXBlOiAnbWF0ZXJpYWxzJywgaW5kZXg6IG1hdGVyaWFsSW5kZXggfSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIG1hdGVyaWFsLCBtYXRlcmlhbERlZiApO1xuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUuY3JlYXRlVW5pcXVlTmFtZSA9IGZ1bmN0aW9uICggb3JpZ2luYWxOYW1lICkge1xuXG5cdFx0dmFyIHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggb3JpZ2luYWxOYW1lIHx8ICcnICk7XG5cblx0XHR2YXIgbmFtZSA9IHNhbml0aXplZE5hbWU7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDE7IHRoaXMubm9kZU5hbWVzVXNlZFsgbmFtZSBdOyArKyBpICkge1xuXG5cdFx0XHRuYW1lID0gc2FuaXRpemVkTmFtZSArICdfJyArIGk7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5vZGVOYW1lc1VzZWRbIG5hbWUgXSA9IHRydWU7XG5cblx0XHRyZXR1cm4gbmFtZTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHQgKiBAcGFyYW0ge0dMVEYuUHJpbWl0aXZlfSBwcmltaXRpdmVEZWZcblx0ICogQHBhcmFtIHtHTFRGUGFyc2VyfSBwYXJzZXJcblx0ICovXG5cdGZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgYm94ID0gbmV3IEJveDMoKTtcblxuXHRcdGlmICggYXR0cmlidXRlcy5QT1NJVElPTiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbIGF0dHJpYnV0ZXMuUE9TSVRJT04gXTtcblxuXHRcdFx0dmFyIG1pbiA9IGFjY2Vzc29yLm1pbjtcblx0XHRcdHZhciBtYXggPSBhY2Nlc3Nvci5tYXg7XG5cblx0XHRcdC8vIGdsVEYgcmVxdWlyZXMgJ21pbicgYW5kICdtYXgnLCBidXQgVlJNICh3aGljaCBleHRlbmRzIGdsVEYpIGN1cnJlbnRseSBpZ25vcmVzIHRoYXQgcmVxdWlyZW1lbnQuXG5cblx0XHRcdGlmICggbWluICE9PSB1bmRlZmluZWQgJiYgbWF4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ym94LnNldChcblx0XHRcdFx0XHRuZXcgVmVjdG9yMyggbWluWyAwIF0sIG1pblsgMSBdLCBtaW5bIDIgXSApLFxuXHRcdFx0XHRcdG5ldyBWZWN0b3IzKCBtYXhbIDAgXSwgbWF4WyAxIF0sIG1heFsgMiBdICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uJyApO1xuXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRhcmdldHMgPSBwcmltaXRpdmVEZWYudGFyZ2V0cztcblxuXHRcdGlmICggdGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0LlBPU0lUSU9OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgYWNjZXNzb3IgPSBwYXJzZXIuanNvbi5hY2Nlc3NvcnNbIHRhcmdldC5QT1NJVElPTiBdO1xuXHRcdFx0XHRcdHZhciBtaW4gPSBhY2Nlc3Nvci5taW47XG5cdFx0XHRcdFx0dmFyIG1heCA9IGFjY2Vzc29yLm1heDtcblxuXHRcdFx0XHRcdC8vIGdsVEYgcmVxdWlyZXMgJ21pbicgYW5kICdtYXgnLCBidXQgVlJNICh3aGljaCBleHRlbmRzIGdsVEYpIGN1cnJlbnRseSBpZ25vcmVzIHRoYXQgcmVxdWlyZW1lbnQuXG5cblx0XHRcdFx0XHRpZiAoIG1pbiAhPT0gdW5kZWZpbmVkICYmIG1heCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCBtYXggb2YgYWJzb2x1dGUgY29tcG9uZW50cyBiZWNhdXNlIHRhcmdldCB3ZWlnaHQgaXMgWy0xLDFdXG5cdFx0XHRcdFx0XHR2ZWN0b3Iuc2V0WCggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDAgXSApLCBNYXRoLmFicyggbWF4WyAwIF0gKSApICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3Iuc2V0WSggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDEgXSApLCBNYXRoLmFicyggbWF4WyAxIF0gKSApICk7XG5cdFx0XHRcdFx0XHR2ZWN0b3Iuc2V0WiggTWF0aC5tYXgoIE1hdGguYWJzKCBtaW5bIDIgXSApLCBNYXRoLmFicyggbWF4WyAyIF0gKSApICk7XG5cblx0XHRcdFx0XHRcdC8vIE5vdGU6IHRoaXMgYXNzdW1lcyB0aGF0IHRoZSBzdW0gb2YgYWxsIHdlaWdodHMgaXMgYXQgbW9zdCAxLiBUaGlzIGlzbid0IHF1aXRlIGNvcnJlY3QgLSBpdCdzIG1vcmUgY29uc2VydmF0aXZlXG5cdFx0XHRcdFx0XHQvLyB0byBhc3N1bWUgdGhhdCBlYWNoIHRhcmdldCBjYW4gaGF2ZSBhIG1heCB3ZWlnaHQgb2YgMS4gSG93ZXZlciwgZm9yIHNvbWUgdXNlIGNhc2VzIC0gbm90YWJseSwgd2hlbiBtb3JwaCB0YXJnZXRzXG5cdFx0XHRcdFx0XHQvLyBhcmUgdXNlZCB0byBpbXBsZW1lbnQga2V5LWZyYW1lIGFuaW1hdGlvbnMgYW5kIGFzIHN1Y2ggb25seSB0d28gYXJlIGFjdGl2ZSBhdCBhIHRpbWUgLSB0aGlzIHJlc3VsdHMgaW4gdmVyeSBsYXJnZVxuXHRcdFx0XHRcdFx0Ly8gYm94ZXMuIFNvIGZvciBub3cgd2UgbWFrZSBhIGJveCB0aGF0J3Mgc29tZXRpbWVzIGEgdG91Y2ggdG9vIHNtYWxsIGJ1dCBpcyBob3BlZnVsbHkgbW9zdGx5IG9mIHJlYXNvbmFibGUgc2l6ZS5cblx0XHRcdFx0XHRcdG1heERpc3BsYWNlbWVudC5tYXgoIHZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXMgcGVyIGNvbW1lbnQgYWJvdmUgdGhpcyBib3ggaXNuJ3QgY29uc2VydmF0aXZlLCBidXQgaGFzIGEgcmVhc29uYWJsZSBzaXplIGZvciBhIHZlcnkgbGFyZ2UgbnVtYmVyIG9mIG1vcnBoIHRhcmdldHMuXG5cdFx0XHRib3guZXhwYW5kQnlWZWN0b3IoIG1heERpc3BsYWNlbWVudCApO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSBib3g7XG5cblx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0Ym94LmdldENlbnRlciggc3BoZXJlLmNlbnRlciApO1xuXHRcdHNwaGVyZS5yYWRpdXMgPSBib3gubWluLmRpc3RhbmNlVG8oIGJveC5tYXggKSAvIDI7XG5cblx0XHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHNwaGVyZTtcblxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5XG5cdCAqIEBwYXJhbSB7R0xURi5QcmltaXRpdmV9IHByaW1pdGl2ZURlZlxuXHQgKiBAcGFyYW0ge0dMVEZQYXJzZXJ9IHBhcnNlclxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckdlb21ldHJ5Pn1cblx0ICovXG5cdGZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoIGFjY2Vzc29ySW5kZXgsIGF0dHJpYnV0ZU5hbWUgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgYWNjZXNzb3JJbmRleCApXG5cdFx0XHRcdC50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lLCBhY2Nlc3NvciApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHR2YXIgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1sgZ2x0ZkF0dHJpYnV0ZU5hbWUgXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHQvLyBTa2lwIGF0dHJpYnV0ZXMgYWxyZWFkeSBwcm92aWRlZCBieSBlLmcuIERyYWNvIGV4dGVuc2lvbi5cblx0XHRcdGlmICggdGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSBjb250aW51ZTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciggYXR0cmlidXRlc1sgZ2x0ZkF0dHJpYnV0ZU5hbWUgXSwgdGhyZWVBdHRyaWJ1dGVOYW1lICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggcHJpbWl0aXZlRGVmLmluZGljZXMgIT09IHVuZGVmaW5lZCAmJiAhIGdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0XHR2YXIgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgcHJpbWl0aXZlRGVmLmluZGljZXMgKS50aGVuKCBmdW5jdGlvbiAoIGFjY2Vzc29yICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBhY2Nlc3NvciApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHBlbmRpbmcucHVzaCggYWNjZXNzb3IgKTtcblxuXHRcdH1cblxuXHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYgKTtcblxuXHRcdGNvbXB1dGVCb3VuZHMoIGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlciApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gcHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQ/IGFkZE1vcnBoVGFyZ2V0cyggZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIgKVxuXHRcdFx0XHQ6IGdlb21ldHJ5O1xuXG5cdFx0fSApO1xuXG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtCdWZmZXJHZW9tZXRyeX0gZ2VvbWV0cnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRyYXdNb2RlXG5cdCAqIEByZXR1cm4ge0J1ZmZlckdlb21ldHJ5fVxuXHQgKi9cblx0ZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZSggZ2VvbWV0cnksIGRyYXdNb2RlICkge1xuXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdC8vIGdlbmVyYXRlIGluZGV4IGlmIG5vdCBwcmVzZW50XG5cblx0XHRpZiAoIGluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9uLmNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0XHRcdGluZGV4ID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR0xURkxvYWRlci50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLicgKTtcblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuXHRcdHZhciBuZXdJbmRpY2VzID0gW107XG5cblx0XHRpZiAoIGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlICkge1xuXG5cdFx0XHQvLyBnbC5UUklBTkdMRV9GQU5cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpICsrICkge1xuXG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggMCApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSApICk7XG5cdFx0XHRcdG5ld0luZGljZXMucHVzaCggaW5kZXguZ2V0WCggaSArIDEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBnbC5UUklBTkdMRV9TVFJJUFxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1iZXJPZlRyaWFuZ2xlczsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGkgJSAyID09PSAwICkge1xuXG5cdFx0XHRcdFx0bmV3SW5kaWNlcy5wdXNoKCBpbmRleC5nZXRYKCBpICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAxICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAyICkgKTtcblxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAyICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKyAxICkgKTtcblx0XHRcdFx0XHRuZXdJbmRpY2VzLnB1c2goIGluZGV4LmdldFgoIGkgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIG5ld0luZGljZXMubGVuZ3RoIC8gMyApICE9PSBudW1iZXJPZlRyaWFuZ2xlcyApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdMVEZMb2FkZXIudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGZpbmFsIGdlb21ldHJ5XG5cblx0XHR2YXIgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuXHRcdG5ld0dlb21ldHJ5LnNldEluZGV4KCBuZXdJbmRpY2VzICk7XG5cblx0XHRyZXR1cm4gbmV3R2VvbWV0cnk7XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dlb21ldHJ5XG5cdCAqXG5cdCAqIENyZWF0ZXMgQnVmZmVyR2VvbWV0cmllcyBmcm9tIHByaW1pdGl2ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8R0xURi5QcmltaXRpdmU+fSBwcmltaXRpdmVzXG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8QnVmZmVyR2VvbWV0cnk+Pn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRHZW9tZXRyaWVzID0gZnVuY3Rpb24gKCBwcmltaXRpdmVzICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHRoaXM7XG5cdFx0dmFyIGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG5cdFx0dmFyIGNhY2hlID0gdGhpcy5wcmltaXRpdmVDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZURyYWNvUHJpbWl0aXZlKCBwcmltaXRpdmUgKSB7XG5cblx0XHRcdHJldHVybiBleHRlbnNpb25zWyBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OIF1cblx0XHRcdFx0LmRlY29kZVByaW1pdGl2ZSggcHJpbWl0aXZlLCBwYXJzZXIgKVxuXHRcdFx0XHQudGhlbiggZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBnZW9tZXRyeSwgcHJpbWl0aXZlLCBwYXJzZXIgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgcGVuZGluZyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBwcmltaXRpdmUgPSBwcmltaXRpdmVzWyBpIF07XG5cdFx0XHR2YXIgY2FjaGVLZXkgPSBjcmVhdGVQcmltaXRpdmVLZXkoIHByaW1pdGl2ZSApO1xuXG5cdFx0XHQvLyBTZWUgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIHRoaXMgZ2VvbWV0cnlcblx0XHRcdHZhciBjYWNoZWQgPSBjYWNoZVsgY2FjaGVLZXkgXTtcblxuXHRcdFx0aWYgKCBjYWNoZWQgKSB7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBjYWNoZWQgZ2VvbWV0cnkgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggY2FjaGVkLnByb21pc2UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlQcm9taXNlO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04gXSApIHtcblxuXHRcdFx0XHRcdC8vIFVzZSBEUkFDTyBnZW9tZXRyeSBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZSggcHJpbWl0aXZlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZ2VvbWV0cnlcblx0XHRcdFx0XHRnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKCBuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FjaGUgdGhpcyBnZW9tZXRyeVxuXHRcdFx0XHRjYWNoZVsgY2FjaGVLZXkgXSA9IHsgcHJpbWl0aXZlOiBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuXG5cdFx0XHRcdHBlbmRpbmcucHVzaCggZ2VvbWV0cnlQcm9taXNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZyApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcblx0ICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRNZXNoID0gZnVuY3Rpb24gKCBtZXNoSW5kZXggKSB7XG5cblx0XHR2YXIgcGFyc2VyID0gdGhpcztcblx0XHR2YXIganNvbiA9IHRoaXMuanNvbjtcblx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblxuXHRcdHZhciBtZXNoRGVmID0ganNvbi5tZXNoZXNbIG1lc2hJbmRleCBdO1xuXHRcdHZhciBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuXG5cdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBwcmltaXRpdmVzWyBpIF0ubWF0ZXJpYWwgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHQ/IGNyZWF0ZURlZmF1bHRNYXRlcmlhbCggdGhpcy5jYWNoZSApXG5cdFx0XHRcdDogdGhpcy5nZXREZXBlbmRlbmN5KCAnbWF0ZXJpYWwnLCBwcmltaXRpdmVzWyBpIF0ubWF0ZXJpYWwgKTtcblxuXHRcdFx0cGVuZGluZy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0cGVuZGluZy5wdXNoKCBwYXJzZXIubG9hZEdlb21ldHJpZXMoIHByaW1pdGl2ZXMgKSApO1xuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICkudGhlbiggZnVuY3Rpb24gKCByZXN1bHRzICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSggMCwgcmVzdWx0cy5sZW5ndGggLSAxICk7XG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IHJlc3VsdHNbIHJlc3VsdHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHR2YXIgbWVzaGVzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGkgXTtcblx0XHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblxuXHRcdFx0XHQvLyAxLiBjcmVhdGUgTWVzaFxuXG5cdFx0XHRcdHZhciBtZXNoO1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHxcblx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8XG5cdFx0XHRcdFx0cHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHxcblx0XHRcdFx0XHRwcmltaXRpdmUubW9kZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gLmlzU2tpbm5lZE1lc2ggaXNuJ3QgaW4gZ2xURiBzcGVjLiBTZWUgLl9tYXJrRGVmcygpXG5cdFx0XHRcdFx0bWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZVxuXHRcdFx0XHRcdFx0PyBuZXcgU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApXG5cdFx0XHRcdFx0XHQ6IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmICEgbWVzaC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQubm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gd2Ugbm9ybWFsaXplIGZsb2F0aW5nIHBvaW50IHNraW4gd2VpZ2h0IGFycmF5IHRvIGZpeCBtYWxmb3JtZWQgYXNzZXRzIChzZWUgIzE1MzE5KVxuXHRcdFx0XHRcdFx0Ly8gaXQncyBpbXBvcnRhbnQgdG8gc2tpcCB0aGlzIGZvciBub24tZmxvYXQzMiBkYXRhIHNpbmNlIG5vcm1hbGl6ZVNraW5XZWlnaHRzIGFzc3VtZXMgbm9uLW5vcm1hbGl6ZWQgaW5wdXRzXG5cdFx0XHRcdFx0XHRtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgKSB7XG5cblx0XHRcdFx0XHRcdG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKCBtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICkge1xuXG5cdFx0XHRcdFx0XHRtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZSggbWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMgKSB7XG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCApIHtcblxuXHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZUxvb3AoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTICkge1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogJyArIHByaW1pdGl2ZS5tb2RlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggT2JqZWN0LmtleXMoIG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHVwZGF0ZU1vcnBoVGFyZ2V0cyggbWVzaCwgbWVzaERlZiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbWVzaERlZi5uYW1lIHx8ICggJ21lc2hfJyArIG1lc2hJbmRleCApICk7XG5cblx0XHRcdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggbWVzaCwgbWVzaERlZiApO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSApO1xuXG5cdFx0XHRcdHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKCBtZXNoICk7XG5cblx0XHRcdFx0bWVzaGVzLnB1c2goIG1lc2ggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1lc2hlcy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1lc2hlc1sgMCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdGdyb3VwLmFkZCggbWVzaGVzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRDYW1lcmEgPSBmdW5jdGlvbiAoIGNhbWVyYUluZGV4ICkge1xuXG5cdFx0dmFyIGNhbWVyYTtcblx0XHR2YXIgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbIGNhbWVyYUluZGV4IF07XG5cdFx0dmFyIHBhcmFtcyA9IGNhbWVyYURlZlsgY2FtZXJhRGVmLnR5cGUgXTtcblxuXHRcdGlmICggISBwYXJhbXMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjYW1lcmFEZWYudHlwZSA9PT0gJ3BlcnNwZWN0aXZlJyApIHtcblxuXHRcdFx0Y2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBNYXRoVXRpbHMucmFkVG9EZWcoIHBhcmFtcy55Zm92ICksIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLCBwYXJhbXMuem5lYXIgfHwgMSwgcGFyYW1zLnpmYXIgfHwgMmU2ICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjYW1lcmFEZWYudHlwZSA9PT0gJ29ydGhvZ3JhcGhpYycgKSB7XG5cblx0XHRcdGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gcGFyYW1zLnhtYWcsIHBhcmFtcy54bWFnLCBwYXJhbXMueW1hZywgLSBwYXJhbXMueW1hZywgcGFyYW1zLnpuZWFyLCBwYXJhbXMuemZhciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjYW1lcmFEZWYubmFtZSApIGNhbWVyYS5uYW1lID0gdGhpcy5jcmVhdGVVbmlxdWVOYW1lKCBjYW1lcmFEZWYubmFtZSApO1xuXG5cdFx0YXNzaWduRXh0cmFzVG9Vc2VyRGF0YSggY2FtZXJhLCBjYW1lcmFEZWYgKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoIGNhbWVyYSApO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRTa2luID0gZnVuY3Rpb24gKCBza2luSW5kZXggKSB7XG5cblx0XHR2YXIgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1sgc2tpbkluZGV4IF07XG5cblx0XHR2YXIgc2tpbkVudHJ5ID0geyBqb2ludHM6IHNraW5EZWYuam9pbnRzIH07XG5cblx0XHRpZiAoIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCBza2luRW50cnkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyApLnRoZW4oIGZ1bmN0aW9uICggYWNjZXNzb3IgKSB7XG5cblx0XHRcdHNraW5FbnRyeS5pbnZlcnNlQmluZE1hdHJpY2VzID0gYWNjZXNzb3I7XG5cblx0XHRcdHJldHVybiBza2luRW50cnk7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG5cdCAqL1xuXHRHTFRGUGFyc2VyLnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBhbmltYXRpb25JbmRleCApIHtcblxuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXG5cdFx0dmFyIGFuaW1hdGlvbkRlZiA9IGpzb24uYW5pbWF0aW9uc1sgYW5pbWF0aW9uSW5kZXggXTtcblxuXHRcdHZhciBwZW5kaW5nTm9kZXMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG5cdFx0dmFyIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgPSBbXTtcblx0XHR2YXIgcGVuZGluZ1NhbXBsZXJzID0gW107XG5cdFx0dmFyIHBlbmRpbmdUYXJnZXRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1sgaSBdO1xuXHRcdFx0dmFyIHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbIGNoYW5uZWwuc2FtcGxlciBdO1xuXHRcdFx0dmFyIHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuXHRcdFx0dmFyIG5hbWUgPSB0YXJnZXQubm9kZSAhPT0gdW5kZWZpbmVkID8gdGFyZ2V0Lm5vZGUgOiB0YXJnZXQuaWQ7IC8vIE5PVEU6IHRhcmdldC5pZCBpcyBkZXByZWNhdGVkLlxuXHRcdFx0dmFyIGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzWyBzYW1wbGVyLmlucHV0IF0gOiBzYW1wbGVyLmlucHV0O1xuXHRcdFx0dmFyIG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1sgc2FtcGxlci5vdXRwdXQgXSA6IHNhbXBsZXIub3V0cHV0O1xuXG5cdFx0XHRwZW5kaW5nTm9kZXMucHVzaCggdGhpcy5nZXREZXBlbmRlbmN5KCAnbm9kZScsIG5hbWUgKSApO1xuXHRcdFx0cGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2goIHRoaXMuZ2V0RGVwZW5kZW5jeSggJ2FjY2Vzc29yJywgaW5wdXQgKSApO1xuXHRcdFx0cGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKCB0aGlzLmdldERlcGVuZGVuY3koICdhY2Nlc3NvcicsIG91dHB1dCApICk7XG5cdFx0XHRwZW5kaW5nU2FtcGxlcnMucHVzaCggc2FtcGxlciApO1xuXHRcdFx0cGVuZGluZ1RhcmdldHMucHVzaCggdGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIFtcblxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdOb2RlcyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdJbnB1dEFjY2Vzc29ycyApLFxuXHRcdFx0UHJvbWlzZS5hbGwoIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nU2FtcGxlcnMgKSxcblx0XHRcdFByb21pc2UuYWxsKCBwZW5kaW5nVGFyZ2V0cyApXG5cblx0XHRdICkudGhlbiggZnVuY3Rpb24gKCBkZXBlbmRlbmNpZXMgKSB7XG5cblx0XHRcdHZhciBub2RlcyA9IGRlcGVuZGVuY2llc1sgMCBdO1xuXHRcdFx0dmFyIGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWyAxIF07XG5cdFx0XHR2YXIgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWyAyIF07XG5cdFx0XHR2YXIgc2FtcGxlcnMgPSBkZXBlbmRlbmNpZXNbIDMgXTtcblx0XHRcdHZhciB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWyA0IF07XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBub2RlID0gbm9kZXNbIGkgXTtcblx0XHRcdFx0dmFyIGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1sgaSBdO1xuXHRcdFx0XHR2YXIgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbIGkgXTtcblx0XHRcdFx0dmFyIHNhbXBsZXIgPSBzYW1wbGVyc1sgaSBdO1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gdGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRcdGlmICggbm9kZSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cblx0XHRcdFx0bm9kZS51cGRhdGVNYXRyaXgoKTtcblx0XHRcdFx0bm9kZS5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgVHlwZWRLZXlmcmFtZVRyYWNrO1xuXG5cdFx0XHRcdHN3aXRjaCAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSApIHtcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLndlaWdodHM6XG5cblx0XHRcdFx0XHRcdFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuXG5cdFx0XHRcdFx0XHRUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMucG9zaXRpb246XG5cdFx0XHRcdFx0Y2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0VHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGFyZ2V0TmFtZSA9IG5vZGUubmFtZSA/IG5vZGUubmFtZSA6IG5vZGUudXVpZDtcblxuXHRcdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHNhbXBsZXIuaW50ZXJwb2xhdGlvbiAhPT0gdW5kZWZpbmVkID8gSU5URVJQT0xBVElPTlsgc2FtcGxlci5pbnRlcnBvbGF0aW9uIF0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuXHRcdFx0XHR2YXIgdGFyZ2V0TmFtZXMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMgKSB7XG5cblx0XHRcdFx0XHQvLyBOb2RlIG1heSBiZSBhIEdyb3VwIChnbFRGIG1lc2ggd2l0aCBzZXZlcmFsIHByaW1pdGl2ZXMpIG9yIGEgTWVzaC5cblx0XHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNNZXNoID09PSB0cnVlICYmIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0TmFtZXMucHVzaCggb2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGFyZ2V0TmFtZXMucHVzaCggdGFyZ2V0TmFtZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb3V0cHV0QXJyYXkgPSBvdXRwdXRBY2Nlc3Nvci5hcnJheTtcblxuXHRcdFx0XHRpZiAoIG91dHB1dEFjY2Vzc29yLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2NhbGU7XG5cblx0XHRcdFx0XHRpZiAoIG91dHB1dEFycmF5LmNvbnN0cnVjdG9yID09PSBJbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdHNjYWxlID0gMSAvIDEyNztcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IDEgLyAyNTU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvdXRwdXRBcnJheS5jb25zdHJ1Y3RvciA9PSBJbnQxNkFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZSA9IDEgLyAzMjc2NztcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG91dHB1dEFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSApIHtcblxuXHRcdFx0XHRcdFx0c2NhbGUgPSAxIC8gNjU1MzU7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBvdXRwdXQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkoIG91dHB1dEFycmF5Lmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG91dHB1dEFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRzY2FsZWRbIGogXSA9IG91dHB1dEFycmF5WyBqIF0gKiBzY2FsZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dEFycmF5ID0gc2NhbGVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuXHRcdFx0XHRcdFx0dGFyZ2V0TmFtZXNbIGogXSArICcuJyArIFBBVEhfUFJPUEVSVElFU1sgdGFyZ2V0LnBhdGggXSxcblx0XHRcdFx0XHRcdGlucHV0QWNjZXNzb3IuYXJyYXksXG5cdFx0XHRcdFx0XHRvdXRwdXRBcnJheSxcblx0XHRcdFx0XHRcdGludGVycG9sYXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgaW50ZXJwb2xhdGlvbiB3aXRoIGN1c3RvbSBmYWN0b3J5IG1ldGhvZC5cblx0XHRcdFx0XHRpZiAoIHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gJ0NVQklDU1BMSU5FJyApIHtcblxuXHRcdFx0XHRcdFx0dHJhY2suY3JlYXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIENVQklDU1BMSU5FIGtleWZyYW1lIGluIGdsVEYgaGFzIHRocmVlIG91dHB1dCB2YWx1ZXMgZm9yIGVhY2ggaW5wdXQgdmFsdWUsXG5cdFx0XHRcdFx0XHRcdC8vIHJlcHJlc2VudGluZyBpblRhbmdlbnQsIHNwbGluZVZlcnRleCwgYW5kIG91dFRhbmdlbnQuIEFzIGEgcmVzdWx0LCB0cmFjay5nZXRWYWx1ZVNpemUoKVxuXHRcdFx0XHRcdFx0XHQvLyBtdXN0IGJlIGRpdmlkZWQgYnkgdGhyZWUgdG8gZ2V0IHRoZSBpbnRlcnBvbGFudCdzIHNhbXBsZVNpemUgYXJndW1lbnQuXG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Ly8gTWFyayBhcyBDVUJJQ1NQTElORS4gYHRyYWNrLmdldEludGVycG9sYXRpb24oKWAgZG9lc24ndCBzdXBwb3J0IGN1c3RvbSBpbnRlcnBvbGFudHMuXG5cdFx0XHRcdFx0XHR0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cmFja3MucHVzaCggdHJhY2sgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogJ2FuaW1hdGlvbl8nICsgYW5pbWF0aW9uSW5kZXg7XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgdW5kZWZpbmVkLCB0cmFja3MgKTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG5cdCAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuXHQgKi9cblx0R0xURlBhcnNlci5wcm90b3R5cGUubG9hZE5vZGUgPSBmdW5jdGlvbiAoIG5vZGVJbmRleCApIHtcblxuXHRcdHZhciBqc29uID0gdGhpcy5qc29uO1xuXHRcdHZhciBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuXHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0dmFyIG5vZGVEZWYgPSBqc29uLm5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdC8vIHJlc2VydmUgbm9kZSdzIG5hbWUgYmVmb3JlIGl0cyBkZXBlbmRlbmNpZXMsIHNvIHRoZSByb290IGhhcyB0aGUgaW50ZW5kZWQgbmFtZS5cblx0XHR2YXIgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggbm9kZURlZi5uYW1lICkgOiAnJztcblxuXHRcdHJldHVybiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1lc2ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnbWVzaCcsIG5vZGVEZWYubWVzaCApLnRoZW4oIGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdFx0XHRcdHZhciBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKCBwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2ggKTtcblxuXHRcdFx0XHRcdC8vIGlmIHdlaWdodHMgYXJlIHByb3ZpZGVkIG9uIHRoZSBub2RlLCBvdmVycmlkZSB3ZWlnaHRzIG9uIHRoZSBtZXNoLlxuXHRcdFx0XHRcdGlmICggbm9kZURlZi53ZWlnaHRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggbyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoICEgby5pc01lc2ggKSByZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gPSBub2RlRGVmLndlaWdodHNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHRcdH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZURlZi5jYW1lcmEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwZW5kaW5nLnB1c2goIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnY2FtZXJhJywgbm9kZURlZi5jYW1lcmEgKS50aGVuKCBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoIHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSApO1xuXG5cdFx0XHRcdH0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHBhcnNlci5faW52b2tlQWxsKCBmdW5jdGlvbiAoIGV4dCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCggbm9kZUluZGV4ICk7XG5cblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbiAoIHByb21pc2UgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBwcm9taXNlICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKCBwZW5kaW5nICk7XG5cblx0XHR9KCkgKS50aGVuKCBmdW5jdGlvbiAoIG9iamVjdHMgKSB7XG5cblx0XHRcdHZhciBub2RlO1xuXG5cdFx0XHQvLyAuaXNCb25lIGlzbid0IGluIGdsVEYgc3BlYy4gU2VlIC5fbWFya0RlZnNcblx0XHRcdGlmICggbm9kZURlZi5pc0JvbmUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0bm9kZSA9IG5ldyBCb25lKCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRub2RlID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHMubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdG5vZGUgPSBvYmplY3RzWyAwIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZSAhPT0gb2JqZWN0c1sgMCBdICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bm9kZS5hZGQoIG9iamVjdHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGVEZWYubmFtZSApIHtcblxuXHRcdFx0XHRub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG5cdFx0XHRcdG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoIG5vZGUsIG5vZGVEZWYgKTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLmV4dGVuc2lvbnMgKSBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoIGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYgKTtcblxuXHRcdFx0aWYgKCBub2RlRGVmLm1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCBub2RlRGVmLm1hdHJpeCApO1xuXHRcdFx0XHRub2RlLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnBvc2l0aW9uLmZyb21BcnJheSggbm9kZURlZi50cmFuc2xhdGlvbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vZGVEZWYucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkoIG5vZGVEZWYucm90YXRpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLnNjYWxlLmZyb21BcnJheSggbm9kZURlZi5zY2FsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRwYXJzZXIuYXNzb2NpYXRpb25zLnNldCggbm9kZSwgeyB0eXBlOiAnbm9kZXMnLCBpbmRleDogbm9kZUluZGV4IH0gKTtcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9ICk7XG5cblx0fTtcblxuXHQvKipcblx0ICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cblx0ICovXG5cdEdMVEZQYXJzZXIucHJvdG90eXBlLmxvYWRTY2VuZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHNjZW5lIG5vZGUgaGllcmFjaHkgYnVpbGRlclxuXG5cdFx0ZnVuY3Rpb24gYnVpbGROb2RlSGllcmFjaHkoIG5vZGVJZCwgcGFyZW50T2JqZWN0LCBqc29uLCBwYXJzZXIgKSB7XG5cblx0XHRcdHZhciBub2RlRGVmID0ganNvbi5ub2Rlc1sgbm9kZUlkIF07XG5cblx0XHRcdHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSggJ25vZGUnLCBub2RlSWQgKS50aGVuKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLnNraW4gPT09IHVuZGVmaW5lZCApIHJldHVybiBub2RlO1xuXG5cdFx0XHRcdC8vIGJ1aWxkIHNrZWxldG9uIGhlcmUgYXMgd2VsbFxuXG5cdFx0XHRcdHZhciBza2luRW50cnk7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KCAnc2tpbicsIG5vZGVEZWYuc2tpbiApLnRoZW4oIGZ1bmN0aW9uICggc2tpbiApIHtcblxuXHRcdFx0XHRcdHNraW5FbnRyeSA9IHNraW47XG5cblx0XHRcdFx0XHR2YXIgcGVuZGluZ0pvaW50cyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNraW5FbnRyeS5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHBlbmRpbmdKb2ludHMucHVzaCggcGFyc2VyLmdldERlcGVuZGVuY3koICdub2RlJywgc2tpbkVudHJ5LmpvaW50c1sgaSBdICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbCggcGVuZGluZ0pvaW50cyApO1xuXG5cdFx0XHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGpvaW50Tm9kZXMgKSB7XG5cblx0XHRcdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG1lc2ggKSB7XG5cblx0XHRcdFx0XHRcdGlmICggISBtZXNoLmlzTWVzaCApIHJldHVybjtcblxuXHRcdFx0XHRcdFx0dmFyIGJvbmVzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBqb2ludE5vZGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBqb2ludE5vZGUgPSBqb2ludE5vZGVzWyBqIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqb2ludE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRib25lcy5wdXNoKCBqb2ludE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXQgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXQuZnJvbUFycmF5KCBza2luRW50cnkuaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaiAqIDE2ICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRib25lSW52ZXJzZXMucHVzaCggbWF0ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJywgc2tpbkVudHJ5LmpvaW50c1sgaiBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1lc2guYmluZCggbmV3IFNrZWxldG9uKCBib25lcywgYm9uZUludmVyc2VzICksIG1lc2gubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHQvLyBidWlsZCBub2RlIGhpZXJhY2h5XG5cblx0XHRcdFx0cGFyZW50T2JqZWN0LmFkZCggbm9kZSApO1xuXG5cdFx0XHRcdHZhciBwZW5kaW5nID0gW107XG5cblx0XHRcdFx0aWYgKCBub2RlRGVmLmNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0dmFyIGNoaWxkcmVuID0gbm9kZURlZi5jaGlsZHJlbjtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0XHRcdHBlbmRpbmcucHVzaCggYnVpbGROb2RlSGllcmFjaHkoIGNoaWxkLCBub2RlLCBqc29uLCBwYXJzZXIgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvYWRTY2VuZSggc2NlbmVJbmRleCApIHtcblxuXHRcdFx0dmFyIGpzb24gPSB0aGlzLmpzb247XG5cdFx0XHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcblx0XHRcdHZhciBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbIHNjZW5lSW5kZXggXTtcblx0XHRcdHZhciBwYXJzZXIgPSB0aGlzO1xuXG5cdFx0XHQvLyBMb2FkZXIgcmV0dXJucyBHcm91cCwgbm90IFNjZW5lLlxuXHRcdFx0Ly8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xODM0MiNpc3N1ZWNvbW1lbnQtNTc4OTgxMTcyXG5cdFx0XHR2YXIgc2NlbmUgPSBuZXcgR3JvdXAoKTtcblx0XHRcdGlmICggc2NlbmVEZWYubmFtZSApIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZSggc2NlbmVEZWYubmFtZSApO1xuXG5cdFx0XHRhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKCBzY2VuZSwgc2NlbmVEZWYgKTtcblxuXHRcdFx0aWYgKCBzY2VuZURlZi5leHRlbnNpb25zICkgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKCBleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYgKTtcblxuXHRcdFx0dmFyIG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcblxuXHRcdFx0dmFyIHBlbmRpbmcgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0cGVuZGluZy5wdXNoKCBidWlsZE5vZGVIaWVyYWNoeSggbm9kZUlkc1sgaSBdLCBzY2VuZSwganNvbiwgcGFyc2VyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoIHBlbmRpbmcgKS50aGVuKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0cmV0dXJuIHNjZW5lO1xuXG5cdFx0XHR9ICk7XG5cblx0XHR9O1xuXG5cdH0oKTtcblxuXHRyZXR1cm4gR0xURkxvYWRlcjtcblxufSApKCk7XG5cbnZhciBUR0FMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG59O1xuXG5UR0FMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEdBTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IHNjb3BlLnBhcnNlKCBidWZmZXIgKTtcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdC8vIHJlZmVyZW5jZSBmcm9tIHZ0aGliYXVsdCwgaHR0cHM6Ly9naXRodWIuY29tL3Z0aGliYXVsdC9yb0Jyb3dzZXIvYmxvYi9tYXN0ZXIvc3JjL0xvYWRlcnMvVGFyZ2EuanNcblxuXHRcdGZ1bmN0aW9uIHRnYUNoZWNrSGVhZGVyKCBoZWFkZXIgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGhlYWRlci5pbWFnZV90eXBlICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIGluZGV4ZWQgdHlwZVxuXG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfSU5ERVhFRDpcblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfSU5ERVhFRDpcblx0XHRcdFx0XHRpZiAoIGhlYWRlci5jb2xvcm1hcF9sZW5ndGggPiAyNTYgfHwgaGVhZGVyLmNvbG9ybWFwX3NpemUgIT09IDI0IHx8IGhlYWRlci5jb2xvcm1hcF90eXBlICE9PSAxICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBJbnZhbGlkIHR5cGUgY29sb3JtYXAgZGF0YSBmb3IgaW5kZXhlZCB0eXBlLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgY29sb3JtYXAgdHlwZVxuXG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfUkdCOlxuXHRcdFx0XHRjYXNlIFRHQV9UWVBFX0dSRVk6XG5cdFx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX1JHQjpcblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfR1JFWTpcblx0XHRcdFx0XHRpZiAoIGhlYWRlci5jb2xvcm1hcF90eXBlICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVEdBTG9hZGVyOiBJbnZhbGlkIHR5cGUgY29sb3JtYXAgZGF0YSBmb3IgY29sb3JtYXAgdHlwZS4nICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdC8vIFdoYXQgdGhlIG5lZWQgb2YgYSBmaWxlIHdpdGhvdXQgZGF0YSA/XG5cblx0XHRcdFx0Y2FzZSBUR0FfVFlQRV9OT19EQVRBOlxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IE5vIGRhdGEuJyApO1xuXG5cdFx0XHRcdFx0Ly8gSW52YWxpZCB0eXBlID9cblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgdHlwZSBcIiVzXCIuJywgaGVhZGVyLmltYWdlX3R5cGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0XG5cblx0XHRcdGlmICggaGVhZGVyLndpZHRoIDw9IDAgfHwgaGVhZGVyLmhlaWdodCA8PSAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgaW1hZ2Ugc2l6ZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaW1hZ2UgcGl4ZWwgc2l6ZVxuXG5cdFx0XHRpZiAoIGhlYWRlci5waXhlbF9zaXplICE9PSA4ICYmIGhlYWRlci5waXhlbF9zaXplICE9PSAxNiAmJlxuXHRcdFx0XHRoZWFkZXIucGl4ZWxfc2l6ZSAhPT0gMjQgJiYgaGVhZGVyLnBpeGVsX3NpemUgIT09IDMyICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEludmFsaWQgcGl4ZWwgc2l6ZSBcIiVzXCIuJywgaGVhZGVyLnBpeGVsX3NpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgdGdhIGltYWdlIGJ1ZmZlclxuXG5cdFx0ZnVuY3Rpb24gdGdhUGFyc2UoIHVzZV9ybGUsIHVzZV9wYWwsIGhlYWRlciwgb2Zmc2V0LCBkYXRhICkge1xuXG5cdFx0XHR2YXIgcGl4ZWxfZGF0YSxcblx0XHRcdFx0cGl4ZWxfc2l6ZSxcblx0XHRcdFx0cGl4ZWxfdG90YWwsXG5cdFx0XHRcdHBhbGV0dGVzO1xuXG5cdFx0XHRwaXhlbF9zaXplID0gaGVhZGVyLnBpeGVsX3NpemUgPj4gMztcblx0XHRcdHBpeGVsX3RvdGFsID0gaGVhZGVyLndpZHRoICogaGVhZGVyLmhlaWdodCAqIHBpeGVsX3NpemU7XG5cblx0XHRcdCAvLyByZWFkIHBhbGV0dGVzXG5cblx0XHRcdCBpZiAoIHVzZV9wYWwgKSB7XG5cblx0XHRcdFx0IHBhbGV0dGVzID0gZGF0YS5zdWJhcnJheSggb2Zmc2V0LCBvZmZzZXQgKz0gaGVhZGVyLmNvbG9ybWFwX2xlbmd0aCAqICggaGVhZGVyLmNvbG9ybWFwX3NpemUgPj4gMyApICk7XG5cblx0XHRcdCB9XG5cblx0XHRcdCAvLyByZWFkIFJMRVxuXG5cdFx0XHQgaWYgKCB1c2VfcmxlICkge1xuXG5cdFx0XHRcdCBwaXhlbF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHBpeGVsX3RvdGFsICk7XG5cblx0XHRcdFx0dmFyIGMsIGNvdW50LCBpO1xuXHRcdFx0XHR2YXIgc2hpZnQgPSAwO1xuXHRcdFx0XHR2YXIgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoIHBpeGVsX3NpemUgKTtcblxuXHRcdFx0XHR3aGlsZSAoIHNoaWZ0IDwgcGl4ZWxfdG90YWwgKSB7XG5cblx0XHRcdFx0XHRjID0gZGF0YVsgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0Y291bnQgPSAoIGMgJiAweDdmICkgKyAxO1xuXG5cdFx0XHRcdFx0Ly8gUkxFIHBpeGVsc1xuXG5cdFx0XHRcdFx0aWYgKCBjICYgMHg4MCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gYmluZCBwaXhlbCB0bXAgYXJyYXlcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwaXhlbF9zaXplOyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHBpeGVsc1sgaSBdID0gZGF0YVsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gY29weSBwaXhlbCBhcnJheVxuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNvdW50OyArKyBpICkge1xuXG5cdFx0XHRcdFx0XHRcdHBpeGVsX2RhdGEuc2V0KCBwaXhlbHMsIHNoaWZ0ICsgaSAqIHBpeGVsX3NpemUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzaGlmdCArPSBwaXhlbF9zaXplICogY291bnQ7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByYXcgcGl4ZWxzXG5cblx0XHRcdFx0XHRcdGNvdW50ICo9IHBpeGVsX3NpemU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY291bnQ7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGl4ZWxfZGF0YVsgc2hpZnQgKyBpIF0gPSBkYXRhWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzaGlmdCArPSBjb3VudDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdCB9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIHJhdyBwaXhlbHNcblxuXHRcdFx0XHRwaXhlbF9kYXRhID0gZGF0YS5zdWJhcnJheShcblx0XHRcdFx0XHQgb2Zmc2V0LCBvZmZzZXQgKz0gKCB1c2VfcGFsID8gaGVhZGVyLndpZHRoICogaGVhZGVyLmhlaWdodCA6IHBpeGVsX3RvdGFsIClcblx0XHRcdFx0KTtcblxuXHRcdFx0IH1cblxuXHRcdFx0IHJldHVybiB7XG5cdFx0XHRcdHBpeGVsX2RhdGE6IHBpeGVsX2RhdGEsXG5cdFx0XHRcdHBhbGV0dGVzOiBwYWxldHRlc1xuXHRcdFx0IH07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0Z2FHZXRJbWFnZURhdGE4Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSwgcGFsZXR0ZXMgKSB7XG5cblx0XHRcdHZhciBjb2xvcm1hcCA9IHBhbGV0dGVzO1xuXHRcdFx0dmFyIGNvbG9yLCBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBpbWFnZVsgaSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gMjU1O1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gY29sb3JtYXBbICggY29sb3IgKiAzICkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBjb2xvcm1hcFsgKCBjb2xvciAqIDMgKSArIDEgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGNvbG9ybWFwWyAoIGNvbG9yICogMyApICsgMiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhMTZiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICkge1xuXG5cdFx0XHR2YXIgY29sb3IsIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gMiApIHtcblxuXHRcdFx0XHRcdGNvbG9yID0gaW1hZ2VbIGkgKyAwIF0gKyAoIGltYWdlWyBpICsgMSBdIDw8IDggKTsgLy8gSW52ZXJzZWQgP1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gKCBjb2xvciAmIDB4N0MwMCApID4+IDc7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSAoIGNvbG9yICYgMHgwM0UwICkgPj4gMjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9ICggY29sb3IgJiAweDAwMUYgKSA+PiAzO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gKCBjb2xvciAmIDB4ODAwMCApID8gMCA6IDI1NTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YTI0Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gMjU1O1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMiBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBpbWFnZVsgaSArIDEgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDAgXSA9IGltYWdlWyBpICsgMiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhMzJiaXRzKCBpbWFnZURhdGEsIHlfc3RhcnQsIHlfc3RlcCwgeV9lbmQsIHhfc3RhcnQsIHhfc3RlcCwgeF9lbmQsIGltYWdlICkge1xuXG5cdFx0XHR2YXIgaSA9IDAsIHgsIHk7XG5cdFx0XHR2YXIgd2lkdGggPSBoZWFkZXIud2lkdGg7XG5cblx0XHRcdGZvciAoIHkgPSB5X3N0YXJ0OyB5ICE9PSB5X2VuZDsgeSArPSB5X3N0ZXAgKSB7XG5cblx0XHRcdFx0Zm9yICggeCA9IHhfc3RhcnQ7IHggIT09IHhfZW5kOyB4ICs9IHhfc3RlcCwgaSArPSA0ICkge1xuXG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAyIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDEgXSA9IGltYWdlWyBpICsgMSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gaW1hZ2VbIGkgKyAyIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAzIF0gPSBpbWFnZVsgaSArIDMgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGltYWdlRGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRnYUdldEltYWdlRGF0YUdyZXk4Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGNvbG9yLCBpID0gMCwgeCwgeTtcblx0XHRcdHZhciB3aWR0aCA9IGhlYWRlci53aWR0aDtcblxuXHRcdFx0Zm9yICggeSA9IHlfc3RhcnQ7IHkgIT09IHlfZW5kOyB5ICs9IHlfc3RlcCApIHtcblxuXHRcdFx0XHRmb3IgKCB4ID0geF9zdGFydDsgeCAhPT0geF9lbmQ7IHggKz0geF9zdGVwLCBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBpbWFnZVsgaSBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gY29sb3I7XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBjb2xvcjtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGNvbG9yO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gMjU1O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGdhR2V0SW1hZ2VEYXRhR3JleTE2Yml0cyggaW1hZ2VEYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGkgPSAwLCB4LCB5O1xuXHRcdFx0dmFyIHdpZHRoID0gaGVhZGVyLndpZHRoO1xuXG5cdFx0XHRmb3IgKCB5ID0geV9zdGFydDsgeSAhPT0geV9lbmQ7IHkgKz0geV9zdGVwICkge1xuXG5cdFx0XHRcdGZvciAoIHggPSB4X3N0YXJ0OyB4ICE9PSB4X2VuZDsgeCArPSB4X3N0ZXAsIGkgKz0gMiApIHtcblxuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMCBdID0gaW1hZ2VbIGkgKyAwIF07XG5cdFx0XHRcdFx0aW1hZ2VEYXRhWyAoIHggKyB3aWR0aCAqIHkgKSAqIDQgKyAxIF0gPSBpbWFnZVsgaSArIDAgXTtcblx0XHRcdFx0XHRpbWFnZURhdGFbICggeCArIHdpZHRoICogeSApICogNCArIDIgXSA9IGltYWdlWyBpICsgMCBdO1xuXHRcdFx0XHRcdGltYWdlRGF0YVsgKCB4ICsgd2lkdGggKiB5ICkgKiA0ICsgMyBdID0gaW1hZ2VbIGkgKyAxIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbWFnZURhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZ2FSR0JBKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBpbWFnZSwgcGFsZXR0ZSApIHtcblxuXHRcdFx0dmFyIHhfc3RhcnQsXG5cdFx0XHRcdHlfc3RhcnQsXG5cdFx0XHRcdHhfc3RlcCxcblx0XHRcdFx0eV9zdGVwLFxuXHRcdFx0XHR4X2VuZCxcblx0XHRcdFx0eV9lbmQ7XG5cblx0XHRcdHN3aXRjaCAoICggaGVhZGVyLmZsYWdzICYgVEdBX09SSUdJTl9NQVNLICkgPj4gVEdBX09SSUdJTl9TSElGVCApIHtcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjYXNlIFRHQV9PUklHSU5fVUw6XG5cdFx0XHRcdFx0eF9zdGFydCA9IDA7XG5cdFx0XHRcdFx0eF9zdGVwID0gMTtcblx0XHRcdFx0XHR4X2VuZCA9IHdpZHRoO1xuXHRcdFx0XHRcdHlfc3RhcnQgPSAwO1xuXHRcdFx0XHRcdHlfc3RlcCA9IDE7XG5cdFx0XHRcdFx0eV9lbmQgPSBoZWlnaHQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUR0FfT1JJR0lOX0JMOlxuXHRcdFx0XHRcdHhfc3RhcnQgPSAwO1xuXHRcdFx0XHRcdHhfc3RlcCA9IDE7XG5cdFx0XHRcdFx0eF9lbmQgPSB3aWR0aDtcblx0XHRcdFx0XHR5X3N0YXJ0ID0gaGVpZ2h0IC0gMTtcblx0XHRcdFx0XHR5X3N0ZXAgPSAtIDE7XG5cdFx0XHRcdFx0eV9lbmQgPSAtIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUR0FfT1JJR0lOX1VSOlxuXHRcdFx0XHRcdHhfc3RhcnQgPSB3aWR0aCAtIDE7XG5cdFx0XHRcdFx0eF9zdGVwID0gLSAxO1xuXHRcdFx0XHRcdHhfZW5kID0gLSAxO1xuXHRcdFx0XHRcdHlfc3RhcnQgPSAwO1xuXHRcdFx0XHRcdHlfc3RlcCA9IDE7XG5cdFx0XHRcdFx0eV9lbmQgPSBoZWlnaHQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUR0FfT1JJR0lOX0JSOlxuXHRcdFx0XHRcdHhfc3RhcnQgPSB3aWR0aCAtIDE7XG5cdFx0XHRcdFx0eF9zdGVwID0gLSAxO1xuXHRcdFx0XHRcdHhfZW5kID0gLSAxO1xuXHRcdFx0XHRcdHlfc3RhcnQgPSBoZWlnaHQgLSAxO1xuXHRcdFx0XHRcdHlfc3RlcCA9IC0gMTtcblx0XHRcdFx0XHR5X2VuZCA9IC0gMTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHVzZV9ncmV5ICkge1xuXG5cdFx0XHRcdHN3aXRjaCAoIGhlYWRlci5waXhlbF9zaXplICkge1xuXG5cdFx0XHRcdFx0Y2FzZSA4OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhR3JleThiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDE2OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhR3JleTE2Yml0cyggZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgaW1hZ2UgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IEZvcm1hdCBub3Qgc3VwcG9ydGVkLicgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBoZWFkZXIucGl4ZWxfc2l6ZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRcdHRnYUdldEltYWdlRGF0YThiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSwgcGFsZXR0ZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDE2OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhMTZiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDI0OlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhMjRiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDMyOlxuXHRcdFx0XHRcdFx0dGdhR2V0SW1hZ2VEYXRhMzJiaXRzKCBkYXRhLCB5X3N0YXJ0LCB5X3N0ZXAsIHlfZW5kLCB4X3N0YXJ0LCB4X3N0ZXAsIHhfZW5kLCBpbWFnZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogRm9ybWF0IG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIExvYWQgaW1hZ2UgZGF0YSBhY2NvcmRpbmcgdG8gc3BlY2lmaWMgbWV0aG9kXG5cdFx0XHQvLyB2YXIgZnVuYyA9ICd0Z2FHZXRJbWFnZURhdGEnICsgKHVzZV9ncmV5ID8gJ0dyZXknIDogJycpICsgKGhlYWRlci5waXhlbF9zaXplKSArICdiaXRzJztcblx0XHRcdC8vIGZ1bmMoZGF0YSwgeV9zdGFydCwgeV9zdGVwLCB5X2VuZCwgeF9zdGFydCwgeF9zdGVwLCB4X2VuZCwgd2lkdGgsIGltYWdlLCBwYWxldHRlICk7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdC8vIFRHQSBjb25zdGFudHNcblxuXHRcdHZhciBUR0FfVFlQRV9OT19EQVRBID0gMCxcblx0XHRcdFRHQV9UWVBFX0lOREVYRUQgPSAxLFxuXHRcdFx0VEdBX1RZUEVfUkdCID0gMixcblx0XHRcdFRHQV9UWVBFX0dSRVkgPSAzLFxuXHRcdFx0VEdBX1RZUEVfUkxFX0lOREVYRUQgPSA5LFxuXHRcdFx0VEdBX1RZUEVfUkxFX1JHQiA9IDEwLFxuXHRcdFx0VEdBX1RZUEVfUkxFX0dSRVkgPSAxMSxcblxuXHRcdFx0VEdBX09SSUdJTl9NQVNLID0gMHgzMCxcblx0XHRcdFRHQV9PUklHSU5fU0hJRlQgPSAweDA0LFxuXHRcdFx0VEdBX09SSUdJTl9CTCA9IDB4MDAsXG5cdFx0XHRUR0FfT1JJR0lOX0JSID0gMHgwMSxcblx0XHRcdFRHQV9PUklHSU5fVUwgPSAweDAyLFxuXHRcdFx0VEdBX09SSUdJTl9VUiA9IDB4MDM7XG5cblx0XHRpZiAoIGJ1ZmZlci5sZW5ndGggPCAxOSApIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UR0FMb2FkZXI6IE5vdCBlbm91Z2ggZGF0YSB0byBjb250YWluIGhlYWRlci4nICk7XG5cblx0XHR2YXIgY29udGVudCA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIgKSxcblx0XHRcdG9mZnNldCA9IDAsXG5cdFx0XHRoZWFkZXIgPSB7XG5cdFx0XHRcdGlkX2xlbmd0aDogY29udGVudFsgb2Zmc2V0ICsrIF0sXG5cdFx0XHRcdGNvbG9ybWFwX3R5cGU6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRpbWFnZV90eXBlOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0Y29sb3JtYXBfaW5kZXg6IGNvbnRlbnRbIG9mZnNldCArKyBdIHwgY29udGVudFsgb2Zmc2V0ICsrIF0gPDwgOCxcblx0XHRcdFx0Y29sb3JtYXBfbGVuZ3RoOiBjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdGNvbG9ybWFwX3NpemU6IGNvbnRlbnRbIG9mZnNldCArKyBdLFxuXHRcdFx0XHRvcmlnaW46IFtcblx0XHRcdFx0XHRjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdFx0Y29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4XG5cdFx0XHRcdF0sXG5cdFx0XHRcdHdpZHRoOiBjb250ZW50WyBvZmZzZXQgKysgXSB8IGNvbnRlbnRbIG9mZnNldCArKyBdIDw8IDgsXG5cdFx0XHRcdGhlaWdodDogY29udGVudFsgb2Zmc2V0ICsrIF0gfCBjb250ZW50WyBvZmZzZXQgKysgXSA8PCA4LFxuXHRcdFx0XHRwaXhlbF9zaXplOiBjb250ZW50WyBvZmZzZXQgKysgXSxcblx0XHRcdFx0ZmxhZ3M6IGNvbnRlbnRbIG9mZnNldCArKyBdXG5cdFx0XHR9O1xuXG5cdFx0Ly8gY2hlY2sgdGdhIGlmIGl0IGlzIHZhbGlkIGZvcm1hdFxuXG5cdFx0dGdhQ2hlY2tIZWFkZXIoIGhlYWRlciApO1xuXG5cdFx0aWYgKCBoZWFkZXIuaWRfbGVuZ3RoICsgb2Zmc2V0ID4gYnVmZmVyLmxlbmd0aCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRHQUxvYWRlcjogTm8gZGF0YS4nICk7XG5cblx0XHR9XG5cblx0XHQvLyBza2lwIHRoZSBuZWVkbid0IGRhdGFcblxuXHRcdG9mZnNldCArPSBoZWFkZXIuaWRfbGVuZ3RoO1xuXG5cdFx0Ly8gZ2V0IHRhcmdhIGluZm9ybWF0aW9uIGFib3V0IFJMRSBjb21wcmVzc2lvbiBhbmQgcGFsZXR0ZVxuXG5cdFx0dmFyIHVzZV9ybGUgPSBmYWxzZSxcblx0XHRcdHVzZV9wYWwgPSBmYWxzZSxcblx0XHRcdHVzZV9ncmV5ID0gZmFsc2U7XG5cblx0XHRzd2l0Y2ggKCBoZWFkZXIuaW1hZ2VfdHlwZSApIHtcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9STEVfSU5ERVhFRDpcblx0XHRcdFx0dXNlX3JsZSA9IHRydWU7XG5cdFx0XHRcdHVzZV9wYWwgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUR0FfVFlQRV9JTkRFWEVEOlxuXHRcdFx0XHR1c2VfcGFsID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX1JHQjpcblx0XHRcdFx0dXNlX3JsZSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX1JHQjpcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEdBX1RZUEVfUkxFX0dSRVk6XG5cdFx0XHRcdHVzZV9ybGUgPSB0cnVlO1xuXHRcdFx0XHR1c2VfZ3JleSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRHQV9UWVBFX0dSRVk6XG5cdFx0XHRcdHVzZV9ncmV5ID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIHVzZU9mZnNjcmVlbiA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnO1xuXG5cdFx0dmFyIGNhbnZhcyA9IHVzZU9mZnNjcmVlbiA/IG5ldyBPZmZzY3JlZW5DYW52YXMoIGhlYWRlci53aWR0aCwgaGVhZGVyLmhlaWdodCApIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcblx0XHRjYW52YXMud2lkdGggPSBoZWFkZXIud2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlYWRlci5oZWlnaHQ7XG5cblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG5cdFx0dmFyIGltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCBoZWFkZXIud2lkdGgsIGhlYWRlci5oZWlnaHQgKTtcblxuXHRcdHZhciByZXN1bHQgPSB0Z2FQYXJzZSggdXNlX3JsZSwgdXNlX3BhbCwgaGVhZGVyLCBvZmZzZXQsIGNvbnRlbnQgKTtcblx0XHRnZXRUZ2FSR0JBKCBpbWFnZURhdGEuZGF0YSwgaGVhZGVyLndpZHRoLCBoZWFkZXIuaGVpZ2h0LCByZXN1bHQucGl4ZWxfZGF0YSwgcmVzdWx0LnBhbGV0dGVzICk7XG5cblx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdH1cblxufSApO1xuXG52YXIgQ29sbGFkYUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cbn07XG5cbkNvbGxhZGFMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogQ29sbGFkYUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBwYXRoID0gKCBzY29wZS5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogc2NvcGUucGF0aDtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCwgcGF0aCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblxuXHRcdHNldCBjb252ZXJ0VXBBeGlzKCB2YWx1ZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogb3B0aW9ucy5jb252ZXJ0VXBBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXAgYXhpcyBpcyBjb252ZXJ0ZWQgYXV0b21hdGljYWxseS4nICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0LCBwYXRoICkge1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgbmFtZSApIHtcblxuXHRcdFx0Ly8gTm9uIHJlY3Vyc2l2ZSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSAuLi5cblxuXHRcdFx0dmFyIGFycmF5ID0gW107XG5cdFx0XHR2YXIgY2hpbGROb2RlcyA9IHhtbC5jaGlsZE5vZGVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZU5hbWUgPT09IG5hbWUgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVN0cmluZ3MoIHRleHQgKSB7XG5cblx0XHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRcdHZhciBwYXJ0cyA9IHRleHQudHJpbSgpLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdHZhciBhcnJheSA9IG5ldyBBcnJheSggcGFydHMubGVuZ3RoICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IHBhcnRzWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VGbG9hdHMoIHRleHQgKSB7XG5cblx0XHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRcdHZhciBwYXJ0cyA9IHRleHQudHJpbSgpLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdHZhciBhcnJheSA9IG5ldyBBcnJheSggcGFydHMubGVuZ3RoICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IHBhcnNlRmxvYXQoIHBhcnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUludHMoIHRleHQgKSB7XG5cblx0XHRcdGlmICggdGV4dC5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0XHRcdHZhciBwYXJ0cyA9IHRleHQudHJpbSgpLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdHZhciBhcnJheSA9IG5ldyBBcnJheSggcGFydHMubGVuZ3RoICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXSA9IHBhcnNlSW50KCBwYXJ0c1sgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VJZCggdGV4dCApIHtcblxuXHRcdFx0cmV0dXJuIHRleHQuc3Vic3RyaW5nKCAxICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuXG5cdFx0XHRyZXR1cm4gJ3RocmVlX2RlZmF1bHRfJyArICggY291bnQgKysgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzRW1wdHkoIG9iamVjdCApIHtcblxuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKCBvYmplY3QgKS5sZW5ndGggPT09IDA7XG5cblx0XHR9XG5cblx0XHQvLyBhc3NldFxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBc3NldCggeG1sICkge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR1bml0OiBwYXJzZUFzc2V0VW5pdCggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ3VuaXQnIClbIDAgXSApLFxuXHRcdFx0XHR1cEF4aXM6IHBhcnNlQXNzZXRVcEF4aXMoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICd1cF9heGlzJyApWyAwIF0gKVxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXNzZXRVbml0KCB4bWwgKSB7XG5cblx0XHRcdGlmICggKCB4bWwgIT09IHVuZGVmaW5lZCApICYmICggeG1sLmhhc0F0dHJpYnV0ZSggJ21ldGVyJyApID09PSB0cnVlICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoIHhtbC5nZXRBdHRyaWJ1dGUoICdtZXRlcicgKSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiAxOyAvLyBkZWZhdWx0IDEgbWV0ZXJcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBc3NldFVwQXhpcyggeG1sICkge1xuXG5cdFx0XHRyZXR1cm4geG1sICE9PSB1bmRlZmluZWQgPyB4bWwudGV4dENvbnRlbnQgOiAnWV9VUCc7XG5cblx0XHR9XG5cblx0XHQvLyBsaWJyYXJ5XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpYnJhcnkoIHhtbCwgbGlicmFyeU5hbWUsIG5vZGVOYW1lLCBwYXJzZXIgKSB7XG5cblx0XHRcdHZhciBsaWJyYXJ5ID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgbGlicmFyeU5hbWUgKVsgMCBdO1xuXG5cdFx0XHRpZiAoIGxpYnJhcnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgZWxlbWVudHMgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggbGlicmFyeSwgbm9kZU5hbWUgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRwYXJzZXIoIGVsZW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkTGlicmFyeSggZGF0YSwgYnVpbGRlciApIHtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gZGF0YSApIHtcblxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gZGF0YVsgbmFtZSBdO1xuXHRcdFx0XHRvYmplY3QuYnVpbGQgPSBidWlsZGVyKCBkYXRhWyBuYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2V0XG5cblx0XHRmdW5jdGlvbiBnZXRCdWlsZCggZGF0YSwgYnVpbGRlciApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0ZGF0YS5idWlsZCA9IGJ1aWxkZXIoIGRhdGEgKTtcblxuXHRcdFx0cmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHR9XG5cblx0XHQvLyBhbmltYXRpb25cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRzb3VyY2VzOiB7fSxcblx0XHRcdFx0c2FtcGxlcnM6IHt9LFxuXHRcdFx0XHRjaGFubmVsczoge31cblx0XHRcdH07XG5cblx0XHRcdHZhciBoYXNDaGlsZHJlbiA9IGZhbHNlO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBpZDtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cdFx0XHRcdFx0XHRpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5zb3VyY2VzWyBpZCBdID0gcGFyc2VTb3VyY2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NhbXBsZXInOlxuXHRcdFx0XHRcdFx0aWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHRcdFx0XHRcdGRhdGEuc2FtcGxlcnNbIGlkIF0gPSBwYXJzZUFuaW1hdGlvblNhbXBsZXIoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NoYW5uZWwnOlxuXHRcdFx0XHRcdFx0aWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICk7XG5cdFx0XHRcdFx0XHRkYXRhLmNoYW5uZWxzWyBpZCBdID0gcGFyc2VBbmltYXRpb25DaGFubmVsKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdhbmltYXRpb24nOlxuXHRcdFx0XHRcdFx0Ly8gaGllcmFyY2h5IG9mIHJlbGF0ZWQgYW5pbWF0aW9uc1xuXHRcdFx0XHRcdFx0cGFyc2VBbmltYXRpb24oIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRoYXNDaGlsZHJlbiA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNDaGlsZHJlbiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gc2luY2UgJ2lkJyBhdHRyaWJ1dGVzIGNhbiBiZSBvcHRpb25hbCwgaXQncyBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgYSBVVUlEIGZvciB1bnFpdWUgYXNzaWdubWVudFxuXG5cdFx0XHRcdGxpYnJhcnkuYW5pbWF0aW9uc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIHx8IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKSBdID0gZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25TYW1wbGVyKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpbnB1dHM6IHt9LFxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdFx0XHRcdHZhciBpZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0dmFyIHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHRkYXRhLmlucHV0c1sgc2VtYW50aWMgXSA9IGlkO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25DaGFubmVsKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdHZhciB0YXJnZXQgPSB4bWwuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApO1xuXG5cdFx0XHQvLyBwYXJzaW5nIFNJRCBBZGRyZXNzaW5nIFN5bnRheFxuXG5cdFx0XHR2YXIgcGFydHMgPSB0YXJnZXQuc3BsaXQoICcvJyApO1xuXG5cdFx0XHR2YXIgaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0dmFyIHNpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdC8vIGNoZWNrIHNlbGVjdGlvbiBzeW50YXhcblxuXHRcdFx0dmFyIGFycmF5U3ludGF4ID0gKCBzaWQuaW5kZXhPZiggJygnICkgIT09IC0gMSApO1xuXHRcdFx0dmFyIG1lbWJlclN5bnRheCA9ICggc2lkLmluZGV4T2YoICcuJyApICE9PSAtIDEgKTtcblxuXHRcdFx0aWYgKCBtZW1iZXJTeW50YXggKSB7XG5cblx0XHRcdFx0Ly8gIG1lbWJlciBzZWxlY3Rpb24gYWNjZXNzXG5cblx0XHRcdFx0cGFydHMgPSBzaWQuc3BsaXQoICcuJyApO1xuXHRcdFx0XHRzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHRkYXRhLm1lbWJlciA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGFycmF5U3ludGF4ICkge1xuXG5cdFx0XHRcdC8vIGFycmF5LWFjY2VzcyBzeW50YXguIGNhbiBiZSB1c2VkIHRvIGV4cHJlc3MgZmllbGRzIGluIG9uZS1kaW1lbnNpb25hbCB2ZWN0b3JzIG9yIHR3by1kaW1lbnNpb25hbCBtYXRyaWNlcy5cblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IHNpZC5zcGxpdCggJygnICk7XG5cdFx0XHRcdHNpZCA9IGluZGljZXMuc2hpZnQoKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGluZGljZXNbIGkgXSA9IHBhcnNlSW50KCBpbmRpY2VzWyBpIF0ucmVwbGFjZSggL1xcKS8sICcnICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGF0YS5pbmRpY2VzID0gaW5kaWNlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRkYXRhLmlkID0gaWQ7XG5cdFx0XHRkYXRhLnNpZCA9IHNpZDtcblxuXHRcdFx0ZGF0YS5hcnJheVN5bnRheCA9IGFycmF5U3ludGF4O1xuXHRcdFx0ZGF0YS5tZW1iZXJTeW50YXggPSBtZW1iZXJTeW50YXg7XG5cblx0XHRcdGRhdGEuc2FtcGxlciA9IHBhcnNlSWQoIHhtbC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEFuaW1hdGlvbiggZGF0YSApIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHR2YXIgY2hhbm5lbHMgPSBkYXRhLmNoYW5uZWxzO1xuXHRcdFx0dmFyIHNhbXBsZXJzID0gZGF0YS5zYW1wbGVycztcblx0XHRcdHZhciBzb3VyY2VzID0gZGF0YS5zb3VyY2VzO1xuXG5cdFx0XHRmb3IgKCB2YXIgdGFyZ2V0IGluIGNoYW5uZWxzICkge1xuXG5cdFx0XHRcdGlmICggY2hhbm5lbHMuaGFzT3duUHJvcGVydHkoIHRhcmdldCApICkge1xuXG5cdFx0XHRcdFx0dmFyIGNoYW5uZWwgPSBjaGFubmVsc1sgdGFyZ2V0IF07XG5cdFx0XHRcdFx0dmFyIHNhbXBsZXIgPSBzYW1wbGVyc1sgY2hhbm5lbC5zYW1wbGVyIF07XG5cblx0XHRcdFx0XHR2YXIgaW5wdXRJZCA9IHNhbXBsZXIuaW5wdXRzLklOUFVUO1xuXHRcdFx0XHRcdHZhciBvdXRwdXRJZCA9IHNhbXBsZXIuaW5wdXRzLk9VVFBVVDtcblxuXHRcdFx0XHRcdHZhciBpbnB1dFNvdXJjZSA9IHNvdXJjZXNbIGlucHV0SWQgXTtcblx0XHRcdFx0XHR2YXIgb3V0cHV0U291cmNlID0gc291cmNlc1sgb3V0cHV0SWQgXTtcblxuXHRcdFx0XHRcdHZhciBhbmltYXRpb24gPSBidWlsZEFuaW1hdGlvbkNoYW5uZWwoIGNoYW5uZWwsIGlucHV0U291cmNlLCBvdXRwdXRTb3VyY2UgKTtcblxuXHRcdFx0XHRcdGNyZWF0ZUtleWZyYW1lVHJhY2tzKCBhbmltYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJhY2tzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmFuaW1hdGlvbnNbIGlkIF0sIGJ1aWxkQW5pbWF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEFuaW1hdGlvbkNoYW5uZWwoIGNoYW5uZWwsIGlucHV0U291cmNlLCBvdXRwdXRTb3VyY2UgKSB7XG5cblx0XHRcdHZhciBub2RlID0gbGlicmFyeS5ub2Rlc1sgY2hhbm5lbC5pZCBdO1xuXHRcdFx0dmFyIG9iamVjdDNEID0gZ2V0Tm9kZSggbm9kZS5pZCApO1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gbm9kZS50cmFuc2Zvcm1zWyBjaGFubmVsLnNpZCBdO1xuXHRcdFx0dmFyIGRlZmF1bHRNYXRyaXggPSBub2RlLm1hdHJpeC5jbG9uZSgpLnRyYW5zcG9zZSgpO1xuXG5cdFx0XHR2YXIgdGltZSwgc3RyaWRlO1xuXHRcdFx0dmFyIGksIGlsLCBqLCBqbDtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Ly8gdGhlIGNvbGxhZGEgc3BlYyBhbGxvd3MgdGhlIGFuaW1hdGlvbiBvZiBkYXRhIGluIHZhcmlvdXMgd2F5cy5cblx0XHRcdC8vIGRlcGVuZGluZyBvbiB0aGUgdHJhbnNmb3JtIHR5cGUgKG1hdHJpeCwgdHJhbnNsYXRlLCByb3RhdGUsIHNjYWxlKSwgd2UgZXhlY3V0ZSBkaWZmZXJlbnQgbG9naWNcblxuXHRcdFx0c3dpdGNoICggdHJhbnNmb3JtICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBpbnB1dFNvdXJjZS5hcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dGltZSA9IGlucHV0U291cmNlLmFycmF5WyBpIF07XG5cdFx0XHRcdFx0XHRzdHJpZGUgPSBpICogb3V0cHV0U291cmNlLnN0cmlkZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhWyB0aW1lIF0gPT09IHVuZGVmaW5lZCApIGRhdGFbIHRpbWUgXSA9IHt9O1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNoYW5uZWwuYXJyYXlTeW50YXggPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gb3V0cHV0U291cmNlLmFycmF5WyBzdHJpZGUgXTtcblx0XHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gY2hhbm5lbC5pbmRpY2VzWyAwIF0gKyA0ICogY2hhbm5lbC5pbmRpY2VzWyAxIF07XG5cblx0XHRcdFx0XHRcdFx0ZGF0YVsgdGltZSBdWyBpbmRleCBdID0gdmFsdWU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gb3V0cHV0U291cmNlLnN0cmlkZTsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgdGltZSBdWyBqIF0gPSBvdXRwdXRTb3VyY2UuYXJyYXlbIHN0cmlkZSArIGogXTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQW5pbWF0aW9uIHRyYW5zZm9ybSB0eXBlIFwiJXNcIiBub3QgeWV0IGltcGxlbWVudGVkLicsIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQW5pbWF0aW9uIHRyYW5zZm9ybSB0eXBlIFwiJXNcIiBub3QgeWV0IGltcGxlbWVudGVkLicsIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBBbmltYXRpb24gdHJhbnNmb3JtIHR5cGUgXCIlc1wiIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJywgdHJhbnNmb3JtICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleWZyYW1lcyA9IHByZXBhcmVBbmltYXRpb25EYXRhKCBkYXRhLCBkZWZhdWx0TWF0cml4ICk7XG5cblx0XHRcdHZhciBhbmltYXRpb24gPSB7XG5cdFx0XHRcdG5hbWU6IG9iamVjdDNELnV1aWQsXG5cdFx0XHRcdGtleWZyYW1lczoga2V5ZnJhbWVzXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbkRhdGEoIGRhdGEsIGRlZmF1bHRNYXRyaXggKSB7XG5cblx0XHRcdHZhciBrZXlmcmFtZXMgPSBbXTtcblxuXHRcdFx0Ly8gdHJhbnNmZXIgZGF0YSBpbnRvIGEgc29ydGFibGUgYXJyYXlcblxuXHRcdFx0Zm9yICggdmFyIHRpbWUgaW4gZGF0YSApIHtcblxuXHRcdFx0XHRrZXlmcmFtZXMucHVzaCggeyB0aW1lOiBwYXJzZUZsb2F0KCB0aW1lICksIHZhbHVlOiBkYXRhWyB0aW1lIF0gfSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBrZXlmcmFtZXMgYXJlIHNvcnRlZCBieSB0aW1lXG5cblx0XHRcdGtleWZyYW1lcy5zb3J0KCBhc2NlbmRpbmcgKTtcblxuXHRcdFx0Ly8gbm93IHdlIGNsZWFuIHVwIGFsbCBhbmltYXRpb24gZGF0YSwgc28gd2UgY2FuIHVzZSB0aGVtIGZvciBrZXlmcmFtZSB0cmFja3NcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdFx0dHJhbnNmb3JtQW5pbWF0aW9uRGF0YSgga2V5ZnJhbWVzLCBpLCBkZWZhdWx0TWF0cml4LmVsZW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ga2V5ZnJhbWVzO1xuXG5cdFx0XHQvLyBhcnJheSBzb3J0IGZ1bmN0aW9uXG5cblx0XHRcdGZ1bmN0aW9uIGFzY2VuZGluZyggYSwgYiApIHtcblxuXHRcdFx0XHRyZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlS2V5ZnJhbWVUcmFja3MoIGFuaW1hdGlvbiwgdHJhY2tzICkge1xuXG5cdFx0XHR2YXIga2V5ZnJhbWVzID0gYW5pbWF0aW9uLmtleWZyYW1lcztcblx0XHRcdHZhciBuYW1lID0gYW5pbWF0aW9uLm5hbWU7XG5cblx0XHRcdHZhciB0aW1lcyA9IFtdO1xuXHRcdFx0dmFyIHBvc2l0aW9uRGF0YSA9IFtdO1xuXHRcdFx0dmFyIHF1YXRlcm5pb25EYXRhID0gW107XG5cdFx0XHR2YXIgc2NhbGVEYXRhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdHZhciB0aW1lID0ga2V5ZnJhbWUudGltZTtcblx0XHRcdFx0dmFyIHZhbHVlID0ga2V5ZnJhbWUudmFsdWU7XG5cblx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggdmFsdWUgKS50cmFuc3Bvc2UoKTtcblx0XHRcdFx0bWF0cml4LmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICk7XG5cblx0XHRcdFx0dGltZXMucHVzaCggdGltZSApO1xuXHRcdFx0XHRwb3NpdGlvbkRhdGEucHVzaCggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXHRcdFx0XHRxdWF0ZXJuaW9uRGF0YS5wdXNoKCBxdWF0ZXJuaW9uLngsIHF1YXRlcm5pb24ueSwgcXVhdGVybmlvbi56LCBxdWF0ZXJuaW9uLncgKTtcblx0XHRcdFx0c2NhbGVEYXRhLnB1c2goIHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvc2l0aW9uRGF0YS5sZW5ndGggPiAwICkgdHJhY2tzLnB1c2goIG5ldyBWZWN0b3JLZXlmcmFtZVRyYWNrKCBuYW1lICsgJy5wb3NpdGlvbicsIHRpbWVzLCBwb3NpdGlvbkRhdGEgKSApO1xuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uRGF0YS5sZW5ndGggPiAwICkgdHJhY2tzLnB1c2goIG5ldyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggbmFtZSArICcucXVhdGVybmlvbicsIHRpbWVzLCBxdWF0ZXJuaW9uRGF0YSApICk7XG5cdFx0XHRpZiAoIHNjYWxlRGF0YS5sZW5ndGggPiAwICkgdHJhY2tzLnB1c2goIG5ldyBWZWN0b3JLZXlmcmFtZVRyYWNrKCBuYW1lICsgJy5zY2FsZScsIHRpbWVzLCBzY2FsZURhdGEgKSApO1xuXG5cdFx0XHRyZXR1cm4gdHJhY2tzO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJhbnNmb3JtQW5pbWF0aW9uRGF0YSgga2V5ZnJhbWVzLCBwcm9wZXJ0eSwgZGVmYXVsdFZhbHVlICkge1xuXG5cdFx0XHR2YXIga2V5ZnJhbWU7XG5cblx0XHRcdHZhciBlbXB0eSA9IHRydWU7XG5cdFx0XHR2YXIgaSwgbDtcblxuXHRcdFx0Ly8gY2hlY2ssIGlmIHZhbHVlcyBvZiBhIHByb3BlcnR5IGFyZSBtaXNzaW5nIGluIG91ciBrZXlmcmFtZXNcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBrZXlmcmFtZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gbnVsbDsgLy8gbWFyayBhcyBtaXNzaW5nXG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGVtcHR5ID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZW1wdHkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Ly8gbm8gdmFsdWVzIGF0IGFsbCwgc28gd2Ugc2V0IGEgZGVmYXVsdCB2YWx1ZVxuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0ga2V5ZnJhbWVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0a2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPSBkZWZhdWx0VmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGZpbGxpbmcgZ2Fwc1xuXG5cdFx0XHRcdGNyZWF0ZU1pc3NpbmdLZXlmcmFtZXMoIGtleWZyYW1lcywgcHJvcGVydHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlTWlzc2luZ0tleWZyYW1lcygga2V5ZnJhbWVzLCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0dmFyIHByZXYsIG5leHQ7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGtleWZyYW1lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRwcmV2ID0gZ2V0UHJldigga2V5ZnJhbWVzLCBpLCBwcm9wZXJ0eSApO1xuXHRcdFx0XHRcdG5leHQgPSBnZXROZXh0KCBrZXlmcmFtZXMsIGksIHByb3BlcnR5ICk7XG5cblx0XHRcdFx0XHRpZiAoIHByZXYgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGtleWZyYW1lLnZhbHVlWyBwcm9wZXJ0eSBdID0gbmV4dC52YWx1ZVsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSA9IHByZXYudmFsdWVbIHByb3BlcnR5IF07XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGludGVycG9sYXRlKCBrZXlmcmFtZSwgcHJldiwgbmV4dCwgcHJvcGVydHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZXYoIGtleWZyYW1lcywgaSwgcHJvcGVydHkgKSB7XG5cblx0XHRcdHdoaWxlICggaSA+PSAwICkge1xuXG5cdFx0XHRcdHZhciBrZXlmcmFtZSA9IGtleWZyYW1lc1sgaSBdO1xuXG5cdFx0XHRcdGlmICgga2V5ZnJhbWUudmFsdWVbIHByb3BlcnR5IF0gIT09IG51bGwgKSByZXR1cm4ga2V5ZnJhbWU7XG5cblx0XHRcdFx0aSAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE5leHQoIGtleWZyYW1lcywgaSwgcHJvcGVydHkgKSB7XG5cblx0XHRcdHdoaWxlICggaSA8IGtleWZyYW1lcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0dmFyIGtleWZyYW1lID0ga2V5ZnJhbWVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBrZXlmcmFtZS52YWx1ZVsgcHJvcGVydHkgXSAhPT0gbnVsbCApIHJldHVybiBrZXlmcmFtZTtcblxuXHRcdFx0XHRpICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIGtleSwgcHJldiwgbmV4dCwgcHJvcGVydHkgKSB7XG5cblx0XHRcdGlmICggKCBuZXh0LnRpbWUgLSBwcmV2LnRpbWUgKSA9PT0gMCApIHtcblxuXHRcdFx0XHRrZXkudmFsdWVbIHByb3BlcnR5IF0gPSBwcmV2LnZhbHVlWyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0a2V5LnZhbHVlWyBwcm9wZXJ0eSBdID0gKCAoIGtleS50aW1lIC0gcHJldi50aW1lICkgKiAoIG5leHQudmFsdWVbIHByb3BlcnR5IF0gLSBwcmV2LnZhbHVlWyBwcm9wZXJ0eSBdICkgLyAoIG5leHQudGltZSAtIHByZXYudGltZSApICkgKyBwcmV2LnZhbHVlWyBwcm9wZXJ0eSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYW5pbWF0aW9uIGNsaXBzXG5cblx0XHRmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbkNsaXAoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSB8fCAnZGVmYXVsdCcsXG5cdFx0XHRcdHN0YXJ0OiBwYXJzZUZsb2F0KCB4bWwuZ2V0QXR0cmlidXRlKCAnc3RhcnQnICkgfHwgMCApLFxuXHRcdFx0XHRlbmQ6IHBhcnNlRmxvYXQoIHhtbC5nZXRBdHRyaWJ1dGUoICdlbmQnICkgfHwgMCApLFxuXHRcdFx0XHRhbmltYXRpb25zOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2FuaW1hdGlvbic6XG5cdFx0XHRcdFx0XHRkYXRhLmFuaW1hdGlvbnMucHVzaCggcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmNsaXBzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEFuaW1hdGlvbkNsaXAoIGRhdGEgKSB7XG5cblx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0dmFyIG5hbWUgPSBkYXRhLm5hbWU7XG5cdFx0XHR2YXIgZHVyYXRpb24gPSAoIGRhdGEuZW5kIC0gZGF0YS5zdGFydCApIHx8IC0gMTtcblx0XHRcdHZhciBhbmltYXRpb25zID0gZGF0YS5hbmltYXRpb25zO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYW5pbWF0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYW5pbWF0aW9uVHJhY2tzID0gZ2V0QW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0gKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gYW5pbWF0aW9uVHJhY2tzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dHJhY2tzLnB1c2goIGFuaW1hdGlvblRyYWNrc1sgaiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ2xpcCggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5jbGlwc1sgaWQgXSwgYnVpbGRBbmltYXRpb25DbGlwICk7XG5cblx0XHR9XG5cblx0XHQvLyBjb250cm9sbGVyXG5cblx0XHRmdW5jdGlvbiBwYXJzZUNvbnRyb2xsZXIoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3NraW4nOlxuXHRcdFx0XHRcdFx0Ly8gdGhlcmUgaXMgZXhhY3RseSBvbmUgc2tpbiBwZXIgY29udHJvbGxlclxuXHRcdFx0XHRcdFx0ZGF0YS5pZCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5za2luID0gcGFyc2VTa2luKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtb3JwaCc6XG5cdFx0XHRcdFx0XHRkYXRhLmlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBNb3JwaCB0YXJnZXQgYW5pbWF0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0LicgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmNvbnRyb2xsZXJzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHNvdXJjZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmluZF9zaGFwZV9tYXRyaXgnOlxuXHRcdFx0XHRcdFx0ZGF0YS5iaW5kU2hhcGVNYXRyaXggPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblx0XHRcdFx0XHRcdHZhciBpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0XHRcdFx0ZGF0YS5zb3VyY2VzWyBpZCBdID0gcGFyc2VTb3VyY2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2pvaW50cyc6XG5cdFx0XHRcdFx0XHRkYXRhLmpvaW50cyA9IHBhcnNlSm9pbnRzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2ZXJ0ZXhfd2VpZ2h0cyc6XG5cdFx0XHRcdFx0XHRkYXRhLnZlcnRleFdlaWdodHMgPSBwYXJzZVZlcnRleFdlaWdodHMoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUpvaW50cyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0aW5wdXRzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdFx0XHRcdHZhciBzZW1hbnRpYyA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NlbWFudGljJyApO1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cdFx0XHRcdFx0XHRkYXRhLmlucHV0c1sgc2VtYW50aWMgXSA9IGlkO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VWZXJ0ZXhXZWlnaHRzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRpbnB1dHM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXHRcdFx0XHRcdFx0dmFyIHNlbWFudGljID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2VtYW50aWMnICk7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnb2Zmc2V0JyApICk7XG5cdFx0XHRcdFx0XHRkYXRhLmlucHV0c1sgc2VtYW50aWMgXSA9IHsgaWQ6IGlkLCBvZmZzZXQ6IG9mZnNldCB9O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Y291bnQnOlxuXHRcdFx0XHRcdFx0ZGF0YS52Y291bnQgPSBwYXJzZUludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHRcdFx0ZGF0YS52ID0gcGFyc2VJbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRDb250cm9sbGVyKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgYnVpbGQgPSB7XG5cdFx0XHRcdGlkOiBkYXRhLmlkXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBsaWJyYXJ5Lmdlb21ldHJpZXNbIGJ1aWxkLmlkIF07XG5cblx0XHRcdGlmICggZGF0YS5za2luICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0YnVpbGQuc2tpbiA9IGJ1aWxkU2tpbiggZGF0YS5za2luICk7XG5cblx0XHRcdFx0Ly8gd2UgZW5oYW5jZSB0aGUgJ3NvdXJjZXMnIHByb3BlcnR5IG9mIHRoZSBjb3JyZXNwb25kaW5nIGdlb21ldHJ5IHdpdGggb3VyIHNraW4gZGF0YVxuXG5cdFx0XHRcdGdlb21ldHJ5LnNvdXJjZXMuc2tpbkluZGljZXMgPSBidWlsZC5za2luLmluZGljZXM7XG5cdFx0XHRcdGdlb21ldHJ5LnNvdXJjZXMuc2tpbldlaWdodHMgPSBidWlsZC5za2luLndlaWdodHM7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRTa2luKCBkYXRhICkge1xuXG5cdFx0XHR2YXIgQk9ORV9MSU1JVCA9IDQ7XG5cblx0XHRcdHZhciBidWlsZCA9IHtcblx0XHRcdFx0am9pbnRzOiBbXSwgLy8gdGhpcyBtdXN0IGJlIGFuIGFycmF5IHRvIHByZXNlcnZlIHRoZSBqb2ludCBvcmRlclxuXHRcdFx0XHRpbmRpY2VzOiB7XG5cdFx0XHRcdFx0YXJyYXk6IFtdLFxuXHRcdFx0XHRcdHN0cmlkZTogQk9ORV9MSU1JVFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR3ZWlnaHRzOiB7XG5cdFx0XHRcdFx0YXJyYXk6IFtdLFxuXHRcdFx0XHRcdHN0cmlkZTogQk9ORV9MSU1JVFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgc291cmNlcyA9IGRhdGEuc291cmNlcztcblx0XHRcdHZhciB2ZXJ0ZXhXZWlnaHRzID0gZGF0YS52ZXJ0ZXhXZWlnaHRzO1xuXG5cdFx0XHR2YXIgdmNvdW50ID0gdmVydGV4V2VpZ2h0cy52Y291bnQ7XG5cdFx0XHR2YXIgdiA9IHZlcnRleFdlaWdodHMudjtcblx0XHRcdHZhciBqb2ludE9mZnNldCA9IHZlcnRleFdlaWdodHMuaW5wdXRzLkpPSU5ULm9mZnNldDtcblx0XHRcdHZhciB3ZWlnaHRPZmZzZXQgPSB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5XRUlHSFQub2Zmc2V0O1xuXG5cdFx0XHR2YXIgam9pbnRTb3VyY2UgPSBkYXRhLnNvdXJjZXNbIGRhdGEuam9pbnRzLmlucHV0cy5KT0lOVCBdO1xuXHRcdFx0dmFyIGludmVyc2VTb3VyY2UgPSBkYXRhLnNvdXJjZXNbIGRhdGEuam9pbnRzLmlucHV0cy5JTlZfQklORF9NQVRSSVggXTtcblxuXHRcdFx0dmFyIHdlaWdodHMgPSBzb3VyY2VzWyB2ZXJ0ZXhXZWlnaHRzLmlucHV0cy5XRUlHSFQuaWQgXS5hcnJheTtcblx0XHRcdHZhciBzdHJpZGUgPSAwO1xuXG5cdFx0XHR2YXIgaSwgaiwgbDtcblxuXHRcdFx0Ly8gcHJvY2NlcyBza2luIGRhdGEgZm9yIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmNvdW50Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGpvaW50Q291bnQgPSB2Y291bnRbIGkgXTsgLy8gdGhpcyBpcyB0aGUgYW1vdW50IG9mIGpvaW50cyB0aGF0IGFmZmVjdCBhIHNpbmdsZSB2ZXJ0ZXhcblx0XHRcdFx0dmFyIHZlcnRleFNraW5EYXRhID0gW107XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBqb2ludENvdW50OyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHNraW5JbmRleCA9IHZbIHN0cmlkZSArIGpvaW50T2Zmc2V0IF07XG5cdFx0XHRcdFx0dmFyIHdlaWdodElkID0gdlsgc3RyaWRlICsgd2VpZ2h0T2Zmc2V0IF07XG5cdFx0XHRcdFx0dmFyIHNraW5XZWlnaHQgPSB3ZWlnaHRzWyB3ZWlnaHRJZCBdO1xuXG5cdFx0XHRcdFx0dmVydGV4U2tpbkRhdGEucHVzaCggeyBpbmRleDogc2tpbkluZGV4LCB3ZWlnaHQ6IHNraW5XZWlnaHQgfSApO1xuXG5cdFx0XHRcdFx0c3RyaWRlICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHdlIHNvcnQgdGhlIGpvaW50cyBpbiBkZXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoZSB3ZWlnaHRzLlxuXHRcdFx0XHQvLyB0aGlzIGVuc3VyZXMsIHdlIG9ubHkgcHJvY2NlZCB0aGUgbW9zdCBpbXBvcnRhbnQgam9pbnRzIG9mIHRoZSB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXhTa2luRGF0YS5zb3J0KCBkZXNjZW5kaW5nICk7XG5cblx0XHRcdFx0Ly8gbm93IHdlIHByb3ZpZGUgZm9yIGVhY2ggdmVydGV4IGEgc2V0IG9mIGZvdXIgaW5kZXggYW5kIHdlaWdodCB2YWx1ZXMuXG5cdFx0XHRcdC8vIHRoZSBvcmRlciBvZiB0aGUgc2tpbiBkYXRhIG1hdGNoZXMgdGhlIG9yZGVyIG9mIHZlcnRpY2VzXG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBCT05FX0xJTUlUOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGQgPSB2ZXJ0ZXhTa2luRGF0YVsgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGJ1aWxkLmluZGljZXMuYXJyYXkucHVzaCggZC5pbmRleCApO1xuXHRcdFx0XHRcdFx0YnVpbGQud2VpZ2h0cy5hcnJheS5wdXNoKCBkLndlaWdodCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0YnVpbGQuaW5kaWNlcy5hcnJheS5wdXNoKCAwICk7XG5cdFx0XHRcdFx0XHRidWlsZC53ZWlnaHRzLmFycmF5LnB1c2goIDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0dXAgYmluZCBtYXRyaXhcblxuXHRcdFx0aWYgKCBkYXRhLmJpbmRTaGFwZU1hdHJpeCApIHtcblxuXHRcdFx0XHRidWlsZC5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGRhdGEuYmluZFNoYXBlTWF0cml4ICkudHJhbnNwb3NlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YnVpbGQuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9jZXNzIGJvbmVzIGFuZCBpbnZlcnNlIGJpbmQgbWF0cml4IGRhdGFcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqb2ludFNvdXJjZS5hcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBuYW1lID0gam9pbnRTb3VyY2UuYXJyYXlbIGkgXTtcblx0XHRcdFx0dmFyIGJvbmVJbnZlcnNlID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGludmVyc2VTb3VyY2UuYXJyYXksIGkgKiBpbnZlcnNlU291cmNlLnN0cmlkZSApLnRyYW5zcG9zZSgpO1xuXG5cdFx0XHRcdGJ1aWxkLmpvaW50cy5wdXNoKCB7IG5hbWU6IG5hbWUsIGJvbmVJbnZlcnNlOiBib25lSW52ZXJzZSB9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0XHQvLyBhcnJheSBzb3J0IGZ1bmN0aW9uXG5cblx0XHRcdGZ1bmN0aW9uIGRlc2NlbmRpbmcoIGEsIGIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGIud2VpZ2h0IC0gYS53ZWlnaHQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbnRyb2xsZXIoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkuY29udHJvbGxlcnNbIGlkIF0sIGJ1aWxkQ29udHJvbGxlciApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW1hZ2VcblxuXHRcdGZ1bmN0aW9uIHBhcnNlSW1hZ2UoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGluaXRfZnJvbTogZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ2luaXRfZnJvbScgKVsgMCBdLnRleHRDb250ZW50XG5cdFx0XHR9O1xuXG5cdFx0XHRsaWJyYXJ5LmltYWdlc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRJbWFnZSggZGF0YSApIHtcblxuXHRcdFx0aWYgKCBkYXRhLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZGF0YS5idWlsZDtcblxuXHRcdFx0cmV0dXJuIGRhdGEuaW5pdF9mcm9tO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0SW1hZ2UoIGlkICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IGxpYnJhcnkuaW1hZ2VzWyBpZCBdO1xuXG5cdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGRhdGEsIGJ1aWxkSW1hZ2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBDb3VsZG5cXCd0IGZpbmQgaW1hZ2Ugd2l0aCBJRDonLCBpZCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIGVmZmVjdFxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3QoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3Byb2ZpbGVfQ09NTU9OJzpcblx0XHRcdFx0XHRcdGRhdGEucHJvZmlsZSA9IHBhcnNlRWZmZWN0UHJvZmlsZUNPTU1PTiggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmVmZmVjdHNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UHJvZmlsZUNPTU1PTiggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0c3VyZmFjZXM6IHt9LFxuXHRcdFx0XHRzYW1wbGVyczoge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICduZXdwYXJhbSc6XG5cdFx0XHRcdFx0XHRwYXJzZUVmZmVjdE5ld3BhcmFtKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWUnOlxuXHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWUgPSBwYXJzZUVmZmVjdFRlY2huaXF1ZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdFx0ZGF0YS5leHRyYSA9IHBhcnNlRWZmZWN0RXh0cmEoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdE5ld3BhcmFtKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdHZhciBzaWQgPSB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc3VyZmFjZSc6XG5cdFx0XHRcdFx0XHRkYXRhLnN1cmZhY2VzWyBzaWQgXSA9IHBhcnNlRWZmZWN0U3VyZmFjZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnc2FtcGxlcjJEJzpcblx0XHRcdFx0XHRcdGRhdGEuc2FtcGxlcnNbIHNpZCBdID0gcGFyc2VFZmZlY3RTYW1wbGVyKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFN1cmZhY2UoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luaXRfZnJvbSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluaXRfZnJvbSA9IGNoaWxkLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RTYW1wbGVyKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdzb3VyY2UnOlxuXHRcdFx0XHRcdFx0ZGF0YS5zb3VyY2UgPSBjaGlsZC50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0VGVjaG5pcXVlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb25zdGFudCc6XG5cdFx0XHRcdFx0Y2FzZSAnbGFtYmVydCc6XG5cdFx0XHRcdFx0Y2FzZSAnYmxpbm4nOlxuXHRcdFx0XHRcdGNhc2UgJ3Bob25nJzpcblx0XHRcdFx0XHRcdGRhdGEudHlwZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdFx0ZGF0YS5wYXJhbWV0ZXJzID0gcGFyc2VFZmZlY3RQYXJhbWV0ZXJzKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RQYXJhbWV0ZXJzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdFx0Y2FzZSAnZGlmZnVzZSc6XG5cdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxuXHRcdFx0XHRcdGNhc2UgJ2J1bXAnOlxuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdGNhc2UgJ3NoaW5pbmVzcyc6XG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5Jzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUVmZmVjdFBhcmFtZXRlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50Jzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSB7XG5cdFx0XHRcdFx0XHRcdG9wYXF1ZTogY2hpbGQuZ2V0QXR0cmlidXRlKCAnb3BhcXVlJyApLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBwYXJzZUVmZmVjdFBhcmFtZXRlciggY2hpbGQgKVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVyKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2Zsb2F0Jzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0ZXh0dXJlJzpcblx0XHRcdFx0XHRcdGRhdGFbIGNoaWxkLm5vZGVOYW1lIF0gPSB7IGlkOiBjaGlsZC5nZXRBdHRyaWJ1dGUoICd0ZXh0dXJlJyApLCBleHRyYTogcGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlKCBjaGlsZCApIH07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHRlY2huaXF1ZToge31cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdleHRyYSc6XG5cdFx0XHRcdFx0XHRwYXJzZUVmZmVjdFBhcmFtZXRlclRleHR1cmVFeHRyYSggY2hpbGQsIGRhdGEgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd0ZWNobmlxdWUnOlxuXHRcdFx0XHRcdFx0cGFyc2VFZmZlY3RQYXJhbWV0ZXJUZXh0dXJlRXh0cmFUZWNobmlxdWUoIGNoaWxkLCBkYXRhICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0UGFyYW1ldGVyVGV4dHVyZUV4dHJhVGVjaG5pcXVlKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdyZXBlYXRVJzpcblx0XHRcdFx0XHRjYXNlICdyZXBlYXRWJzpcblx0XHRcdFx0XHRjYXNlICdvZmZzZXRVJzpcblx0XHRcdFx0XHRjYXNlICdvZmZzZXRWJzpcblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnd3JhcFUnOlxuXHRcdFx0XHRcdGNhc2UgJ3dyYXBWJzpcblxuXHRcdFx0XHRcdFx0Ly8gc29tZSBmaWxlcyBoYXZlIHZhbHVlcyBmb3Igd3JhcFUvd3JhcFYgd2hpY2ggYmVjb21lIE5hTiB2aWEgcGFyc2VJbnRcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZC50ZXh0Q29udGVudC50b1VwcGVyQ2FzZSgpID09PSAnVFJVRScgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWVbIGNoaWxkLm5vZGVOYW1lIF0gPSAxO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjaGlsZC50ZXh0Q29udGVudC50b1VwcGVyQ2FzZSgpID09PSAnRkFMU0UnICkge1xuXG5cdFx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlWyBjaGlsZC5ub2RlTmFtZSBdID0gMDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLnRlY2huaXF1ZVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlSW50KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFZmZlY3RFeHRyYSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gcGFyc2VFZmZlY3RFeHRyYVRlY2huaXF1ZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRWZmZWN0RXh0cmFUZWNobmlxdWUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2RvdWJsZV9zaWRlZCc6XG5cdFx0XHRcdFx0XHRkYXRhWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VJbnQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEVmZmVjdCggZGF0YSApIHtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRFZmZlY3QoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkuZWZmZWN0c1sgaWQgXSwgYnVpbGRFZmZlY3QgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1hdGVyaWFsXG5cblx0XHRmdW5jdGlvbiBwYXJzZU1hdGVyaWFsKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0geG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2VmZmVjdCc6XG5cdFx0XHRcdFx0XHRkYXRhLnVybCA9IHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkubWF0ZXJpYWxzWyB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSA9IGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlTG9hZGVyKCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGxvYWRlcjtcblxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGltYWdlLnNsaWNlKCAoIGltYWdlLmxhc3RJbmRleE9mKCAnLicgKSAtIDEgPj4+IDAgKSArIDIgKTsgLy8gaHR0cDovL3d3dy5qc3RpcHMuY28vZW4vamF2YXNjcmlwdC9nZXQtZmlsZS1leHRlbnNpb24vXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0c3dpdGNoICggZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ3RnYSc6XG5cdFx0XHRcdFx0bG9hZGVyID0gdGdhTG9hZGVyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0bG9hZGVyID0gdGV4dHVyZUxvYWRlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRNYXRlcmlhbCggZGF0YSApIHtcblxuXHRcdFx0dmFyIGVmZmVjdCA9IGdldEVmZmVjdCggZGF0YS51cmwgKTtcblx0XHRcdHZhciB0ZWNobmlxdWUgPSBlZmZlY3QucHJvZmlsZS50ZWNobmlxdWU7XG5cdFx0XHR2YXIgZXh0cmEgPSBlZmZlY3QucHJvZmlsZS5leHRyYTtcblxuXHRcdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0XHRzd2l0Y2ggKCB0ZWNobmlxdWUudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRcdGNhc2UgJ2JsaW5uJzpcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZSB8fCAnJztcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggdGV4dHVyZU9iamVjdCApIHtcblxuXHRcdFx0XHR2YXIgc2FtcGxlciA9IGVmZmVjdC5wcm9maWxlLnNhbXBsZXJzWyB0ZXh0dXJlT2JqZWN0LmlkIF07XG5cdFx0XHRcdHZhciBpbWFnZSA9IG51bGw7XG5cblx0XHRcdFx0Ly8gZ2V0IGltYWdlXG5cblx0XHRcdFx0aWYgKCBzYW1wbGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3VyZmFjZSA9IGVmZmVjdC5wcm9maWxlLnN1cmZhY2VzWyBzYW1wbGVyLnNvdXJjZSBdO1xuXHRcdFx0XHRcdGltYWdlID0gZ2V0SW1hZ2UoIHN1cmZhY2UuaW5pdF9mcm9tICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVuZGVmaW5lZCBzYW1wbGVyLiBBY2Nlc3MgaW1hZ2UgZGlyZWN0bHkgKHNlZSAjMTI1MzApLicgKTtcblx0XHRcdFx0XHRpbWFnZSA9IGdldEltYWdlKCB0ZXh0dXJlT2JqZWN0LmlkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSB0ZXh0dXJlIGlmIGltYWdlIGlzIGF2YWlhYmxlXG5cblx0XHRcdFx0aWYgKCBpbWFnZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdHZhciBsb2FkZXIgPSBnZXRUZXh0dXJlTG9hZGVyKCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggaW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGV4dHJhID0gdGV4dHVyZU9iamVjdC5leHRyYTtcblxuXHRcdFx0XHRcdFx0aWYgKCBleHRyYSAhPT0gdW5kZWZpbmVkICYmIGV4dHJhLnRlY2huaXF1ZSAhPT0gdW5kZWZpbmVkICYmIGlzRW1wdHkoIGV4dHJhLnRlY2huaXF1ZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdGVjaG5pcXVlID0gZXh0cmEudGVjaG5pcXVlO1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSB0ZWNobmlxdWUud3JhcFUgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSB0ZWNobmlxdWUud3JhcFYgPyBSZXBlYXRXcmFwcGluZyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuc2V0KCB0ZWNobmlxdWUub2Zmc2V0VSB8fCAwLCB0ZWNobmlxdWUub2Zmc2V0ViB8fCAwICk7XG5cdFx0XHRcdFx0XHRcdHRleHR1cmUucmVwZWF0LnNldCggdGVjaG5pcXVlLnJlcGVhdFUgfHwgMSwgdGVjaG5pcXVlLnJlcGVhdFYgfHwgMSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogTG9hZGVyIGZvciB0ZXh0dXJlICVzIG5vdCBmb3VuZC4nLCBpbWFnZSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBjcmVhdGUgdGV4dHVyZSB3aXRoIElEOicsIHRleHR1cmVPYmplY3QuaWQgKTtcblxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRlY2huaXF1ZS5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0dmFyIHBhcmFtZXRlciA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGtleSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIuY29sb3IgKSBtYXRlcmlhbC5jb2xvci5mcm9tQXJyYXkoIHBhcmFtZXRlci5jb2xvciApO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIHBhcmFtZXRlci50ZXh0dXJlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5jb2xvciAmJiBtYXRlcmlhbC5zcGVjdWxhciApIG1hdGVyaWFsLnNwZWN1bGFyLmZyb21BcnJheSggcGFyYW1ldGVyLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXHRcdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXIudGV4dHVyZSApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSggcGFyYW1ldGVyLnRleHR1cmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NoaW5pbmVzcyc6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5mbG9hdCAmJiBtYXRlcmlhbC5zaGluaW5lc3MgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBwYXJhbWV0ZXIuZmxvYXQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci5jb2xvciAmJiBtYXRlcmlhbC5lbWlzc2l2ZSApIG1hdGVyaWFsLmVtaXNzaXZlLmZyb21BcnJheSggcGFyYW1ldGVyLmNvbG9yICk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcmFtZXRlci50ZXh0dXJlICkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKCBwYXJhbWV0ZXIudGV4dHVyZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdHZhciB0cmFuc3BhcmVudCA9IHBhcmFtZXRlcnNbICd0cmFuc3BhcmVudCcgXTtcblx0XHRcdHZhciB0cmFuc3BhcmVuY3kgPSBwYXJhbWV0ZXJzWyAndHJhbnNwYXJlbmN5JyBdO1xuXG5cdFx0XHQvLyA8dHJhbnNwYXJlbmN5PiBkb2VzIG5vdCBleGlzdCBidXQgPHRyYW5zcGFyZW50PlxuXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW5jeSA9PT0gdW5kZWZpbmVkICYmIHRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRcdHRyYW5zcGFyZW5jeSA9IHtcblx0XHRcdFx0XHRmbG9hdDogMVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIDx0cmFuc3BhcmVudD4gZG9lcyBub3QgZXhpc3QgYnV0IDx0cmFuc3BhcmVuY3k+XG5cblx0XHRcdGlmICggdHJhbnNwYXJlbnQgPT09IHVuZGVmaW5lZCAmJiB0cmFuc3BhcmVuY3kgKSB7XG5cblx0XHRcdFx0dHJhbnNwYXJlbnQgPSB7XG5cdFx0XHRcdFx0b3BhcXVlOiAnQV9PTkUnLFxuXHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdGNvbG9yOiBbIDEsIDEsIDEsIDEgXVxuXHRcdFx0XHRcdH0gfTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRyYW5zcGFyZW50ICYmIHRyYW5zcGFyZW5jeSApIHtcblxuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSBpZiBhIHRleHR1cmUgZXhpc3RzIGJ1dCBubyBjb2xvclxuXG5cdFx0XHRcdGlmICggdHJhbnNwYXJlbnQuZGF0YS50ZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0Ly8gd2UgZG8gbm90IHNldCBhbiBhbHBoYSBtYXAgKHNlZSAjMTM3OTIpXG5cblx0XHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZhciBjb2xvciA9IHRyYW5zcGFyZW50LmRhdGEuY29sb3I7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCB0cmFuc3BhcmVudC5vcGFxdWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0FfT05FJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwub3BhY2l0eSA9IGNvbG9yWyAzIF0gKiB0cmFuc3BhcmVuY3kuZmxvYXQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnUkdCX1pFUk8nOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5vcGFjaXR5ID0gMSAtICggY29sb3JbIDAgXSAqIHRyYW5zcGFyZW5jeS5mbG9hdCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0FfWkVSTyc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxIC0gKCBjb2xvclsgMyBdICogdHJhbnNwYXJlbmN5LmZsb2F0ICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnUkdCX09ORSc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSBjb2xvclsgMCBdICogdHJhbnNwYXJlbmN5LmZsb2F0O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEludmFsaWQgb3BhcXVlIHR5cGUgXCIlc1wiIG9mIHRyYW5zcGFyZW50IHRhZy4nLCB0cmFuc3BhcmVudC5vcGFxdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwub3BhY2l0eSA8IDEgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vXG5cblx0XHRcdGlmICggZXh0cmEgIT09IHVuZGVmaW5lZCAmJiBleHRyYS50ZWNobmlxdWUgIT09IHVuZGVmaW5lZCAmJiBleHRyYS50ZWNobmlxdWUuZG91YmxlX3NpZGVkID09PSAxICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBEb3VibGVTaWRlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5Lm1hdGVyaWFsc1sgaWQgXSwgYnVpbGRNYXRlcmlhbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2FtZXJhXG5cblx0XHRmdW5jdGlvbiBwYXJzZUNhbWVyYSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnIClcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdvcHRpY3MnOlxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MgPSBwYXJzZUNhbWVyYU9wdGljcyggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmNhbWVyYXNbIHhtbC5nZXRBdHRyaWJ1dGUoICdpZCcgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhT3B0aWNzKCB4bWwgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VDYW1lcmFUZWNobmlxdWUoIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhVGVjaG5pcXVlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncGVyc3BlY3RpdmUnOlxuXHRcdFx0XHRcdGNhc2UgJ29ydGhvZ3JhcGhpYyc6XG5cblx0XHRcdFx0XHRcdGRhdGEudGVjaG5pcXVlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRkYXRhLnBhcmFtZXRlcnMgPSBwYXJzZUNhbWVyYVBhcmFtZXRlcnMoIGNoaWxkICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQ2FtZXJhUGFyYW1ldGVycyggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3hmb3YnOlxuXHRcdFx0XHRcdGNhc2UgJ3lmb3YnOlxuXHRcdFx0XHRcdGNhc2UgJ3htYWcnOlxuXHRcdFx0XHRcdGNhc2UgJ3ltYWcnOlxuXHRcdFx0XHRcdGNhc2UgJ3puZWFyJzpcblx0XHRcdFx0XHRjYXNlICd6ZmFyJzpcblx0XHRcdFx0XHRjYXNlICdhc3BlY3RfcmF0aW8nOlxuXHRcdFx0XHRcdFx0ZGF0YVsgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZENhbWVyYSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGNhbWVyYTtcblxuXHRcdFx0c3dpdGNoICggZGF0YS5vcHRpY3MudGVjaG5pcXVlICkge1xuXG5cdFx0XHRcdGNhc2UgJ3BlcnNwZWN0aXZlJzpcblx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnlmb3YsXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLmFzcGVjdF9yYXRpbyxcblx0XHRcdFx0XHRcdGRhdGEub3B0aWNzLnBhcmFtZXRlcnMuem5lYXIsXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpmYXJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ29ydGhvZ3JhcGhpYyc6XG5cdFx0XHRcdFx0dmFyIHltYWcgPSBkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnltYWc7XG5cdFx0XHRcdFx0dmFyIHhtYWcgPSBkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnhtYWc7XG5cdFx0XHRcdFx0dmFyIGFzcGVjdFJhdGlvID0gZGF0YS5vcHRpY3MucGFyYW1ldGVycy5hc3BlY3RfcmF0aW87XG5cblx0XHRcdFx0XHR4bWFnID0gKCB4bWFnID09PSB1bmRlZmluZWQgKSA/ICggeW1hZyAqIGFzcGVjdFJhdGlvICkgOiB4bWFnO1xuXHRcdFx0XHRcdHltYWcgPSAoIHltYWcgPT09IHVuZGVmaW5lZCApID8gKCB4bWFnIC8gYXNwZWN0UmF0aW8gKSA6IHltYWc7XG5cblx0XHRcdFx0XHR4bWFnICo9IDAuNTtcblx0XHRcdFx0XHR5bWFnICo9IDAuNTtcblxuXHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoXG5cdFx0XHRcdFx0XHQtIHhtYWcsIHhtYWcsIHltYWcsIC0geW1hZywgLy8gbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXG5cdFx0XHRcdFx0XHRkYXRhLm9wdGljcy5wYXJhbWV0ZXJzLnpuZWFyLFxuXHRcdFx0XHRcdFx0ZGF0YS5vcHRpY3MucGFyYW1ldGVycy56ZmFyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNhbWVyYS5uYW1lID0gZGF0YS5uYW1lIHx8ICcnO1xuXG5cdFx0XHRyZXR1cm4gY2FtZXJhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2FtZXJhKCBpZCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSBsaWJyYXJ5LmNhbWVyYXNbIGlkIF07XG5cblx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBnZXRCdWlsZCggZGF0YSwgYnVpbGRDYW1lcmEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBDb3VsZG5cXCd0IGZpbmQgY2FtZXJhIHdpdGggSUQ6JywgaWQgKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBsaWdodFxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWdodCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHRkYXRhID0gcGFyc2VMaWdodFRlY2huaXF1ZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmxpZ2h0c1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VMaWdodFRlY2huaXF1ZSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZGlyZWN0aW9uYWwnOlxuXHRcdFx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0XHRjYXNlICdzcG90Jzpcblx0XHRcdFx0XHRjYXNlICdhbWJpZW50JzpcblxuXHRcdFx0XHRcdFx0ZGF0YS50ZWNobmlxdWUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGRhdGEucGFyYW1ldGVycyA9IHBhcnNlTGlnaHRQYXJhbWV0ZXJzKCBjaGlsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTGlnaHRQYXJhbWV0ZXJzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdjb2xvcic6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEuY29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2ZhbGxvZmZfYW5nbGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS5mYWxsb2ZmQW5nbGUgPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdxdWFkcmF0aWNfYXR0ZW51YXRpb24nOlxuXHRcdFx0XHRcdFx0dmFyIGYgPSBwYXJzZUZsb2F0KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5kaXN0YW5jZSA9IGYgPyBNYXRoLnNxcnQoIDEgLyBmICkgOiAwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRMaWdodCggZGF0YSApIHtcblxuXHRcdFx0dmFyIGxpZ2h0O1xuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnRlY2huaXF1ZSApIHtcblxuXHRcdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdFx0bGlnaHQgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0XHRsaWdodCA9IG5ldyBQb2ludExpZ2h0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdFx0bGlnaHQgPSBuZXcgU3BvdExpZ2h0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYW1iaWVudCc6XG5cdFx0XHRcdFx0bGlnaHQgPSBuZXcgQW1iaWVudExpZ2h0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBkYXRhLnBhcmFtZXRlcnMuY29sb3IgKSBsaWdodC5jb2xvci5jb3B5KCBkYXRhLnBhcmFtZXRlcnMuY29sb3IgKTtcblx0XHRcdGlmICggZGF0YS5wYXJhbWV0ZXJzLmRpc3RhbmNlICkgbGlnaHQuZGlzdGFuY2UgPSBkYXRhLnBhcmFtZXRlcnMuZGlzdGFuY2U7XG5cblx0XHRcdHJldHVybiBsaWdodDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldExpZ2h0KCBpZCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSBsaWJyYXJ5LmxpZ2h0c1sgaWQgXTtcblxuXHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBkYXRhLCBidWlsZExpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogQ291bGRuXFwndCBmaW5kIGxpZ2h0IHdpdGggSUQ6JywgaWQgKTtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHQvLyBnZW9tZXRyeVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VHZW9tZXRyeSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICksXG5cdFx0XHRcdHNvdXJjZXM6IHt9LFxuXHRcdFx0XHR2ZXJ0aWNlczoge30sXG5cdFx0XHRcdHByaW1pdGl2ZXM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbWVzaCA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCB4bWwsICdtZXNoJyApWyAwIF07XG5cblx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgdGFncyBpbnNpZGUgZ2VvbWV0cnkgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzEyNjA2KTogY29udmV4X21lc2gsIHNwbGluZSwgYnJlcFxuXHRcdFx0aWYgKCBtZXNoID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1lc2guY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gbWVzaC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBpZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblx0XHRcdFx0XHRcdGRhdGEuc291cmNlc1sgaWQgXSA9IHBhcnNlU291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2ZXJ0aWNlcyc6XG5cdFx0XHRcdFx0XHQvLyBkYXRhLnNvdXJjZXNbIGlkIF0gPSBkYXRhLnNvdXJjZXNbIHBhcnNlSWQoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCBjaGlsZCwgJ2lucHV0JyApWyAwIF0uZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICkgXTtcblx0XHRcdFx0XHRcdGRhdGEudmVydGljZXMgPSBwYXJzZUdlb21ldHJ5VmVydGljZXMoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3BvbHlnb25zJzpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVuc3VwcG9ydGVkIHByaW1pdGl2ZSB0eXBlOiAnLCBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5lcyc6XG5cdFx0XHRcdFx0Y2FzZSAnbGluZXN0cmlwcyc6XG5cdFx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXHRcdFx0XHRcdGNhc2UgJ3RyaWFuZ2xlcyc6XG5cdFx0XHRcdFx0XHRkYXRhLnByaW1pdGl2ZXMucHVzaCggcGFyc2VHZW9tZXRyeVByaW1pdGl2ZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkuZ2VvbWV0cmllc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTb3VyY2UoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGFycmF5OiBbXSxcblx0XHRcdFx0c3RyaWRlOiAzXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdmbG9hdF9hcnJheSc6XG5cdFx0XHRcdFx0XHRkYXRhLmFycmF5ID0gcGFyc2VGbG9hdHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ05hbWVfYXJyYXknOlxuXHRcdFx0XHRcdFx0ZGF0YS5hcnJheSA9IHBhcnNlU3RyaW5ncyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cdFx0XHRcdFx0XHR2YXIgYWNjZXNzb3IgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggY2hpbGQsICdhY2Nlc3NvcicgKVsgMCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGFjY2Vzc29yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS5zdHJpZGUgPSBwYXJzZUludCggYWNjZXNzb3IuZ2V0QXR0cmlidXRlKCAnc3RyaWRlJyApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VHZW9tZXRyeVZlcnRpY2VzKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRkYXRhWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzZW1hbnRpYycgKSBdID0gcGFyc2VJZCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUdlb21ldHJ5UHJpbWl0aXZlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBwcmltaXRpdmUgPSB7XG5cdFx0XHRcdHR5cGU6IHhtbC5ub2RlTmFtZSxcblx0XHRcdFx0bWF0ZXJpYWw6IHhtbC5nZXRBdHRyaWJ1dGUoICdtYXRlcmlhbCcgKSxcblx0XHRcdFx0Y291bnQ6IHBhcnNlSW50KCB4bWwuZ2V0QXR0cmlidXRlKCAnY291bnQnICkgKSxcblx0XHRcdFx0aW5wdXRzOiB7fSxcblx0XHRcdFx0c3RyaWRlOiAwLFxuXHRcdFx0XHRoYXNVVjogZmFsc2Vcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICkgKTtcblx0XHRcdFx0XHRcdHZhciBzZW1hbnRpYyA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NlbWFudGljJyApO1xuXHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KCBjaGlsZC5nZXRBdHRyaWJ1dGUoICdvZmZzZXQnICkgKTtcblx0XHRcdFx0XHRcdHZhciBzZXQgPSBwYXJzZUludCggY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2V0JyApICk7XG5cdFx0XHRcdFx0XHR2YXIgaW5wdXRuYW1lID0gKCBzZXQgPiAwID8gc2VtYW50aWMgKyBzZXQgOiBzZW1hbnRpYyApO1xuXHRcdFx0XHRcdFx0cHJpbWl0aXZlLmlucHV0c1sgaW5wdXRuYW1lIF0gPSB7IGlkOiBpZCwgb2Zmc2V0OiBvZmZzZXQgfTtcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5zdHJpZGUgPSBNYXRoLm1heCggcHJpbWl0aXZlLnN0cmlkZSwgb2Zmc2V0ICsgMSApO1xuXHRcdFx0XHRcdFx0aWYgKCBzZW1hbnRpYyA9PT0gJ1RFWENPT1JEJyApIHByaW1pdGl2ZS5oYXNVViA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3Zjb3VudCc6XG5cdFx0XHRcdFx0XHRwcmltaXRpdmUudmNvdW50ID0gcGFyc2VJbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwJzpcblx0XHRcdFx0XHRcdHByaW1pdGl2ZS5wID0gcGFyc2VJbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcmltaXRpdmU7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBncm91cFByaW1pdGl2ZXMoIHByaW1pdGl2ZXMgKSB7XG5cblx0XHRcdHZhciBidWlsZCA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwcmltaXRpdmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggYnVpbGRbIHByaW1pdGl2ZS50eXBlIF0gPT09IHVuZGVmaW5lZCApIGJ1aWxkWyBwcmltaXRpdmUudHlwZSBdID0gW107XG5cblx0XHRcdFx0YnVpbGRbIHByaW1pdGl2ZS50eXBlIF0ucHVzaCggcHJpbWl0aXZlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ1aWxkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tVVkNvb3JkaW5hdGVzKCBwcmltaXRpdmVzICkge1xuXG5cdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5oYXNVViA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNvdW50ICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvdW50ID4gMCAmJiBjb3VudCA8IHByaW1pdGl2ZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdHByaW1pdGl2ZXMudXZzTmVlZHNGaXggPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEdlb21ldHJ5KCBkYXRhICkge1xuXG5cdFx0XHR2YXIgYnVpbGQgPSB7fTtcblxuXHRcdFx0dmFyIHNvdXJjZXMgPSBkYXRhLnNvdXJjZXM7XG5cdFx0XHR2YXIgdmVydGljZXMgPSBkYXRhLnZlcnRpY2VzO1xuXHRcdFx0dmFyIHByaW1pdGl2ZXMgPSBkYXRhLnByaW1pdGl2ZXM7XG5cblx0XHRcdGlmICggcHJpbWl0aXZlcy5sZW5ndGggPT09IDAgKSByZXR1cm4ge307XG5cblx0XHRcdC8vIG91ciBnb2FsIGlzIHRvIGNyZWF0ZSBvbmUgYnVmZmVyIGdlb21ldHJ5IGZvciBhIHNpbmdsZSB0eXBlIG9mIHByaW1pdGl2ZXNcblx0XHRcdC8vIGZpcnN0LCB3ZSBncm91cCBhbGwgcHJpbWl0aXZlcyBieSB0aGVpciB0eXBlXG5cblx0XHRcdHZhciBncm91cGVkUHJpbWl0aXZlcyA9IGdyb3VwUHJpbWl0aXZlcyggcHJpbWl0aXZlcyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgdHlwZSBpbiBncm91cGVkUHJpbWl0aXZlcyApIHtcblxuXHRcdFx0XHR2YXIgcHJpbWl0aXZlVHlwZSA9IGdyb3VwZWRQcmltaXRpdmVzWyB0eXBlIF07XG5cblx0XHRcdFx0Ly8gc2Vjb25kLCBlbnN1cmUgY29uc2lzdGVudCB1diBjb29yZGluYXRlcyBmb3IgZWFjaCB0eXBlIG9mIHByaW1pdGl2ZXMgKHBvbHlsaXN0LHRyaWFuZ2xlcyBvciBsaW5lcylcblxuXHRcdFx0XHRjaGVja1VWQ29vcmRpbmF0ZXMoIHByaW1pdGl2ZVR5cGUgKTtcblxuXHRcdFx0XHQvLyB0aGlyZCwgY3JlYXRlIGEgYnVmZmVyIGdlb21ldHJ5IGZvciBlYWNoIHR5cGUgb2YgcHJpbWl0aXZlc1xuXG5cdFx0XHRcdGJ1aWxkWyB0eXBlIF0gPSBidWlsZEdlb21ldHJ5VHlwZSggcHJpbWl0aXZlVHlwZSwgc291cmNlcywgdmVydGljZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZEdlb21ldHJ5VHlwZSggcHJpbWl0aXZlcywgc291cmNlcywgdmVydGljZXMgKSB7XG5cblx0XHRcdHZhciBidWlsZCA9IHt9O1xuXG5cdFx0XHR2YXIgcG9zaXRpb24gPSB7IGFycmF5OiBbXSwgc3RyaWRlOiAwIH07XG5cdFx0XHR2YXIgbm9ybWFsID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0dmFyIHV2ID0geyBhcnJheTogW10sIHN0cmlkZTogMCB9O1xuXHRcdFx0dmFyIHV2MiA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblx0XHRcdHZhciBjb2xvciA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDAgfTtcblxuXHRcdFx0dmFyIHNraW5JbmRleCA9IHsgYXJyYXk6IFtdLCBzdHJpZGU6IDQgfTtcblx0XHRcdHZhciBza2luV2VpZ2h0ID0geyBhcnJheTogW10sIHN0cmlkZTogNCB9O1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0dmFyIG1hdGVyaWFsS2V5cyA9IFtdO1xuXG5cdFx0XHR2YXIgc3RhcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCB2YXIgcCA9IDA7IHAgPCBwcmltaXRpdmVzLmxlbmd0aDsgcCArKyApIHtcblxuXHRcdFx0XHR2YXIgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1sgcCBdO1xuXHRcdFx0XHR2YXIgaW5wdXRzID0gcHJpbWl0aXZlLmlucHV0cztcblxuXHRcdFx0XHQvLyBncm91cHNcblxuXHRcdFx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHByaW1pdGl2ZS50eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluZXMnOlxuXHRcdFx0XHRcdGNhc2UgJ2xpbmVzdHJpcHMnOlxuXHRcdFx0XHRcdFx0Y291bnQgPSBwcmltaXRpdmUuY291bnQgKiAyO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxuXHRcdFx0XHRcdFx0Y291bnQgPSBwcmltaXRpdmUuY291bnQgKiAzO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwb2x5bGlzdCc6XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBnID0gMDsgZyA8IHByaW1pdGl2ZS5jb3VudDsgZyArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgdmMgPSBwcmltaXRpdmUudmNvdW50WyBnIF07XG5cblx0XHRcdFx0XHRcdFx0c3dpdGNoICggdmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0XHRjb3VudCArPSAzOyAvLyBzaW5nbGUgdHJpYW5nbGVcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSA0OlxuXHRcdFx0XHRcdFx0XHRcdFx0Y291bnQgKz0gNjsgLy8gcXVhZCwgc3ViZGl2aWRlZCBpbnRvIHR3byB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50ICs9ICggdmMgLSAyICkgKiAzOyAvLyBwb2x5bGlzdCB3aXRoIG1vcmUgdGhhbiBmb3VyIHZlcnRpY2VzXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogVW5rbm93IHByaW1pdGl2ZSB0eXBlOicsIHByaW1pdGl2ZS50eXBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LmFkZEdyb3VwKCBzdGFydCwgY291bnQsIHAgKTtcblx0XHRcdFx0c3RhcnQgKz0gY291bnQ7XG5cblx0XHRcdFx0Ly8gbWF0ZXJpYWxcblxuXHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5tYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsS2V5cy5wdXNoKCBwcmltaXRpdmUubWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ2VvbWV0cnkgZGF0YVxuXG5cdFx0XHRcdGZvciAoIHZhciBuYW1lIGluIGlucHV0cyApIHtcblxuXHRcdFx0XHRcdHZhciBpbnB1dCA9IGlucHV0c1sgbmFtZSBdO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggbmFtZSApXHR7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1ZFUlRFWCc6XG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gdmVydGljZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgaWQgPSB2ZXJ0aWNlc1sga2V5IF07XG5cblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBrZXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ1BPU0lUSU9OJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHByZXZMZW5ndGggPSBwb3NpdGlvbi5hcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgcG9zaXRpb24uYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24uc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzb3VyY2VzLnNraW5XZWlnaHRzICYmIHNvdXJjZXMuc2tpbkluZGljZXMgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzLnNraW5JbmRpY2VzLCBpbnB1dC5vZmZzZXQsIHNraW5JbmRleC5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXMuc2tpbldlaWdodHMsIGlucHV0Lm9mZnNldCwgc2tpbldlaWdodC5hcnJheSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBzZWUgIzM4MDNcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHByaW1pdGl2ZS5oYXNVViA9PT0gZmFsc2UgJiYgcHJpbWl0aXZlcy51dnNOZWVkc0ZpeCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb3VudCA9ICggcG9zaXRpb24uYXJyYXkubGVuZ3RoIC0gcHJldkxlbmd0aCApIC8gcG9zaXRpb24uc3RyaWRlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGZpbGwgbWlzc2luZyB1diBjb29yZGluYXRlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1di5hcnJheS5wdXNoKCAwLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdOT1JNQUwnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIG5vcm1hbC5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub3JtYWwuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdDT0xPUic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgY29sb3IuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3Iuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZXNbIGlkIF0sIGlucHV0Lm9mZnNldCwgdXYuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXYuc3RyaWRlID0gc291cmNlc1sgaWQgXS5zdHJpZGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdURVhDT09SRDEnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpZCBdLCBpbnB1dC5vZmZzZXQsIHV2Mi5hcnJheSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1di5zdHJpZGUgPSBzb3VyY2VzWyBpZCBdLnN0cmlkZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFNlbWFudGljIFwiJXNcIiBub3QgaGFuZGxlZCBpbiBnZW9tZXRyeSBidWlsZCBwcm9jZXNzLicsIGtleSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnTk9STUFMJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCBub3JtYWwuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnQ09MT1InOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIGNvbG9yLmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQnOlxuXHRcdFx0XHRcdFx0XHRidWlsZEdlb21ldHJ5RGF0YSggcHJpbWl0aXZlLCBzb3VyY2VzWyBpbnB1dC5pZCBdLCBpbnB1dC5vZmZzZXQsIHV2LmFycmF5ICk7XG5cdFx0XHRcdFx0XHRcdHV2LnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnVEVYQ09PUkQxJzpcblx0XHRcdFx0XHRcdFx0YnVpbGRHZW9tZXRyeURhdGEoIHByaW1pdGl2ZSwgc291cmNlc1sgaW5wdXQuaWQgXSwgaW5wdXQub2Zmc2V0LCB1djIuYXJyYXkgKTtcblx0XHRcdFx0XHRcdFx0dXYyLnN0cmlkZSA9IHNvdXJjZXNbIGlucHV0LmlkIF0uc3RyaWRlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0aWYgKCBwb3NpdGlvbi5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24uYXJyYXksIHBvc2l0aW9uLnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIG5vcm1hbC5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbC5hcnJheSwgbm9ybWFsLnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIGNvbG9yLmFycmF5Lmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvci5hcnJheSwgY29sb3Iuc3RyaWRlICkgKTtcblx0XHRcdGlmICggdXYuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2LmFycmF5LCB1di5zdHJpZGUgKSApO1xuXHRcdFx0aWYgKCB1djIuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1djIuYXJyYXksIHV2Mi5zdHJpZGUgKSApO1xuXG5cdFx0XHRpZiAoIHNraW5JbmRleC5hcnJheS5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnc2tpbkluZGV4JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHNraW5JbmRleC5hcnJheSwgc2tpbkluZGV4LnN0cmlkZSApICk7XG5cdFx0XHRpZiAoIHNraW5XZWlnaHQuYXJyYXkubGVuZ3RoID4gMCApIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc2tpbldlaWdodC5hcnJheSwgc2tpbldlaWdodC5zdHJpZGUgKSApO1xuXG5cdFx0XHRidWlsZC5kYXRhID0gZ2VvbWV0cnk7XG5cdFx0XHRidWlsZC50eXBlID0gcHJpbWl0aXZlc1sgMCBdLnR5cGU7XG5cdFx0XHRidWlsZC5tYXRlcmlhbEtleXMgPSBtYXRlcmlhbEtleXM7XG5cblx0XHRcdHJldHVybiBidWlsZDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnlEYXRhKCBwcmltaXRpdmUsIHNvdXJjZSwgb2Zmc2V0LCBhcnJheSApIHtcblxuXHRcdFx0dmFyIGluZGljZXMgPSBwcmltaXRpdmUucDtcblx0XHRcdHZhciBzdHJpZGUgPSBwcmltaXRpdmUuc3RyaWRlO1xuXHRcdFx0dmFyIHZjb3VudCA9IHByaW1pdGl2ZS52Y291bnQ7XG5cblx0XHRcdGZ1bmN0aW9uIHB1c2hWZWN0b3IoIGkgKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gaW5kaWNlc1sgaSArIG9mZnNldCBdICogc291cmNlU3RyaWRlO1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gaW5kZXggKyBzb3VyY2VTdHJpZGU7XG5cblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCBzb3VyY2VBcnJheVsgaW5kZXggXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc291cmNlQXJyYXkgPSBzb3VyY2UuYXJyYXk7XG5cdFx0XHR2YXIgc291cmNlU3RyaWRlID0gc291cmNlLnN0cmlkZTtcblxuXHRcdFx0aWYgKCBwcmltaXRpdmUudmNvdW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBjb3VudCA9IHZjb3VudFsgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBjb3VudCA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRleCArIHN0cmlkZSAqIDA7XG5cdFx0XHRcdFx0XHR2YXIgYiA9IGluZGV4ICsgc3RyaWRlICogMTtcblx0XHRcdFx0XHRcdHZhciBjID0gaW5kZXggKyBzdHJpZGUgKiAyO1xuXHRcdFx0XHRcdFx0dmFyIGQgPSBpbmRleCArIHN0cmlkZSAqIDM7XG5cblx0XHRcdFx0XHRcdHB1c2hWZWN0b3IoIGEgKTsgcHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBkICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVjdG9yKCBiICk7IHB1c2hWZWN0b3IoIGMgKTsgcHVzaFZlY3RvciggZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY291bnQgPT09IDMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhID0gaW5kZXggKyBzdHJpZGUgKiAwO1xuXHRcdFx0XHRcdFx0dmFyIGIgPSBpbmRleCArIHN0cmlkZSAqIDE7XG5cdFx0XHRcdFx0XHR2YXIgYyA9IGluZGV4ICsgc3RyaWRlICogMjtcblxuXHRcdFx0XHRcdFx0cHVzaFZlY3RvciggYSApOyBwdXNoVmVjdG9yKCBiICk7IHB1c2hWZWN0b3IoIGMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50ID4gNCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAxLCBrbCA9ICggY291bnQgLSAyICk7IGsgPD0ga2w7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRleCArIHN0cmlkZSAqIDA7XG5cdFx0XHRcdFx0XHRcdHZhciBiID0gaW5kZXggKyBzdHJpZGUgKiBrO1xuXHRcdFx0XHRcdFx0XHR2YXIgYyA9IGluZGV4ICsgc3RyaWRlICogKCBrICsgMSApO1xuXG5cdFx0XHRcdFx0XHRcdHB1c2hWZWN0b3IoIGEgKTsgcHVzaFZlY3RvciggYiApOyBwdXNoVmVjdG9yKCBjICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4ICs9IHN0cmlkZSAqIGNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gc3RyaWRlICkge1xuXG5cdFx0XHRcdFx0cHVzaFZlY3RvciggaSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkuZ2VvbWV0cmllc1sgaWQgXSwgYnVpbGRHZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8ga2luZW1hdGljc1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzTW9kZWwoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHRqb2ludHM6IHt9LFxuXHRcdFx0XHRsaW5rczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0cGFyc2VLaW5lbWF0aWNzVGVjaG5pcXVlQ29tbW9uKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkua2luZW1hdGljc01vZGVsc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRLaW5lbWF0aWNzTW9kZWwoIGRhdGEgKSB7XG5cblx0XHRcdGlmICggZGF0YS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2luZW1hdGljc01vZGVsKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmtpbmVtYXRpY3NNb2RlbHNbIGlkIF0sIGJ1aWxkS2luZW1hdGljc01vZGVsICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NUZWNobmlxdWVDb21tb24oIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnam9pbnQnOlxuXHRcdFx0XHRcdFx0ZGF0YS5qb2ludHNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gcGFyc2VLaW5lbWF0aWNzSm9pbnQoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2xpbmsnOlxuXHRcdFx0XHRcdFx0ZGF0YS5saW5rcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NMaW5rKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0pvaW50KCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxuXHRcdFx0XHRcdGNhc2UgJ3Jldm9sdXRlJzpcblx0XHRcdFx0XHRcdGRhdGEgPSBwYXJzZUtpbmVtYXRpY3NKb2ludFBhcmFtZXRlciggY2hpbGQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0pvaW50UGFyYW1ldGVyKCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRzaWQ6IHhtbC5nZXRBdHRyaWJ1dGUoICdzaWQnICksXG5cdFx0XHRcdG5hbWU6IHhtbC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIHx8ICcnLFxuXHRcdFx0XHRheGlzOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0XHRsaW1pdHM6IHtcblx0XHRcdFx0XHRtaW46IDAsXG5cdFx0XHRcdFx0bWF4OiAwXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHR5cGU6IHhtbC5ub2RlTmFtZSxcblx0XHRcdFx0c3RhdGljOiBmYWxzZSxcblx0XHRcdFx0emVyb1Bvc2l0aW9uOiAwLFxuXHRcdFx0XHRtaWRkbGVQb3NpdGlvbjogMFxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXhpcyc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEuYXhpcy5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdsaW1pdHMnOlxuXHRcdFx0XHRcdFx0dmFyIG1heCA9IGNoaWxkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnbWF4JyApWyAwIF07XG5cdFx0XHRcdFx0XHR2YXIgbWluID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdtaW4nIClbIDAgXTtcblxuXHRcdFx0XHRcdFx0ZGF0YS5saW1pdHMubWF4ID0gcGFyc2VGbG9hdCggbWF4LnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRkYXRhLmxpbWl0cy5taW4gPSBwYXJzZUZsb2F0KCBtaW4udGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiBtaW4gaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIG1heCwgY29uc2lkZXIgdGhlIGpvaW50IHN0YXRpY1xuXG5cdFx0XHRpZiAoIGRhdGEubGltaXRzLm1pbiA+PSBkYXRhLmxpbWl0cy5tYXggKSB7XG5cblx0XHRcdFx0ZGF0YS5zdGF0aWMgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBtaWRkbGUgcG9zaXRpb25cblxuXHRcdFx0ZGF0YS5taWRkbGVQb3NpdGlvbiA9ICggZGF0YS5saW1pdHMubWluICsgZGF0YS5saW1pdHMubWF4ICkgLyAyLjA7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzTGluayggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0c2lkOiB4bWwuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0YXR0YWNobWVudHM6IFtdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zOiBbXVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYXR0YWNobWVudF9mdWxsJzpcblx0XHRcdFx0XHRcdGRhdGEuYXR0YWNobWVudHMucHVzaCggcGFyc2VLaW5lbWF0aWNzQXR0YWNobWVudCggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NUcmFuc2Zvcm0oIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0F0dGFjaG1lbnQoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGpvaW50OiB4bWwuZ2V0QXR0cmlidXRlKCAnam9pbnQnICkuc3BsaXQoICcvJyApLnBvcCgpLFxuXHRcdFx0XHR0cmFuc2Zvcm1zOiBbXSxcblx0XHRcdFx0bGlua3M6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdsaW5rJzpcblx0XHRcdFx0XHRcdGRhdGEubGlua3MucHVzaCggcGFyc2VLaW5lbWF0aWNzTGluayggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtcy5wdXNoKCBwYXJzZUtpbmVtYXRpY3NUcmFuc2Zvcm0oIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc1RyYW5zZm9ybSggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0dHlwZTogeG1sLm5vZGVOYW1lXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggeG1sLnRleHRDb250ZW50ICk7XG5cblx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRcdGRhdGEub2JqID0gbmV3IE1hdHJpeDQoKTtcblx0XHRcdFx0XHRkYXRhLm9iai5mcm9tQXJyYXkoIGFycmF5ICkudHJhbnNwb3NlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRkYXRhLm9iaiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdFx0ZGF0YS5vYmouZnJvbUFycmF5KCBhcnJheSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0ZGF0YS5vYmogPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHRcdGRhdGEub2JqLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRkYXRhLmFuZ2xlID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBhcnJheVsgMyBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBwaHlzaWNzXG5cblx0XHRmdW5jdGlvbiBwYXJzZVBoeXNpY3NNb2RlbCggeG1sICkge1xuXG5cdFx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdFx0bmFtZTogeG1sLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgfHwgJycsXG5cdFx0XHRcdHJpZ2lkQm9kaWVzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncmlnaWRfYm9keSc6XG5cdFx0XHRcdFx0XHRkYXRhLnJpZ2lkQm9kaWVzWyBjaGlsZC5nZXRBdHRyaWJ1dGUoICduYW1lJyApIF0gPSB7fTtcblx0XHRcdFx0XHRcdHBhcnNlUGh5c2ljc1JpZ2lkQm9keSggY2hpbGQsIGRhdGEucmlnaWRCb2RpZXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ25hbWUnICkgXSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGxpYnJhcnkucGh5c2ljc01vZGVsc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VQaHlzaWNzUmlnaWRCb2R5KCB4bWwsIGRhdGEgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXHRcdFx0XHRcdFx0cGFyc2VQaHlzaWNzVGVjaG5pcXVlQ29tbW9uKCBjaGlsZCwgZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBoeXNpY3NUZWNobmlxdWVDb21tb24oIHhtbCwgZGF0YSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnaW5lcnRpYSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluZXJ0aWEgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWFzcyc6XG5cdFx0XHRcdFx0XHRkYXRhLm1hc3MgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKVsgMCBdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBzY2VuZVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VLaW5lbWF0aWNzU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGJpbmRKb2ludEF4aXM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0geG1sLmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX2pvaW50X2F4aXMnOlxuXHRcdFx0XHRcdFx0ZGF0YS5iaW5kSm9pbnRBeGlzLnB1c2goIHBhcnNlS2luZW1hdGljc0JpbmRKb2ludEF4aXMoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LmtpbmVtYXRpY3NTY2VuZXNbIHBhcnNlSWQoIHhtbC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSBdID0gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlS2luZW1hdGljc0JpbmRKb2ludEF4aXMoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdHRhcmdldDogeG1sLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKS5zcGxpdCggJy8nICkucG9wKClcblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2F4aXMnOlxuXHRcdFx0XHRcdFx0dmFyIHBhcmFtID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdwYXJhbScgKVsgMCBdO1xuXHRcdFx0XHRcdFx0ZGF0YS5heGlzID0gcGFyYW0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHR2YXIgdG1wSm9pbnRJbmRleCA9IGRhdGEuYXhpcy5zcGxpdCggJ2luc3RfJyApLnBvcCgpLnNwbGl0KCAnYXhpcycgKVsgMCBdO1xuXHRcdFx0XHRcdFx0ZGF0YS5qb2ludEluZGV4ID0gdG1wSm9pbnRJbmRleC5zdWJzdHIoIDAsIHRtcEpvaW50SW5kZXgubGVuZ3RoIC0gMSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRLaW5lbWF0aWNzU2NlbmUoIGRhdGEgKSB7XG5cblx0XHRcdGlmICggZGF0YS5idWlsZCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGRhdGEuYnVpbGQ7XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0S2luZW1hdGljc1NjZW5lKCBpZCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEJ1aWxkKCBsaWJyYXJ5LmtpbmVtYXRpY3NTY2VuZXNbIGlkIF0sIGJ1aWxkS2luZW1hdGljc1NjZW5lICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXR1cEtpbmVtYXRpY3MoKSB7XG5cblx0XHRcdHZhciBraW5lbWF0aWNzTW9kZWxJZCA9IE9iamVjdC5rZXlzKCBsaWJyYXJ5LmtpbmVtYXRpY3NNb2RlbHMgKVsgMCBdO1xuXHRcdFx0dmFyIGtpbmVtYXRpY3NTY2VuZUlkID0gT2JqZWN0LmtleXMoIGxpYnJhcnkua2luZW1hdGljc1NjZW5lcyApWyAwIF07XG5cdFx0XHR2YXIgdmlzdWFsU2NlbmVJZCA9IE9iamVjdC5rZXlzKCBsaWJyYXJ5LnZpc3VhbFNjZW5lcyApWyAwIF07XG5cblx0XHRcdGlmICgga2luZW1hdGljc01vZGVsSWQgPT09IHVuZGVmaW5lZCB8fCBraW5lbWF0aWNzU2NlbmVJZCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIga2luZW1hdGljc01vZGVsID0gZ2V0S2luZW1hdGljc01vZGVsKCBraW5lbWF0aWNzTW9kZWxJZCApO1xuXHRcdFx0dmFyIGtpbmVtYXRpY3NTY2VuZSA9IGdldEtpbmVtYXRpY3NTY2VuZSgga2luZW1hdGljc1NjZW5lSWQgKTtcblx0XHRcdHZhciB2aXN1YWxTY2VuZSA9IGdldFZpc3VhbFNjZW5lKCB2aXN1YWxTY2VuZUlkICk7XG5cblx0XHRcdHZhciBiaW5kSm9pbnRBeGlzID0ga2luZW1hdGljc1NjZW5lLmJpbmRKb2ludEF4aXM7XG5cdFx0XHR2YXIgam9pbnRNYXAgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYmluZEpvaW50QXhpcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBheGlzID0gYmluZEpvaW50QXhpc1sgaSBdO1xuXG5cdFx0XHRcdC8vIHRoZSByZXN1bHQgb2YgdGhlIGZvbGxvd2luZyBxdWVyeSBpcyBhbiBlbGVtZW50IG9mIHR5cGUgJ3RyYW5zbGF0ZScsICdyb3RhdGUnLCdzY2FsZScgb3IgJ21hdHJpeCdcblxuXHRcdFx0XHR2YXIgdGFyZ2V0RWxlbWVudCA9IGNvbGxhZGEucXVlcnlTZWxlY3RvciggJ1tzaWQ9XCInICsgYXhpcy50YXJnZXQgKyAnXCJdJyApO1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0RWxlbWVudCApIHtcblxuXHRcdFx0XHRcdC8vIGdldCB0aGUgcGFyZW50IG9mIHRoZSB0cmFuc2Zvcm0gZWxlbWVudFxuXG5cdFx0XHRcdFx0dmFyIHBhcmVudFZpc3VhbEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBjb25uZWN0IHRoZSBqb2ludCBvZiB0aGUga2luZW1hdGljcyBtb2RlbCB3aXRoIHRoZSBlbGVtZW50IGluIHRoZSB2aXN1YWwgc2NlbmVcblxuXHRcdFx0XHRcdGNvbm5lY3QoIGF4aXMuam9pbnRJbmRleCwgcGFyZW50VmlzdWFsRWxlbWVudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb25uZWN0KCBqb2ludEluZGV4LCB2aXN1YWxFbGVtZW50ICkge1xuXG5cdFx0XHRcdHZhciB2aXN1YWxFbGVtZW50TmFtZSA9IHZpc3VhbEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHRcdFx0dmFyIGpvaW50ID0ga2luZW1hdGljc01vZGVsLmpvaW50c1sgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdHZpc3VhbFNjZW5lLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRcdGlmICggb2JqZWN0Lm5hbWUgPT09IHZpc3VhbEVsZW1lbnROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRqb2ludE1hcFsgam9pbnRJbmRleCBdID0ge1xuXHRcdFx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtczogYnVpbGRUcmFuc2Zvcm1MaXN0KCB2aXN1YWxFbGVtZW50ICksXG5cdFx0XHRcdFx0XHRcdGpvaW50OiBqb2ludCxcblx0XHRcdFx0XHRcdFx0cG9zaXRpb246IGpvaW50Lnplcm9Qb3NpdGlvblxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG0wID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdFx0a2luZW1hdGljcyA9IHtcblxuXHRcdFx0XHRqb2ludHM6IGtpbmVtYXRpY3NNb2RlbCAmJiBraW5lbWF0aWNzTW9kZWwuam9pbnRzLFxuXG5cdFx0XHRcdGdldEpvaW50VmFsdWU6IGZ1bmN0aW9uICggam9pbnRJbmRleCApIHtcblxuXHRcdFx0XHRcdHZhciBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBqb2ludERhdGEgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBqb2ludERhdGEucG9zaXRpb247XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBKb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0LicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldEpvaW50VmFsdWU6IGZ1bmN0aW9uICggam9pbnRJbmRleCwgdmFsdWUgKSB7XG5cblx0XHRcdFx0XHR2YXIgam9pbnREYXRhID0gam9pbnRNYXBbIGpvaW50SW5kZXggXTtcblxuXHRcdFx0XHRcdGlmICggam9pbnREYXRhICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgam9pbnQgPSBqb2ludERhdGEuam9pbnQ7XG5cblx0XHRcdFx0XHRcdGlmICggdmFsdWUgPiBqb2ludC5saW1pdHMubWF4IHx8IHZhbHVlIDwgam9pbnQubGltaXRzLm1pbiApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBKb2ludCAnICsgam9pbnRJbmRleCArICcgdmFsdWUgJyArIHZhbHVlICsgJyBvdXRzaWRlIG9mIGxpbWl0cyAobWluOiAnICsgam9pbnQubGltaXRzLm1pbiArICcsIG1heDogJyArIGpvaW50LmxpbWl0cy5tYXggKyAnKS4nICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGpvaW50LnN0YXRpYyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBKb2ludCAnICsgam9pbnRJbmRleCArICcgaXMgc3RhdGljLicgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gam9pbnREYXRhLm9iamVjdDtcblx0XHRcdFx0XHRcdFx0dmFyIGF4aXMgPSBqb2ludC5heGlzO1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtcyA9IGpvaW50RGF0YS50cmFuc2Zvcm1zO1xuXG5cdFx0XHRcdFx0XHRcdG1hdHJpeC5pZGVudGl0eSgpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGVhY2ggdXBkYXRlLCB3ZSBoYXZlIHRvIGFwcGx5IGFsbCB0cmFuc2Zvcm1zIGluIHRoZSBjb3JyZWN0IG9yZGVyXG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIG9mIHRoZSB0cmFuc2Zvcm0gbm9kZSB3aXRoIGEgam9pbnQsIGFwcGx5IHRoZSBqb2ludCB2YWx1ZVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0cmFuc2Zvcm0uc2lkICYmIHRyYW5zZm9ybS5zaWQuaW5kZXhPZiggam9pbnRJbmRleCApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGpvaW50LnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAncmV2b2x1dGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVJvdGF0aW9uQXhpcyggYXhpcywgTWF0aFV0aWxzLmRlZ1RvUmFkKCB2YWx1ZSApICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVRyYW5zbGF0aW9uKCBheGlzLnggKiB2YWx1ZSwgYXhpcy55ICogdmFsdWUsIGF4aXMueiAqIHZhbHVlICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVua25vd24gam9pbnQgdHlwZTogJyArIGpvaW50LnR5cGUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggdHJhbnNmb3JtLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIHRyYW5zZm9ybS5vYmogKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTAubWFrZVRyYW5zbGF0aW9uKCB0cmFuc2Zvcm0ub2JqLngsIHRyYW5zZm9ybS5vYmoueSwgdHJhbnNmb3JtLm9iai56ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4LnNjYWxlKCB0cmFuc2Zvcm0ub2JqICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIG0wLm1ha2VSb3RhdGlvbkF4aXMoIHRyYW5zZm9ybS5vYmosIHRyYW5zZm9ybS5hbmdsZSApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xuXG5cdFx0XHRcdFx0XHRcdGpvaW50TWFwWyBqb2ludEluZGV4IF0ucG9zaXRpb24gPSB2YWx1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5Db2xsYWRhTG9hZGVyOiAnICsgam9pbnRJbmRleCArICcgZG9lcyBub3QgZXhpc3QuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtTGlzdCggbm9kZSApIHtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybXMgPSBbXTtcblxuXHRcdFx0dmFyIHhtbCA9IGNvbGxhZGEucXVlcnlTZWxlY3RvciggJ1tpZD1cIicgKyBub2RlLmlkICsgJ1wiXScgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBhcnJheSApLnRyYW5zcG9zZSgpO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3Jtcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdHNpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBjaGlsZC5ub2RlTmFtZSxcblx0XHRcdFx0XHRcdFx0b2JqOiBtYXRyaXhcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRjYXNlICdzY2FsZSc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRzaWQ6IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0XHRcdFx0dHlwZTogY2hpbGQubm9kZU5hbWUsXG5cdFx0XHRcdFx0XHRcdG9iajogdmVjdG9yXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggYXJyYXkgKTtcblx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IE1hdGhVdGlscy5kZWdUb1JhZCggYXJyYXlbIDMgXSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3Jtcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdHNpZDogY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApLFxuXHRcdFx0XHRcdFx0XHR0eXBlOiBjaGlsZC5ub2RlTmFtZSxcblx0XHRcdFx0XHRcdFx0b2JqOiB2ZWN0b3IsXG5cdFx0XHRcdFx0XHRcdGFuZ2xlOiBhbmdsZVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cmFuc2Zvcm1zO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbm9kZXNcblxuXHRcdGZ1bmN0aW9uIHByZXBhcmVOb2RlcyggeG1sICkge1xuXG5cdFx0XHR2YXIgZWxlbWVudHMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdub2RlJyApO1xuXG5cdFx0XHQvLyBlbnN1cmUgYWxsIG5vZGUgZWxlbWVudHMgaGF2ZSBpZCBhdHRyaWJ1dGVzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGVsZW1lbnRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSggJ2lkJyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCAnaWQnLCBnZW5lcmF0ZUlkKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSB8fCAnJyxcblx0XHRcdFx0dHlwZTogeG1sLmdldEF0dHJpYnV0ZSggJ3R5cGUnICksXG5cdFx0XHRcdGlkOiB4bWwuZ2V0QXR0cmlidXRlKCAnaWQnICksXG5cdFx0XHRcdHNpZDogeG1sLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSxcblx0XHRcdFx0bWF0cml4OiBuZXcgTWF0cml4NCgpLFxuXHRcdFx0XHRub2RlczogW10sXG5cdFx0XHRcdGluc3RhbmNlQ2FtZXJhczogW10sXG5cdFx0XHRcdGluc3RhbmNlQ29udHJvbGxlcnM6IFtdLFxuXHRcdFx0XHRpbnN0YW5jZUxpZ2h0czogW10sXG5cdFx0XHRcdGluc3RhbmNlR2VvbWV0cmllczogW10sXG5cdFx0XHRcdGluc3RhbmNlTm9kZXM6IFtdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbm9kZSc6XG5cdFx0XHRcdFx0XHRkYXRhLm5vZGVzLnB1c2goIGNoaWxkLmdldEF0dHJpYnV0ZSggJ2lkJyApICk7XG5cdFx0XHRcdFx0XHRwYXJzZU5vZGUoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2NhbWVyYSc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlQ2FtZXJhcy5wdXNoKCBwYXJzZUlkKCBjaGlsZC5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9jb250cm9sbGVyJzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VDb250cm9sbGVycy5wdXNoKCBwYXJzZU5vZGVJbnN0YW5jZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdpbnN0YW5jZV9saWdodCc6XG5cdFx0XHRcdFx0XHRkYXRhLmluc3RhbmNlTGlnaHRzLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdGRhdGEuaW5zdGFuY2VHZW9tZXRyaWVzLnB1c2goIHBhcnNlTm9kZUluc3RhbmNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2luc3RhbmNlX25vZGUnOlxuXHRcdFx0XHRcdFx0ZGF0YS5pbnN0YW5jZU5vZGVzLnB1c2goIHBhcnNlSWQoIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3VybCcgKSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdGRhdGEubWF0cml4Lm11bHRpcGx5KCBtYXRyaXguZnJvbUFycmF5KCBhcnJheSApLnRyYW5zcG9zZSgpICk7XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZlY3Rvci5mcm9tQXJyYXkoIGFycmF5ICk7XG5cdFx0XHRcdFx0XHRkYXRhLm1hdHJpeC5tdWx0aXBseSggbWF0cml4Lm1ha2VUcmFuc2xhdGlvbiggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApICk7XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBwYXJzZUZsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IE1hdGhVdGlscy5kZWdUb1JhZCggYXJyYXlbIDMgXSApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXgubXVsdGlwbHkoIG1hdHJpeC5tYWtlUm90YXRpb25BeGlzKCB2ZWN0b3IuZnJvbUFycmF5KCBhcnJheSApLCBhbmdsZSApICk7XG5cdFx0XHRcdFx0XHRkYXRhLnRyYW5zZm9ybXNbIGNoaWxkLmdldEF0dHJpYnV0ZSggJ3NpZCcgKSBdID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdFx0ZGF0YS5tYXRyaXguc2NhbGUoIHZlY3Rvci5mcm9tQXJyYXkoIGFycmF5ICkgKTtcblx0XHRcdFx0XHRcdGRhdGEudHJhbnNmb3Jtc1sgY2hpbGQuZ2V0QXR0cmlidXRlKCAnc2lkJyApIF0gPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzTm9kZSggZGF0YS5pZCApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFRoZXJlIGlzIGFscmVhZHkgYSBub2RlIHdpdGggSUQgJXMuIEV4Y2x1ZGUgY3VycmVudCBub2RlIGZyb20gZnVydGhlciBwcm9jZXNzaW5nLicsIGRhdGEuaWQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRsaWJyYXJ5Lm5vZGVzWyBkYXRhLmlkIF0gPSBkYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlSW5zdGFuY2UoIHhtbCApIHtcblxuXHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdGlkOiBwYXJzZUlkKCB4bWwuZ2V0QXR0cmlidXRlKCAndXJsJyApICksXG5cdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdHNrZWxldG9uczogW11cblx0XHRcdH07XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnYmluZF9tYXRlcmlhbCc6XG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2VzID0gY2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdpbnN0YW5jZV9tYXRlcmlhbCcgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaW5zdGFuY2VzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbIGogXTtcblx0XHRcdFx0XHRcdFx0dmFyIHN5bWJvbCA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZSggJ3N5bWJvbCcgKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRhcmdldCA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZSggJ3RhcmdldCcgKTtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLm1hdGVyaWFsc1sgc3ltYm9sIF0gPSBwYXJzZUlkKCB0YXJnZXQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NrZWxldG9uJzpcblx0XHRcdFx0XHRcdGRhdGEuc2tlbGV0b25zLnB1c2goIHBhcnNlSWQoIGNoaWxkLnRleHRDb250ZW50ICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkU2tlbGV0b24oIHNrZWxldG9ucywgam9pbnRzICkge1xuXG5cdFx0XHR2YXIgYm9uZURhdGEgPSBbXTtcblx0XHRcdHZhciBzb3J0ZWRCb25lRGF0YSA9IFtdO1xuXG5cdFx0XHR2YXIgaSwgaiwgZGF0YTtcblxuXHRcdFx0Ly8gYSBza2VsZXRvbiBjYW4gaGF2ZSBtdWx0aXBsZSByb290IGJvbmVzLiBjb2xsYWRhIGV4cHJlc3NlcyB0aGlzXG5cdFx0XHQvLyBzaXR1dGF0aW9uIHdpdGggbXVsdGlwbGUgXCJza2VsZXRvblwiIHRhZ3MgcGVyIGNvbnRyb2xsZXIgaW5zdGFuY2VcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBza2VsZXRvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBza2VsZXRvbiA9IHNrZWxldG9uc1sgaSBdO1xuXG5cdFx0XHRcdHZhciByb290O1xuXG5cdFx0XHRcdGlmICggaGFzTm9kZSggc2tlbGV0b24gKSApIHtcblxuXHRcdFx0XHRcdHJvb3QgPSBnZXROb2RlKCBza2VsZXRvbiApO1xuXHRcdFx0XHRcdGJ1aWxkQm9uZUhpZXJhcmNoeSggcm9vdCwgam9pbnRzLCBib25lRGF0YSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGhhc1Zpc3VhbFNjZW5lKCBza2VsZXRvbiApICkge1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlcmUgdGhlIHNrZWxldG9uIHJlZmVycyB0byB0aGUgdmlzdWFsIHNjZW5lICgjMTMzMzUpXG5cblx0XHRcdFx0XHR2YXIgdmlzdWFsU2NlbmUgPSBsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgc2tlbGV0b24gXTtcblx0XHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2aXN1YWxTY2VuZS5jaGlsZHJlbjtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5bIGogXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZC50eXBlID09PSAnSk9JTlQnICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciByb290ID0gZ2V0Tm9kZSggY2hpbGQuaWQgKTtcblx0XHRcdFx0XHRcdFx0YnVpbGRCb25lSGllcmFyY2h5KCByb290LCBqb2ludHMsIGJvbmVEYXRhICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IFVuYWJsZSB0byBmaW5kIHJvb3QgYm9uZSBvZiBza2VsZXRvbiB3aXRoIElEOicsIHNrZWxldG9uICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNvcnQgYm9uZSBkYXRhICh0aGUgb3JkZXIgaXMgZGVmaW5lZCBpbiB0aGUgY29ycmVzcG9uZGluZyBjb250cm9sbGVyKVxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGpvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBib25lRGF0YS5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRkYXRhID0gYm9uZURhdGFbIGogXTtcblxuXHRcdFx0XHRcdGlmICggZGF0YS5ib25lLm5hbWUgPT09IGpvaW50c1sgaSBdLm5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdHNvcnRlZEJvbmVEYXRhWyBpIF0gPSBkYXRhO1xuXHRcdFx0XHRcdFx0ZGF0YS5wcm9jZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCB1bnByb2Nlc3NlZCBib25lIGRhdGEgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJvbmVEYXRhLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRkYXRhID0gYm9uZURhdGFbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEucHJvY2Vzc2VkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHNvcnRlZEJvbmVEYXRhLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0XHRkYXRhLnByb2Nlc3NlZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3Igc2tlbGV0b24gY3JlYXRpb25cblxuXHRcdFx0dmFyIGJvbmVzID0gW107XG5cdFx0XHR2YXIgYm9uZUludmVyc2VzID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc29ydGVkQm9uZURhdGEubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGRhdGEgPSBzb3J0ZWRCb25lRGF0YVsgaSBdO1xuXG5cdFx0XHRcdGJvbmVzLnB1c2goIGRhdGEuYm9uZSApO1xuXHRcdFx0XHRib25lSW52ZXJzZXMucHVzaCggZGF0YS5ib25lSW52ZXJzZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJ1aWxkQm9uZUhpZXJhcmNoeSggcm9vdCwgam9pbnRzLCBib25lRGF0YSApIHtcblxuXHRcdFx0Ly8gc2V0dXAgYm9uZSBkYXRhIGZyb20gdmlzdWFsIHNjZW5lXG5cblx0XHRcdHJvb3QudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzQm9uZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBib25lSW52ZXJzZTtcblxuXHRcdFx0XHRcdC8vIHJldHJpZXZlIHRoZSBib25lSW52ZXJzZSBmcm9tIHRoZSBjb250cm9sbGVyIGRhdGFcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGpvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBqb2ludCA9IGpvaW50c1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGpvaW50Lm5hbWUgPT09IG9iamVjdC5uYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdGJvbmVJbnZlcnNlID0gam9pbnQuYm9uZUludmVyc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGJvbmVJbnZlcnNlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFVuZm9ydHVuYXRlbHksIHRoZXJlIGNhbiBiZSBqb2ludHMgaW4gdGhlIHZpc3VhbCBzY2VuZSB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGVcblx0XHRcdFx0XHRcdC8vIGNvcnJlc3BvbmRpbmcgY29udHJvbGxlci4gSW4gdGhpcyBjYXNlLCB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGR1bW15IGJvbmVJbnZlcnNlIG1hdHJpeFxuXHRcdFx0XHRcdFx0Ly8gZm9yIHRoZSByZXNwZWN0aXZlIGJvbmUuIFRoaXMgYm9uZSB3b24ndCBhZmZlY3QgYW55IHZlcnRpY2VzLCBiZWNhdXNlIHRoZXJlIGFyZSBubyBza2luIGluZGljZXNcblx0XHRcdFx0XHRcdC8vIGFuZCB3ZWlnaHRzIGRlZmluZWQgZm9yIGl0LiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byBhZGQgdGhlIGJvbmUgdG8gdGhlIHNvcnRlZCBib25lIGxpc3QgaW4gb3JkZXIgdG9cblx0XHRcdFx0XHRcdC8vIGVuc3VyZSBhIGNvcnJlY3QgYW5pbWF0aW9uIG9mIHRoZSBtb2RlbC5cblxuXHRcdFx0XHRcdFx0Ym9uZUludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ym9uZURhdGEucHVzaCggeyBib25lOiBvYmplY3QsIGJvbmVJbnZlcnNlOiBib25lSW52ZXJzZSwgcHJvY2Vzc2VkOiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZE5vZGUoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBvYmplY3RzID0gW107XG5cblx0XHRcdHZhciBtYXRyaXggPSBkYXRhLm1hdHJpeDtcblx0XHRcdHZhciBub2RlcyA9IGRhdGEubm9kZXM7XG5cdFx0XHR2YXIgdHlwZSA9IGRhdGEudHlwZTtcblx0XHRcdHZhciBpbnN0YW5jZUNhbWVyYXMgPSBkYXRhLmluc3RhbmNlQ2FtZXJhcztcblx0XHRcdHZhciBpbnN0YW5jZUNvbnRyb2xsZXJzID0gZGF0YS5pbnN0YW5jZUNvbnRyb2xsZXJzO1xuXHRcdFx0dmFyIGluc3RhbmNlTGlnaHRzID0gZGF0YS5pbnN0YW5jZUxpZ2h0cztcblx0XHRcdHZhciBpbnN0YW5jZUdlb21ldHJpZXMgPSBkYXRhLmluc3RhbmNlR2VvbWV0cmllcztcblx0XHRcdHZhciBpbnN0YW5jZU5vZGVzID0gZGF0YS5pbnN0YW5jZU5vZGVzO1xuXG5cdFx0XHQvLyBub2Rlc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdHMucHVzaCggZ2V0Tm9kZSggbm9kZXNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2UgY2FtZXJhc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZUNhbWVyYXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5zdGFuY2VDYW1lcmEgPSBnZXRDYW1lcmEoIGluc3RhbmNlQ2FtZXJhc1sgaSBdICk7XG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZUNhbWVyYSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdG9iamVjdHMucHVzaCggaW5zdGFuY2VDYW1lcmEuY2xvbmUoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBjb250cm9sbGVyc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZUNvbnRyb2xsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VDb250cm9sbGVyc1sgaSBdO1xuXHRcdFx0XHR2YXIgY29udHJvbGxlciA9IGdldENvbnRyb2xsZXIoIGluc3RhbmNlLmlkICk7XG5cdFx0XHRcdHZhciBnZW9tZXRyaWVzID0gZ2V0R2VvbWV0cnkoIGNvbnRyb2xsZXIuaWQgKTtcblx0XHRcdFx0dmFyIG5ld09iamVjdHMgPSBidWlsZE9iamVjdHMoIGdlb21ldHJpZXMsIGluc3RhbmNlLm1hdGVyaWFscyApO1xuXG5cdFx0XHRcdHZhciBza2VsZXRvbnMgPSBpbnN0YW5jZS5za2VsZXRvbnM7XG5cdFx0XHRcdHZhciBqb2ludHMgPSBjb250cm9sbGVyLnNraW4uam9pbnRzO1xuXG5cdFx0XHRcdHZhciBza2VsZXRvbiA9IGJ1aWxkU2tlbGV0b24oIHNrZWxldG9ucywgam9pbnRzICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG5ld09iamVjdHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gbmV3T2JqZWN0c1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0LmJpbmQoIHNrZWxldG9uLCBjb250cm9sbGVyLnNraW4uYmluZE1hdHJpeCApO1xuXHRcdFx0XHRcdFx0b2JqZWN0Lm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbnN0YW5jZSBsaWdodHNcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5zdGFuY2VMaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5zdGFuY2VMaWdodCA9IGdldExpZ2h0KCBpbnN0YW5jZUxpZ2h0c1sgaSBdICk7XG5cblx0XHRcdFx0aWYgKCBpbnN0YW5jZUxpZ2h0ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBpbnN0YW5jZUxpZ2h0LmNsb25lKCkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5zdGFuY2UgZ2VvbWV0cmllc1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZUdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZUdlb21ldHJpZXNbIGkgXTtcblxuXHRcdFx0XHQvLyBhIHNpbmdsZSBnZW9tZXRyeSBpbnN0YW5jZSBpbiBjb2xsYWRhIGNhbiBsZWFkIHRvIG11bHRpcGxlIG9iamVjdDNEcy5cblx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgY2FzZSB3aGVuIHByaW1pdGl2ZXMgYXJlIGNvbWJpbmVkIGxpa2UgdHJpYW5nbGVzIGFuZCBsaW5lc1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyaWVzID0gZ2V0R2VvbWV0cnkoIGluc3RhbmNlLmlkICk7XG5cdFx0XHRcdHZhciBuZXdPYmplY3RzID0gYnVpbGRPYmplY3RzKCBnZW9tZXRyaWVzLCBpbnN0YW5jZS5tYXRlcmlhbHMgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbmV3T2JqZWN0cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdG9iamVjdHMucHVzaCggbmV3T2JqZWN0c1sgaiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluc3RhbmNlIG5vZGVzXG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluc3RhbmNlTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRvYmplY3RzLnB1c2goIGdldE5vZGUoIGluc3RhbmNlTm9kZXNbIGkgXSApLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb2JqZWN0O1xuXG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA9PT0gMCAmJiBvYmplY3RzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRvYmplY3QgPSBvYmplY3RzWyAwIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0b2JqZWN0ID0gKCB0eXBlID09PSAnSk9JTlQnICkgPyBuZXcgQm9uZSgpIDogbmV3IEdyb3VwKCk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRvYmplY3QuYWRkKCBvYmplY3RzWyBpIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0Lm5hbWUgPSAoIHR5cGUgPT09ICdKT0lOVCcgKSA/IGRhdGEuc2lkIDogZGF0YS5uYW1lO1xuXHRcdFx0b2JqZWN0Lm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHRcdG9iamVjdC5tYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0cmV0dXJuIG9iamVjdDtcblxuXHRcdH1cblxuXHRcdHZhciBmYWxsYmFja01hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmMDBmZiB9ICk7XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlTWF0ZXJpYWxCaW5kaW5nKCBrZXlzLCBpbnN0YW5jZU1hdGVyaWFscyApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGlkID0gaW5zdGFuY2VNYXRlcmlhbHNbIGtleXNbIGkgXSBdO1xuXG5cdFx0XHRcdGlmICggaWQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IE1hdGVyaWFsIHdpdGgga2V5ICVzIG5vdCBmb3VuZC4gQXBwbHkgZmFsbGJhY2sgbWF0ZXJpYWwuJywga2V5c1sgaSBdICk7XG5cdFx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIGZhbGxiYWNrTWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIGdldE1hdGVyaWFsKCBpZCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbHM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBidWlsZE9iamVjdHMoIGdlb21ldHJpZXMsIGluc3RhbmNlTWF0ZXJpYWxzICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0cyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgdHlwZSBpbiBnZW9tZXRyaWVzICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIHR5cGUgXTtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gcmVzb2x2ZU1hdGVyaWFsQmluZGluZyggZ2VvbWV0cnkubWF0ZXJpYWxLZXlzLCBpbnN0YW5jZU1hdGVyaWFscyApO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBjYXNlIGlmIG5vIG1hdGVyaWFscyBhcmUgZGVmaW5lZFxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2xpbmVzJyB8fCB0eXBlID09PSAnbGluZXN0cmlwcycgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlZ2FyZCBza2lubmluZ1xuXG5cdFx0XHRcdHZhciBza2lubmluZyA9ICggZ2VvbWV0cnkuZGF0YS5hdHRyaWJ1dGVzLnNraW5JbmRleCAhPT0gdW5kZWZpbmVkICk7XG5cblx0XHRcdFx0aWYgKCBza2lubmluZyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbHNbIGkgXS5za2lubmluZyA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNob29zZSBiZXR3ZWVuIGEgc2luZ2xlIG9yIG11bHRpIG1hdGVyaWFscyAobWF0ZXJpYWwgYXJyYXkpXG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gKCBtYXRlcmlhbHMubGVuZ3RoID09PSAxICkgPyBtYXRlcmlhbHNbIDAgXSA6IG1hdGVyaWFscztcblxuXHRcdFx0XHQvLyBub3cgY3JlYXRlIGEgc3BlY2lmaWMgM0Qgb2JqZWN0XG5cblx0XHRcdFx0dmFyIG9iamVjdDtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluZXMnOlxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnkuZGF0YSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGluZXN0cmlwcyc6XG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZSggZ2VvbWV0cnkuZGF0YSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndHJpYW5nbGVzJzpcblx0XHRcdFx0XHRjYXNlICdwb2x5bGlzdCc6XG5cdFx0XHRcdFx0XHRpZiAoIHNraW5uaW5nICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnkuZGF0YSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnkuZGF0YSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0cztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc05vZGUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gbGlicmFyeS5ub2Rlc1sgaWQgXSAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Tm9kZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBnZXRCdWlsZCggbGlicmFyeS5ub2Rlc1sgaWQgXSwgYnVpbGROb2RlICk7XG5cblx0XHR9XG5cblx0XHQvLyB2aXN1YWwgc2NlbmVzXG5cblx0XHRmdW5jdGlvbiBwYXJzZVZpc3VhbFNjZW5lKCB4bWwgKSB7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRuYW1lOiB4bWwuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSxcblx0XHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHRwcmVwYXJlTm9kZXMoIHhtbCApO1xuXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBnZXRFbGVtZW50c0J5VGFnTmFtZSggeG1sLCAnbm9kZScgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGRhdGEuY2hpbGRyZW4ucHVzaCggcGFyc2VOb2RlKCBlbGVtZW50c1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgeG1sLmdldEF0dHJpYnV0ZSggJ2lkJyApIF0gPSBkYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYnVpbGRWaXN1YWxTY2VuZSggZGF0YSApIHtcblxuXHRcdFx0dmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRncm91cC5uYW1lID0gZGF0YS5uYW1lO1xuXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRncm91cC5hZGQoIGdldE5vZGUoIGNoaWxkLmlkICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYXNWaXN1YWxTY2VuZSggaWQgKSB7XG5cblx0XHRcdHJldHVybiBsaWJyYXJ5LnZpc3VhbFNjZW5lc1sgaWQgXSAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmlzdWFsU2NlbmUoIGlkICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0QnVpbGQoIGxpYnJhcnkudmlzdWFsU2NlbmVzWyBpZCBdLCBidWlsZFZpc3VhbFNjZW5lICk7XG5cblx0XHR9XG5cblx0XHQvLyBzY2VuZXNcblxuXHRcdGZ1bmN0aW9uIHBhcnNlU2NlbmUoIHhtbCApIHtcblxuXHRcdFx0dmFyIGluc3RhbmNlID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ2luc3RhbmNlX3Zpc3VhbF9zY2VuZScgKVsgMCBdO1xuXHRcdFx0cmV0dXJuIGdldFZpc3VhbFNjZW5lKCBwYXJzZUlkKCBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoICd1cmwnICkgKSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0dXBBbmltYXRpb25zKCkge1xuXG5cdFx0XHR2YXIgY2xpcHMgPSBsaWJyYXJ5LmNsaXBzO1xuXG5cdFx0XHRpZiAoIGlzRW1wdHkoIGNsaXBzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0VtcHR5KCBsaWJyYXJ5LmFuaW1hdGlvbnMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgYW5pbWF0aW9ucyBidXQgbm8gY2xpcHMsIHdlIGNyZWF0ZSBhIGRlZmF1bHQgY2xpcCBmb3IgcGxheWJhY2tcblxuXHRcdFx0XHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpZCBpbiBsaWJyYXJ5LmFuaW1hdGlvbnMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBhbmltYXRpb25UcmFja3MgPSBnZXRBbmltYXRpb24oIGlkICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFuaW1hdGlvblRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBhbmltYXRpb25UcmFja3NbIGkgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIG5ldyBBbmltYXRpb25DbGlwKCAnZGVmYXVsdCcsIC0gMSwgdHJhY2tzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGlkIGluIGNsaXBzICkge1xuXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBnZXRBbmltYXRpb25DbGlwKCBpZCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSBwYXJzZXIgZXJyb3IgZWxlbWVudCBpbnRvIHRleHQgd2l0aCBlYWNoIGNoaWxkIGVsZW1lbnRzIHRleHRcblx0XHQvLyBzZXBhcmF0ZWQgYnkgbmV3IGxpbmVzLlxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VyRXJyb3JUb1RleHQoIHBhcnNlckVycm9yICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHR2YXIgc3RhY2sgPSBbIHBhcnNlckVycm9yIF07XG5cblx0XHRcdHdoaWxlICggc3RhY2subGVuZ3RoICkge1xuXG5cdFx0XHRcdHZhciBub2RlID0gc3RhY2suc2hpZnQoKTtcblxuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICkge1xuXG5cdFx0XHRcdFx0cmVzdWx0ICs9IG5vZGUudGV4dENvbnRlbnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJlc3VsdCArPSAnXFxuJztcblx0XHRcdFx0XHRzdGFjay5wdXNoLmFwcGx5KCBzdGFjaywgbm9kZS5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQudHJpbSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0ZXh0Lmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0cmV0dXJuIHsgc2NlbmU6IG5ldyBTY2VuZSgpIH07XG5cblx0XHR9XG5cblx0XHR2YXIgeG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyggdGV4dCwgJ2FwcGxpY2F0aW9uL3htbCcgKTtcblxuXHRcdHZhciBjb2xsYWRhID0gZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHhtbCwgJ0NPTExBREEnIClbIDAgXTtcblxuXHRcdHZhciBwYXJzZXJFcnJvciA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggJ3BhcnNlcmVycm9yJyApWyAwIF07XG5cdFx0aWYgKCBwYXJzZXJFcnJvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBDaHJvbWUgd2lsbCByZXR1cm4gcGFyc2VyIGVycm9yIHdpdGggYSBkaXYgaW4gaXRcblxuXHRcdFx0dmFyIGVycm9yRWxlbWVudCA9IGdldEVsZW1lbnRzQnlUYWdOYW1lKCBwYXJzZXJFcnJvciwgJ2RpdicgKVsgMCBdO1xuXHRcdFx0dmFyIGVycm9yVGV4dDtcblxuXHRcdFx0aWYgKCBlcnJvckVsZW1lbnQgKSB7XG5cblx0XHRcdFx0ZXJyb3JUZXh0ID0gZXJyb3JFbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGVycm9yVGV4dCA9IHBhcnNlckVycm9yVG9UZXh0KCBwYXJzZXJFcnJvciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Db2xsYWRhTG9hZGVyOiBGYWlsZWQgdG8gcGFyc2UgY29sbGFkYSBmaWxlLlxcbicsIGVycm9yVGV4dCApO1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdC8vIG1ldGFkYXRhXG5cblx0XHR2YXIgdmVyc2lvbiA9IGNvbGxhZGEuZ2V0QXR0cmlidXRlKCAndmVyc2lvbicgKTtcblx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLkNvbGxhZGFMb2FkZXI6IEZpbGUgdmVyc2lvbicsIHZlcnNpb24gKTtcblxuXHRcdHZhciBhc3NldCA9IHBhcnNlQXNzZXQoIGdldEVsZW1lbnRzQnlUYWdOYW1lKCBjb2xsYWRhLCAnYXNzZXQnIClbIDAgXSApO1xuXHRcdHZhciB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdHRleHR1cmVMb2FkZXIuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHR2YXIgdGdhTG9hZGVyO1xuXG5cdFx0aWYgKCBUR0FMb2FkZXIgKSB7XG5cblx0XHRcdHRnYUxvYWRlciA9IG5ldyBUR0FMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0dGdhTG9hZGVyLnNldFBhdGgoIHRoaXMucmVzb3VyY2VQYXRoIHx8IHBhdGggKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXHRcdHZhciBraW5lbWF0aWNzID0ge307XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdC8vXG5cblx0XHR2YXIgbGlicmFyeSA9IHtcblx0XHRcdGFuaW1hdGlvbnM6IHt9LFxuXHRcdFx0Y2xpcHM6IHt9LFxuXHRcdFx0Y29udHJvbGxlcnM6IHt9LFxuXHRcdFx0aW1hZ2VzOiB7fSxcblx0XHRcdGVmZmVjdHM6IHt9LFxuXHRcdFx0bWF0ZXJpYWxzOiB7fSxcblx0XHRcdGNhbWVyYXM6IHt9LFxuXHRcdFx0bGlnaHRzOiB7fSxcblx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0bm9kZXM6IHt9LFxuXHRcdFx0dmlzdWFsU2NlbmVzOiB7fSxcblx0XHRcdGtpbmVtYXRpY3NNb2RlbHM6IHt9LFxuXHRcdFx0cGh5c2ljc01vZGVsczoge30sXG5cdFx0XHRraW5lbWF0aWNzU2NlbmVzOiB7fVxuXHRcdH07XG5cblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2FuaW1hdGlvbnMnLCAnYW5pbWF0aW9uJywgcGFyc2VBbmltYXRpb24gKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X2FuaW1hdGlvbl9jbGlwcycsICdhbmltYXRpb25fY2xpcCcsIHBhcnNlQW5pbWF0aW9uQ2xpcCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfY29udHJvbGxlcnMnLCAnY29udHJvbGxlcicsIHBhcnNlQ29udHJvbGxlciApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfaW1hZ2VzJywgJ2ltYWdlJywgcGFyc2VJbWFnZSApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfZWZmZWN0cycsICdlZmZlY3QnLCBwYXJzZUVmZmVjdCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfbWF0ZXJpYWxzJywgJ21hdGVyaWFsJywgcGFyc2VNYXRlcmlhbCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfY2FtZXJhcycsICdjYW1lcmEnLCBwYXJzZUNhbWVyYSApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfbGlnaHRzJywgJ2xpZ2h0JywgcGFyc2VMaWdodCApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfZ2VvbWV0cmllcycsICdnZW9tZXRyeScsIHBhcnNlR2VvbWV0cnkgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X25vZGVzJywgJ25vZGUnLCBwYXJzZU5vZGUgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdsaWJyYXJ5X3Zpc3VhbF9zY2VuZXMnLCAndmlzdWFsX3NjZW5lJywgcGFyc2VWaXN1YWxTY2VuZSApO1xuXHRcdHBhcnNlTGlicmFyeSggY29sbGFkYSwgJ2xpYnJhcnlfa2luZW1hdGljc19tb2RlbHMnLCAna2luZW1hdGljc19tb2RlbCcsIHBhcnNlS2luZW1hdGljc01vZGVsICk7XG5cdFx0cGFyc2VMaWJyYXJ5KCBjb2xsYWRhLCAnbGlicmFyeV9waHlzaWNzX21vZGVscycsICdwaHlzaWNzX21vZGVsJywgcGFyc2VQaHlzaWNzTW9kZWwgKTtcblx0XHRwYXJzZUxpYnJhcnkoIGNvbGxhZGEsICdzY2VuZScsICdpbnN0YW5jZV9raW5lbWF0aWNzX3NjZW5lJywgcGFyc2VLaW5lbWF0aWNzU2NlbmUgKTtcblxuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5hbmltYXRpb25zLCBidWlsZEFuaW1hdGlvbiApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5jbGlwcywgYnVpbGRBbmltYXRpb25DbGlwICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmNvbnRyb2xsZXJzLCBidWlsZENvbnRyb2xsZXIgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuaW1hZ2VzLCBidWlsZEltYWdlICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5LmVmZmVjdHMsIGJ1aWxkRWZmZWN0ICk7XG5cdFx0YnVpbGRMaWJyYXJ5KCBsaWJyYXJ5Lm1hdGVyaWFscywgYnVpbGRNYXRlcmlhbCApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5jYW1lcmFzLCBidWlsZENhbWVyYSApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS5saWdodHMsIGJ1aWxkTGlnaHQgKTtcblx0XHRidWlsZExpYnJhcnkoIGxpYnJhcnkuZ2VvbWV0cmllcywgYnVpbGRHZW9tZXRyeSApO1xuXHRcdGJ1aWxkTGlicmFyeSggbGlicmFyeS52aXN1YWxTY2VuZXMsIGJ1aWxkVmlzdWFsU2NlbmUgKTtcblxuXHRcdHNldHVwQW5pbWF0aW9ucygpO1xuXHRcdHNldHVwS2luZW1hdGljcygpO1xuXG5cdFx0dmFyIHNjZW5lID0gcGFyc2VTY2VuZSggZ2V0RWxlbWVudHNCeVRhZ05hbWUoIGNvbGxhZGEsICdzY2VuZScgKVsgMCBdICk7XG5cdFx0c2NlbmUuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cblx0XHRpZiAoIGFzc2V0LnVwQXhpcyA9PT0gJ1pfVVAnICkge1xuXG5cdFx0XHRzY2VuZS5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggbmV3IEV1bGVyKCAtIE1hdGguUEkgLyAyLCAwLCAwICkgKTtcblxuXHRcdH1cblxuXHRcdHNjZW5lLnNjYWxlLm11bHRpcGx5U2NhbGFyKCBhc3NldC51bml0ICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0IGFuaW1hdGlvbnMoKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sbGFkYUxvYWRlcjogUGxlYXNlIGFjY2VzcyBhbmltYXRpb25zIG92ZXIgc2NlbmUuYW5pbWF0aW9ucyBub3cuJyApO1xuXHRcdFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuXHRcdFx0fSxcblx0XHRcdGtpbmVtYXRpY3M6IGtpbmVtYXRpY3MsXG5cdFx0XHRsaWJyYXJ5OiBsaWJyYXJ5LFxuXHRcdFx0c2NlbmU6IHNjZW5lXG5cdFx0fTtcblxuXHR9XG5cbn0gKTtcblxudmFyIE9CSkxvYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdC8vIG8gb2JqZWN0X25hbWUgfCBnIGdyb3VwX25hbWVcblx0dmFyIG9iamVjdF9wYXR0ZXJuID0gL15bb2ddXFxzKiguKyk/Lztcblx0Ly8gbXRsbGliIGZpbGVfcmVmZXJlbmNlXG5cdHZhciBtYXRlcmlhbF9saWJyYXJ5X3BhdHRlcm4gPSAvXm10bGxpYiAvO1xuXHQvLyB1c2VtdGwgbWF0ZXJpYWxfbmFtZVxuXHR2YXIgbWF0ZXJpYWxfdXNlX3BhdHRlcm4gPSAvXnVzZW10bCAvO1xuXHQvLyB1c2VtYXAgbWFwX25hbWVcblx0dmFyIG1hcF91c2VfcGF0dGVybiA9IC9edXNlbWFwIC87XG5cblx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcblx0dmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcblxuXHR2YXIgYWIgPSBuZXcgVmVjdG9yMygpO1xuXHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdGZ1bmN0aW9uIFBhcnNlclN0YXRlKCkge1xuXG5cdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0b2JqZWN0czogW10sXG5cdFx0XHRvYmplY3Q6IHt9LFxuXG5cdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRub3JtYWxzOiBbXSxcblx0XHRcdGNvbG9yczogW10sXG5cdFx0XHR1dnM6IFtdLFxuXG5cdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0bWF0ZXJpYWxMaWJyYXJpZXM6IFtdLFxuXG5cdFx0XHRzdGFydE9iamVjdDogZnVuY3Rpb24gKCBuYW1lLCBmcm9tRGVjbGFyYXRpb24gKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGN1cnJlbnQgb2JqZWN0IChpbml0aWFsIGZyb20gcmVzZXQpIGlzIG5vdCBmcm9tIGEgZy9vIGRlY2xhcmF0aW9uIGluIHRoZSBwYXJzZWRcblx0XHRcdFx0Ly8gZmlsZS4gV2UgbmVlZCB0byB1c2UgaXQgZm9yIHRoZSBmaXJzdCBwYXJzZWQgZy9vIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdGhpcy5vYmplY3QuZnJvbURlY2xhcmF0aW9uID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0XHRcdHRoaXMub2JqZWN0LmZyb21EZWNsYXJhdGlvbiA9ICggZnJvbURlY2xhcmF0aW9uICE9PSBmYWxzZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHByZXZpb3VzTWF0ZXJpYWwgPSAoIHRoaXMub2JqZWN0ICYmIHR5cGVvZiB0aGlzLm9iamVjdC5jdXJyZW50TWF0ZXJpYWwgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9iamVjdC5jdXJyZW50TWF0ZXJpYWwoKSA6IHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdGlmICggdGhpcy5vYmplY3QgJiYgdHlwZW9mIHRoaXMub2JqZWN0Ll9maW5hbGl6ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Ll9maW5hbGl6ZSggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLm9iamVjdCA9IHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lIHx8ICcnLFxuXHRcdFx0XHRcdGZyb21EZWNsYXJhdGlvbjogKCBmcm9tRGVjbGFyYXRpb24gIT09IGZhbHNlICksXG5cblx0XHRcdFx0XHRnZW9tZXRyeToge1xuXHRcdFx0XHRcdFx0dmVydGljZXM6IFtdLFxuXHRcdFx0XHRcdFx0bm9ybWFsczogW10sXG5cdFx0XHRcdFx0XHRjb2xvcnM6IFtdLFxuXHRcdFx0XHRcdFx0dXZzOiBbXSxcblx0XHRcdFx0XHRcdGhhc1VWSW5kaWNlczogZmFsc2Vcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG1hdGVyaWFsczogW10sXG5cdFx0XHRcdFx0c21vb3RoOiB0cnVlLFxuXG5cdFx0XHRcdFx0c3RhcnRNYXRlcmlhbDogZnVuY3Rpb24gKCBuYW1lLCBsaWJyYXJpZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMuX2ZpbmFsaXplKCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0XHQvLyBOZXcgdXNlbXRsIGRlY2xhcmF0aW9uIG92ZXJ3cml0ZXMgYW4gaW5oZXJpdGVkIG1hdGVyaWFsLCBleGNlcHQgaWYgZmFjZXMgd2VyZSBkZWNsYXJlZFxuXHRcdFx0XHRcdFx0Ly8gYWZ0ZXIgdGhlIG1hdGVyaWFsLCB0aGVuIGl0IG11c3QgYmUgcHJlc2VydmVkIGZvciBwcm9wZXIgTXVsdGlNYXRlcmlhbCBjb250aW51YXRpb24uXG5cdFx0XHRcdFx0XHRpZiAoIHByZXZpb3VzICYmICggcHJldmlvdXMuaW5oZXJpdGVkIHx8IHByZXZpb3VzLmdyb3VwQ291bnQgPD0gMCApICkge1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF0ZXJpYWxzLnNwbGljZSggcHJldmlvdXMuaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSB7XG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0aGlzLm1hdGVyaWFscy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWUgfHwgJycsXG5cdFx0XHRcdFx0XHRcdG10bGxpYjogKCBBcnJheS5pc0FycmF5KCBsaWJyYXJpZXMgKSAmJiBsaWJyYXJpZXMubGVuZ3RoID4gMCA/IGxpYnJhcmllc1sgbGlicmFyaWVzLmxlbmd0aCAtIDEgXSA6ICcnICksXG5cdFx0XHRcdFx0XHRcdHNtb290aDogKCBwcmV2aW91cyAhPT0gdW5kZWZpbmVkID8gcHJldmlvdXMuc21vb3RoIDogdGhpcy5zbW9vdGggKSxcblx0XHRcdFx0XHRcdFx0Z3JvdXBTdGFydDogKCBwcmV2aW91cyAhPT0gdW5kZWZpbmVkID8gcHJldmlvdXMuZ3JvdXBFbmQgOiAwICksXG5cdFx0XHRcdFx0XHRcdGdyb3VwRW5kOiAtIDEsXG5cdFx0XHRcdFx0XHRcdGdyb3VwQ291bnQ6IC0gMSxcblx0XHRcdFx0XHRcdFx0aW5oZXJpdGVkOiBmYWxzZSxcblxuXHRcdFx0XHRcdFx0XHRjbG9uZTogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciBjbG9uZWQgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbmRleDogKCB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInID8gaW5kZXggOiB0aGlzLmluZGV4ICksXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRtdGxsaWI6IHRoaXMubXRsbGliLFxuXHRcdFx0XHRcdFx0XHRcdFx0c21vb3RoOiB0aGlzLnNtb290aCxcblx0XHRcdFx0XHRcdFx0XHRcdGdyb3VwU3RhcnQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRncm91cEVuZDogLSAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0Z3JvdXBDb3VudDogLSAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5oZXJpdGVkOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVkLmNsb25lID0gdGhpcy5jbG9uZS5iaW5kKCBjbG9uZWQgKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY2xvbmVkO1xuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHRoaXMubWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRcdHJldHVybiBtYXRlcmlhbDtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRjdXJyZW50TWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbHMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0X2ZpbmFsaXplOiBmdW5jdGlvbiAoIGVuZCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGxhc3RNdWx0aU1hdGVyaWFsID0gdGhpcy5jdXJyZW50TWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRcdGlmICggbGFzdE11bHRpTWF0ZXJpYWwgJiYgbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBFbmQgPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRsYXN0TXVsdGlNYXRlcmlhbC5ncm91cEVuZCA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC8gMztcblx0XHRcdFx0XHRcdFx0bGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBDb3VudCA9IGxhc3RNdWx0aU1hdGVyaWFsLmdyb3VwRW5kIC0gbGFzdE11bHRpTWF0ZXJpYWwuZ3JvdXBTdGFydDtcblx0XHRcdFx0XHRcdFx0bGFzdE11bHRpTWF0ZXJpYWwuaW5oZXJpdGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSWdub3JlIG9iamVjdHMgdGFpbCBtYXRlcmlhbHMgaWYgbm8gZmFjZSBkZWNsYXJhdGlvbnMgZm9sbG93ZWQgdGhlbSBiZWZvcmUgYSBuZXcgby9nIHN0YXJ0ZWQuXG5cdFx0XHRcdFx0XHRpZiAoIGVuZCAmJiB0aGlzLm1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBtaSA9IHRoaXMubWF0ZXJpYWxzLmxlbmd0aCAtIDE7IG1pID49IDA7IG1pIC0tICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsc1sgbWkgXS5ncm91cENvdW50IDw9IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWF0ZXJpYWxzLnNwbGljZSggbWksIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gR3VhcmFudGVlIGF0IGxlYXN0IG9uZSBlbXB0eSBtYXRlcmlhbCwgdGhpcyBtYWtlcyB0aGUgY3JlYXRpb24gbGF0ZXIgbW9yZSBzdHJhaWdodCBmb3J3YXJkLlxuXHRcdFx0XHRcdFx0aWYgKCBlbmQgJiYgdGhpcy5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF0ZXJpYWxzLnB1c2goIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiAnJyxcblx0XHRcdFx0XHRcdFx0XHRzbW9vdGg6IHRoaXMuc21vb3RoXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gbGFzdE11bHRpTWF0ZXJpYWw7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gSW5oZXJpdCBwcmV2aW91cyBvYmplY3RzIG1hdGVyaWFsLlxuXHRcdFx0XHQvLyBTcGVjIHRlbGxzIHVzIHRoYXQgYSBkZWNsYXJlZCBtYXRlcmlhbCBtdXN0IGJlIHNldCB0byBhbGwgb2JqZWN0cyB1bnRpbCBhIG5ldyBtYXRlcmlhbCBpcyBkZWNsYXJlZC5cblx0XHRcdFx0Ly8gSWYgYSB1c2VtdGwgZGVjbGFyYXRpb24gaXMgZW5jb3VudGVyZWQgd2hpbGUgdGhpcyBuZXcgb2JqZWN0IGlzIGJlaW5nIHBhcnNlZCwgaXQgd2lsbFxuXHRcdFx0XHQvLyBvdmVyd3JpdGUgdGhlIGluaGVyaXRlZCBtYXRlcmlhbC4gRXhjZXB0aW9uIGJlaW5nIHRoYXQgdGhlcmUgd2FzIGFscmVhZHkgZmFjZSBkZWNsYXJhdGlvbnNcblx0XHRcdFx0Ly8gdG8gdGhlIGluaGVyaXRlZCBtYXRlcmlhbCwgdGhlbiBpdCB3aWxsIGJlIHByZXNlcnZlZCBmb3IgcHJvcGVyIE11bHRpTWF0ZXJpYWwgY29udGludWF0aW9uLlxuXG5cdFx0XHRcdGlmICggcHJldmlvdXNNYXRlcmlhbCAmJiBwcmV2aW91c01hdGVyaWFsLm5hbWUgJiYgdHlwZW9mIHByZXZpb3VzTWF0ZXJpYWwuY2xvbmUgPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGVjbGFyZWQgPSBwcmV2aW91c01hdGVyaWFsLmNsb25lKCAwICk7XG5cdFx0XHRcdFx0ZGVjbGFyZWQuaW5oZXJpdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm9iamVjdC5tYXRlcmlhbHMucHVzaCggZGVjbGFyZWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5vYmplY3RzLnB1c2goIHRoaXMub2JqZWN0ICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKCB0aGlzLm9iamVjdCAmJiB0eXBlb2YgdGhpcy5vYmplY3QuX2ZpbmFsaXplID09PSAnZnVuY3Rpb24nICkge1xuXG5cdFx0XHRcdFx0dGhpcy5vYmplY3QuX2ZpbmFsaXplKCB0cnVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRwYXJzZVZlcnRleEluZGV4OiBmdW5jdGlvbiAoIHZhbHVlLCBsZW4gKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlLCAxMCApO1xuXHRcdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAzICkgKiAzO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRwYXJzZU5vcm1hbEluZGV4OiBmdW5jdGlvbiAoIHZhbHVlLCBsZW4gKSB7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlLCAxMCApO1xuXHRcdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyBsZW4gLyAzICkgKiAzO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRwYXJzZVVWSW5kZXg6IGZ1bmN0aW9uICggdmFsdWUsIGxlbiApIHtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludCggdmFsdWUsIDEwICk7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIGxlbiAvIDIgKSAqIDI7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFZlcnRleDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLnZlcnRpY2VzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYSArIDAgXSwgc3JjWyBhICsgMSBdLCBzcmNbIGEgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYiArIDAgXSwgc3JjWyBiICsgMSBdLCBzcmNbIGIgKyAyIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYyArIDAgXSwgc3JjWyBjICsgMSBdLCBzcmNbIGMgKyAyIF0gKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVmVydGV4UG9pbnQ6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSwgc3JjWyBhICsgMiBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFZlcnRleExpbmU6IGZ1bmN0aW9uICggYSApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSwgc3JjWyBhICsgMiBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZE5vcm1hbDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdHZhciBzcmMgPSB0aGlzLm5vcm1hbHM7XG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5ub3JtYWxzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSwgc3JjWyBhICsgMiBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSwgc3JjWyBiICsgMiBdICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGMgKyAwIF0sIHNyY1sgYyArIDEgXSwgc3JjWyBjICsgMiBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZEZhY2VOb3JtYWw6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0XHR2YXIgc3JjID0gdGhpcy52ZXJ0aWNlcztcblx0XHRcdFx0dmFyIGRzdCA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5Lm5vcm1hbHM7XG5cblx0XHRcdFx0dkEuZnJvbUFycmF5KCBzcmMsIGEgKTtcblx0XHRcdFx0dkIuZnJvbUFycmF5KCBzcmMsIGIgKTtcblx0XHRcdFx0dkMuZnJvbUFycmF5KCBzcmMsIGMgKTtcblxuXHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdGRzdC5wdXNoKCBjYi54LCBjYi55LCBjYi56ICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZENvbG9yOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMuY29sb3JzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkuY29sb3JzO1xuXG5cdFx0XHRcdGlmICggc3JjWyBhIF0gIT09IHVuZGVmaW5lZCApIGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSwgc3JjWyBhICsgMiBdICk7XG5cdFx0XHRcdGlmICggc3JjWyBiIF0gIT09IHVuZGVmaW5lZCApIGRzdC5wdXNoKCBzcmNbIGIgKyAwIF0sIHNyY1sgYiArIDEgXSwgc3JjWyBiICsgMiBdICk7XG5cdFx0XHRcdGlmICggc3JjWyBjIF0gIT09IHVuZGVmaW5lZCApIGRzdC5wdXNoKCBzcmNbIGMgKyAwIF0sIHNyY1sgYyArIDEgXSwgc3JjWyBjICsgMiBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZFVWOiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudXZzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSApO1xuXHRcdFx0XHRkc3QucHVzaCggc3JjWyBiICsgMCBdLCBzcmNbIGIgKyAxIF0gKTtcblx0XHRcdFx0ZHN0LnB1c2goIHNyY1sgYyArIDAgXSwgc3JjWyBjICsgMSBdICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGFkZERlZmF1bHRVVjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdHZhciBkc3QgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS51dnM7XG5cblx0XHRcdFx0ZHN0LnB1c2goIDAsIDAgKTtcblx0XHRcdFx0ZHN0LnB1c2goIDAsIDAgKTtcblx0XHRcdFx0ZHN0LnB1c2goIDAsIDAgKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0YWRkVVZMaW5lOiBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHRcdFx0dmFyIHNyYyA9IHRoaXMudXZzO1xuXHRcdFx0XHR2YXIgZHN0ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnkudXZzO1xuXG5cdFx0XHRcdGRzdC5wdXNoKCBzcmNbIGEgKyAwIF0sIHNyY1sgYSArIDEgXSApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRGYWNlOiBmdW5jdGlvbiAoIGEsIGIsIGMsIHVhLCB1YiwgdWMsIG5hLCBuYiwgbmMgKSB7XG5cblx0XHRcdFx0dmFyIHZMZW4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0XHR2YXIgaWEgPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIGEsIHZMZW4gKTtcblx0XHRcdFx0dmFyIGliID0gdGhpcy5wYXJzZVZlcnRleEluZGV4KCBiLCB2TGVuICk7XG5cdFx0XHRcdHZhciBpYyA9IHRoaXMucGFyc2VWZXJ0ZXhJbmRleCggYywgdkxlbiApO1xuXG5cdFx0XHRcdHRoaXMuYWRkVmVydGV4KCBpYSwgaWIsIGljICk7XG5cdFx0XHRcdHRoaXMuYWRkQ29sb3IoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHQvLyBub3JtYWxzXG5cblx0XHRcdFx0aWYgKCBuYSAhPT0gdW5kZWZpbmVkICYmIG5hICE9PSAnJyApIHtcblxuXHRcdFx0XHRcdHZhciBuTGVuID0gdGhpcy5ub3JtYWxzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlhID0gdGhpcy5wYXJzZU5vcm1hbEluZGV4KCBuYSwgbkxlbiApO1xuXHRcdFx0XHRcdGliID0gdGhpcy5wYXJzZU5vcm1hbEluZGV4KCBuYiwgbkxlbiApO1xuXHRcdFx0XHRcdGljID0gdGhpcy5wYXJzZU5vcm1hbEluZGV4KCBuYywgbkxlbiApO1xuXG5cdFx0XHRcdFx0dGhpcy5hZGROb3JtYWwoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRGYWNlTm9ybWFsKCBpYSwgaWIsIGljICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHV2c1xuXG5cdFx0XHRcdGlmICggdWEgIT09IHVuZGVmaW5lZCAmJiB1YSAhPT0gJycgKSB7XG5cblx0XHRcdFx0XHR2YXIgdXZMZW4gPSB0aGlzLnV2cy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpYSA9IHRoaXMucGFyc2VVVkluZGV4KCB1YSwgdXZMZW4gKTtcblx0XHRcdFx0XHRpYiA9IHRoaXMucGFyc2VVVkluZGV4KCB1YiwgdXZMZW4gKTtcblx0XHRcdFx0XHRpYyA9IHRoaXMucGFyc2VVVkluZGV4KCB1YywgdXZMZW4gKTtcblxuXHRcdFx0XHRcdHRoaXMuYWRkVVYoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHRcdHRoaXMub2JqZWN0Lmdlb21ldHJ5Lmhhc1VWSW5kaWNlcyA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIGFkZCBwbGFjZWhvbGRlciB2YWx1ZXMgKGZvciBpbmNvbnNpc3RlbnQgZmFjZSBkZWZpbml0aW9ucylcblxuXHRcdFx0XHRcdHRoaXMuYWRkRGVmYXVsdFVWKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRQb2ludEdlb21ldHJ5OiBmdW5jdGlvbiAoIHZlcnRpY2VzICkge1xuXG5cdFx0XHRcdHRoaXMub2JqZWN0Lmdlb21ldHJ5LnR5cGUgPSAnUG9pbnRzJztcblxuXHRcdFx0XHR2YXIgdkxlbiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIHZhciB2aSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IHZpIDwgbDsgdmkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5kZXggPSB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIHZlcnRpY2VzWyB2aSBdLCB2TGVuICk7XG5cblx0XHRcdFx0XHR0aGlzLmFkZFZlcnRleFBvaW50KCBpbmRleCApO1xuXHRcdFx0XHRcdHRoaXMuYWRkQ29sb3IoIGluZGV4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9LFxuXG5cdFx0XHRhZGRMaW5lR2VvbWV0cnk6IGZ1bmN0aW9uICggdmVydGljZXMsIHV2cyApIHtcblxuXHRcdFx0XHR0aGlzLm9iamVjdC5nZW9tZXRyeS50eXBlID0gJ0xpbmUnO1xuXG5cdFx0XHRcdHZhciB2TGVuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cdFx0XHRcdHZhciB1dkxlbiA9IHRoaXMudXZzLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgdmkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyB2aSA8IGw7IHZpICsrICkge1xuXG5cdFx0XHRcdFx0dGhpcy5hZGRWZXJ0ZXhMaW5lKCB0aGlzLnBhcnNlVmVydGV4SW5kZXgoIHZlcnRpY2VzWyB2aSBdLCB2TGVuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggdmFyIHV2aSA9IDAsIGwgPSB1dnMubGVuZ3RoOyB1dmkgPCBsOyB1dmkgKysgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZFVWTGluZSggdGhpcy5wYXJzZVVWSW5kZXgoIHV2c1sgdXZpIF0sIHV2TGVuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRzdGF0ZS5zdGFydE9iamVjdCggJycsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gc3RhdGU7XG5cblx0fVxuXG5cdC8vXG5cblx0ZnVuY3Rpb24gT0JKTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdFx0dGhpcy5tYXRlcmlhbHMgPSBudWxsO1xuXG5cdH1cblxuXHRPQkpMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBPQkpMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xuXHRcdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XG5cblx0XHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdH0sXG5cblx0XHRzZXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9LFxuXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dmFyIHN0YXRlID0gbmV3IFBhcnNlclN0YXRlKCk7XG5cblx0XHRcdGlmICggdGV4dC5pbmRleE9mKCAnXFxyXFxuJyApICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBmYXN0ZXIgdGhhbiBTdHJpbmcuc3BsaXQgd2l0aCByZWdleCB0aGF0IHNwbGl0cyBvbiBib3RoXG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIC9cXHJcXG4vZywgJ1xcbicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRleHQuaW5kZXhPZiggJ1xcXFxcXG4nICkgIT09IC0gMSApIHtcblxuXHRcdFx0XHQvLyBqb2luIGxpbmVzIHNlcGFyYXRlZCBieSBhIGxpbmUgY29udGludWF0aW9uIGNoYXJhY3RlciAoXFwpXG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIC9cXFxcXFxuL2csICcnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxpbmVzID0gdGV4dC5zcGxpdCggJ1xcbicgKTtcblx0XHRcdHZhciBsaW5lID0gJycsIGxpbmVGaXJzdENoYXIgPSAnJztcblx0XHRcdHZhciBsaW5lTGVuZ3RoID0gMDtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdFx0Ly8gRmFzdGVyIHRvIGp1c3QgdHJpbSBsZWZ0IHNpZGUgb2YgdGhlIGxpbmUuIFVzZSBpZiBhdmFpbGFibGUuXG5cdFx0XHR2YXIgdHJpbUxlZnQgPSAoIHR5cGVvZiAnJy50cmltTGVmdCA9PT0gJ2Z1bmN0aW9uJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGxpbmUgPSBsaW5lc1sgaSBdO1xuXG5cdFx0XHRcdGxpbmUgPSB0cmltTGVmdCA/IGxpbmUudHJpbUxlZnQoKSA6IGxpbmUudHJpbSgpO1xuXG5cdFx0XHRcdGxpbmVMZW5ndGggPSBsaW5lLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGxpbmVMZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRsaW5lRmlyc3RDaGFyID0gbGluZS5jaGFyQXQoIDAgKTtcblxuXHRcdFx0XHQvLyBAdG9kbyBpbnZva2UgcGFzc2VkIGluIGhhbmRsZXIgaWYgYW55XG5cdFx0XHRcdGlmICggbGluZUZpcnN0Q2hhciA9PT0gJyMnICkgY29udGludWU7XG5cblx0XHRcdFx0aWYgKCBsaW5lRmlyc3RDaGFyID09PSAndicgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IGxpbmUuc3BsaXQoIC9cXHMrLyApO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZGF0YVsgMCBdICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRcdFx0c3RhdGUudmVydGljZXMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAxIF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAyIF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAzIF0gKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEubGVuZ3RoID49IDcgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb2xvcnMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQoIGRhdGFbIDQgXSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgNSBdICksXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyA2IF0gKVxuXG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgbm8gY29sb3JzIGFyZSBkZWZpbmVkLCBhZGQgcGxhY2Vob2xkZXJzIHNvIGNvbG9yIGFuZCB2ZXJ0ZXggaW5kaWNlcyBtYXRjaFxuXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29sb3JzLnB1c2goIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd2bic6XG5cdFx0XHRcdFx0XHRcdHN0YXRlLm5vcm1hbHMucHVzaChcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAxIF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAyIF0gKSxcblx0XHRcdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBkYXRhWyAzIF0gKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3Z0Jzpcblx0XHRcdFx0XHRcdFx0c3RhdGUudXZzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMSBdICksXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggZGF0YVsgMiBdIClcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbGluZUZpcnN0Q2hhciA9PT0gJ2YnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpbmVEYXRhID0gbGluZS5zdWJzdHIoIDEgKS50cmltKCk7XG5cdFx0XHRcdFx0dmFyIHZlcnRleERhdGEgPSBsaW5lRGF0YS5zcGxpdCggL1xccysvICk7XG5cdFx0XHRcdFx0dmFyIGZhY2VWZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Ly8gUGFyc2UgdGhlIGZhY2UgdmVydGV4IGRhdGEgaW50byBhbiBlYXN5IHRvIHdvcmsgd2l0aCBmb3JtYXRcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGV4RGF0YVsgaiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZlcnRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXhQYXJ0cyA9IHZlcnRleC5zcGxpdCggJy8nICk7XG5cdFx0XHRcdFx0XHRcdGZhY2VWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXhQYXJ0cyApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEcmF3IGFuIGVkZ2UgYmV0d2VlbiB0aGUgZmlyc3QgdmVydGV4IGFuZCBhbGwgc3Vic2VxdWVudCB2ZXJ0aWNlcyB0byBmb3JtIGFuIG4tZ29uXG5cblx0XHRcdFx0XHR2YXIgdjEgPSBmYWNlVmVydGljZXNbIDAgXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMSwgamwgPSBmYWNlVmVydGljZXMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdjIgPSBmYWNlVmVydGljZXNbIGogXTtcblx0XHRcdFx0XHRcdHZhciB2MyA9IGZhY2VWZXJ0aWNlc1sgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0c3RhdGUuYWRkRmFjZShcblx0XHRcdFx0XHRcdFx0djFbIDAgXSwgdjJbIDAgXSwgdjNbIDAgXSxcblx0XHRcdFx0XHRcdFx0djFbIDEgXSwgdjJbIDEgXSwgdjNbIDEgXSxcblx0XHRcdFx0XHRcdFx0djFbIDIgXSwgdjJbIDIgXSwgdjNbIDIgXVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lRmlyc3RDaGFyID09PSAnbCcgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGluZVBhcnRzID0gbGluZS5zdWJzdHJpbmcoIDEgKS50cmltKCkuc3BsaXQoICcgJyApO1xuXHRcdFx0XHRcdHZhciBsaW5lVmVydGljZXMgPSBbXSwgbGluZVVWcyA9IFtdO1xuXG5cdFx0XHRcdFx0aWYgKCBsaW5lLmluZGV4T2YoICcvJyApID09PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRcdGxpbmVWZXJ0aWNlcyA9IGxpbmVQYXJ0cztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBsaSA9IDAsIGxsZW4gPSBsaW5lUGFydHMubGVuZ3RoOyBsaSA8IGxsZW47IGxpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBwYXJ0cyA9IGxpbmVQYXJ0c1sgbGkgXS5zcGxpdCggJy8nICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBwYXJ0c1sgMCBdICE9PSAnJyApIGxpbmVWZXJ0aWNlcy5wdXNoKCBwYXJ0c1sgMCBdICk7XG5cdFx0XHRcdFx0XHRcdGlmICggcGFydHNbIDEgXSAhPT0gJycgKSBsaW5lVVZzLnB1c2goIHBhcnRzWyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3RhdGUuYWRkTGluZUdlb21ldHJ5KCBsaW5lVmVydGljZXMsIGxpbmVVVnMgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lRmlyc3RDaGFyID09PSAncCcgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGluZURhdGEgPSBsaW5lLnN1YnN0ciggMSApLnRyaW0oKTtcblx0XHRcdFx0XHR2YXIgcG9pbnREYXRhID0gbGluZURhdGEuc3BsaXQoICcgJyApO1xuXG5cdFx0XHRcdFx0c3RhdGUuYWRkUG9pbnRHZW9tZXRyeSggcG9pbnREYXRhICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBvYmplY3RfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdC8vIG8gb2JqZWN0X25hbWVcblx0XHRcdFx0XHQvLyBvclxuXHRcdFx0XHRcdC8vIGcgZ3JvdXBfbmFtZVxuXG5cdFx0XHRcdFx0Ly8gV09SS0FST1VORDogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Mjg2OVxuXHRcdFx0XHRcdC8vIHZhciBuYW1lID0gcmVzdWx0WyAwIF0uc3Vic3RyKCAxICkudHJpbSgpO1xuXHRcdFx0XHRcdHZhciBuYW1lID0gKCAnICcgKyByZXN1bHRbIDAgXS5zdWJzdHIoIDEgKS50cmltKCkgKS5zdWJzdHIoIDEgKTtcblxuXHRcdFx0XHRcdHN0YXRlLnN0YXJ0T2JqZWN0KCBuYW1lICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxfdXNlX3BhdHRlcm4udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gbWF0ZXJpYWxcblxuXHRcdFx0XHRcdHN0YXRlLm9iamVjdC5zdGFydE1hdGVyaWFsKCBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKSwgc3RhdGUubWF0ZXJpYWxMaWJyYXJpZXMgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbF9saWJyYXJ5X3BhdHRlcm4udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gbXRsIGZpbGVcblxuXHRcdFx0XHRcdHN0YXRlLm1hdGVyaWFsTGlicmFyaWVzLnB1c2goIGxpbmUuc3Vic3RyaW5nKCA3ICkudHJpbSgpICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWFwX3VzZV9wYXR0ZXJuLnRlc3QoIGxpbmUgKSApIHtcblxuXHRcdFx0XHRcdC8vIHRoZSBsaW5lIGlzIHBhcnNlZCBidXQgaWdub3JlZCBzaW5jZSB0aGUgbG9hZGVyIGFzc3VtZXMgdGV4dHVyZXMgYXJlIGRlZmluZWQgTVRMIGZpbGVzXG5cdFx0XHRcdFx0Ly8gKGFjY29yZGluZyB0byBodHRwczovL3d3dy5va2luby5jb20vY29udi9pbXBfd2F2ZS5odG0sICd1c2VtYXAnIGlzIHRoZSBvbGQtc3R5bGUgV2F2ZWZyb250IHRleHR1cmUgcmVmZXJlbmNlIG1ldGhvZClcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9CSkxvYWRlcjogUmVuZGVyaW5nIGlkZW50aWZpZXIgXCJ1c2VtYXBcIiBub3Qgc3VwcG9ydGVkLiBUZXh0dXJlcyBtdXN0IGJlIGRlZmluZWQgaW4gTVRMIGZpbGVzLicgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaW5lRmlyc3RDaGFyID09PSAncycgKSB7XG5cblx0XHRcdFx0XHRyZXN1bHQgPSBsaW5lLnNwbGl0KCAnICcgKTtcblxuXHRcdFx0XHRcdC8vIHNtb290aCBzaGFkaW5nXG5cblx0XHRcdFx0XHQvLyBAdG9kbyBIYW5kbGUgZmlsZXMgdGhhdCBoYXZlIHZhcnlpbmcgc21vb3RoIHZhbHVlcyBmb3IgYSBzZXQgb2YgZmFjZXMgaW5zaWRlIG9uZSBnZW9tZXRyeSxcblx0XHRcdFx0XHQvLyBidXQgZG9lcyBub3QgZGVmaW5lIGEgdXNlbXRsIGZvciBlYWNoIGZhY2Ugc2V0LlxuXHRcdFx0XHRcdC8vIFRoaXMgc2hvdWxkIGJlIGRldGVjdGVkIGFuZCBhIGR1bW15IG1hdGVyaWFsIGNyZWF0ZWQgKGxhdGVyIE11bHRpTWF0ZXJpYWwgYW5kIGdlb21ldHJ5IGdyb3VwcykuXG5cdFx0XHRcdFx0Ly8gVGhpcyByZXF1aXJlcyBzb21lIGNhcmUgdG8gbm90IGNyZWF0ZSBleHRyYSBtYXRlcmlhbCBvbiBlYWNoIHNtb290aCB2YWx1ZSBmb3IgXCJub3JtYWxcIiBvYmogZmlsZXMuXG5cdFx0XHRcdFx0Ly8gd2hlcmUgZXhwbGljaXQgdXNlbXRsIGRlZmluZXMgZ2VvbWV0cnkgZ3JvdXBzLlxuXHRcdFx0XHRcdC8vIEV4YW1wbGUgYXNzZXQ6IGV4YW1wbGVzL21vZGVscy9vYmovY2VyYmVydXMvQ2VyYmVydXMub2JqXG5cblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdCAqIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9vYmovXG5cdFx0XHRcdFx0ICogb3Jcblx0XHRcdFx0XHQgKiBodHRwOi8vd3d3LmNzLnV0YWguZWR1L35ib3Vsb3MvY3MzNTA1L29ial9zcGVjLnBkZlxuXHRcdFx0XHRcdCAqXG5cdFx0XHRcdFx0ICogRnJvbSBjaGFwdGVyIFwiR3JvdXBpbmdcIiBTeW50YXggZXhwbGFuYXRpb24gXCJzIGdyb3VwX251bWJlclwiOlxuXHRcdFx0XHRcdCAqIFwiZ3JvdXBfbnVtYmVyIGlzIHRoZSBzbW9vdGhpbmcgZ3JvdXAgbnVtYmVyLiBUbyB0dXJuIG9mZiBzbW9vdGhpbmcgZ3JvdXBzLCB1c2UgYSB2YWx1ZSBvZiAwIG9yIG9mZi5cblx0XHRcdFx0XHQgKiBQb2x5Z29uYWwgZWxlbWVudHMgdXNlIGdyb3VwIG51bWJlcnMgdG8gcHV0IGVsZW1lbnRzIGluIGRpZmZlcmVudCBzbW9vdGhpbmcgZ3JvdXBzLiBGb3IgZnJlZS1mb3JtXG5cdFx0XHRcdFx0ICogc3VyZmFjZXMsIHNtb290aGluZyBncm91cHMgYXJlIGVpdGhlciB0dXJuZWQgb24gb3Igb2ZmOyB0aGVyZSBpcyBubyBkaWZmZXJlbmNlIGJldHdlZW4gdmFsdWVzIGdyZWF0ZXJcblx0XHRcdFx0XHQgKiB0aGFuIDAuXCJcblx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRpZiAoIHJlc3VsdC5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSByZXN1bHRbIDEgXS50cmltKCkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHN0YXRlLm9iamVjdC5zbW9vdGggPSAoIHZhbHVlICE9PSAnMCcgJiYgdmFsdWUgIT09ICdvZmYnICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBaQnJ1c2ggY2FuIHByb2R1Y2UgXCJzXCIgbGluZXMgIzExNzA3XG5cdFx0XHRcdFx0XHRzdGF0ZS5vYmplY3Quc21vb3RoID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHN0YXRlLm9iamVjdC5jdXJyZW50TWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsICkgbWF0ZXJpYWwuc21vb3RoID0gc3RhdGUub2JqZWN0LnNtb290aDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG51bGwgdGVybWluYXRlZCBmaWxlcyB3aXRob3V0IGV4Y2VwdGlvblxuXHRcdFx0XHRcdGlmICggbGluZSA9PT0gJ1xcMCcgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9CSkxvYWRlcjogVW5leHBlY3RlZCBsaW5lOiBcIicgKyBsaW5lICsgJ1wiJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRzdGF0ZS5maW5hbGl6ZSgpO1xuXG5cdFx0XHR2YXIgY29udGFpbmVyID0gbmV3IEdyb3VwKCk7XG5cdFx0XHRjb250YWluZXIubWF0ZXJpYWxMaWJyYXJpZXMgPSBbXS5jb25jYXQoIHN0YXRlLm1hdGVyaWFsTGlicmFyaWVzICk7XG5cblx0XHRcdHZhciBoYXNQcmltaXRpdmVzID0gISAoIHN0YXRlLm9iamVjdHMubGVuZ3RoID09PSAxICYmIHN0YXRlLm9iamVjdHNbIDAgXS5nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPT09IDAgKTtcblxuXHRcdFx0aWYgKCBoYXNQcmltaXRpdmVzID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHN0YXRlLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBzdGF0ZS5vYmplY3RzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBvYmplY3QubWF0ZXJpYWxzO1xuXHRcdFx0XHRcdHZhciBpc0xpbmUgPSAoIGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lJyApO1xuXHRcdFx0XHRcdHZhciBpc1BvaW50cyA9ICggZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50cycgKTtcblx0XHRcdFx0XHR2YXIgaGFzVmVydGV4Q29sb3JzID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBTa2lwIG8vZyBsaW5lIGRlY2xhcmF0aW9ucyB0aGF0IGRpZCBub3QgZm9sbG93IHdpdGggYW55IGZhY2VzXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdHZhciBidWZmZXJnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5ub3JtYWxzLCAzICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdGhhc1ZlcnRleENvbG9ycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMsIDMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5oYXNVVkluZGljZXMgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnV2cywgMiApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxzXG5cblx0XHRcdFx0XHR2YXIgY3JlYXRlZE1hdGVyaWFscyA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIG1pID0gMCwgbWlMZW4gPSBtYXRlcmlhbHMubGVuZ3RoOyBtaSA8IG1pTGVuOyBtaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZU1hdGVyaWFsID0gbWF0ZXJpYWxzWyBtaSBdO1xuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsSGFzaCA9IHNvdXJjZU1hdGVyaWFsLm5hbWUgKyAnXycgKyBzb3VyY2VNYXRlcmlhbC5zbW9vdGggKyAnXycgKyBoYXNWZXJ0ZXhDb2xvcnM7XG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBzdGF0ZS5tYXRlcmlhbHNbIG1hdGVyaWFsSGFzaCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHMuY3JlYXRlKCBzb3VyY2VNYXRlcmlhbC5uYW1lICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbXRsIGV0Yy4gbG9hZGVycyBwcm9iYWJseSBjYW4ndCBjcmVhdGUgbGluZSBtYXRlcmlhbHMgY29ycmVjdGx5LCBjb3B5IHByb3BlcnRpZXMgdG8gYSBsaW5lIG1hdGVyaWFsLlxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzTGluZSAmJiBtYXRlcmlhbCAmJiAhICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBMaW5lQmFzaWNNYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsTGluZSA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXHRcdFx0XHRcdFx0XHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIG1hdGVyaWFsTGluZSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbExpbmUuY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsTGluZTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpc1BvaW50cyAmJiBtYXRlcmlhbCAmJiAhICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBQb2ludHNNYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsUG9pbnRzID0gbmV3IFBvaW50c01hdGVyaWFsKCB7IHNpemU6IDEwLCBzaXplQXR0ZW51YXRpb246IGZhbHNlIH0gKTtcblx0XHRcdFx0XHRcdFx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCBtYXRlcmlhbFBvaW50cywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbFBvaW50cy5jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsUG9pbnRzLm1hcCA9IG1hdGVyaWFsLm1hcDtcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsUG9pbnRzO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpc0xpbmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzUG9pbnRzICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMSwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSB9ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm5hbWUgPSBzb3VyY2VNYXRlcmlhbC5uYW1lO1xuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5mbGF0U2hhZGluZyA9IHNvdXJjZU1hdGVyaWFsLnNtb290aCA/IGZhbHNlIDogdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gaGFzVmVydGV4Q29sb3JzO1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLm1hdGVyaWFsc1sgbWF0ZXJpYWxIYXNoIF0gPSBtYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjcmVhdGVkTWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgbWVzaFxuXG5cdFx0XHRcdFx0dmFyIG1lc2g7XG5cblx0XHRcdFx0XHRpZiAoIGNyZWF0ZWRNYXRlcmlhbHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG1pID0gMCwgbWlMZW4gPSBtYXRlcmlhbHMubGVuZ3RoOyBtaSA8IG1pTGVuOyBtaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc291cmNlTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIG1pIF07XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEdyb3VwKCBzb3VyY2VNYXRlcmlhbC5ncm91cFN0YXJ0LCBzb3VyY2VNYXRlcmlhbC5ncm91cENvdW50LCBtaSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggaXNMaW5lICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFscyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpc1BvaW50cyApIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IFBvaW50cyggYnVmZmVyZ2VvbWV0cnksIGNyZWF0ZWRNYXRlcmlhbHMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRtZXNoID0gbmV3IE1lc2goIGJ1ZmZlcmdlb21ldHJ5LCBjcmVhdGVkTWF0ZXJpYWxzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNMaW5lICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFsc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGlzUG9pbnRzICkge1xuXG5cdFx0XHRcdFx0XHRcdG1lc2ggPSBuZXcgUG9pbnRzKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFsc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBNZXNoKCBidWZmZXJnZW9tZXRyeSwgY3JlYXRlZE1hdGVyaWFsc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1lc2gubmFtZSA9IG9iamVjdC5uYW1lO1xuXG5cdFx0XHRcdFx0Y29udGFpbmVyLmFkZCggbWVzaCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IHRoZSBkZWZhdWx0IHBhcnNlciBzdGF0ZSBvYmplY3Qgd2l0aCBubyBnZW9tZXRyeSBkYXRhLCBpbnRlcnByZXQgZGF0YSBhcyBwb2ludCBjbG91ZFxuXG5cdFx0XHRcdGlmICggc3RhdGUudmVydGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBzaXplOiAxLCBzaXplQXR0ZW51YXRpb246IGZhbHNlIH0gKTtcblxuXHRcdFx0XHRcdHZhciBidWZmZXJnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggc3RhdGUudmVydGljZXMsIDMgKSApO1xuXG5cdFx0XHRcdFx0aWYgKCBzdGF0ZS5jb2xvcnMubGVuZ3RoID4gMCAmJiBzdGF0ZS5jb2xvcnNbIDAgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBzdGF0ZS5jb2xvcnMsIDMgKSApO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBwb2ludHMgPSBuZXcgUG9pbnRzKCBidWZmZXJnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRjb250YWluZXIuYWRkKCBwb2ludHMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbnRhaW5lcjtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0cmV0dXJuIE9CSkxvYWRlcjtcblxufSApKCk7XG5cbi8qKlxuICogTG9hZHMgYSBXYXZlZnJvbnQgLm10bCBmaWxlIHNwZWNpZnlpbmcgbWF0ZXJpYWxzXG4gKi9cblxudmFyIE1UTExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHRMb2FkZXIkMS5jYWxsKCB0aGlzLCBtYW5hZ2VyICk7XG5cbn07XG5cbk1UTExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMb2FkZXIkMS5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBNVExMb2FkZXIsXG5cblx0LyoqXG5cdCAqIExvYWRzIGFuZCBwYXJzZXMgYSBNVEwgYXNzZXQgZnJvbSBhIFVSTC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFVSTCB0byB0aGUgTVRMIGZpbGUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxvYWRdIC0gQ2FsbGJhY2sgaW52b2tlZCB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25Qcm9ncmVzc10gLSBDYWxsYmFjayBmb3IgZG93bmxvYWQgcHJvZ3Jlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSAtIENhbGxiYWNrIGZvciBkb3dubG9hZCBlcnJvcnMuXG5cdCAqXG5cdCAqIEBzZWUgc2V0UGF0aCBzZXRSZXNvdXJjZVBhdGhcblx0ICpcblx0ICogQG5vdGUgSW4gb3JkZXIgZm9yIHJlbGF0aXZlIHRleHR1cmUgcmVmZXJlbmNlcyB0byByZXNvbHZlIGNvcnJlY3RseVxuXHQgKiB5b3UgbXVzdCBjYWxsIHNldFJlc291cmNlUGF0aCgpIGV4cGxpY2l0bHkgcHJpb3IgdG8gbG9hZC5cblx0ICovXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIHBhdGggPSAoIHRoaXMucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHRoaXMucGF0aDtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCB0aGlzLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0LCBwYXRoICkgKTtcblxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0aWYgKCBvbkVycm9yICkge1xuXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0TWF0ZXJpYWxPcHRpb25zOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5tYXRlcmlhbE9wdGlvbnMgPSB2YWx1ZTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBNVEwgZmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgLSBDb250ZW50IG9mIE1UTCBmaWxlXG5cdCAqIEByZXR1cm4ge01UTExvYWRlci5NYXRlcmlhbENyZWF0b3J9XG5cdCAqXG5cdCAqIEBzZWUgc2V0UGF0aCBzZXRSZXNvdXJjZVBhdGhcblx0ICpcblx0ICogQG5vdGUgSW4gb3JkZXIgZm9yIHJlbGF0aXZlIHRleHR1cmUgcmVmZXJlbmNlcyB0byByZXNvbHZlIGNvcnJlY3RseVxuXHQgKiB5b3UgbXVzdCBjYWxsIHNldFJlc291cmNlUGF0aCgpIGV4cGxpY2l0bHkgcHJpb3IgdG8gcGFyc2UuXG5cdCAqL1xuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0LCBwYXRoICkge1xuXG5cdFx0dmFyIGxpbmVzID0gdGV4dC5zcGxpdCggJ1xcbicgKTtcblx0XHR2YXIgaW5mbyA9IHt9O1xuXHRcdHZhciBkZWxpbWl0ZXJfcGF0dGVybiA9IC9cXHMrLztcblx0XHR2YXIgbWF0ZXJpYWxzSW5mbyA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XG5cdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cblx0XHRcdGlmICggbGluZS5sZW5ndGggPT09IDAgfHwgbGluZS5jaGFyQXQoIDAgKSA9PT0gJyMnICkge1xuXG5cdFx0XHRcdC8vIEJsYW5rIGxpbmUgb3IgY29tbWVudCBpZ25vcmVcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvcyA9IGxpbmUuaW5kZXhPZiggJyAnICk7XG5cblx0XHRcdHZhciBrZXkgPSAoIHBvcyA+PSAwICkgPyBsaW5lLnN1YnN0cmluZyggMCwgcG9zICkgOiBsaW5lO1xuXHRcdFx0a2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdHZhciB2YWx1ZSA9ICggcG9zID49IDAgKSA/IGxpbmUuc3Vic3RyaW5nKCBwb3MgKyAxICkgOiAnJztcblx0XHRcdHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXG5cdFx0XHRpZiAoIGtleSA9PT0gJ25ld210bCcgKSB7XG5cblx0XHRcdFx0Ly8gTmV3IG1hdGVyaWFsXG5cblx0XHRcdFx0aW5mbyA9IHsgbmFtZTogdmFsdWUgfTtcblx0XHRcdFx0bWF0ZXJpYWxzSW5mb1sgdmFsdWUgXSA9IGluZm87XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKCBrZXkgPT09ICdrYScgfHwga2V5ID09PSAna2QnIHx8IGtleSA9PT0gJ2tzJyB8fCBrZXkgPT09ICdrZScgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3MgPSB2YWx1ZS5zcGxpdCggZGVsaW1pdGVyX3BhdHRlcm4sIDMgKTtcblx0XHRcdFx0XHRpbmZvWyBrZXkgXSA9IFsgcGFyc2VGbG9hdCggc3NbIDAgXSApLCBwYXJzZUZsb2F0KCBzc1sgMSBdICksIHBhcnNlRmxvYXQoIHNzWyAyIF0gKSBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmZvWyBrZXkgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIG1hdGVyaWFsQ3JlYXRvciA9IG5ldyBNVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yKCB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoLCB0aGlzLm1hdGVyaWFsT3B0aW9ucyApO1xuXHRcdG1hdGVyaWFsQ3JlYXRvci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdG1hdGVyaWFsQ3JlYXRvci5zZXRNYW5hZ2VyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRtYXRlcmlhbENyZWF0b3Iuc2V0TWF0ZXJpYWxzKCBtYXRlcmlhbHNJbmZvICk7XG5cdFx0cmV0dXJuIG1hdGVyaWFsQ3JlYXRvcjtcblxuXHR9XG5cbn0gKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvclxuICogQHBhcmFtIGJhc2VVcmwgLSBVcmwgcmVsYXRpdmUgdG8gd2hpY2ggdGV4dHVyZXMgYXJlIGxvYWRlZFxuICogQHBhcmFtIG9wdGlvbnMgLSBTZXQgb2Ygb3B0aW9ucyBvbiBob3cgdG8gY29uc3RydWN0IHRoZSBtYXRlcmlhbHNcbiAqICAgICAgICAgICAgICAgICAgc2lkZTogV2hpY2ggc2lkZSB0byBhcHBseSB0aGUgbWF0ZXJpYWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgRnJvbnRTaWRlIChkZWZhdWx0KSwgVEhSRUUuQmFja1NpZGUsIFRIUkVFLkRvdWJsZVNpZGVcbiAqICAgICAgICAgICAgICAgICAgd3JhcDogV2hhdCB0eXBlIG9mIHdyYXBwaW5nIHRvIGFwcGx5IGZvciB0ZXh0dXJlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBSZXBlYXRXcmFwcGluZyAoZGVmYXVsdCksIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcsIFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcbiAqICAgICAgICAgICAgICAgICAgbm9ybWFsaXplUkdCOiBSR0JzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byAwLTEgZnJvbSAwLTI1NVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHQ6IGZhbHNlLCBhc3N1bWVkIHRvIGJlIGFscmVhZHkgbm9ybWFsaXplZFxuICogICAgICAgICAgICAgICAgICBpZ25vcmVaZXJvUkdCczogSWdub3JlIHZhbHVlcyBvZiBSR0JzIChLYSxLZCxLcykgdGhhdCBhcmUgYWxsIDAnc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogZmFsc2VcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IgPSBmdW5jdGlvbiAoIGJhc2VVcmwsIG9wdGlvbnMgKSB7XG5cblx0dGhpcy5iYXNlVXJsID0gYmFzZVVybCB8fCAnJztcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5tYXRlcmlhbHNJbmZvID0ge307XG5cdHRoaXMubWF0ZXJpYWxzID0ge307XG5cdHRoaXMubWF0ZXJpYWxzQXJyYXkgPSBbXTtcblx0dGhpcy5uYW1lTG9va3VwID0ge307XG5cblx0dGhpcy5zaWRlID0gKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNpZGUgKSA/IHRoaXMub3B0aW9ucy5zaWRlIDogRnJvbnRTaWRlO1xuXHR0aGlzLndyYXAgPSAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMud3JhcCApID8gdGhpcy5vcHRpb25zLndyYXAgOiBSZXBlYXRXcmFwcGluZztcblxufTtcblxuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IE1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IsXG5cblx0Y3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0TWFuYWdlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFsc0luZm8gPSB0aGlzLmNvbnZlcnQoIG1hdGVyaWFsc0luZm8gKTtcblx0XHR0aGlzLm1hdGVyaWFscyA9IHt9O1xuXHRcdHRoaXMubWF0ZXJpYWxzQXJyYXkgPSBbXTtcblx0XHR0aGlzLm5hbWVMb29rdXAgPSB7fTtcblxuXHR9LFxuXG5cdGNvbnZlcnQ6IGZ1bmN0aW9uICggbWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdGlmICggISB0aGlzLm9wdGlvbnMgKSByZXR1cm4gbWF0ZXJpYWxzSW5mbztcblxuXHRcdHZhciBjb252ZXJ0ZWQgPSB7fTtcblxuXHRcdGZvciAoIHZhciBtbiBpbiBtYXRlcmlhbHNJbmZvICkge1xuXG5cdFx0XHQvLyBDb252ZXJ0IG1hdGVyaWFscyBpbmZvIGludG8gbm9ybWFsaXplZCBmb3JtIGJhc2VkIG9uIG9wdGlvbnNcblxuXHRcdFx0dmFyIG1hdCA9IG1hdGVyaWFsc0luZm9bIG1uIF07XG5cblx0XHRcdHZhciBjb3ZtYXQgPSB7fTtcblxuXHRcdFx0Y29udmVydGVkWyBtbiBdID0gY292bWF0O1xuXG5cdFx0XHRmb3IgKCB2YXIgcHJvcCBpbiBtYXQgKSB7XG5cblx0XHRcdFx0dmFyIHNhdmUgPSB0cnVlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRbIHByb3AgXTtcblx0XHRcdFx0dmFyIGxwcm9wID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGxwcm9wICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAna2QnOlxuXHRcdFx0XHRcdGNhc2UgJ2thJzpcblx0XHRcdFx0XHRjYXNlICdrcyc6XG5cblx0XHRcdFx0XHRcdC8vIERpZmZ1c2UgY29sb3IgKGNvbG9yIHVuZGVyIHdoaXRlIGxpZ2h0KSB1c2luZyBSR0IgdmFsdWVzXG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5ub3JtYWxpemVSR0IgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBbIHZhbHVlWyAwIF0gLyAyNTUsIHZhbHVlWyAxIF0gLyAyNTUsIHZhbHVlWyAyIF0gLyAyNTUgXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaWdub3JlWmVyb1JHQnMgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZVsgMCBdID09PSAwICYmIHZhbHVlWyAxIF0gPT09IDAgJiYgdmFsdWVbIDIgXSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGlnbm9yZVxuXG5cdFx0XHRcdFx0XHRcdFx0c2F2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzYXZlICkge1xuXG5cdFx0XHRcdFx0Y292bWF0WyBscHJvcCBdID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydGVkO1xuXG5cdH0sXG5cblx0cHJlbG9hZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Zm9yICggdmFyIG1uIGluIHRoaXMubWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdFx0dGhpcy5jcmVhdGUoIG1uICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5uYW1lTG9va3VwWyBtYXRlcmlhbE5hbWUgXTtcblxuXHR9LFxuXG5cdGdldEFzQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgbW4gaW4gdGhpcy5tYXRlcmlhbHNJbmZvICkge1xuXG5cdFx0XHR0aGlzLm1hdGVyaWFsc0FycmF5WyBpbmRleCBdID0gdGhpcy5jcmVhdGUoIG1uICk7XG5cdFx0XHR0aGlzLm5hbWVMb29rdXBbIG1uIF0gPSBpbmRleDtcblx0XHRcdGluZGV4ICsrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzQXJyYXk7XG5cblx0fSxcblxuXHRjcmVhdGU6IGZ1bmN0aW9uICggbWF0ZXJpYWxOYW1lICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsc1sgbWF0ZXJpYWxOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5jcmVhdGVNYXRlcmlhbF8oIG1hdGVyaWFsTmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXTtcblxuXHR9LFxuXG5cdGNyZWF0ZU1hdGVyaWFsXzogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XG5cblx0XHQvLyBDcmVhdGUgbWF0ZXJpYWxcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0dmFyIG1hdCA9IHRoaXMubWF0ZXJpYWxzSW5mb1sgbWF0ZXJpYWxOYW1lIF07XG5cdFx0dmFyIHBhcmFtcyA9IHtcblxuXHRcdFx0bmFtZTogbWF0ZXJpYWxOYW1lLFxuXHRcdFx0c2lkZTogdGhpcy5zaWRlXG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVVSTCggYmFzZVVybCwgdXJsICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycgKVxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cblx0XHRcdC8vIEFic29sdXRlIFVSTFxuXHRcdFx0aWYgKCAvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KCB1cmwgKSApIHJldHVybiB1cmw7XG5cblx0XHRcdHJldHVybiBiYXNlVXJsICsgdXJsO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2V0TWFwRm9yVHlwZSggbWFwVHlwZSwgdmFsdWUgKSB7XG5cblx0XHRcdGlmICggcGFyYW1zWyBtYXBUeXBlIF0gKSByZXR1cm47IC8vIEtlZXAgdGhlIGZpcnN0IGVuY291bnRlcmVkIHRleHR1cmVcblxuXHRcdFx0dmFyIHRleFBhcmFtcyA9IHNjb3BlLmdldFRleHR1cmVQYXJhbXMoIHZhbHVlLCBwYXJhbXMgKTtcblx0XHRcdHZhciBtYXAgPSBzY29wZS5sb2FkVGV4dHVyZSggcmVzb2x2ZVVSTCggc2NvcGUuYmFzZVVybCwgdGV4UGFyYW1zLnVybCApICk7XG5cblx0XHRcdG1hcC5yZXBlYXQuY29weSggdGV4UGFyYW1zLnNjYWxlICk7XG5cdFx0XHRtYXAub2Zmc2V0LmNvcHkoIHRleFBhcmFtcy5vZmZzZXQgKTtcblxuXHRcdFx0bWFwLndyYXBTID0gc2NvcGUud3JhcDtcblx0XHRcdG1hcC53cmFwVCA9IHNjb3BlLndyYXA7XG5cblx0XHRcdHBhcmFtc1sgbWFwVHlwZSBdID0gbWFwO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSBtYXRbIHByb3AgXTtcblx0XHRcdHZhciBuO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBwcm9wLnRvTG93ZXJDYXNlKCkgKSB7XG5cblx0XHRcdFx0Ly8gTnMgaXMgbWF0ZXJpYWwgc3BlY3VsYXIgZXhwb25lbnRcblxuXHRcdFx0XHRjYXNlICdrZCc6XG5cblx0XHRcdFx0XHQvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xuXG5cdFx0XHRcdFx0cGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAna3MnOlxuXG5cdFx0XHRcdFx0Ly8gU3BlY3VsYXIgY29sb3IgKGNvbG9yIHdoZW4gbGlnaHQgaXMgcmVmbGVjdGVkIGZyb20gc2hpbnkgc3VyZmFjZSkgdXNpbmcgUkdCIHZhbHVlc1xuXHRcdFx0XHRcdHBhcmFtcy5zcGVjdWxhciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2tlJzpcblxuXHRcdFx0XHRcdC8vIEVtaXNzaXZlIHVzaW5nIFJHQiB2YWx1ZXNcblx0XHRcdFx0XHRwYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfa2QnOlxuXG5cdFx0XHRcdFx0Ly8gRGlmZnVzZSB0ZXh0dXJlIG1hcFxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ21hcCcsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfa3MnOlxuXG5cdFx0XHRcdFx0Ly8gU3BlY3VsYXIgbWFwXG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnc3BlY3VsYXJNYXAnLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwX2tlJzpcblxuXHRcdFx0XHRcdC8vIEVtaXNzaXZlIG1hcFxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ2VtaXNzaXZlTWFwJywgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ25vcm0nOlxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ25vcm1hbE1hcCcsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfYnVtcCc6XG5cdFx0XHRcdGNhc2UgJ2J1bXAnOlxuXG5cdFx0XHRcdFx0Ly8gQnVtcCB0ZXh0dXJlIG1hcFxuXG5cdFx0XHRcdFx0c2V0TWFwRm9yVHlwZSggJ2J1bXBNYXAnLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFwX2QnOlxuXG5cdFx0XHRcdFx0Ly8gQWxwaGEgbWFwXG5cblx0XHRcdFx0XHRzZXRNYXBGb3JUeXBlKCAnYWxwaGFNYXAnLCB2YWx1ZSApO1xuXHRcdFx0XHRcdHBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICducyc6XG5cblx0XHRcdFx0XHQvLyBUaGUgc3BlY3VsYXIgZXhwb25lbnQgKGRlZmluZXMgdGhlIGZvY3VzIG9mIHRoZSBzcGVjdWxhciBoaWdobGlnaHQpXG5cdFx0XHRcdFx0Ly8gQSBoaWdoIGV4cG9uZW50IHJlc3VsdHMgaW4gYSB0aWdodCwgY29uY2VudHJhdGVkIGhpZ2hsaWdodC4gTnMgdmFsdWVzIG5vcm1hbGx5IHJhbmdlIGZyb20gMCB0byAxMDAwLlxuXG5cdFx0XHRcdFx0cGFyYW1zLnNoaW5pbmVzcyA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRuID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdGlmICggbiA8IDEgKSB7XG5cblx0XHRcdFx0XHRcdHBhcmFtcy5vcGFjaXR5ID0gbjtcblx0XHRcdFx0XHRcdHBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cic6XG5cdFx0XHRcdFx0biA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW52ZXJ0VHJQcm9wZXJ0eSApIG4gPSAxIC0gbjtcblxuXHRcdFx0XHRcdGlmICggbiA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdHBhcmFtcy5vcGFjaXR5ID0gMSAtIG47XG5cdFx0XHRcdFx0XHRwYXJhbXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXSA9IG5ldyBNZXNoUGhvbmdNYXRlcmlhbCggcGFyYW1zICk7XG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXTtcblxuXHR9LFxuXG5cdGdldFRleHR1cmVQYXJhbXM6IGZ1bmN0aW9uICggdmFsdWUsIG1hdFBhcmFtcyApIHtcblxuXHRcdHZhciB0ZXhQYXJhbXMgPSB7XG5cblx0XHRcdHNjYWxlOiBuZXcgVmVjdG9yMiggMSwgMSApLFxuXHRcdFx0b2Zmc2V0OiBuZXcgVmVjdG9yMiggMCwgMCApXG5cblx0XHQgfTtcblxuXHRcdHZhciBpdGVtcyA9IHZhbHVlLnNwbGl0KCAvXFxzKy8gKTtcblx0XHR2YXIgcG9zO1xuXG5cdFx0cG9zID0gaXRlbXMuaW5kZXhPZiggJy1ibScgKTtcblxuXHRcdGlmICggcG9zID49IDAgKSB7XG5cblx0XHRcdG1hdFBhcmFtcy5idW1wU2NhbGUgPSBwYXJzZUZsb2F0KCBpdGVtc1sgcG9zICsgMSBdICk7XG5cdFx0XHRpdGVtcy5zcGxpY2UoIHBvcywgMiApO1xuXG5cdFx0fVxuXG5cdFx0cG9zID0gaXRlbXMuaW5kZXhPZiggJy1zJyApO1xuXG5cdFx0aWYgKCBwb3MgPj0gMCApIHtcblxuXHRcdFx0dGV4UGFyYW1zLnNjYWxlLnNldCggcGFyc2VGbG9hdCggaXRlbXNbIHBvcyArIDEgXSApLCBwYXJzZUZsb2F0KCBpdGVtc1sgcG9zICsgMiBdICkgKTtcblx0XHRcdGl0ZW1zLnNwbGljZSggcG9zLCA0ICk7IC8vIHdlIGV4cGVjdCAzIHBhcmFtZXRlcnMgaGVyZSFcblxuXHRcdH1cblxuXHRcdHBvcyA9IGl0ZW1zLmluZGV4T2YoICctbycgKTtcblxuXHRcdGlmICggcG9zID49IDAgKSB7XG5cblx0XHRcdHRleFBhcmFtcy5vZmZzZXQuc2V0KCBwYXJzZUZsb2F0KCBpdGVtc1sgcG9zICsgMSBdICksIHBhcnNlRmxvYXQoIGl0ZW1zWyBwb3MgKyAyIF0gKSApO1xuXHRcdFx0aXRlbXMuc3BsaWNlKCBwb3MsIDQgKTsgLy8gd2UgZXhwZWN0IDMgcGFyYW1ldGVycyBoZXJlIVxuXG5cdFx0fVxuXG5cdFx0dGV4UGFyYW1zLnVybCA9IGl0ZW1zLmpvaW4oICcgJyApLnRyaW0oKTtcblx0XHRyZXR1cm4gdGV4UGFyYW1zO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgdGV4dHVyZTtcblx0XHR2YXIgbWFuYWdlciA9ICggdGhpcy5tYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IHRoaXMubWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0XHR2YXIgbG9hZGVyID0gbWFuYWdlci5nZXRIYW5kbGVyKCB1cmwgKTtcblxuXHRcdGlmICggbG9hZGVyID09PSBudWxsICkge1xuXG5cdFx0XHRsb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggbWFuYWdlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4gKSBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHRpZiAoIG1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9XG5cbn07XG5cbi8qISBjaGV2cm90YWluIC0gdjQuNi4wICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImNoZXZyb3RhaW5cIixbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmNoZXZyb3RhaW49ZSgpOnQuY2hldnJvdGFpbj1lKCk7fShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnVuZGVmaW5lZCxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgZT17fTtmdW5jdGlvbiBuKHIpe2lmKGVbcl0pcmV0dXJuIGVbcl0uZXhwb3J0czt2YXIgaT1lW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiBuLm09dCxuLmM9ZSxuLmQ9ZnVuY3Rpb24odCxlLHIpe24ubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtlbnVtZXJhYmxlOiEwLGdldDpyfSk7fSxuLnI9ZnVuY3Rpb24odCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt9LG4udD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9bih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgcj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG4ucihyKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGkgaW4gdCluLmQocixpLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsaSkpO3JldHVybiByfSxuLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIG4uZChlLFwiYVwiLGUpLGV9LG4ubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sbi5wPVwiXCIsbihuLnM9MTgpfShbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuIHQmJjA9PT10Lmxlbmd0aH1mdW5jdGlvbiBpKHQpe3JldHVybiBudWxsPT10P1tdOk9iamVjdC5rZXlzKHQpfWZ1bmN0aW9uIG8odCl7Zm9yKHZhciBlPVtdLG49T2JqZWN0LmtleXModCkscj0wO3I8bi5sZW5ndGg7cisrKWUucHVzaCh0W25bcl1dKTtyZXR1cm4gZX1mdW5jdGlvbiBhKHQsZSl7Zm9yKHZhciBuPVtdLHI9aSh0KSxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBhPXJbb107bi5wdXNoKGUuY2FsbChudWxsLHRbYV0sYSkpO31yZXR1cm4gbn1mdW5jdGlvbiBzKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPHQubGVuZ3RoO3IrKyluLnB1c2goZS5jYWxsKG51bGwsdFtyXSxyKSk7cmV0dXJuIG59ZnVuY3Rpb24gdSh0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO0FycmF5LmlzQXJyYXkocik/ZT1lLmNvbmNhdCh1KHIpKTplLnB1c2gocik7fXJldHVybiBlfWZ1bmN0aW9uIGModCl7cmV0dXJuIHIodCk/dm9pZCAwOnRbMF19ZnVuY3Rpb24gcCh0KXt2YXIgZT10JiZ0Lmxlbmd0aDtyZXR1cm4gZT90W2UtMV06dm9pZCAwfWZ1bmN0aW9uIGwodCxlKXtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWUuY2FsbChudWxsLHRbbl0sbik7ZWxzZSB7aWYoIUModCkpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTt2YXIgcj1pKHQpO2ZvcihuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBvPXJbbl0sYT10W29dO2UuY2FsbChudWxsLGEsbyk7fX19ZnVuY3Rpb24gaCh0KXtyZXR1cm4gXCJzdHJpbmdcIj09dHlwZW9mIHR9ZnVuY3Rpb24gZih0KXtyZXR1cm4gdm9pZCAwPT09dH1mdW5jdGlvbiBkKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRnVuY3Rpb259ZnVuY3Rpb24gRSh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0xKSx0LnNsaWNlKGUsdC5sZW5ndGgpfWZ1bmN0aW9uIG0odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MSksdC5zbGljZSgwLHQubGVuZ3RoLWUpfWZ1bmN0aW9uIHkodCxlKXt2YXIgbj1bXTtpZihBcnJheS5pc0FycmF5KHQpKWZvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgaT10W3JdO2UuY2FsbChudWxsLGkpJiZuLnB1c2goaSk7fXJldHVybiBufWZ1bmN0aW9uIFQodCxlKXtyZXR1cm4geSh0LGZ1bmN0aW9uKHQpe3JldHVybiAhZSh0KX0pfWZ1bmN0aW9uIHYodCxlKXtmb3IodmFyIG49T2JqZWN0LmtleXModCkscj17fSxpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciBvPW5baV0sYT10W29dO2UoYSkmJihyW29dPWEpO31yZXR1cm4gcn1mdW5jdGlvbiBnKHQsZSl7cmV0dXJuICEhQyh0KSYmdC5oYXNPd25Qcm9wZXJ0eShlKX1mdW5jdGlvbiBfKHQsZSl7cmV0dXJuIHZvaWQgMCE9PU4odCxmdW5jdGlvbih0KXtyZXR1cm4gdD09PWV9KX1mdW5jdGlvbiBSKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5wdXNoKHRbbl0pO3JldHVybiBlfWZ1bmN0aW9uIEEodCl7dmFyIGU9e307Zm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pO3JldHVybiBlfWZ1bmN0aW9uIE4odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtpZihlLmNhbGwobnVsbCxyKSlyZXR1cm4gcn19ZnVuY3Rpb24gTyh0LGUpe2Zvcih2YXIgbj1bXSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl07ZS5jYWxsKG51bGwsaSkmJm4ucHVzaChpKTt9cmV0dXJuIG59ZnVuY3Rpb24gUyh0LGUsbil7Zm9yKHZhciByPUFycmF5LmlzQXJyYXkodCksYT1yP3Q6byh0KSxzPXI/W106aSh0KSx1PW4sYz0wO2M8YS5sZW5ndGg7YysrKXU9ZS5jYWxsKG51bGwsdSxhW2NdLHI/YzpzW2NdKTtyZXR1cm4gdX1mdW5jdGlvbiBJKHQpe3JldHVybiBUKHQsZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9KX1mdW5jdGlvbiBMKHQsZSl7dm9pZCAwPT09ZSYmKGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9KTt2YXIgbj1bXTtyZXR1cm4gUyh0LGZ1bmN0aW9uKHQscil7dmFyIGk9ZShyKTtyZXR1cm4gXyhuLGkpP3Q6KG4ucHVzaChpKSx0LmNvbmNhdChyKSl9LFtdKX1mdW5jdGlvbiBrKHQpe2Zvcih2YXIgZT1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyllW24tMV09YXJndW1lbnRzW25dO3ZhciByPVtudWxsXS5jb25jYXQoZSk7cmV0dXJuIEZ1bmN0aW9uLmJpbmQuYXBwbHkodCxyKX1mdW5jdGlvbiBQKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfWZ1bmN0aW9uIHgodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBSZWdFeHB9ZnVuY3Rpb24gQyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIE9iamVjdH1mdW5jdGlvbiBNKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIWUodFtuXSxuKSlyZXR1cm4gITE7cmV0dXJuICEwfWZ1bmN0aW9uIEYodCxlKXtyZXR1cm4gVCh0LGZ1bmN0aW9uKHQpe3JldHVybiBfKGUsdCl9KX1mdW5jdGlvbiBiKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoZSh0W25dKSlyZXR1cm4gITA7cmV0dXJuICExfWZ1bmN0aW9uIEQodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dPT09ZSlyZXR1cm4gbjtyZXR1cm4gLTF9ZnVuY3Rpb24gdyh0LGUpe3ZhciBuPVIodCk7cmV0dXJuIG4uc29ydChmdW5jdGlvbih0LG4pe3JldHVybiBlKHQpLWUobil9KSxufWZ1bmN0aW9uIFUodCxlKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IEVycm9yKFwiY2FuJ3QgemlwT2JqZWN0IHdpdGggZGlmZmVyZW50IG51bWJlciBvZiBrZXlzIGFuZCB2YWx1ZXMhXCIpO2Zvcih2YXIgbj17fSxyPTA7cjx0Lmxlbmd0aDtyKyspblt0W3JdXT1lW3JdO3JldHVybiBufWZ1bmN0aW9uIEcodCl7Zm9yKHZhciBlPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbi0xXT1hcmd1bWVudHNbbl07Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspZm9yKHZhciBvPWVbcl0sYT1pKG8pLHM9MDtzPGEubGVuZ3RoO3MrKyl7dmFyIHU9YVtzXTt0W3VdPW9bdV07fXJldHVybiB0fWZ1bmN0aW9uIEIodCl7Zm9yKHZhciBlPVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbi0xXT1hcmd1bWVudHNbbl07Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBvPWVbcl07aWYoIWYobykpZm9yKHZhciBhPWkobykscz0wO3M8YS5sZW5ndGg7cysrKXt2YXIgdT1hW3NdO2codCx1KXx8KHRbdV09b1t1XSk7fX1yZXR1cm4gdH1mdW5jdGlvbiBLKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO3JldHVybiBCLmFwcGx5KG51bGwsW3t9XS5jb25jYXQodCkpfWZ1bmN0aW9uIFcodCxlKXt2YXIgbj17fTtyZXR1cm4gbCh0LGZ1bmN0aW9uKHQpe3ZhciByPWUodCksaT1uW3JdO2k/aS5wdXNoKHQpOm5bcl09W3RdO30pLG59ZnVuY3Rpb24gaih0LGUpe2Zvcih2YXIgbj1BKHQpLHI9aShlKSxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBhPXJbb10scz1lW2FdO25bYV09czt9cmV0dXJuIG59ZnVuY3Rpb24gVigpe31mdW5jdGlvbiBZKHQpe3JldHVybiB0fWZ1bmN0aW9uIEgodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtlLnB1c2godm9pZCAwIT09cj9yOnZvaWQgMCk7fXJldHVybiBlfWZ1bmN0aW9uIFgodCl7Y29uc29sZSYmY29uc29sZS5lcnJvciYmY29uc29sZS5lcnJvcihcIkVycm9yOiBcIit0KTt9ZnVuY3Rpb24geih0KXtjb25zb2xlJiZjb25zb2xlLndhcm4mJmNvbnNvbGUud2FybihcIldhcm5pbmc6IFwiK3QpO31mdW5jdGlvbiBxKCl7cmV0dXJuIFwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcH1mdW5jdGlvbiAkKHQsZSl7ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWUucHJvdG90eXBlO09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG4pLmZvckVhY2goZnVuY3Rpb24ocil7aWYoXCJjb25zdHJ1Y3RvclwiIT09cil7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHIpO2kmJihpLmdldHx8aS5zZXQpP09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxyLGkpOnQucHJvdG90eXBlW3JdPWUucHJvdG90eXBlW3JdO319KTt9KTt9ZnVuY3Rpb24gWih0KXtmdW5jdGlvbiBlKCl7fWUucHJvdG90eXBlPXQ7dmFyIG49bmV3IGU7ZnVuY3Rpb24gcigpe3JldHVybiB0eXBlb2Ygbi5iYXJ9cmV0dXJuIHIoKSxyKCksdH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmlzRW1wdHk9cixlLmtleXM9aSxlLnZhbHVlcz1vLGUubWFwVmFsdWVzPWEsZS5tYXA9cyxlLmZsYXR0ZW49dSxlLmZpcnN0PWMsZS5sYXN0PXAsZS5mb3JFYWNoPWwsZS5pc1N0cmluZz1oLGUuaXNVbmRlZmluZWQ9ZixlLmlzRnVuY3Rpb249ZCxlLmRyb3A9RSxlLmRyb3BSaWdodD1tLGUuZmlsdGVyPXksZS5yZWplY3Q9VCxlLnBpY2s9dixlLmhhcz1nLGUuY29udGFpbnM9XyxlLmNsb25lQXJyPVIsZS5jbG9uZU9iaj1BLGUuZmluZD1OLGUuZmluZEFsbD1PLGUucmVkdWNlPVMsZS5jb21wYWN0PUksZS51bmlxPUwsZS5wYXJ0aWFsPWssZS5pc0FycmF5PVAsZS5pc1JlZ0V4cD14LGUuaXNPYmplY3Q9QyxlLmV2ZXJ5PU0sZS5kaWZmZXJlbmNlPUYsZS5zb21lPWIsZS5pbmRleE9mPUQsZS5zb3J0Qnk9dyxlLnppcE9iamVjdD1VLGUuYXNzaWduPUcsZS5hc3NpZ25Ob092ZXJ3cml0ZT1CLGUuZGVmYXVsdHM9SyxlLmdyb3VwQnk9VyxlLm1lcmdlPWosZS5OT09QPVYsZS5JREVOVElUWT1ZLGUucGFja0FycmF5PUgsZS5QUklOVF9FUlJPUj1YLGUuUFJJTlRfV0FSTklORz16LGUuaXNFUzIwMTVNYXBTdXBwb3J0ZWQ9cSxlLmFwcGx5TWl4aW5zPSQsZS50b0Zhc3RQcm9wZXJ0aWVzPVo7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDApLGE9bigyKSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlZmluaXRpb249dDt9cmV0dXJuIHQucHJvdG90eXBlLmFjY2VwdD1mdW5jdGlvbih0KXt0LnZpc2l0KHRoaXMpLG8uZm9yRWFjaCh0aGlzLmRlZmluaXRpb24sZnVuY3Rpb24oZSl7ZS5hY2NlcHQodCk7fSk7fSx0fSgpO2UuQWJzdHJhY3RQcm9kdWN0aW9uPXM7dmFyIHU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxbXSl8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZGVmaW5pdGlvblwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5yZWZlcmVuY2VkUnVsZT90aGlzLnJlZmVyZW5jZWRSdWxlLmRlZmluaXRpb246W119LHNldDpmdW5jdGlvbih0KXt9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKHQpe3QudmlzaXQodGhpcyk7fSxlfShzKTtlLk5vblRlcm1pbmFsPXU7dmFyIGM9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyxlLmRlZmluaXRpb24pfHx0aGlzO3JldHVybiBuLm9yZ1RleHQ9XCJcIixvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLlJ1bGU9Yzt2YXIgcD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG8uYXNzaWduKG4sby5waWNrKGUsZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSksbn1yZXR1cm4gaShlLHQpLGV9KHMpO2UuRmxhdD1wO3ZhciBsPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLk9wdGlvbj1sO3ZhciBoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLlJlcGV0aXRpb25NYW5kYXRvcnk9aDt2YXIgZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mO3ZhciBkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLlJlcGV0aXRpb249ZDt2YXIgRT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzLGUuZGVmaW5pdGlvbil8fHRoaXM7cmV0dXJuIG4uaWR4PTEsby5hc3NpZ24obixvLnBpY2soZSxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKSxufXJldHVybiBpKGUsdCksZX0ocyk7ZS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1FO3ZhciBtPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSl7dmFyIG49dC5jYWxsKHRoaXMsZS5kZWZpbml0aW9uKXx8dGhpcztyZXR1cm4gbi5pZHg9MSxvLmFzc2lnbihuLG8ucGljayhlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSkpLG59cmV0dXJuIGkoZSx0KSxlfShzKTtlLkFsdGVybmF0aW9uPW07dmFyIHk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaWR4PTEsby5hc3NpZ24odGhpcyxvLnBpY2sodCxmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pKTt9cmV0dXJuIHQucHJvdG90eXBlLmFjY2VwdD1mdW5jdGlvbih0KXt0LnZpc2l0KHRoaXMpO30sdH0oKTtmdW5jdGlvbiBUKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuIG8ubWFwKHQsVCl9aWYodCBpbnN0YW5jZW9mIHUpcmV0dXJuIHt0eXBlOlwiTm9uVGVybWluYWxcIixuYW1lOnQubm9uVGVybWluYWxOYW1lLGlkeDp0LmlkeH07aWYodCBpbnN0YW5jZW9mIHApcmV0dXJuIHt0eXBlOlwiRmxhdFwiLGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgbClyZXR1cm4ge3R5cGU6XCJPcHRpb25cIixpZHg6dC5pZHgsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBoKXJldHVybiB7dHlwZTpcIlJlcGV0aXRpb25NYW5kYXRvcnlcIixuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBmKXJldHVybiB7dHlwZTpcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIsbmFtZTp0Lm5hbWUsaWR4OnQuaWR4LHNlcGFyYXRvcjpUKG5ldyB5KHt0ZXJtaW5hbFR5cGU6dC5zZXBhcmF0b3J9KSksZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBFKXJldHVybiB7dHlwZTpcIlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yXCIsbmFtZTp0Lm5hbWUsaWR4OnQuaWR4LHNlcGFyYXRvcjpUKG5ldyB5KHt0ZXJtaW5hbFR5cGU6dC5zZXBhcmF0b3J9KSksZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBkKXJldHVybiB7dHlwZTpcIlJlcGV0aXRpb25cIixuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjplKHQuZGVmaW5pdGlvbil9O2lmKHQgaW5zdGFuY2VvZiBtKXJldHVybiB7dHlwZTpcIkFsdGVybmF0aW9uXCIsbmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246ZSh0LmRlZmluaXRpb24pfTtpZih0IGluc3RhbmNlb2YgeSl7dmFyIG49e3R5cGU6XCJUZXJtaW5hbFwiLG5hbWU6YS50b2tlbk5hbWUodC50ZXJtaW5hbFR5cGUpLGxhYmVsOmEudG9rZW5MYWJlbCh0LnRlcm1pbmFsVHlwZSksaWR4OnQuaWR4fSxyPXQudGVybWluYWxUeXBlLlBBVFRFUk47cmV0dXJuIHQudGVybWluYWxUeXBlLlBBVFRFUk4mJihuLnBhdHRlcm49by5pc1JlZ0V4cChyKT9yLnNvdXJjZTpyKSxufWlmKHQgaW5zdGFuY2VvZiBjKXJldHVybiB7dHlwZTpcIlJ1bGVcIixuYW1lOnQubmFtZSxvcmdUZXh0OnQub3JnVGV4dCxkZWZpbml0aW9uOmUodC5kZWZpbml0aW9uKX07dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1lLlRlcm1pbmFsPXksZS5zZXJpYWxpemVHcmFtbWFyPWZ1bmN0aW9uKHQpe3JldHVybiBvLm1hcCh0LFQpfSxlLnNlcmlhbGl6ZVByb2R1Y3Rpb249VDt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9big0KSxvPW4oMTUpLGE9big3KTtmdW5jdGlvbiBzKHQpe3JldHVybiByLmlzU3RyaW5nKHQuTEFCRUwpJiZcIlwiIT09dC5MQUJFTH1mdW5jdGlvbiB1KHQpe3JldHVybiByLmlzT2JqZWN0KHQpJiZ0Lmhhc093blByb3BlcnR5KFwidG9rZW5OYW1lXCIpJiZyLmlzU3RyaW5nKHQudG9rZW5OYW1lKT90LnRva2VuTmFtZTppLmZ1bmN0aW9uTmFtZSh0KX1lLnRva2VuTGFiZWw9ZnVuY3Rpb24odCl7cmV0dXJuIHModCk/dC5MQUJFTDp1KHQpfSxlLmhhc1Rva2VuTGFiZWw9cyxlLnRva2VuTmFtZT11O3ZhciBjPVwicGFyZW50XCIscD1cImNhdGVnb3JpZXNcIixsPVwibGFiZWxcIixoPVwiZ3JvdXBcIixmPVwicHVzaF9tb2RlXCIsZD1cInBvcF9tb2RlXCIsRT1cImxvbmdlcl9hbHRcIixtPVwibGluZV9icmVha3NcIix5PVwic3RhcnRfY2hhcnNfaGludFwiO2Z1bmN0aW9uIFQodCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPXQucGF0dGVybixvPXt9O2kuZGVmaW5lTmFtZVByb3AobyxlKXx8KG8udG9rZW5OYW1lPWUpO3IuaXNVbmRlZmluZWQobil8fChvLlBBVFRFUk49bik7aWYoci5oYXModCxjKSl0aHJvdyBcIlRoZSBwYXJlbnQgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cXG5TZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9TQVAvY2hldnJvdGFpbi9pc3N1ZXMvNTY0I2lzc3VlY29tbWVudC0zNDkwNjIzNDYgZm9yIGRldGFpbHMuXCI7ci5oYXModCxwKSYmKG8uQ0FURUdPUklFUz10W3BdKTthLmF1Z21lbnRUb2tlblR5cGVzKFtvXSksci5oYXModCxsKSYmKG8uTEFCRUw9dFtsXSk7ci5oYXModCxoKSYmKG8uR1JPVVA9dFtoXSk7ci5oYXModCxkKSYmKG8uUE9QX01PREU9dFtkXSk7ci5oYXModCxmKSYmKG8uUFVTSF9NT0RFPXRbZl0pO3IuaGFzKHQsRSkmJihvLkxPTkdFUl9BTFQ9dFtFXSk7ci5oYXModCxtKSYmKG8uTElORV9CUkVBS1M9dFttXSk7ci5oYXModCx5KSYmKG8uU1RBUlRfQ0hBUlNfSElOVD10W3ldKTtyZXR1cm4gb30odCl9ZS5jcmVhdGVUb2tlbj1ULGUuRU9GPVQoe25hbWU6XCJFT0ZcIixwYXR0ZXJuOm8uTGV4ZXIuTkF9KSxhLmF1Z21lbnRUb2tlblR5cGVzKFtlLkVPRl0pLGUuY3JlYXRlVG9rZW5JbnN0YW5jZT1mdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3JldHVybiB7aW1hZ2U6ZSxzdGFydE9mZnNldDpuLGVuZE9mZnNldDpyLHN0YXJ0TGluZTppLGVuZExpbmU6byxzdGFydENvbHVtbjphLGVuZENvbHVtbjpzLHRva2VuVHlwZUlkeDp0LnRva2VuVHlwZUlkeCx0b2tlblR5cGU6dH19LGUudG9rZW5NYXRjaGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGEudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcih0LGUpfTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oNCksYT1uKDApLHM9bigyNiksdT1uKDIpLGM9bigyMykscD1uKDE2KSxsPW4oMTApLGg9bigyNCksZj1uKDI1KSxkPW4oMzEpLEU9bigzMiksbT1uKDM0KSx5PW4oMzUpLFQ9bigzNiksdj1uKDM3KSxnPW4oMzgpO2UuRU5EX09GX0ZJTEU9dS5jcmVhdGVUb2tlbkluc3RhbmNlKHUuRU9GLFwiXCIsTmFOLE5hTixOYU4sTmFOLE5hTixOYU4pLE9iamVjdC5mcmVlemUoZS5FTkRfT0ZfRklMRSksZS5ERUZBVUxUX1BBUlNFUl9DT05GSUc9T2JqZWN0LmZyZWV6ZSh7cmVjb3ZlcnlFbmFibGVkOiExLG1heExvb2thaGVhZDo0LGlnbm9yZWRJc3N1ZXM6e30sZHluYW1pY1Rva2Vuc0VuYWJsZWQ6ITEsb3V0cHV0Q3N0OiEwLGVycm9yTWVzc2FnZVByb3ZpZGVyOmwuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIsc2VyaWFsaXplZEdyYW1tYXI6bnVsbH0pLGUuREVGQVVMVF9SVUxFX0NPTkZJRz1PYmplY3QuZnJlZXplKHtyZWNvdmVyeVZhbHVlRnVuYzpmdW5jdGlvbigpe30scmVzeW5jRW5hYmxlZDohMH0pLGZ1bmN0aW9uKHQpe3RbdC5JTlZBTElEX1JVTEVfTkFNRT0wXT1cIklOVkFMSURfUlVMRV9OQU1FXCIsdFt0LkRVUExJQ0FURV9SVUxFX05BTUU9MV09XCJEVVBMSUNBVEVfUlVMRV9OQU1FXCIsdFt0LklOVkFMSURfUlVMRV9PVkVSUklERT0yXT1cIklOVkFMSURfUlVMRV9PVkVSUklERVwiLHRbdC5EVVBMSUNBVEVfUFJPRFVDVElPTlM9M109XCJEVVBMSUNBVEVfUFJPRFVDVElPTlNcIix0W3QuVU5SRVNPTFZFRF9TVUJSVUxFX1JFRj00XT1cIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIix0W3QuTEVGVF9SRUNVUlNJT049NV09XCJMRUZUX1JFQ1VSU0lPTlwiLHRbdC5OT05FX0xBU1RfRU1QVFlfQUxUPTZdPVwiTk9ORV9MQVNUX0VNUFRZX0FMVFwiLHRbdC5BTUJJR1VPVVNfQUxUUz03XT1cIkFNQklHVU9VU19BTFRTXCIsdFt0LkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0U9OF09XCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCIsdFt0LklOVkFMSURfVE9LRU5fTkFNRT05XT1cIklOVkFMSURfVE9LRU5fTkFNRVwiLHRbdC5JTlZBTElEX05FU1RFRF9SVUxFX05BTUU9MTBdPVwiSU5WQUxJRF9ORVNURURfUlVMRV9OQU1FXCIsdFt0LkRVUExJQ0FURV9ORVNURURfTkFNRT0xMV09XCJEVVBMSUNBVEVfTkVTVEVEX05BTUVcIix0W3QuTk9fTk9OX0VNUFRZX0xPT0tBSEVBRD0xMl09XCJOT19OT05fRU1QVFlfTE9PS0FIRUFEXCIsdFt0LkFNQklHVU9VU19QUkVGSVhfQUxUUz0xM109XCJBTUJJR1VPVVNfUFJFRklYX0FMVFNcIix0W3QuVE9PX01BTllfQUxUUz0xNF09XCJUT09fTUFOWV9BTFRTXCI7fShlLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGV8fChlLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGU9e30pKSxlLkVNUFRZX0FMVD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9dm9pZCAwKSxmdW5jdGlvbigpe3JldHVybiB0fX07dmFyIF89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsbil7dm9pZCAwPT09biYmKG49ZS5ERUZBVUxUX1BBUlNFUl9DT05GSUcpLHRoaXMuaWdub3JlZElzc3Vlcz1lLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5pZ25vcmVkSXNzdWVzLHRoaXMuZGVmaW5pdGlvbkVycm9ycz1bXSx0aGlzLnNlbGZBbmFseXNpc0RvbmU9ITE7dGhpcy5pbml0RXJyb3JIYW5kbGVyKG4pLHRoaXMuaW5pdExleGVyQWRhcHRlcigpLHRoaXMuaW5pdExvb2tzQWhlYWQobiksdGhpcy5pbml0UmVjb2duaXplckVuZ2luZSh0LG4pLHRoaXMuaW5pdFJlY292ZXJhYmxlKG4pLHRoaXMuaW5pdFRyZWVCdWlsZGVyKG4pLHRoaXMuaW5pdENvbnRlbnRBc3Npc3QoKSx0aGlzLmlnbm9yZWRJc3N1ZXM9YS5oYXMobixcImlnbm9yZWRJc3N1ZXNcIik/bi5pZ25vcmVkSXNzdWVzOmUuREVGQVVMVF9QQVJTRVJfQ09ORklHLmlnbm9yZWRJc3N1ZXMsYS50b0Zhc3RQcm9wZXJ0aWVzKHRoaXMpO31yZXR1cm4gdC5wZXJmb3JtU2VsZkFuYWx5c2lzPWZ1bmN0aW9uKHQpe3QucGVyZm9ybVNlbGZBbmFseXNpcygpO30sdC5wcm90b3R5cGUucGVyZm9ybVNlbGZBbmFseXNpcz1mdW5jdGlvbigpe3ZhciBlLG49dGhpczt0aGlzLnNlbGZBbmFseXNpc0RvbmU9ITA7dmFyIHI9by5jbGFzc05hbWVGcm9tSW5zdGFuY2UodGhpcyksaT10aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlO2lmKHRoaXMuc2VyaWFsaXplZEdyYW1tYXIpe3ZhciB1PWMuZGVzZXJpYWxpemVHcmFtbWFyKHRoaXMuc2VyaWFsaXplZEdyYW1tYXIsdGhpcy50b2tlbnNNYXApO2EuZm9yRWFjaCh1LGZ1bmN0aW9uKHQpe24uZ2FzdFByb2R1Y3Rpb25zQ2FjaGUucHV0KHQubmFtZSx0KTt9KTt9dmFyIGY9aC5yZXNvbHZlR3JhbW1hcih7cnVsZXM6aS52YWx1ZXMoKX0pO2lmKHRoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoLmFwcGx5KHRoaXMuZGVmaW5pdGlvbkVycm9ycyxmKSxhLmlzRW1wdHkoZikpe3ZhciBkPWgudmFsaWRhdGVHcmFtbWFyKHtydWxlczppLnZhbHVlcygpLG1heExvb2thaGVhZDp0aGlzLm1heExvb2thaGVhZCx0b2tlblR5cGVzOmEudmFsdWVzKHRoaXMudG9rZW5zTWFwKSxpZ25vcmVkSXNzdWVzOnRoaXMuaWdub3JlZElzc3VlcyxlcnJNc2dQcm92aWRlcjpsLmRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixncmFtbWFyTmFtZTpyfSk7dGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2guYXBwbHkodGhpcy5kZWZpbml0aW9uRXJyb3JzLGQpO31pZihhLmlzRW1wdHkodGhpcy5kZWZpbml0aW9uRXJyb3JzKSl7dmFyIEU9cy5jb21wdXRlQWxsUHJvZHNGb2xsb3dzKGkudmFsdWVzKCkpO3RoaXMucmVzeW5jRm9sbG93cz1FO312YXIgbT1wLmFuYWx5emVDc3QoaS52YWx1ZXMoKSx0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQpO2lmKHRoaXMuYWxsUnVsZU5hbWVzPW0uYWxsUnVsZU5hbWVzLCF0LkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HJiYhYS5pc0VtcHR5KHRoaXMuZGVmaW5pdGlvbkVycm9ycykpdGhyb3cgZT1hLm1hcCh0aGlzLmRlZmluaXRpb25FcnJvcnMsZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pLG5ldyBFcnJvcihcIlBhcnNlciBEZWZpbml0aW9uIEVycm9ycyBkZXRlY3RlZDpcXG4gXCIrZS5qb2luKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKSl9LHQuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkc9ITEsdH0oKTtlLlBhcnNlcj1fLGEuYXBwbHlNaXhpbnMoXyxbZi5SZWNvdmVyYWJsZSxkLkxvb2tzQWhlYWQsRS5UcmVlQnVpbGRlcixtLkxleGVyQWRhcHRlcixULlJlY29nbml6ZXJFbmdpbmUseS5SZWNvZ25pemVyQXBpLHYuRXJyb3JIYW5kbGVyLGcuQ29udGVudEFzc2lzdF0pO3ZhciBSPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4obixyKXt2b2lkIDA9PT1yJiYocj1lLkRFRkFVTFRfUEFSU0VSX0NPTkZJRyk7dmFyIGk9YS5jbG9uZU9iaihyKTtyZXR1cm4gaS5vdXRwdXRDc3Q9ITAsdC5jYWxsKHRoaXMsbixpKXx8dGhpc31yZXR1cm4gaShuLHQpLG59KF8pO2UuQ3N0UGFyc2VyPVI7dmFyIEE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuLHIpe3ZvaWQgMD09PXImJihyPWUuREVGQVVMVF9QQVJTRVJfQ09ORklHKTt2YXIgaT1hLmNsb25lT2JqKHIpO3JldHVybiBpLm91dHB1dENzdD0hMSx0LmNhbGwodGhpcyxuLGkpfHx0aGlzfXJldHVybiBpKG4sdCksbn0oXyk7ZS5FbWJlZGRlZEFjdGlvbnNQYXJzZXI9QTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApO2UuY2xhc3NOYW1lRnJvbUluc3RhbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBhKHQuY29uc3RydWN0b3IpfTt2YXIgaT0vXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLyxvPVwibmFtZVwiO2Z1bmN0aW9uIGEodCl7dmFyIGU9dC5uYW1lO3JldHVybiBlfHx0LnRvU3RyaW5nKCkubWF0Y2goaSlbMV19ZS5mdW5jdGlvbk5hbWU9YSxlLmRlZmluZU5hbWVQcm9wPWZ1bmN0aW9uKHQsZSl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG8pO3JldHVybiAhKCFyLmlzVW5kZWZpbmVkKG4pJiYhbi5jb25maWd1cmFibGV8fChPYmplY3QuZGVmaW5lUHJvcGVydHkodCxvLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMSx2YWx1ZTplfSksMCkpfTt2YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLl9zdGF0ZT17fTt9cmV0dXJuIHQucHJvdG90eXBlLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gci5rZXlzKHRoaXMuX3N0YXRlKX0sdC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKHRoaXMuX3N0YXRlKX0sdC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7dGhpcy5fc3RhdGVbdF09ZTt9LHQucHJvdG90eXBlLnB1dEFsbD1mdW5jdGlvbih0KXt0aGlzLl9zdGF0ZT1yLmFzc2lnbih0aGlzLl9zdGF0ZSx0Ll9zdGF0ZSk7fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3N0YXRlW3RdfSx0LnByb3RvdHlwZS5jb250YWluc0tleT1mdW5jdGlvbih0KXtyZXR1cm4gci5oYXModGhpcy5fc3RhdGUsdCl9LHQucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5fc3RhdGU9e307fSx0fSgpO2UuSGFzaFRhYmxlPXM7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigxKSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUudmlzaXQ9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIHIuTm9uVGVybWluYWwpcmV0dXJuIHRoaXMudmlzaXROb25UZXJtaW5hbCh0KTtpZih0IGluc3RhbmNlb2Ygci5GbGF0KXJldHVybiB0aGlzLnZpc2l0RmxhdCh0KTtpZih0IGluc3RhbmNlb2Ygci5PcHRpb24pcmV0dXJuIHRoaXMudmlzaXRPcHRpb24odCk7aWYodCBpbnN0YW5jZW9mIHIuUmVwZXRpdGlvbk1hbmRhdG9yeSlyZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkodCk7aWYodCBpbnN0YW5jZW9mIHIuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcih0KTtpZih0IGluc3RhbmNlb2Ygci5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcilyZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKHQpO2lmKHQgaW5zdGFuY2VvZiByLlJlcGV0aXRpb24pcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uKHQpO2lmKHQgaW5zdGFuY2VvZiByLkFsdGVybmF0aW9uKXJldHVybiB0aGlzLnZpc2l0QWx0ZXJuYXRpb24odCk7aWYodCBpbnN0YW5jZW9mIHIuVGVybWluYWwpcmV0dXJuIHRoaXMudmlzaXRUZXJtaW5hbCh0KTtpZih0IGluc3RhbmNlb2Ygci5SdWxlKXJldHVybiB0aGlzLnZpc2l0UnVsZSh0KTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfSx0LnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRGbGF0PWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb249ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnk9ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7fSx0LnByb3RvdHlwZS52aXNpdFRlcm1pbmFsPWZ1bmN0aW9uKHQpe30sdC5wcm90b3R5cGUudmlzaXRSdWxlPWZ1bmN0aW9uKHQpe30sdH0oKTtlLkdBc3RWaXNpdG9yPWk7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPVwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCIsbz1cIk5vVmlhYmxlQWx0RXhjZXB0aW9uXCIsYT1cIkVhcmx5RXhpdEV4Y2VwdGlvblwiLHM9XCJOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvblwiLHU9W2ksbyxhLHNdO2Z1bmN0aW9uIGModCxlLG4pe3RoaXMubmFtZT1pLHRoaXMubWVzc2FnZT10LHRoaXMudG9rZW49ZSx0aGlzLnByZXZpb3VzVG9rZW49bix0aGlzLnJlc3luY2VkVG9rZW5zPVtdO31mdW5jdGlvbiBwKHQsZSxuKXt0aGlzLm5hbWU9byx0aGlzLm1lc3NhZ2U9dCx0aGlzLnRva2VuPWUsdGhpcy5wcmV2aW91c1Rva2VuPW4sdGhpcy5yZXN5bmNlZFRva2Vucz1bXTt9ZnVuY3Rpb24gbCh0LGUpe3RoaXMubmFtZT1zLHRoaXMubWVzc2FnZT10LHRoaXMudG9rZW49ZSx0aGlzLnJlc3luY2VkVG9rZW5zPVtdO31mdW5jdGlvbiBoKHQsZSxuKXt0aGlzLm5hbWU9YSx0aGlzLm1lc3NhZ2U9dCx0aGlzLnRva2VuPWUsdGhpcy5wcmV2aW91c1Rva2VuPW4sdGhpcy5yZXN5bmNlZFRva2Vucz1bXTt9T2JqZWN0LmZyZWV6ZSh1KSxlLmlzUmVjb2duaXRpb25FeGNlcHRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHIuY29udGFpbnModSx0Lm5hbWUpfSxlLk1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbj1jLGMucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZSxlLk5vVmlhYmxlQWx0RXhjZXB0aW9uPXAscC5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlLGUuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb249bCxsLnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGUsZS5FYXJseUV4aXRFeGNlcHRpb249aCxoLnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGU7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oNCksbz1uKDIpO2Z1bmN0aW9uIGEodCl7Zm9yKHZhciBlPXIuY2xvbmVBcnIodCksbj10LGk9ITA7aTspe249ci5jb21wYWN0KHIuZmxhdHRlbihyLm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiB0LkNBVEVHT1JJRVN9KSkpO3ZhciBvPXIuZGlmZmVyZW5jZShuLGUpO2U9ZS5jb25jYXQobyksci5pc0VtcHR5KG8pP2k9ITE6bj1vO31yZXR1cm4gZX1mdW5jdGlvbiBzKHQpe3IuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe2wodCl8fChlLnRva2VuSWR4VG9DbGFzcy5wdXQoZS50b2tlblNob3J0TmFtZUlkeCx0KSx0LnRva2VuVHlwZUlkeD1lLnRva2VuU2hvcnROYW1lSWR4KyspLGgodCkmJiFyLmlzQXJyYXkodC5DQVRFR09SSUVTKSYmKHQuQ0FURUdPUklFUz1bdC5DQVRFR09SSUVTXSksaCh0KXx8KHQuQ0FURUdPUklFUz1bXSksZih0KXx8KHQuY2F0ZWdvcnlNYXRjaGVzPVtdKSxkKHQpfHwodC5jYXRlZ29yeU1hdGNoZXNNYXA9e30pLEUodCl8fCh0LnRva2VuTmFtZT1vLnRva2VuTmFtZSh0KSk7fSk7fWZ1bmN0aW9uIHUodCl7ci5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dC5jYXRlZ29yeU1hdGNoZXM9W10sci5mb3JFYWNoKHQuY2F0ZWdvcnlNYXRjaGVzTWFwLGZ1bmN0aW9uKG4scil7dC5jYXRlZ29yeU1hdGNoZXMucHVzaChlLnRva2VuSWR4VG9DbGFzcy5nZXQocikudG9rZW5UeXBlSWR4KTt9KTt9KTt9ZnVuY3Rpb24gYyh0KXtyLmZvckVhY2godCxmdW5jdGlvbih0KXtwKFtdLHQpO30pO31mdW5jdGlvbiBwKHQsZSl7ci5mb3JFYWNoKHQsZnVuY3Rpb24odCl7ZS5jYXRlZ29yeU1hdGNoZXNNYXBbdC50b2tlblR5cGVJZHhdPSEwO30pLHIuZm9yRWFjaChlLkNBVEVHT1JJRVMsZnVuY3Rpb24obil7dmFyIGk9dC5jb25jYXQoZSk7ci5jb250YWlucyhpLG4pfHxwKGksbik7fSk7fWZ1bmN0aW9uIGwodCl7cmV0dXJuIHIuaGFzKHQsXCJ0b2tlblR5cGVJZHhcIil9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gci5oYXModCxcIkNBVEVHT1JJRVNcIil9ZnVuY3Rpb24gZih0KXtyZXR1cm4gci5oYXModCxcImNhdGVnb3J5TWF0Y2hlc1wiKX1mdW5jdGlvbiBkKHQpe3JldHVybiByLmhhcyh0LFwiY2F0ZWdvcnlNYXRjaGVzTWFwXCIpfWZ1bmN0aW9uIEUodCl7cmV0dXJuIHIuaGFzKHQsXCJ0b2tlbk5hbWVcIil9ZS50b2tlblN0cnVjdHVyZWRNYXRjaGVyPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b2tlblR5cGVJZHg7cmV0dXJuIG49PT1lLnRva2VuVHlwZUlkeHx8ITA9PT1lLmlzUGFyZW50JiYhMD09PWUuY2F0ZWdvcnlNYXRjaGVzTWFwW25dfSxlLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC50b2tlblR5cGVJZHg9PT1lLnRva2VuVHlwZUlkeH0sZS50b2tlblNob3J0TmFtZUlkeD0xLGUudG9rZW5JZHhUb0NsYXNzPW5ldyBpLkhhc2hUYWJsZSxlLmF1Z21lbnRUb2tlblR5cGVzPWZ1bmN0aW9uKHQpe3ZhciBlPWEodCk7cyhlKSxjKGUpLHUoZSksci5mb3JFYWNoKGUsZnVuY3Rpb24odCl7dC5pc1BhcmVudD10LmNhdGVnb3J5TWF0Y2hlcy5sZW5ndGg+MDt9KTt9LGUuZXhwYW5kQ2F0ZWdvcmllcz1hLGUuYXNzaWduVG9rZW5EZWZhdWx0UHJvcHM9cyxlLmFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wPXUsZS5hc3NpZ25DYXRlZ29yaWVzTWFwUHJvcD1jLGUuc2luZ2xlQXNzaWduQ2F0ZWdvcmllc1Rva3NNYXA9cCxlLmhhc1Nob3J0S2V5UHJvcGVydHk9bCxlLmhhc0NhdGVnb3JpZXNQcm9wZXJ0eT1oLGUuaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eT1mLGUuaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNNYXBQcm9wZXJ0eT1kLGUuaGFzVG9rZW5OYW1lUHJvcGVydHk9RSxlLmlzVG9rZW5UeXBlPWZ1bmN0aW9uKHQpe3JldHVybiByLmhhcyh0LFwidG9rZW5UeXBlSWR4XCIpfTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMCksYT1uKDEpLHM9big1KSx1PW4oMik7ZS5pc1NlcXVlbmNlUHJvZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGEuRmxhdHx8dCBpbnN0YW5jZW9mIGEuT3B0aW9ufHx0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9ufHx0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uTWFuZGF0b3J5fHx0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcnx8dCBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3J8fHQgaW5zdGFuY2VvZiBhLlRlcm1pbmFsfHx0IGluc3RhbmNlb2YgYS5SdWxlfSxlLmlzT3B0aW9uYWxQcm9kPWZ1bmN0aW9uIHQoZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49W10pLCEhKGUgaW5zdGFuY2VvZiBhLk9wdGlvbnx8ZSBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbnx8ZSBpbnN0YW5jZW9mIGEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpfHwoZSBpbnN0YW5jZW9mIGEuQWx0ZXJuYXRpb24/by5zb21lKGUuZGVmaW5pdGlvbixmdW5jdGlvbihlKXtyZXR1cm4gdChlLG4pfSk6IShlIGluc3RhbmNlb2YgYS5Ob25UZXJtaW5hbCYmby5jb250YWlucyhuLGUpKSYmZSBpbnN0YW5jZW9mIGEuQWJzdHJhY3RQcm9kdWN0aW9uJiYoZSBpbnN0YW5jZW9mIGEuTm9uVGVybWluYWwmJm4ucHVzaChlKSxvLmV2ZXJ5KGUuZGVmaW5pdGlvbixmdW5jdGlvbihlKXtyZXR1cm4gdChlLG4pfSkpKX0sZS5pc0JyYW5jaGluZ1Byb2Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBhLkFsdGVybmF0aW9ufSxlLmdldFByb2R1Y3Rpb25Ec2xOYW1lPWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBhLk5vblRlcm1pbmFsKXJldHVybiBcIlNVQlJVTEVcIjtpZih0IGluc3RhbmNlb2YgYS5PcHRpb24pcmV0dXJuIFwiT1BUSU9OXCI7aWYodCBpbnN0YW5jZW9mIGEuQWx0ZXJuYXRpb24pcmV0dXJuIFwiT1JcIjtpZih0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uTWFuZGF0b3J5KXJldHVybiBcIkFUX0xFQVNUX09ORVwiO2lmKHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXJldHVybiBcIkFUX0xFQVNUX09ORV9TRVBcIjtpZih0IGluc3RhbmNlb2YgYS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcilyZXR1cm4gXCJNQU5ZX1NFUFwiO2lmKHQgaW5zdGFuY2VvZiBhLlJlcGV0aXRpb24pcmV0dXJuIFwiTUFOWVwiO2lmKHQgaW5zdGFuY2VvZiBhLlRlcm1pbmFsKXJldHVybiBcIkNPTlNVTUVcIjt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfTt2YXIgYz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dmFyIGU9bnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO3JldHVybiBlLnNlcGFyYXRvcj1cIi1cIixlLmRzbE1ldGhvZHM9e29wdGlvbjpbXSxhbHRlcm5hdGlvbjpbXSxyZXBldGl0aW9uOltdLHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOltdLHJlcGV0aXRpb25NYW5kYXRvcnk6W10scmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6W119LGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsPWZ1bmN0aW9uKHQpe3ZhciBlPXUudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKSt0aGlzLnNlcGFyYXRvcitcIlRlcm1pbmFsXCI7by5oYXModGhpcy5kc2xNZXRob2RzLGUpfHwodGhpcy5kc2xNZXRob2RzW2VdPVtdKSx0aGlzLmRzbE1ldGhvZHNbZV0ucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0Tm9uVGVybWluYWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5ub25UZXJtaW5hbE5hbWUrdGhpcy5zZXBhcmF0b3IrXCJUZXJtaW5hbFwiO28uaGFzKHRoaXMuZHNsTWV0aG9kcyxlKXx8KHRoaXMuZHNsTWV0aG9kc1tlXT1bXSksdGhpcy5kc2xNZXRob2RzW2VdLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbih0KXt0aGlzLmRzbE1ldGhvZHMub3B0aW9uLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uV2l0aFNlcGFyYXRvci5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uTWFuZGF0b3J5LnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvci5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuZHNsTWV0aG9kcy5hbHRlcm5hdGlvbi5wdXNoKHQpO30sZX0ocy5HQXN0VmlzaXRvcik7ZS5Ec2xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcj1jO30sZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCxlLG4pe3JldHVybiBufGV8dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkJJVFNfRk9SX01FVEhPRF9JRFg9NCxlLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYPTQsZS5CSVRTX0ZPUl9SVUxFX0lEWD0yNCxlLkJJVFNfRk9SX0FMVF9JRFg9OCxlLk9SX0lEWD0xPDxlLkJJVFNfRk9SX01FVEhPRF9JRFgsZS5PUFRJT05fSURYPTI8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLk1BTllfSURYPTM8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLkFUX0xFQVNUX09ORV9JRFg9NDw8ZS5CSVRTX0ZPUl9NRVRIT0RfSURYLGUuTUFOWV9TRVBfSURYPTU8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLkFUX0xFQVNUX09ORV9TRVBfSURYPTY8PGUuQklUU19GT1JfTUVUSE9EX0lEWCxlLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZD1yO3ZhciBpPTMyLWUuQklUU19GT1JfQUxUX0lEWDtlLmdldEtleUZvckFsdEluZGV4PWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBhPW8rMTw8aTtyZXR1cm4gcih0LGUsbil8YX07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigyKSxpPW4oMCksbz1uKDApLGE9bigxKSxzPW4oOCksdT1uKDExKSxjPW4oMTcpLHA9bigzKTtlLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyPXtidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZXhwZWN0ZWQsbj10LmFjdHVhbDt0LnByZXZpb3VzLHQucnVsZU5hbWU7cmV0dXJuIFwiRXhwZWN0aW5nIFwiKyhyLmhhc1Rva2VuTGFiZWwoZSk/XCItLVxceDNlIFwiK3IudG9rZW5MYWJlbChlKStcIiA8LS1cIjpcInRva2VuIG9mIHR5cGUgLS1cXHgzZSBcIityLnRva2VuTmFtZShlKStcIiA8LS1cIikrXCIgYnV0IGZvdW5kIC0tXFx4M2UgJ1wiK24uaW1hZ2UrXCInIDwtLVwifSxidWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZTpmdW5jdGlvbih0KXt2YXIgZT10LmZpcnN0UmVkdW5kYW50O3QucnVsZU5hbWU7cmV0dXJuIFwiUmVkdW5kYW50IGlucHV0LCBleHBlY3RpbmcgRU9GIGJ1dCBmb3VuZDogXCIrZS5pbWFnZX0sYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dC5leHBlY3RlZFBhdGhzUGVyQWx0LG49dC5hY3R1YWwsaT0odC5wcmV2aW91cyx0LmN1c3RvbVVzZXJEZXNjcmlwdGlvbiksYT0odC5ydWxlTmFtZSxcIlxcbmJ1dCBmb3VuZDogJ1wiK28uZmlyc3QobikuaW1hZ2UrXCInXCIpO2lmKGkpcmV0dXJuIFwiRXhwZWN0aW5nOiBcIitpK2E7dmFyIHM9by5yZWR1Y2UoZSxmdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbmNhdChlKX0sW10pLHU9by5tYXAocyxmdW5jdGlvbih0KXtyZXR1cm4gXCJbXCIrby5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gci50b2tlbkxhYmVsKHQpfSkuam9pbihcIiwgXCIpK1wiXVwifSk7cmV0dXJuIFwiRXhwZWN0aW5nOiBcIisoXCJvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOlxcblwiK28ubWFwKHUsZnVuY3Rpb24odCxlKXtyZXR1cm4gXCIgIFwiKyhlKzEpK1wiLiBcIit0fSkuam9pbihcIlxcblwiKSkrYX0sYnVpbGRFYXJseUV4aXRNZXNzYWdlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZXhwZWN0ZWRJdGVyYXRpb25QYXRocyxuPXQuYWN0dWFsLGk9dC5jdXN0b21Vc2VyRGVzY3JpcHRpb24sYT0odC5ydWxlTmFtZSxcIlxcbmJ1dCBmb3VuZDogJ1wiK28uZmlyc3QobikuaW1hZ2UrXCInXCIpO3JldHVybiBpP1wiRXhwZWN0aW5nOiBcIitpK2E6XCJFeHBlY3Rpbmc6IFwiKyhcImV4cGVjdGluZyBhdCBsZWFzdCBvbmUgaXRlcmF0aW9uIHdoaWNoIHN0YXJ0cyB3aXRoIG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6OlxcbiAgPFwiK28ubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIFwiW1wiK28ubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHIudG9rZW5MYWJlbCh0KX0pLmpvaW4oXCIsXCIpK1wiXVwifSkuam9pbihcIiAsXCIpK1wiPlwiKSthfX0sT2JqZWN0LmZyZWV6ZShlLmRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyKSxlLmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyPXtidWlsZFJ1bGVOb3RGb3VuZEVycm9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFwiSW52YWxpZCBncmFtbWFyLCByZWZlcmVuY2UgdG8gYSBydWxlIHdoaWNoIGlzIG5vdCBkZWZpbmVkOiAtPlwiK2Uubm9uVGVybWluYWxOYW1lK1wiPC1cXG5pbnNpZGUgdG9wIGxldmVsIHJ1bGU6IC0+XCIrdC5uYW1lK1wiPC1cIn19LGUuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyPXtidWlsZER1cGxpY2F0ZUZvdW5kRXJyb3I6ZnVuY3Rpb24odCxlKXt2YXIgbixpPXQubmFtZSx1PW8uZmlyc3QoZSksYz11LmlkeCxwPXMuZ2V0UHJvZHVjdGlvbkRzbE5hbWUodSksbD0obj11KWluc3RhbmNlb2YgYS5UZXJtaW5hbD9yLnRva2VuTmFtZShuLnRlcm1pbmFsVHlwZSk6biBpbnN0YW5jZW9mIGEuTm9uVGVybWluYWw/bi5ub25UZXJtaW5hbE5hbWU6XCJcIixoPVwiLT5cIitwK1wiPC0gd2l0aCBudW1lcmljYWwgc3VmZml4OiAtPlwiK2MrXCI8LVxcbiAgICAgICAgICAgICAgICAgIFwiKyhsP1wiYW5kIGFyZ3VtZW50OiAtPlwiK2wrXCI8LVwiOlwiXCIpK1wiXFxuICAgICAgICAgICAgICAgICAgYXBwZWFycyBtb3JlIHRoYW4gb25jZSAoXCIrZS5sZW5ndGgrXCIgdGltZXMpIGluIHRoZSB0b3AgbGV2ZWwgcnVsZTogLT5cIitpK1wiPC0uXFxuICAgICAgICAgICAgICAgICAgXCIrKDA9PT1jP1wiQWxzbyBub3RlIHRoYXQgbnVtZXJpY2FsIHN1ZmZpeCAwIG1lYW5zIFwiK3ArXCIgd2l0aG91dCBhbnkgc3VmZml4LlwiOlwiXCIpK1wiXFxuICAgICAgICAgICAgICAgICAgVG8gZml4IHRoaXMgbWFrZSBzdXJlIGVhY2ggdXNhZ2Ugb2YgXCIrcCtcIiBcIisobD9cIndpdGggdGhlIGFyZ3VtZW50OiAtPlwiK2wrXCI8LVwiOlwiXCIpK1wiXFxuICAgICAgICAgICAgICAgICAgaW4gdGhlIHJ1bGUgLT5cIitpK1wiPC0gaGFzIGEgZGlmZmVyZW50IG9jY3VycmVuY2UgaW5kZXggKDAtNSksIGFzIHRoYXQgY29tYmluYXRpb24gYWN0cyBhcyBhIHVuaXF1ZVxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGtleSBpbiB0aGUgZ3JhbW1hciwgd2hpY2ggaXMgbmVlZGVkIGJ5IHRoZSBwYXJzaW5nIGVuZ2luZS5cXG4gICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXFxuICAgICAgICAgICAgICAgICAgXCI7cmV0dXJuIGg9KGg9aC5yZXBsYWNlKC9bIFxcdF0rL2csXCIgXCIpKS5yZXBsYWNlKC9cXHNcXHMrL2csXCJcXG5cIil9LGJ1aWxkSW52YWxpZE5lc3RlZFJ1bGVOYW1lRXJyb3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gXCJJbnZhbGlkIG5lc3RlZCBydWxlIG5hbWU6IC0+XCIrZS5uYW1lK1wiPC0gaW5zaWRlIHJ1bGU6IC0+XCIrdC5uYW1lK1wiPC1cXG5pdCBtdXN0IG1hdGNoIHRoZSBwYXR0ZXJuOiAtPlwiK3UudmFsaWROZXN0ZWRSdWxlTmFtZS50b1N0cmluZygpK1wiPC0uXFxuTm90ZSB0aGF0IHRoaXMgbWVhbnMgYSBuZXN0ZWQgcnVsZSBuYW1lIG11c3Qgc3RhcnQgd2l0aCB0aGUgJyQnKGRvbGxhcikgc2lnbi5cIn0sYnVpbGREdXBsaWNhdGVOZXN0ZWRSdWxlTmFtZUVycm9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFwiRHVwbGljYXRlIG5lc3RlZCBydWxlIG5hbWU6IC0+XCIrby5maXJzdChlKS5uYW1lK1wiPC0gaW5zaWRlIHJ1bGU6IC0+XCIrdC5uYW1lK1wiPC1cXG5BIG5lc3RlZCBuYW1lIG11c3QgYmUgdW5pcXVlIGluIHRoZSBzY29wZSBvZiBhIHRvcCBsZXZlbCBncmFtbWFyIHJ1bGUuXCJ9LGJ1aWxkTmFtZXNwYWNlQ29uZmxpY3RFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJOYW1lc3BhY2UgY29uZmxpY3QgZm91bmQgaW4gZ3JhbW1hci5cXG5UaGUgZ3JhbW1hciBoYXMgYm90aCBhIFRlcm1pbmFsKFRva2VuKSBhbmQgYSBOb24tVGVybWluYWwoUnVsZSkgbmFtZWQ6IDxcIit0Lm5hbWUrXCI+LlxcblRvIHJlc29sdmUgdGhpcyBtYWtlIHN1cmUgZWFjaCBUZXJtaW5hbCBhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIGFyZSB1bmlxdWVcXG5UaGlzIGlzIGVhc3kgdG8gYWNjb21wbGlzaCBieSB1c2luZyB0aGUgY29udmVudGlvbiB0aGF0IFRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGxldHRlclxcbmFuZCBOb24tVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhIGxvd2VyIGNhc2UgbGV0dGVyLlwifSxidWlsZEFsdGVybmF0aW9uUHJlZml4QW1iaWd1aXR5RXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9by5tYXAodC5wcmVmaXhQYXRoLGZ1bmN0aW9uKHQpe3JldHVybiByLnRva2VuTGFiZWwodCl9KS5qb2luKFwiLCBcIiksbj0wPT09dC5hbHRlcm5hdGlvbi5pZHg/XCJcIjp0LmFsdGVybmF0aW9uLmlkeDtyZXR1cm4gXCJBbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzOiA8XCIrdC5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKStcIj4gZHVlIHRvIGNvbW1vbiBsb29rYWhlYWQgcHJlZml4XFxuaW4gPE9SXCIrbitcIj4gaW5zaWRlIDxcIit0LnRvcExldmVsUnVsZS5uYW1lK1wiPiBSdWxlLFxcbjxcIitlK1wiPiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNDT01NT05fUFJFRklYXFxuRm9yIEZ1cnRoZXIgZGV0YWlscy5cIn0sYnVpbGRBbHRlcm5hdGlvbkFtYmlndWl0eUVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPW8ubWFwKHQucHJlZml4UGF0aCxmdW5jdGlvbih0KXtyZXR1cm4gci50b2tlbkxhYmVsKHQpfSkuam9pbihcIiwgXCIpLG49MD09PXQuYWx0ZXJuYXRpb24uaWR4P1wiXCI6dC5hbHRlcm5hdGlvbi5pZHgsaT1cIkFtYmlndW91cyBhbHRlcm5hdGl2ZXM6IDxcIit0LmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpK1wiPiBpbiA8T1JcIituK1wiPiBpbnNpZGUgPFwiK3QudG9wTGV2ZWxSdWxlLm5hbWUrXCI+IFJ1bGUsXFxuPFwiK2UrXCI+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5cIixhPWMuVkVSU0lPTi5yZXBsYWNlKC9cXC4vZyxcIl9cIik7cmV0dXJuIGk9aStcIlRvIFJlc29sdmUgdGhpcywgdHJ5IG9uZSBvZiBvZiB0aGUgZm9sbG93aW5nOiBcXG4xLiBSZWZhY3RvciB5b3VyIGdyYW1tYXIgdG8gYmUgTEwoSykgZm9yIHRoZSBjdXJyZW50IHZhbHVlIG9mIGsgKGJ5IGRlZmF1bHQgaz1cIitwLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5tYXhMb29rYWhlYWQrXCJ9KVxcbjIuIEluY3JlYXNlIHRoZSB2YWx1ZSBvZiBLIGZvciB5b3VyIGdyYW1tYXIgYnkgcHJvdmlkaW5nIGEgbGFyZ2VyICdtYXhMb29rYWhlYWQnIHZhbHVlIGluIHRoZSBwYXJzZXIncyBjb25maWdcXG4zLiBUaGlzIGlzc3VlIGNhbiBiZSBpZ25vcmVkIChpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuLi4pLCBzZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jdW1lbnRhdGlvbi9cIithK1wiL2ludGVyZmFjZXMvaXBhcnNlcmNvbmZpZy5odG1sI2lnbm9yZWRpc3N1ZXMgZm9yIG1vcmUgZGV0YWlsc1xcblwifSxidWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yOmZ1bmN0aW9uKHQpe3ZhciBlPXMuZ2V0UHJvZHVjdGlvbkRzbE5hbWUodC5yZXBldGl0aW9uKTtyZXR1cm4gMCE9PXQucmVwZXRpdGlvbi5pZHgmJihlKz10LnJlcGV0aXRpb24uaWR4KSxcIlRoZSByZXBldGl0aW9uIDxcIitlK1wiPiB3aXRoaW4gUnVsZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIj4gY2FuIG5ldmVyIGNvbnN1bWUgYW55IHRva2Vucy5cXG5UaGlzIGNvdWxkIGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcC5cIn0sYnVpbGRUb2tlbk5hbWVFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJJbnZhbGlkIEdyYW1tYXIgVG9rZW4gbmFtZTogLT5cIityLnRva2VuTmFtZSh0LnRva2VuVHlwZSkrXCI8LSBpdCBtdXN0IG1hdGNoIHRoZSBwYXR0ZXJuOiAtPlwiK3QuZXhwZWN0ZWRQYXR0ZXJuLnRvU3RyaW5nKCkrXCI8LVwifSxidWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJBbWJpZ3VvdXMgZW1wdHkgYWx0ZXJuYXRpdmU6IDxcIisodC5lbXB0eUNob2ljZUlkeCsxKStcIj4gaW4gPE9SXCIrdC5hbHRlcm5hdGlvbi5pZHgrXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIj4gUnVsZS5cXG5Pbmx5IHRoZSBsYXN0IGFsdGVybmF0aXZlIG1heSBiZSBhbiBlbXB0eSBhbHRlcm5hdGl2ZS5cIn0sYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3I6ZnVuY3Rpb24odCl7cmV0dXJuIFwiQW4gQWx0ZXJuYXRpb24gY2Fubm90IGhhdmUgbW9yZSB0aGFuIDI1NiBhbHRlcm5hdGl2ZXM6XFxuPE9SXCIrdC5hbHRlcm5hdGlvbi5pZHgrXCI+IGluc2lkZSA8XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIj4gUnVsZS5cXG4gaGFzIFwiKyh0LmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoKzEpK1wiIGFsdGVybmF0aXZlcy5cIn0sYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3I6ZnVuY3Rpb24odCl7dmFyIGU9dC50b3BMZXZlbFJ1bGUubmFtZTtyZXR1cm4gXCJMZWZ0IFJlY3Vyc2lvbiBmb3VuZCBpbiBncmFtbWFyLlxcbnJ1bGU6IDxcIitlK1wiPiBjYW4gYmUgaW52b2tlZCBmcm9tIGl0c2VsZiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSlcXG53aXRob3V0IGNvbnN1bWluZyBhbnkgVG9rZW5zLiBUaGUgZ3JhbW1hciBwYXRoIHRoYXQgY2F1c2VzIHRoaXMgaXM6IFxcbiBcIisoZStcIiAtLVxceDNlIFwiK2kubWFwKHQubGVmdFJlY3Vyc2lvblBhdGgsZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pLmNvbmNhdChbZV0pLmpvaW4oXCIgLS1cXHgzZSBcIikpK1wiXFxuIFRvIGZpeCB0aGlzIHJlZmFjdG9yIHlvdXIgZ3JhbW1hciB0byByZW1vdmUgdGhlIGxlZnQgcmVjdXJzaW9uLlxcbnNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTExfcGFyc2VyI0xlZnRfRmFjdG9yaW5nLlwifSxidWlsZEludmFsaWRSdWxlTmFtZUVycm9yOmZ1bmN0aW9uKHQpe3JldHVybiBcIkludmFsaWQgZ3JhbW1hciBydWxlIG5hbWU6IC0+XCIrdC50b3BMZXZlbFJ1bGUubmFtZStcIjwtIGl0IG11c3QgbWF0Y2ggdGhlIHBhdHRlcm46IC0+XCIrdC5leHBlY3RlZFBhdHRlcm4udG9TdHJpbmcoKStcIjwtXCJ9LGJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4gXCJEdXBsaWNhdGUgZGVmaW5pdGlvbiwgcnVsZTogLT5cIisodC50b3BMZXZlbFJ1bGUgaW5zdGFuY2VvZiBhLlJ1bGU/dC50b3BMZXZlbFJ1bGUubmFtZTp0LnRvcExldmVsUnVsZSkrXCI8LSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIGdyYW1tYXI6IC0+XCIrdC5ncmFtbWFyTmFtZStcIjwtXCJ9fTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMCksYT1uKDApLHM9bigzKSx1PW4oOCksYz1uKDIpLHA9bigxMiksbD1uKDE2KSxoPW4oMTMpLGY9bigxKSxkPW4oNSk7ZnVuY3Rpb24gRSh0KXtyZXR1cm4gdS5nZXRQcm9kdWN0aW9uRHNsTmFtZSh0KStcIl8jX1wiK3QuaWR4K1wiXyNfXCIrbSh0KX1mdW5jdGlvbiBtKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZi5UZXJtaW5hbD9jLnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSk6dCBpbnN0YW5jZW9mIGYuTm9uVGVybWluYWw/dC5ub25UZXJtaW5hbE5hbWU6XCJcIn1lLnZhbGlkYXRlR3JhbW1hcj1mdW5jdGlvbih0LGUsbixyLGkscCl7dmFyIGg9by5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgeTt0LmFjY2VwdChuKTt2YXIgcj1uLmFsbFByb2R1Y3Rpb25zLGk9by5ncm91cEJ5KHIsRSksYT1vLnBpY2soaSxmdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg+MX0pO3JldHVybiBvLm1hcChvLnZhbHVlcyhhKSxmdW5jdGlvbihuKXt2YXIgcj1vLmZpcnN0KG4pLGk9ZS5idWlsZER1cGxpY2F0ZUZvdW5kRXJyb3IodCxuKSxhPXUuZ2V0UHJvZHVjdGlvbkRzbE5hbWUociksYz17bWVzc2FnZTppLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QUk9EVUNUSU9OUyxydWxlTmFtZTp0Lm5hbWUsZHNsTmFtZTphLG9jY3VycmVuY2U6ci5pZHh9LHA9bShyKTtyZXR1cm4gcCYmKGMucGFyYW1ldGVyPXApLGN9KX0odCxpKX0pLGY9by5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gUih0LHQsaSl9KSxkPVtdLEE9W10sTj1bXTthLmV2ZXJ5KGYsYS5pc0VtcHR5KSYmKGQ9YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gTyh0LGkpfSksQT1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBTKHQsZSxyLGkpfSksTj1rKHQsZSxpKSk7dmFyIEk9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtdLGk9YS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4gYy50b2tlbk5hbWUodCl9KTtyZXR1cm4gYS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIGU9dC5uYW1lO2lmKGEuY29udGFpbnMoaSxlKSl7dmFyIG89bi5idWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3IodCk7ci5wdXNoKHttZXNzYWdlOm8sdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRSxydWxlTmFtZTplfSk7fX0pLHJ9KHQsbixpKSxQPW8ubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIGcodCxpKX0pLHg9ZnVuY3Rpb24odCxlKXt2YXIgbj1bXTtyZXR1cm4gYS5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIHI9bmV3IGwuTmFtZWREU0xNZXRob2RzQ29sbGVjdG9yVmlzaXRvcihcIlwiKTt0LmFjY2VwdChyKTt2YXIgaT1hLm1hcChyLnJlc3VsdCxmdW5jdGlvbih0KXtyZXR1cm4gdC5vcmdQcm9kfSk7bi5wdXNoKGEubWFwKGksZnVuY3Rpb24obil7cmV0dXJuIHYodCxuLGUpfSkpO30pLGEuZmxhdHRlbihuKX0odCxpKSxDPWZ1bmN0aW9uKHQsZSl7dmFyIG49W107cmV0dXJuIGEuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciByPW5ldyBsLk5hbWVkRFNMTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoXCJcIik7dC5hY2NlcHQocik7dmFyIGk9YS5ncm91cEJ5KHIucmVzdWx0LGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSxvPWEucGljayhpLGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aD4xfSk7YS5mb3JFYWNoKGEudmFsdWVzKG8pLGZ1bmN0aW9uKHIpe3ZhciBpPWEubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuIHQub3JnUHJvZH0pLG89ZS5idWlsZER1cGxpY2F0ZU5lc3RlZFJ1bGVOYW1lRXJyb3IodCxpKTtuLnB1c2goe21lc3NhZ2U6byx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfTkVTVEVEX05BTUUscnVsZU5hbWU6dC5uYW1lfSk7fSk7fSksbn0odCxpKSxNPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIEwodCxpKX0pLEY9YS5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gVCh0LGkpfSksYj1hLm1hcCh0LGZ1bmN0aW9uKGUpe3JldHVybiBfKGUsdCxwLGkpfSk7cmV0dXJuIG8uZmxhdHRlbihoLmNvbmNhdChQLHgsQyxOLGYsZCxBLEksTSxGLGIpKX0sZS5pZGVudGlmeVByb2R1Y3Rpb25Gb3JEdXBsaWNhdGVzPUU7dmFyIHk9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3ZhciBlPW51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztyZXR1cm4gZS5hbGxQcm9kdWN0aW9ucz1bXSxlfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXROb25UZXJtaW5hbD1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdE9wdGlvbj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeT1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2godCk7fSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0VGVybWluYWw9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZX0oZC5HQXN0VmlzaXRvcik7ZnVuY3Rpb24gVCh0LG4pe3ZhciByPVtdLGk9dC5uYW1lO3JldHVybiBpLm1hdGNoKGUudmFsaWRUZXJtc1BhdHRlcm4pfHxyLnB1c2goe21lc3NhZ2U6bi5idWlsZEludmFsaWRSdWxlTmFtZUVycm9yKHt0b3BMZXZlbFJ1bGU6dCxleHBlY3RlZFBhdHRlcm46ZS52YWxpZFRlcm1zUGF0dGVybn0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUlVMRV9OQU1FLHJ1bGVOYW1lOml9KSxyfWZ1bmN0aW9uIHYodCxuLHIpe3ZhciBpLG89W107cmV0dXJuIG4ubmFtZS5tYXRjaChlLnZhbGlkTmVzdGVkUnVsZU5hbWUpfHwoaT1yLmJ1aWxkSW52YWxpZE5lc3RlZFJ1bGVOYW1lRXJyb3IodCxuKSxvLnB1c2goe21lc3NhZ2U6aSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX05FU1RFRF9SVUxFX05BTUUscnVsZU5hbWU6dC5uYW1lfSkpLG99ZnVuY3Rpb24gZyh0LG4pe3ZhciByPVtdO3JldHVybiBjLnRva2VuTmFtZSh0KS5tYXRjaChlLnZhbGlkVGVybXNQYXR0ZXJuKXx8ci5wdXNoKHttZXNzYWdlOm4uYnVpbGRUb2tlbk5hbWVFcnJvcih7dG9rZW5UeXBlOnQsZXhwZWN0ZWRQYXR0ZXJuOmUudmFsaWRUZXJtc1BhdHRlcm59KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1RPS0VOX05BTUV9KSxyfWZ1bmN0aW9uIF8odCxlLG4scil7dmFyIGk9W107aWYoYS5yZWR1Y2UoZSxmdW5jdGlvbihlLG4pe3JldHVybiBuLm5hbWU9PT10Lm5hbWU/ZSsxOmV9LDApPjEpe3ZhciBvPXIuYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKHt0b3BMZXZlbFJ1bGU6dCxncmFtbWFyTmFtZTpufSk7aS5wdXNoKHttZXNzYWdlOm8sdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxydWxlTmFtZTp0Lm5hbWV9KTt9cmV0dXJuIGl9ZnVuY3Rpb24gUih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1bXSk7dmFyIGk9W10sYT1BKGUuZGVmaW5pdGlvbik7aWYoby5pc0VtcHR5KGEpKXJldHVybiBbXTt2YXIgdT10Lm5hbWU7by5jb250YWlucyhhLHQpJiZpLnB1c2goe21lc3NhZ2U6bi5idWlsZExlZnRSZWN1cnNpb25FcnJvcih7dG9wTGV2ZWxSdWxlOnQsbGVmdFJlY3Vyc2lvblBhdGg6cn0pLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFRlRfUkVDVVJTSU9OLHJ1bGVOYW1lOnV9KTt2YXIgYz1vLmRpZmZlcmVuY2UoYSxyLmNvbmNhdChbdF0pKSxwPW8ubWFwKGMsZnVuY3Rpb24oZSl7dmFyIGk9by5jbG9uZUFycihyKTtyZXR1cm4gaS5wdXNoKGUpLFIodCxlLG4saSl9KTtyZXR1cm4gaS5jb25jYXQoby5mbGF0dGVuKHApKX1mdW5jdGlvbiBBKHQpe3ZhciBlPVtdO2lmKG8uaXNFbXB0eSh0KSlyZXR1cm4gZTt2YXIgbj1vLmZpcnN0KHQpO2lmKG4gaW5zdGFuY2VvZiBmLk5vblRlcm1pbmFsKWUucHVzaChuLnJlZmVyZW5jZWRSdWxlKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBmLkZsYXR8fG4gaW5zdGFuY2VvZiBmLk9wdGlvbnx8biBpbnN0YW5jZW9mIGYuUmVwZXRpdGlvbk1hbmRhdG9yeXx8biBpbnN0YW5jZW9mIGYuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3J8fG4gaW5zdGFuY2VvZiBmLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yfHxuIGluc3RhbmNlb2YgZi5SZXBldGl0aW9uKWU9ZS5jb25jYXQoQShuLmRlZmluaXRpb24pKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBmLkFsdGVybmF0aW9uKWU9by5mbGF0dGVuKG8ubWFwKG4uZGVmaW5pdGlvbixmdW5jdGlvbih0KXtyZXR1cm4gQSh0LmRlZmluaXRpb24pfSkpO2Vsc2UgaWYoIShuIGluc3RhbmNlb2YgZi5UZXJtaW5hbCkpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTt2YXIgcj11LmlzT3B0aW9uYWxQcm9kKG4pLGk9dC5sZW5ndGg+MTtpZihyJiZpKXt2YXIgYT1vLmRyb3AodCk7cmV0dXJuIGUuY29uY2F0KEEoYSkpfXJldHVybiBlfWUuT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3I9eSxlLnZhbGlkVGVybXNQYXR0ZXJuPS9eW2EtekEtWl9dXFx3KiQvLGUudmFsaWROZXN0ZWRSdWxlTmFtZT1uZXcgUmVnRXhwKGUudmFsaWRUZXJtc1BhdHRlcm4uc291cmNlLnJlcGxhY2UoXCJeXCIsXCJeXFxcXCRcIikpLGUudmFsaWRhdGVSdWxlTmFtZT1ULGUudmFsaWRhdGVOZXN0ZWRSdWxlTmFtZT12LGUudmFsaWRhdGVUb2tlbk5hbWU9ZyxlLnZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3Q9XyxlLnZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbj1mdW5jdGlvbih0LGUsbil7dmFyIHIsaT1bXTtyZXR1cm4gby5jb250YWlucyhlLHQpfHwocj1cIkludmFsaWQgcnVsZSBvdmVycmlkZSwgcnVsZTogLT5cIit0K1wiPC0gY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gdGhlIGdyYW1tYXI6IC0+XCIrbitcIjwtYXMgaXQgaXMgbm90IGRlZmluZWQgaW4gYW55IG9mIHRoZSBzdXBlciBncmFtbWFycyBcIixpLnB1c2goe21lc3NhZ2U6cix0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1JVTEVfT1ZFUlJJREUscnVsZU5hbWU6dH0pKSxpfSxlLnZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uPVIsZS5nZXRGaXJzdE5vbmVUZXJtaW5hbD1BO3ZhciBOPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuYWx0ZXJuYXRpb25zPVtdLGV9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS52aXNpdEFsdGVybmF0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuYWx0ZXJuYXRpb25zLnB1c2godCk7fSxlfShkLkdBc3RWaXNpdG9yKTtmdW5jdGlvbiBPKHQsZSl7dmFyIG49bmV3IE47dC5hY2NlcHQobik7dmFyIHI9bi5hbHRlcm5hdGlvbnM7cmV0dXJuIG8ucmVkdWNlKHIsZnVuY3Rpb24obixyKXt2YXIgaT1vLmRyb3BSaWdodChyLmRlZmluaXRpb24pLGE9by5tYXAoaSxmdW5jdGlvbihuLGkpe3ZhciBhPWgubmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW25dLFtdLG51bGwsMSk7cmV0dXJuIG8uaXNFbXB0eShhKT97bWVzc2FnZTplLmJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yKHt0b3BMZXZlbFJ1bGU6dCxhbHRlcm5hdGlvbjpyLGVtcHR5Q2hvaWNlSWR4Oml9KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT05FX0xBU1RfRU1QVFlfQUxULHJ1bGVOYW1lOnQubmFtZSxvY2N1cnJlbmNlOnIuaWR4LGFsdGVybmF0aXZlOmkrMX06bnVsbH0pO3JldHVybiBuLmNvbmNhdChvLmNvbXBhY3QoYSkpfSxbXSl9ZnVuY3Rpb24gUyh0LGUsbixyKXt2YXIgaT1uZXcgTjt0LmFjY2VwdChpKTt2YXIgYz1pLmFsdGVybmF0aW9ucyxsPW5bdC5uYW1lXTtyZXR1cm4gbCYmKGM9YS5yZWplY3QoYyxmdW5jdGlvbih0KXtyZXR1cm4gbFt1LmdldFByb2R1Y3Rpb25Ec2xOYW1lKHQpKygwPT09dC5pZHg/XCJcIjp0LmlkeCldfSkpLG8ucmVkdWNlKGMsZnVuY3Rpb24obixpKXt2YXIgdT1pLmlkeCxjPXAuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcih1LHQsZSksbD1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1bXSx1PWEucmVkdWNlKHQsZnVuY3Rpb24oZSxuLHIpe3JldHVybiBhLmZvckVhY2gobixmdW5jdGlvbihuKXt2YXIgbz1bcl07YS5mb3JFYWNoKHQsZnVuY3Rpb24odCxlKXtyIT09ZSYmcC5jb250YWluc1BhdGgodCxuKSYmby5wdXNoKGUpO30pLG8ubGVuZ3RoPjEmJiFwLmNvbnRhaW5zUGF0aChpLG4pJiYoaS5wdXNoKG4pLGUucHVzaCh7YWx0czpvLHBhdGg6bn0pKTt9KSxlfSxbXSk7cmV0dXJuIG8ubWFwKHUsZnVuY3Rpb24odCl7dmFyIGk9YS5tYXAodC5hbHRzLGZ1bmN0aW9uKHQpe3JldHVybiB0KzF9KSxvPXIuYnVpbGRBbHRlcm5hdGlvbkFtYmlndWl0eUVycm9yKHt0b3BMZXZlbFJ1bGU6bixhbHRlcm5hdGlvbjplLGFtYmlndWl0eUluZGljZXM6aSxwcmVmaXhQYXRoOnQucGF0aH0pO3JldHVybiB7bWVzc2FnZTpvLHR5cGU6cy5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19BTFRTLHJ1bGVOYW1lOm4ubmFtZSxvY2N1cnJlbmNlOmUuaWR4LGFsdGVybmF0aXZlczpbdC5hbHRzXX19KX0oYyxpLHQsciksaD1QKGMsaSx0LHIpO3JldHVybiBuLmNvbmNhdChsLGgpfSxbXSl9ZS52YWxpZGF0ZUVtcHR5T3JBbHRlcm5hdGl2ZT1PLGUudmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcz1TO3ZhciBJPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuYWxsUHJvZHVjdGlvbnM9W10sZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHQpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0KTt9LGV9KGQuR0FzdFZpc2l0b3IpO2Z1bmN0aW9uIEwodCxlKXt2YXIgbj1uZXcgTjt0LmFjY2VwdChuKTt2YXIgcj1uLmFsdGVybmF0aW9ucztyZXR1cm4gby5yZWR1Y2UocixmdW5jdGlvbihuLHIpe3JldHVybiByLmRlZmluaXRpb24ubGVuZ3RoPjI1NSYmbi5wdXNoKHttZXNzYWdlOmUuYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3Ioe3RvcExldmVsUnVsZTp0LGFsdGVybmF0aW9uOnJ9KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5UT09fTUFOWV9BTFRTLHJ1bGVOYW1lOnQubmFtZSxvY2N1cnJlbmNlOnIuaWR4fSksbn0sW10pfWZ1bmN0aW9uIGsodCxlLG4pe3ZhciByPVtdO3JldHVybiBhLmZvckVhY2godCxmdW5jdGlvbih0KXt2YXIgaT1uZXcgSTt0LmFjY2VwdChpKTt2YXIgbz1pLmFsbFByb2R1Y3Rpb25zO2EuZm9yRWFjaChvLGZ1bmN0aW9uKGkpe3ZhciBvPXAuZ2V0UHJvZFR5cGUoaSksdT1pLmlkeCxjPXAuZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QodSx0LG8sZSlbMF07aWYoYS5pc0VtcHR5KGEuZmxhdHRlbihjKSkpe3ZhciBsPW4uYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcih7dG9wTGV2ZWxSdWxlOnQscmVwZXRpdGlvbjppfSk7ci5wdXNoKHttZXNzYWdlOmwsdHlwZTpzLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTk9OX0VNUFRZX0xPT0tBSEVBRCxydWxlTmFtZTp0Lm5hbWV9KTt9fSk7fSkscn1mdW5jdGlvbiBQKHQsZSxuLHIpe3ZhciBpPVtdLG89YS5yZWR1Y2UodCxmdW5jdGlvbih0LGUsbil7dmFyIHI9YS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge2lkeDpuLHBhdGg6dH19KTtyZXR1cm4gdC5jb25jYXQocil9LFtdKTtyZXR1cm4gYS5mb3JFYWNoKG8sZnVuY3Rpb24odCl7dmFyIHU9dC5pZHgsYz10LnBhdGgsbD1hLmZpbmRBbGwobyxmdW5jdGlvbih0KXtyZXR1cm4gdC5pZHg8dSYmcC5pc1N0cmljdFByZWZpeE9mUGF0aCh0LnBhdGgsYyl9KSxoPWEubWFwKGwsZnVuY3Rpb24odCl7dmFyIGk9W3QuaWR4KzEsdSsxXSxvPTA9PT1lLmlkeD9cIlwiOmUuaWR4O3JldHVybiB7bWVzc2FnZTpyLmJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcih7dG9wTGV2ZWxSdWxlOm4sYWx0ZXJuYXRpb246ZSxhbWJpZ3VpdHlJbmRpY2VzOmkscHJlZml4UGF0aDp0LnBhdGh9KSx0eXBlOnMuUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfUFJFRklYX0FMVFMscnVsZU5hbWU6bi5uYW1lLG9jY3VycmVuY2U6byxhbHRlcm5hdGl2ZXM6aX19KTtpPWkuY29uY2F0KGgpO30pLGl9ZS5SZXBldGlvbkNvbGxlY3Rvcj1JLGUudmFsaWRhdGVUb29NYW55QWx0cz1MLGUudmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoPWssZS5jaGVja1ByZWZpeEFsdGVybmF0aXZlc0FtYmlndWl0aWVzPVA7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbyxhPW4oMCkscz1uKDEzKSx1PW4oMTQpLGM9big3KSxwPW4oMSksbD1uKDUpOyFmdW5jdGlvbih0KXt0W3QuT1BUSU9OPTBdPVwiT1BUSU9OXCIsdFt0LlJFUEVUSVRJT049MV09XCJSRVBFVElUSU9OXCIsdFt0LlJFUEVUSVRJT05fTUFOREFUT1JZPTJdPVwiUkVQRVRJVElPTl9NQU5EQVRPUllcIix0W3QuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1I9M109XCJSRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUlwiLHRbdC5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SPTRdPVwiUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUlwiLHRbdC5BTFRFUk5BVElPTj01XT1cIkFMVEVSTkFUSU9OXCI7fShvPWUuUFJPRF9UWVBFfHwoZS5QUk9EX1RZUEU9e30pKSxlLmdldFByb2RUeXBlPWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBwLk9wdGlvbilyZXR1cm4gby5PUFRJT047aWYodCBpbnN0YW5jZW9mIHAuUmVwZXRpdGlvbilyZXR1cm4gby5SRVBFVElUSU9OO2lmKHQgaW5zdGFuY2VvZiBwLlJlcGV0aXRpb25NYW5kYXRvcnkpcmV0dXJuIG8uUkVQRVRJVElPTl9NQU5EQVRPUlk7aWYodCBpbnN0YW5jZW9mIHAuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpcmV0dXJuIG8uUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1I7aWYodCBpbnN0YW5jZW9mIHAuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpcmV0dXJuIG8uUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUjtpZih0IGluc3RhbmNlb2YgcC5BbHRlcm5hdGlvbilyZXR1cm4gby5BTFRFUk5BVElPTjt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfSxlLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yPWZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt2YXIgYT1FKHQsZSxuKTtyZXR1cm4gbyhhLHIsVChhKT9jLnRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXM6Yy50b2tlblN0cnVjdHVyZWRNYXRjaGVyLGkpfSxlLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZD1mdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9bSh0LGUsaSxuKSxzPVQoYSk/Yy50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzOmMudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtyZXR1cm4gbyhhWzBdLHMscil9LGUuYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPXQubGVuZ3RoLG89YS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10Lmxlbmd0aH0pfSk7aWYoZSlyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciByPWEubWFwKGUsZnVuY3Rpb24odCl7cmV0dXJuIHQuR0FURX0pLG89MDtvPGk7bysrKXt2YXIgcz10W29dLHU9cy5sZW5ndGgsYz1yW29dO2lmKHZvaWQgMD09PWN8fCExIT09Yy5jYWxsKHRoaXMpKXQ6Zm9yKHZhciBwPTA7cDx1O3ArKyl7Zm9yKHZhciBsPXNbcF0saD1sLmxlbmd0aCxmPTA7ZjxoO2YrKyl7dmFyIGQ9dGhpcy5MQShmKzEpO2lmKCExPT09bihkLGxbZl0pKWNvbnRpbnVlIHR9cmV0dXJuIG99fX07aWYobyYmIXIpe3ZhciBzPWEubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuZmxhdHRlbih0KX0pLHU9YS5yZWR1Y2UocyxmdW5jdGlvbih0LGUsbil7cmV0dXJuIGEuZm9yRWFjaChlLGZ1bmN0aW9uKGUpe2EuaGFzKHQsZS50b2tlblR5cGVJZHgpfHwodFtlLnRva2VuVHlwZUlkeF09biksYS5mb3JFYWNoKGUuY2F0ZWdvcnlNYXRjaGVzLGZ1bmN0aW9uKGUpe2EuaGFzKHQsZSl8fCh0W2VdPW4pO30pO30pLHR9LFtdKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgdD10aGlzLkxBKDEpO3JldHVybiB1W3QudG9rZW5UeXBlSWR4XX19cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTxpO2UrKyl7dmFyIHI9dFtlXSxvPXIubGVuZ3RoO3Q6Zm9yKHZhciBhPTA7YTxvO2ErKyl7Zm9yKHZhciBzPXJbYV0sdT1zLmxlbmd0aCxjPTA7Yzx1O2MrKyl7dmFyIHA9dGhpcy5MQShjKzEpO2lmKCExPT09bihwLHNbY10pKWNvbnRpbnVlIHR9cmV0dXJuIGV9fX19LGUuYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10Lmxlbmd0aH0pLGk9dC5sZW5ndGg7aWYociYmIW4pe3ZhciBvPWEuZmxhdHRlbih0KTtpZigxPT09by5sZW5ndGgmJmEuaXNFbXB0eShvWzBdLmNhdGVnb3J5TWF0Y2hlcykpe3ZhciBzPW9bMF0udG9rZW5UeXBlSWR4O3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzLkxBKDEpLnRva2VuVHlwZUlkeD09PXN9fXZhciB1PWEucmVkdWNlKG8sZnVuY3Rpb24odCxlLG4pe3JldHVybiB0W2UudG9rZW5UeXBlSWR4XT0hMCxhLmZvckVhY2goZS5jYXRlZ29yeU1hdGNoZXMsZnVuY3Rpb24oZSl7dFtlXT0hMDt9KSx0fSxbXSk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5MQSgxKTtyZXR1cm4gITA9PT11W3QudG9rZW5UeXBlSWR4XX19cmV0dXJuIGZ1bmN0aW9uKCl7dDpmb3IodmFyIG49MDtuPGk7bisrKXtmb3IodmFyIHI9dFtuXSxvPXIubGVuZ3RoLGE9MDthPG87YSsrKXt2YXIgcz10aGlzLkxBKGErMSk7aWYoITE9PT1lKHMsclthXSkpY29udGludWUgdH1yZXR1cm4gITB9cmV0dXJuICExfX07dmFyIGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4scil7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBpLnRvcFByb2Q9ZSxpLnRhcmdldE9jY3VycmVuY2U9bixpLnRhcmdldFByb2RUeXBlPXIsaX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnN0YXJ0V2Fsa2luZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhbGsodGhpcy50b3BQcm9kKSx0aGlzLnJlc3REZWZ9LGUucHJvdG90eXBlLmNoZWNrSXNUYXJnZXQ9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHQuaWR4PT09dGhpcy50YXJnZXRPY2N1cnJlbmNlJiZ0aGlzLnRhcmdldFByb2RUeXBlPT09ZSYmKHRoaXMucmVzdERlZj1uLmNvbmNhdChyKSwhMCl9LGUucHJvdG90eXBlLndhbGtPcHRpb249ZnVuY3Rpb24oZSxuLHIpe3RoaXMuY2hlY2tJc1RhcmdldChlLG8uT1BUSU9OLG4scil8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLGUsbixyKTt9LGUucHJvdG90eXBlLndhbGtBdExlYXN0T25lPWZ1bmN0aW9uKGUsbixyKXt0aGlzLmNoZWNrSXNUYXJnZXQoZSxvLlJFUEVUSVRJT05fTUFOREFUT1JZLG4scil8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLGUsbixyKTt9LGUucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwPWZ1bmN0aW9uKGUsbixyKXt0aGlzLmNoZWNrSXNUYXJnZXQoZSxvLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLG4scil8fHQucHJvdG90eXBlLndhbGtPcHRpb24uY2FsbCh0aGlzLGUsbixyKTt9LGUucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKGUsbixyKXt0aGlzLmNoZWNrSXNUYXJnZXQoZSxvLlJFUEVUSVRJT04sbixyKXx8dC5wcm90b3R5cGUud2Fsa09wdGlvbi5jYWxsKHRoaXMsZSxuLHIpO30sZS5wcm90b3R5cGUud2Fsa01hbnlTZXA9ZnVuY3Rpb24oZSxuLHIpe3RoaXMuY2hlY2tJc1RhcmdldChlLG8uUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUixuLHIpfHx0LnByb3RvdHlwZS53YWxrT3B0aW9uLmNhbGwodGhpcyxlLG4scik7fSxlfSh1LlJlc3RXYWxrZXIpLGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gci50YXJnZXRPY2N1cnJlbmNlPWUsci50YXJnZXRQcm9kVHlwZT1uLHIucmVzdWx0PVtdLHJ9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5jaGVja0lzVGFyZ2V0PWZ1bmN0aW9uKHQsZSl7dC5pZHg9PT10aGlzLnRhcmdldE9jY3VycmVuY2UmJnRoaXMudGFyZ2V0UHJvZFR5cGU9PT1lJiYodGhpcy5yZXN1bHQ9dC5kZWZpbml0aW9uKTt9LGUucHJvdG90eXBlLnZpc2l0T3B0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uT1BUSU9OKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbj1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLlJFUEVUSVRJT04pO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJc1RhcmdldCh0LG8uUkVQRVRJVElPTl9NQU5EQVRPUlkpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1mdW5jdGlvbih0KXt0aGlzLmNoZWNrSXNUYXJnZXQodCxvLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5SRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SKTt9LGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7dGhpcy5jaGVja0lzVGFyZ2V0KHQsby5BTFRFUk5BVElPTik7fSxlfShsLkdBc3RWaXNpdG9yKTtmdW5jdGlvbiBkKHQsZSl7ZnVuY3Rpb24gbih0LGUpe3JldHVybiBhLnJlZHVjZSh0LGZ1bmN0aW9uKHQsbixyKXtpZihyIT09ZSl7dmFyIGk9YS5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJ0aWFsUGF0aH0pO3JldHVybiB0LmNvbmNhdChpKX1yZXR1cm4gdH0sW10pfWZ1bmN0aW9uIHIodCxlKXtyZXR1cm4gdm9pZCAwPT09YS5maW5kKHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuZXZlcnkoZSxmdW5jdGlvbihlLG4pe3JldHVybiByPWUsaT10W25dLHI9PT1pfHxyJiZpJiYoci5jYXRlZ29yeU1hdGNoZXNNYXBbaS50b2tlblR5cGVJZHhdfHxpLmNhdGVnb3J5TWF0Y2hlc01hcFtyLnRva2VuVHlwZUlkeF0pO3ZhciByLGk7fSl9KX1mdW5jdGlvbiBpKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0O24rKyllLnB1c2goW10pO3JldHVybiBlfWZvcih2YXIgbz1hLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBzLnBvc3NpYmxlUGF0aHNGcm9tKFt0XSwxKX0pLHU9aShvLmxlbmd0aCksYz1vLHA9MTtwPD1lO3ArKyl7dmFyIGw9YztjPWkobC5sZW5ndGgpO2Zvcih2YXIgaD0wO2g8bC5sZW5ndGg7aCsrKWZvcih2YXIgZj1sW2hdLGQ9bihsLGgpLEU9MDtFPGYubGVuZ3RoO0UrKyl7dmFyIG09ZltFXS5wYXJ0aWFsUGF0aCxUPWZbRV0uc3VmZml4RGVmO2lmKHIoZCxtKXx8YS5pc0VtcHR5KFQpfHxtLmxlbmd0aD09PWUpe3ZhciB2PXVbaF07eSh2LG0pfHx2LnB1c2gobSk7fWVsc2Uge3ZhciBnPXMucG9zc2libGVQYXRoc0Zyb20oVCxwKzEsbSk7Y1toXT1jW2hdLmNvbmNhdChnKTt9fX1yZXR1cm4gdX1mdW5jdGlvbiBFKHQsZSxuKXt2YXIgcj1uZXcgZih0LG8uQUxURVJOQVRJT04pO3JldHVybiBlLmFjY2VwdChyKSxkKHIucmVzdWx0LG4pfWZ1bmN0aW9uIG0odCxlLG4scil7dmFyIGk9bmV3IGYodCxuKTtlLmFjY2VwdChpKTt2YXIgbz1pLnJlc3VsdCxhPW5ldyBoKGUsdCxuKS5zdGFydFdhbGtpbmcoKTtyZXR1cm4gZChbbmV3IHAuRmxhdCh7ZGVmaW5pdGlvbjpvfSksbmV3IHAuRmxhdCh7ZGVmaW5pdGlvbjphfSldLHIpfWZ1bmN0aW9uIHkodCxlKXtyZXR1cm4gdm9pZCAwIT09YS5maW5kKHQsZnVuY3Rpb24odCl7cmV0dXJuIGUubGVuZ3RoPT09dC5sZW5ndGgmJmEuZXZlcnkoZSxmdW5jdGlvbihlLG4pe3JldHVybiBlPT09dFtuXXx8dFtuXS5jYXRlZ29yeU1hdGNoZXNNYXBbZS50b2tlblR5cGVJZHhdfSl9KX1mdW5jdGlvbiBUKHQpe3JldHVybiBhLmV2ZXJ5KHQsZnVuY3Rpb24odCl7cmV0dXJuIGEuZXZlcnkodCxmdW5jdGlvbih0KXtyZXR1cm4gYS5ldmVyeSh0LGZ1bmN0aW9uKHQpe3JldHVybiBhLmlzRW1wdHkodC5jYXRlZ29yeU1hdGNoZXMpfSl9KX0pfWUubG9va0FoZWFkU2VxdWVuY2VGcm9tQWx0ZXJuYXRpdmVzPWQsZS5nZXRMb29rYWhlYWRQYXRoc0Zvck9yPUUsZS5nZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZD1tLGUuY29udGFpbnNQYXRoPXksZS5pc1N0cmljdFByZWZpeE9mUGF0aD1mdW5jdGlvbih0LGUpe3JldHVybiB0Lmxlbmd0aDxlLmxlbmd0aCYmYS5ldmVyeSh0LGZ1bmN0aW9uKHQsbil7dmFyIHI9ZVtuXTtyZXR1cm4gdD09PXJ8fHIuY2F0ZWdvcnlNYXRjaGVzTWFwW3QudG9rZW5UeXBlSWR4XX0pfSxlLmFyZVRva2VuQ2F0ZWdvcmllc05vdFVzZWQ9VDt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMTQpLGE9bigwKSxzPW4oMiksdT1uKDIxKSxjPW4oMSkscD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbil7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLnRvcFByb2Q9ZSxyLnBhdGg9bixyLnBvc3NpYmxlVG9rVHlwZXM9W10sci5uZXh0UHJvZHVjdGlvbk5hbWU9XCJcIixyLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZT0wLHIuZm91bmQ9ITEsci5pc0F0RW5kT2ZQYXRoPSExLHJ9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS5zdGFydFdhbGtpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLmZvdW5kPSExLHRoaXMucGF0aC5ydWxlU3RhY2tbMF0hPT10aGlzLnRvcFByb2QubmFtZSl0aHJvdyBFcnJvcihcIlRoZSBwYXRoIGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIHdhbGtlcidzIHRvcCBSdWxlIVwiKTtyZXR1cm4gdGhpcy5ydWxlU3RhY2s9YS5jbG9uZUFycih0aGlzLnBhdGgucnVsZVN0YWNrKS5yZXZlcnNlKCksdGhpcy5vY2N1cnJlbmNlU3RhY2s9YS5jbG9uZUFycih0aGlzLnBhdGgub2NjdXJyZW5jZVN0YWNrKS5yZXZlcnNlKCksdGhpcy5ydWxlU3RhY2sucG9wKCksdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCksdGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKSx0aGlzLndhbGsodGhpcy50b3BQcm9kKSx0aGlzLnBvc3NpYmxlVG9rVHlwZXN9LGUucHJvdG90eXBlLndhbGs9ZnVuY3Rpb24oZSxuKXt2b2lkIDA9PT1uJiYobj1bXSksdGhpcy5mb3VuZHx8dC5wcm90b3R5cGUud2Fsay5jYWxsKHRoaXMsZSxuKTt9LGUucHJvdG90eXBlLndhbGtQcm9kUmVmPWZ1bmN0aW9uKHQsZSxuKXtpZih0LnJlZmVyZW5jZWRSdWxlLm5hbWU9PT10aGlzLm5leHRQcm9kdWN0aW9uTmFtZSYmdC5pZHg9PT10aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSl7dmFyIHI9ZS5jb25jYXQobik7dGhpcy51cGRhdGVFeHBlY3RlZE5leHQoKSx0aGlzLndhbGsodC5yZWZlcmVuY2VkUnVsZSxyKTt9fSxlLnByb3RvdHlwZS51cGRhdGVFeHBlY3RlZE5leHQ9ZnVuY3Rpb24oKXthLmlzRW1wdHkodGhpcy5ydWxlU3RhY2spPyh0aGlzLm5leHRQcm9kdWN0aW9uTmFtZT1cIlwiLHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlPTAsdGhpcy5pc0F0RW5kT2ZQYXRoPSEwKToodGhpcy5uZXh0UHJvZHVjdGlvbk5hbWU9dGhpcy5ydWxlU3RhY2sucG9wKCksdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2U9dGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCkpO30sZX0oby5SZXN0V2Fsa2VyKTtlLkFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyPXA7dmFyIGw9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe3ZhciByPXQuY2FsbCh0aGlzLGUsbil8fHRoaXM7cmV0dXJuIHIucGF0aD1uLHIubmV4dFRlcm1pbmFsTmFtZT1cIlwiLHIubmV4dFRlcm1pbmFsT2NjdXJyZW5jZT0wLHIubmV4dFRlcm1pbmFsTmFtZT1zLnRva2VuTmFtZShyLnBhdGgubGFzdFRvayksci5uZXh0VGVybWluYWxPY2N1cnJlbmNlPXIucGF0aC5sYXN0VG9rT2NjdXJyZW5jZSxyfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLmlzQXRFbmRPZlBhdGgmJnMudG9rZW5OYW1lKHQudGVybWluYWxUeXBlKT09PXRoaXMubmV4dFRlcm1pbmFsTmFtZSYmdC5pZHg9PT10aGlzLm5leHRUZXJtaW5hbE9jY3VycmVuY2UmJiF0aGlzLmZvdW5kKXt2YXIgcj1lLmNvbmNhdChuKSxpPW5ldyBjLkZsYXQoe2RlZmluaXRpb246cn0pO3RoaXMucG9zc2libGVUb2tUeXBlcz11LmZpcnN0KGkpLHRoaXMuZm91bmQ9ITA7fX0sZX0ocCk7ZS5OZXh0QWZ0ZXJUb2tlbldhbGtlcj1sO3ZhciBoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxuKXt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIudG9wUnVsZT1lLHIub2NjdXJyZW5jZT1uLHIucmVzdWx0PXt0b2tlbjp2b2lkIDAsb2NjdXJyZW5jZTp2b2lkIDAsaXNFbmRPZlJ1bGU6dm9pZCAwfSxyfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUuc3RhcnRXYWxraW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud2Fsayh0aGlzLnRvcFJ1bGUpLHRoaXMucmVzdWx0fSxlfShvLlJlc3RXYWxrZXIpO2UuQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXI9aDt2YXIgZj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLndhbGtNYW55PWZ1bmN0aW9uKGUsbixyKXtpZihlLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGk9YS5maXJzdChuLmNvbmNhdChyKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9dm9pZCAwPT09aSxpIGluc3RhbmNlb2YgYy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWkudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9aS5pZHgpO31lbHNlIHQucHJvdG90eXBlLndhbGtNYW55LmNhbGwodGhpcyxlLG4scik7fSxlfShoKTtlLk5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlcj1mO3ZhciBkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUud2Fsa01hbnlTZXA9ZnVuY3Rpb24oZSxuLHIpe2lmKGUuaWR4PT09dGhpcy5vY2N1cnJlbmNlKXt2YXIgaT1hLmZpcnN0KG4uY29uY2F0KHIpKTt0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZT12b2lkIDA9PT1pLGkgaW5zdGFuY2VvZiBjLlRlcm1pbmFsJiYodGhpcy5yZXN1bHQudG9rZW49aS50ZXJtaW5hbFR5cGUsdGhpcy5yZXN1bHQub2NjdXJyZW5jZT1pLmlkeCk7fWVsc2UgdC5wcm90b3R5cGUud2Fsa01hbnlTZXAuY2FsbCh0aGlzLGUsbixyKTt9LGV9KGgpO2UuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyPWQ7dmFyIEU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBudWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGkoZSx0KSxlLnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZT1mdW5jdGlvbihlLG4scil7aWYoZS5pZHg9PT10aGlzLm9jY3VycmVuY2Upe3ZhciBpPWEuZmlyc3Qobi5jb25jYXQocikpO3RoaXMucmVzdWx0LmlzRW5kT2ZSdWxlPXZvaWQgMD09PWksaSBpbnN0YW5jZW9mIGMuVGVybWluYWwmJih0aGlzLnJlc3VsdC50b2tlbj1pLnRlcm1pbmFsVHlwZSx0aGlzLnJlc3VsdC5vY2N1cnJlbmNlPWkuaWR4KTt9ZWxzZSB0LnByb3RvdHlwZS53YWxrQXRMZWFzdE9uZS5jYWxsKHRoaXMsZSxuLHIpO30sZX0oaCk7ZS5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXI9RTt2YXIgbT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwPWZ1bmN0aW9uKGUsbixyKXtpZihlLmlkeD09PXRoaXMub2NjdXJyZW5jZSl7dmFyIGk9YS5maXJzdChuLmNvbmNhdChyKSk7dGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGU9dm9pZCAwPT09aSxpIGluc3RhbmNlb2YgYy5UZXJtaW5hbCYmKHRoaXMucmVzdWx0LnRva2VuPWkudGVybWluYWxUeXBlLHRoaXMucmVzdWx0Lm9jY3VycmVuY2U9aS5pZHgpO31lbHNlIHQucHJvdG90eXBlLndhbGtBdExlYXN0T25lU2VwLmNhbGwodGhpcyxlLG4scik7fSxlfShoKTtmdW5jdGlvbiB5KHQsZSxuLHIpe3ZhciBpPWEuY2xvbmVBcnIobik7aS5wdXNoKHQubmFtZSk7dmFyIG89YS5jbG9uZUFycihyKTtyZXR1cm4gby5wdXNoKDEpLHtpZHg6ZSxkZWY6dC5kZWZpbml0aW9uLHJ1bGVTdGFjazppLG9jY3VycmVuY2VTdGFjazpvfX1lLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcj1tLGUucG9zc2libGVQYXRoc0Zyb209ZnVuY3Rpb24gdChlLG4scil7dm9pZCAwPT09ciYmKHI9W10pLHI9YS5jbG9uZUFycihyKTt2YXIgaT1bXSxvPTA7ZnVuY3Rpb24gcyhzKXt2YXIgdT10KHMuY29uY2F0KGEuZHJvcChlLG8rMSkpLG4scik7cmV0dXJuIGkuY29uY2F0KHUpfWZvcig7ci5sZW5ndGg8biYmbzxlLmxlbmd0aDspe3ZhciB1PWVbb107aWYodSBpbnN0YW5jZW9mIGMuRmxhdClyZXR1cm4gcyh1LmRlZmluaXRpb24pO2lmKHUgaW5zdGFuY2VvZiBjLk5vblRlcm1pbmFsKXJldHVybiBzKHUuZGVmaW5pdGlvbik7aWYodSBpbnN0YW5jZW9mIGMuT3B0aW9uKWk9cyh1LmRlZmluaXRpb24pO2Vsc2Uge2lmKHUgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25NYW5kYXRvcnkpcmV0dXJuIHMocD11LmRlZmluaXRpb24uY29uY2F0KFtuZXcgYy5SZXBldGl0aW9uKHtkZWZpbml0aW9uOnUuZGVmaW5pdGlvbn0pXSkpO2lmKHUgaW5zdGFuY2VvZiBjLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXJldHVybiBzKHA9W25ldyBjLkZsYXQoe2RlZmluaXRpb246dS5kZWZpbml0aW9ufSksbmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbbmV3IGMuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTp1LnNlcGFyYXRvcn0pXS5jb25jYXQodS5kZWZpbml0aW9uKX0pXSk7aWYodSBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Ipe3ZhciBwPXUuZGVmaW5pdGlvbi5jb25jYXQoW25ldyBjLlJlcGV0aXRpb24oe2RlZmluaXRpb246W25ldyBjLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6dS5zZXBhcmF0b3J9KV0uY29uY2F0KHUuZGVmaW5pdGlvbil9KV0pO2k9cyhwKTt9ZWxzZSBpZih1IGluc3RhbmNlb2YgYy5SZXBldGl0aW9uKXA9dS5kZWZpbml0aW9uLmNvbmNhdChbbmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjp1LmRlZmluaXRpb259KV0pLGk9cyhwKTtlbHNlIHtpZih1IGluc3RhbmNlb2YgYy5BbHRlcm5hdGlvbilyZXR1cm4gYS5mb3JFYWNoKHUuZGVmaW5pdGlvbixmdW5jdGlvbih0KXtpPXModC5kZWZpbml0aW9uKTt9KSxpO2lmKCEodSBpbnN0YW5jZW9mIGMuVGVybWluYWwpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7ci5wdXNoKHUudGVybWluYWxUeXBlKTt9fW8rKzt9cmV0dXJuIGkucHVzaCh7cGFydGlhbFBhdGg6cixzdWZmaXhEZWY6YS5kcm9wKGUsbyl9KSxpfSxlLm5leHRQb3NzaWJsZVRva2Vuc0FmdGVyPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVtcIkVYSVRfTk9ORV9URVJNSU5BTFwiXSxvPSExLHM9ZS5sZW5ndGgsdT1zLXItMSxwPVtdLGw9W107Zm9yKGwucHVzaCh7aWR4Oi0xLGRlZjp0LHJ1bGVTdGFjazpbXSxvY2N1cnJlbmNlU3RhY2s6W119KTshYS5pc0VtcHR5KGwpOyl7dmFyIGg9bC5wb3AoKTtpZihcIkVYSVRfQUxURVJOQVRJVkVcIiE9PWgpe3ZhciBmPWguZGVmLGQ9aC5pZHgsRT1oLnJ1bGVTdGFjayxtPWgub2NjdXJyZW5jZVN0YWNrO2lmKCFhLmlzRW1wdHkoZikpe3ZhciBUPWZbMF07aWYoXCJFWElUX05PTkVfVEVSTUlOQUxcIj09PVQpe3ZhciB2PXtpZHg6ZCxkZWY6YS5kcm9wKGYpLHJ1bGVTdGFjazphLmRyb3BSaWdodChFKSxvY2N1cnJlbmNlU3RhY2s6YS5kcm9wUmlnaHQobSl9O2wucHVzaCh2KTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5UZXJtaW5hbClpZihkPHMtMSl7dmFyIGc9ZCsxO24oZVtnXSxULnRlcm1pbmFsVHlwZSkmJih2PXtpZHg6ZyxkZWY6YS5kcm9wKGYpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSxsLnB1c2godikpO31lbHNlIHtpZihkIT09cy0xKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7cC5wdXNoKHtuZXh0VG9rZW5UeXBlOlQudGVybWluYWxUeXBlLG5leHRUb2tlbk9jY3VycmVuY2U6VC5pZHgscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19KSxvPSEwO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLk5vblRlcm1pbmFsKXt2YXIgXz1hLmNsb25lQXJyKEUpO18ucHVzaChULm5vblRlcm1pbmFsTmFtZSk7dmFyIFI9YS5jbG9uZUFycihtKTtSLnB1c2goVC5pZHgpLHY9e2lkeDpkLGRlZjpULmRlZmluaXRpb24uY29uY2F0KGksYS5kcm9wKGYpKSxydWxlU3RhY2s6XyxvY2N1cnJlbmNlU3RhY2s6Un0sbC5wdXNoKHYpO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLk9wdGlvbil7dmFyIEE9e2lkeDpkLGRlZjphLmRyb3AoZikscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19O2wucHVzaChBKSxsLnB1c2goXCJFWElUX0FMVEVSTkFUSVZFXCIpO3ZhciBOPXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfTtsLnB1c2goTik7fWVsc2UgaWYoVCBpbnN0YW5jZW9mIGMuUmVwZXRpdGlvbk1hbmRhdG9yeSl7dmFyIE89bmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpULmRlZmluaXRpb24saWR4OlQuaWR4fSk7dj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoW09dLGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaCh2KTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcil7dmFyIFM9bmV3IGMuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTpULnNlcGFyYXRvcn0pO089bmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbU10uY29uY2F0KFQuZGVmaW5pdGlvbiksaWR4OlQuaWR4fSksdj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoW09dLGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaCh2KTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcil7QT17aWR4OmQsZGVmOmEuZHJvcChmKSxydWxlU3RhY2s6RSxvY2N1cnJlbmNlU3RhY2s6bX0sbC5wdXNoKEEpLGwucHVzaChcIkVYSVRfQUxURVJOQVRJVkVcIiksUz1uZXcgYy5UZXJtaW5hbCh7dGVybWluYWxUeXBlOlQuc2VwYXJhdG9yfSk7dmFyIEk9bmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpbU10uY29uY2F0KFQuZGVmaW5pdGlvbiksaWR4OlQuaWR4fSk7Tj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoW0ldLGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaChOKTt9ZWxzZSBpZihUIGluc3RhbmNlb2YgYy5SZXBldGl0aW9uKUE9e2lkeDpkLGRlZjphLmRyb3AoZikscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaChBKSxsLnB1c2goXCJFWElUX0FMVEVSTkFUSVZFXCIpLEk9bmV3IGMuUmVwZXRpdGlvbih7ZGVmaW5pdGlvbjpULmRlZmluaXRpb24saWR4OlQuaWR4fSksTj17aWR4OmQsZGVmOlQuZGVmaW5pdGlvbi5jb25jYXQoW0ldLGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19LGwucHVzaChOKTtlbHNlIGlmKFQgaW5zdGFuY2VvZiBjLkFsdGVybmF0aW9uKWZvcih2YXIgTD1ULmRlZmluaXRpb24ubGVuZ3RoLTE7TD49MDtMLS0pe3ZhciBrPXtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uW0xdLmRlZmluaXRpb24uY29uY2F0KGEuZHJvcChmKSkscnVsZVN0YWNrOkUsb2NjdXJyZW5jZVN0YWNrOm19O2wucHVzaChrKSxsLnB1c2goXCJFWElUX0FMVEVSTkFUSVZFXCIpO31lbHNlIGlmKFQgaW5zdGFuY2VvZiBjLkZsYXQpbC5wdXNoKHtpZHg6ZCxkZWY6VC5kZWZpbml0aW9uLmNvbmNhdChhLmRyb3AoZikpLHJ1bGVTdGFjazpFLG9jY3VycmVuY2VTdGFjazptfSk7ZWxzZSB7aWYoIShUIGluc3RhbmNlb2YgYy5SdWxlKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO2wucHVzaCh5KFQsZCxFLG0pKTt9fX1lbHNlIG8mJmEubGFzdChsKS5pZHg8PXUmJmwucG9wKCk7fXJldHVybiBwfTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9bigxKSxvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUud2Fsaz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dm9pZCAwPT09ZSYmKGU9W10pLHIuZm9yRWFjaCh0LmRlZmluaXRpb24sZnVuY3Rpb24obyxhKXt2YXIgcz1yLmRyb3AodC5kZWZpbml0aW9uLGErMSk7aWYobyBpbnN0YW5jZW9mIGkuTm9uVGVybWluYWwpbi53YWxrUHJvZFJlZihvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5UZXJtaW5hbCluLndhbGtUZXJtaW5hbChvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5GbGF0KW4ud2Fsa0ZsYXQobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuT3B0aW9uKW4ud2Fsa09wdGlvbihvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5SZXBldGl0aW9uTWFuZGF0b3J5KW4ud2Fsa0F0TGVhc3RPbmUobyxzLGUpO2Vsc2UgaWYobyBpbnN0YW5jZW9mIGkuUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Ipbi53YWxrQXRMZWFzdE9uZVNlcChvLHMsZSk7ZWxzZSBpZihvIGluc3RhbmNlb2YgaS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvciluLndhbGtNYW55U2VwKG8scyxlKTtlbHNlIGlmKG8gaW5zdGFuY2VvZiBpLlJlcGV0aXRpb24pbi53YWxrTWFueShvLHMsZSk7ZWxzZSB7aWYoIShvIGluc3RhbmNlb2YgaS5BbHRlcm5hdGlvbikpdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtuLndhbGtPcihvLHMsZSk7fX0pO30sdC5wcm90b3R5cGUud2Fsa1Rlcm1pbmFsPWZ1bmN0aW9uKHQsZSxuKXt9LHQucHJvdG90eXBlLndhbGtQcm9kUmVmPWZ1bmN0aW9uKHQsZSxuKXt9LHQucHJvdG90eXBlLndhbGtGbGF0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1lLmNvbmNhdChuKTt0aGlzLndhbGsodCxyKTt9LHQucHJvdG90eXBlLndhbGtPcHRpb249ZnVuY3Rpb24odCxlLG4pe3ZhciByPWUuY29uY2F0KG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtuZXcgaS5PcHRpb24oe2RlZmluaXRpb246dC5kZWZpbml0aW9ufSldLmNvbmNhdChlLG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa0F0TGVhc3RPbmVTZXA9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWEodCxlLG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa01hbnk9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtuZXcgaS5PcHRpb24oe2RlZmluaXRpb246dC5kZWZpbml0aW9ufSldLmNvbmNhdChlLG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa01hbnlTZXA9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWEodCxlLG4pO3RoaXMud2Fsayh0LHIpO30sdC5wcm90b3R5cGUud2Fsa09yPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz10aGlzLGE9ZS5jb25jYXQobik7ci5mb3JFYWNoKHQuZGVmaW5pdGlvbixmdW5jdGlvbih0KXt2YXIgZT1uZXcgaS5GbGF0KHtkZWZpbml0aW9uOlt0XX0pO28ud2FsayhlLGEpO30pO30sdH0oKTtmdW5jdGlvbiBhKHQsZSxuKXtyZXR1cm4gW25ldyBpLk9wdGlvbih7ZGVmaW5pdGlvbjpbbmV3IGkuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTp0LnNlcGFyYXRvcn0pXS5jb25jYXQodC5kZWZpbml0aW9uKX0pXS5jb25jYXQoZSxuKX1lLlJlc3RXYWxrZXI9bzt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDI3KSxpPW4oMCksbz1uKDcpLGE9bigyMCk7IWZ1bmN0aW9uKHQpe3RbdC5NSVNTSU5HX1BBVFRFUk49MF09XCJNSVNTSU5HX1BBVFRFUk5cIix0W3QuSU5WQUxJRF9QQVRURVJOPTFdPVwiSU5WQUxJRF9QQVRURVJOXCIsdFt0LkVPSV9BTkNIT1JfRk9VTkQ9Ml09XCJFT0lfQU5DSE9SX0ZPVU5EXCIsdFt0LlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EPTNdPVwiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIix0W3QuRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EPTRdPVwiRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EXCIsdFt0LklOVkFMSURfR1JPVVBfVFlQRV9GT1VORD01XT1cIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiLHRbdC5QVVNIX01PREVfRE9FU19OT1RfRVhJU1Q9Nl09XCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIix0W3QuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERT03XT1cIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIix0W3QuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZPThdPVwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCIsdFt0Lk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUPTldPVwiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIix0W3QuTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORUQ9MTBdPVwiTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIix0W3QuU09JX0FOQ0hPUl9GT1VORD0xMV09XCJTT0lfQU5DSE9SX0ZPVU5EXCIsdFt0LkVNUFRZX01BVENIX1BBVFRFUk49MTJdPVwiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiLHRbdC5OT19MSU5FX0JSRUFLU19GTEFHUz0xM109XCJOT19MSU5FX0JSRUFLU19GTEFHU1wiLHRbdC5VTlJFQUNIQUJMRV9QQVRURVJOPTE0XT1cIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIix0W3QuSURFTlRJRllfVEVSTUlOQVRPUj0xNV09XCJJREVOVElGWV9URVJNSU5BVE9SXCIsdFt0LkNVU1RPTV9MSU5FX0JSRUFLPTE2XT1cIkNVU1RPTV9MSU5FX0JSRUFLXCI7fShlLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZXx8KGUuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlPXt9KSk7dmFyIHM9e2RlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nOiExLHBvc2l0aW9uVHJhY2tpbmc6XCJmdWxsXCIsbGluZVRlcm1pbmF0b3JzUGF0dGVybjovXFxufFxcclxcbj8vZyxsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6W1wiXFxuXCIsXCJcXHJcIl0sZW5zdXJlT3B0aW1pemF0aW9uczohMSxzYWZlTW9kZTohMSxlcnJvck1lc3NhZ2VQcm92aWRlcjphLmRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXJ9O09iamVjdC5mcmVlemUocyk7dmFyIHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dmFyIG49dGhpcztpZih2b2lkIDA9PT1lJiYoZT1zKSx0aGlzLmxleGVyRGVmaW5pdGlvbj10LHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzPVtdLHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZz1bXSx0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZz17fSx0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc9e30sdGhpcy5tb2Rlcz1bXSx0aGlzLmVtcHR5R3JvdXBzPXt9LHRoaXMuY29uZmlnPXZvaWQgMCx0aGlzLnRyYWNrU3RhcnRMaW5lcz0hMCx0aGlzLnRyYWNrRW5kTGluZXM9ITAsdGhpcy5oYXNDdXN0b209ITEsdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWQ9e30sXCJib29sZWFuXCI9PXR5cGVvZiBlKXRocm93IEVycm9yKFwiVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGV4ZXIgY29uc3RydWN0b3IgaXMgbm93IGFuIElMZXhlckNvbmZpZyBPYmplY3QuXFxuYSBib29sZWFuIDJuZCBhcmd1bWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO2lmKHRoaXMuY29uZmlnPWkubWVyZ2UocyxlKSx0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuPT09cy5saW5lVGVybWluYXRvcnNQYXR0ZXJuKXRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm49ci5MaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlcjtlbHNlIGlmKHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycz09PXMubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKXRocm93IEVycm9yKFwiRXJyb3I6IE1pc3NpbmcgPGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycz4gcHJvcGVydHkgb24gdGhlIExleGVyIGNvbmZpZy5cXG5cXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI01JU1NJTkdfTElORV9URVJNX0NIQVJTXCIpO2lmKGUuc2FmZU1vZGUmJmUuZW5zdXJlT3B0aW1pemF0aW9ucyl0aHJvdyBFcnJvcignXCJzYWZlTW9kZVwiIGFuZCBcImVuc3VyZU9wdGltaXphdGlvbnNcIiBmbGFncyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO3RoaXMudHJhY2tTdGFydExpbmVzPS9mdWxsfG9ubHlTdGFydC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyksdGhpcy50cmFja0VuZExpbmVzPS9mdWxsL2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKTt2YXIgYSx1PSEwO2kuaXNBcnJheSh0KT8oKGE9e21vZGVzOnt9fSkubW9kZXNbci5ERUZBVUxUX01PREVdPWkuY2xvbmVBcnIodCksYVtyLkRFRkFVTFRfTU9ERV09ci5ERUZBVUxUX01PREUpOih1PSExLGE9aS5jbG9uZU9iaih0KSksdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnM9dGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KHIucGVyZm9ybVJ1bnRpbWVDaGVja3MoYSx0aGlzLnRyYWNrU3RhcnRMaW5lcyx0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKSx0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmc9dGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLmNvbmNhdChyLnBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhhLHRoaXMudHJhY2tTdGFydExpbmVzLHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykpLGEubW9kZXM9YS5tb2Rlcz9hLm1vZGVzOnt9LGkuZm9yRWFjaChhLm1vZGVzLGZ1bmN0aW9uKHQsZSl7YS5tb2Rlc1tlXT1pLnJlamVjdCh0LGZ1bmN0aW9uKHQpe3JldHVybiBpLmlzVW5kZWZpbmVkKHQpfSk7fSk7dmFyIGM9aS5rZXlzKGEubW9kZXMpO2lmKGkuZm9yRWFjaChhLm1vZGVzLGZ1bmN0aW9uKHQsYSl7aWYobi5tb2Rlcy5wdXNoKGEpLG4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzPW4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChyLnZhbGlkYXRlUGF0dGVybnModCxjKSksaS5pc0VtcHR5KG4ubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSl7by5hdWdtZW50VG9rZW5UeXBlcyh0KTt2YXIgcz1yLmFuYWx5emVUb2tlblR5cGVzKHQse2xpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczpuLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMscG9zaXRpb25UcmFja2luZzplLnBvc2l0aW9uVHJhY2tpbmcsZW5zdXJlT3B0aW1pemF0aW9uczplLmVuc3VyZU9wdGltaXphdGlvbnMsc2FmZU1vZGU6ZS5zYWZlTW9kZX0pO24ucGF0dGVybklkeFRvQ29uZmlnW2FdPXMucGF0dGVybklkeFRvQ29uZmlnLG4uY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1thXT1zLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcsbi5lbXB0eUdyb3Vwcz1pLm1lcmdlKG4uZW1wdHlHcm91cHMscy5lbXB0eUdyb3Vwcyksbi5oYXNDdXN0b209cy5oYXNDdXN0b218fG4uaGFzQ3VzdG9tLG4uY2FuTW9kZUJlT3B0aW1pemVkW2FdPXMuY2FuQmVPcHRpbWl6ZWQ7fX0pLHRoaXMuZGVmYXVsdE1vZGU9YS5kZWZhdWx0TW9kZSwhaS5pc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSYmIXRoaXMuY29uZmlnLmRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nKXt2YXIgcD1pLm1hcCh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tZXNzYWdlfSkuam9pbihcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpO3Rocm93IG5ldyBFcnJvcihcIkVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiK3ApfWlmKGkuZm9yRWFjaCh0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcsZnVuY3Rpb24odCl7aS5QUklOVF9XQVJOSU5HKHQubWVzc2FnZSk7fSksci5TVVBQT1JUX1NUSUNLWT8odGhpcy5jaG9wSW5wdXQ9aS5JREVOVElUWSx0aGlzLm1hdGNoPXRoaXMubWF0Y2hXaXRoVGVzdCk6KHRoaXMudXBkYXRlTGFzdEluZGV4PWkuTk9PUCx0aGlzLm1hdGNoPXRoaXMubWF0Y2hXaXRoRXhlYyksdSYmKHRoaXMuaGFuZGxlTW9kZXM9aS5OT09QKSwhMT09PXRoaXMudHJhY2tTdGFydExpbmVzJiYodGhpcy5jb21wdXRlTmV3Q29sdW1uPWkuSURFTlRJVFkpLCExPT09dGhpcy50cmFja0VuZExpbmVzJiYodGhpcy51cGRhdGVUb2tlbkVuZExpbmVDb2x1bW5Mb2NhdGlvbj1pLk5PT1ApLC9mdWxsL2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSl0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2U9dGhpcy5jcmVhdGVGdWxsVG9rZW47ZWxzZSBpZigvb25seVN0YXJ0L2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSl0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2U9dGhpcy5jcmVhdGVTdGFydE9ubHlUb2tlbjtlbHNlIHtpZighL29ubHlPZmZzZXQvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKXRocm93IEVycm9yKCdJbnZhbGlkIDxwb3NpdGlvblRyYWNraW5nPiBjb25maWcgb3B0aW9uOiBcIicrdGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZysnXCInKTt0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2U9dGhpcy5jcmVhdGVPZmZzZXRPbmx5VG9rZW47fXRoaXMuaGFzQ3VzdG9tP3RoaXMuYWRkVG9rZW49dGhpcy5hZGRUb2tlblVzaW5nUHVzaDp0aGlzLmFkZFRva2VuPXRoaXMuYWRkVG9rZW5Vc2luZ01lbWJlckFjY2Vzczt2YXIgbD1pLnJlZHVjZSh0aGlzLmNhbk1vZGVCZU9wdGltaXplZCxmdW5jdGlvbih0LGUsbil7cmV0dXJuICExPT09ZSYmdC5wdXNoKG4pLHR9LFtdKTtpZihlLmVuc3VyZU9wdGltaXphdGlvbnMmJiFpLmlzRW1wdHkobCkpdGhyb3cgRXJyb3IoXCJMZXhlciBNb2RlczogPCBcIitsLmpvaW4oXCIsIFwiKSsnID4gY2Fubm90IGJlIG9wdGltaXplZC5cXG5cXHQgRGlzYWJsZSB0aGUgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgbGV4ZXIgY29uZmlnIGZsYWcgdG8gc2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIHJ1biB0aGUgbGV4ZXIgaW4gYW4gdW4tb3B0aW1pemVkIG1vZGUuXFxuXFx0IE9yIGluc3BlY3QgdGhlIGNvbnNvbGUgbG9nIGZvciBkZXRhaWxzIG9uIGhvdyB0byByZXNvbHZlIHRoZXNlIGlzc3Vlcy4nKX1yZXR1cm4gdC5wcm90b3R5cGUudG9rZW5pemU9ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT10aGlzLmRlZmF1bHRNb2RlKSwhaS5pc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSl7dmFyIG49aS5tYXAodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gVG9rZW5pemUgYmVjYXVzZSBFcnJvcnMgZGV0ZWN0ZWQgaW4gZGVmaW5pdGlvbiBvZiBMZXhlcjpcXG5cIituKX1yZXR1cm4gdGhpcy50b2tlbml6ZUludGVybmFsKHQsZSl9LHQucHJvdG90eXBlLnRva2VuaXplSW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbixvLGEscyx1LGMscCxsLGgsZixkLEUsbT10aGlzLHk9dCxUPXkubGVuZ3RoLHY9MCxnPTAsXz10aGlzLmhhc0N1c3RvbT8wOk1hdGguZmxvb3IodC5sZW5ndGgvMTApLFI9bmV3IEFycmF5KF8pLEE9W10sTj10aGlzLnRyYWNrU3RhcnRMaW5lcz8xOnZvaWQgMCxPPXRoaXMudHJhY2tTdGFydExpbmVzPzE6dm9pZCAwLFM9ci5jbG9uZUVtcHR5R3JvdXBzKHRoaXMuZW1wdHlHcm91cHMpLEk9dGhpcy50cmFja1N0YXJ0TGluZXMsTD10aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuLGs9MCxQPVtdLHg9W10sQz1bXSxNPVtdO09iamVjdC5mcmVlemUoTSk7dmFyIEYsYj12b2lkIDAsRD1mdW5jdGlvbih0KXtpZigxPT09Qy5sZW5ndGgmJnZvaWQgMD09PXQudG9rZW5UeXBlLlBVU0hfTU9ERSl7dmFyIGU9bS5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UodCk7QS5wdXNoKHtvZmZzZXQ6dC5zdGFydE9mZnNldCxsaW5lOnZvaWQgMCE9PXQuc3RhcnRMaW5lP3Quc3RhcnRMaW5lOnZvaWQgMCxjb2x1bW46dm9pZCAwIT09dC5zdGFydENvbHVtbj90LnN0YXJ0Q29sdW1uOnZvaWQgMCxsZW5ndGg6dC5pbWFnZS5sZW5ndGgsbWVzc2FnZTplfSk7fWVsc2Uge0MucG9wKCk7dmFyIG49aS5sYXN0KEMpO1A9bS5wYXR0ZXJuSWR4VG9Db25maWdbbl0seD1tLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbbl0saz1QLmxlbmd0aDt2YXIgcj1tLmNhbk1vZGVCZU9wdGltaXplZFtuXSYmITE9PT1tLmNvbmZpZy5zYWZlTW9kZTtiPXgmJnI/ZnVuY3Rpb24odCl7dmFyIGU9eFt0XTtyZXR1cm4gdm9pZCAwPT09ZT9NOmV9OmZ1bmN0aW9uKCl7cmV0dXJuIFB9O319O2Z1bmN0aW9uIHcodCl7Qy5wdXNoKHQpLHg9dGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW3RdLFA9dGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbdF0saz1QLmxlbmd0aCxrPVAubGVuZ3RoO3ZhciBlPXRoaXMuY2FuTW9kZUJlT3B0aW1pemVkW3RdJiYhMT09PXRoaXMuY29uZmlnLnNhZmVNb2RlO2I9eCYmZT9mdW5jdGlvbih0KXt2YXIgZT14W3RdO3JldHVybiB2b2lkIDA9PT1lP006ZX06ZnVuY3Rpb24oKXtyZXR1cm4gUH07fWZvcih3LmNhbGwodGhpcyxlKTt2PFQ7KXt1PW51bGw7dmFyIFU9eS5jaGFyQ29kZUF0KHYpLEc9YihVKSxCPUcubGVuZ3RoO2ZvcihuPTA7bjxCO24rKyl7dmFyIEs9KEY9R1tuXSkucGF0dGVybjtpZighMSE9PShaPUYuc2hvcnQpP1U9PT1aJiYodT1LKTohMD09PUYuaXNDdXN0b20/dT1udWxsIT09KEU9Sy5leGVjKHksdixSLFMpKT9FWzBdOkU6KHRoaXMudXBkYXRlTGFzdEluZGV4KEssdiksdT10aGlzLm1hdGNoKEssdCx2KSksbnVsbCE9PXUpe2lmKHZvaWQgMCE9PShzPUYubG9uZ2VyQWx0KSl7dmFyIFc9UFtzXSxqPVcucGF0dGVybjshMD09PVcuaXNDdXN0b20/YT1udWxsIT09KEU9ai5leGVjKHksdixSLFMpKT9FWzBdOkU6KHRoaXMudXBkYXRlTGFzdEluZGV4KGosdiksYT10aGlzLm1hdGNoKGosdCx2KSksYSYmYS5sZW5ndGg+dS5sZW5ndGgmJih1PWEsRj1XKTt9YnJlYWt9fWlmKG51bGwhPT11KXtpZihjPXUubGVuZ3RoLHZvaWQgMCE9PShwPUYuZ3JvdXApJiYobD1GLnRva2VuVHlwZUlkeCxoPXRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSh1LHYsbCxGLnRva2VuVHlwZSxOLE8sYyksITE9PT1wP2c9dGhpcy5hZGRUb2tlbihSLGcsaCk6U1twXS5wdXNoKGgpKSx0PXRoaXMuY2hvcElucHV0KHQsYyksdis9YyxPPXRoaXMuY29tcHV0ZU5ld0NvbHVtbihPLGMpLCEwPT09SSYmITA9PT1GLmNhbkxpbmVUZXJtaW5hdG9yKXt2YXIgVj0wLFk9dm9pZCAwLEg9dm9pZCAwO0wubGFzdEluZGV4PTA7ZG97ITA9PT0oWT1MLnRlc3QodSkpJiYoSD1MLmxhc3RJbmRleC0xLFYrKyk7fXdoaWxlKFkpOzAhPT1WJiYoTis9VixPPWMtSCx0aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uKGgscCxILFYsTixPLGMpKTt9dGhpcy5oYW5kbGVNb2RlcyhGLEQsdyxoKTt9ZWxzZSB7Zm9yKHZhciBYPXYsej1OLHE9TywkPSExOyEkJiZ2PFQ7KWZvcih5LmNoYXJDb2RlQXQodiksdD10aGlzLmNob3BJbnB1dCh0LDEpLHYrKyxvPTA7bzxrO28rKyl7dmFyIFosUT1QW29dO0s9US5wYXR0ZXJuO2lmKCExIT09KFo9US5zaG9ydCk/eS5jaGFyQ29kZUF0KHYpPT09WiYmKCQ9ITApOiEwPT09US5pc0N1c3RvbT8kPW51bGwhPT1LLmV4ZWMoeSx2LFIsUyk6KHRoaXMudXBkYXRlTGFzdEluZGV4KEssdiksJD1udWxsIT09Sy5leGVjKHQpKSwhMD09PSQpYnJlYWt9Zj12LVgsZD10aGlzLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZSh5LFgsZix6LHEpLEEucHVzaCh7b2Zmc2V0OlgsbGluZTp6LGNvbHVtbjpxLGxlbmd0aDpmLG1lc3NhZ2U6ZH0pO319cmV0dXJuIHRoaXMuaGFzQ3VzdG9tfHwoUi5sZW5ndGg9Zykse3Rva2VuczpSLGdyb3VwczpTLGVycm9yczpBfX0sdC5wcm90b3R5cGUuaGFuZGxlTW9kZXM9ZnVuY3Rpb24odCxlLG4scil7aWYoITA9PT10LnBvcCl7dmFyIGk9dC5wdXNoO2Uociksdm9pZCAwIT09aSYmbi5jYWxsKHRoaXMsaSk7fWVsc2Ugdm9pZCAwIT09dC5wdXNoJiZuLmNhbGwodGhpcyx0LnB1c2gpO30sdC5wcm90b3R5cGUuY2hvcElucHV0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuc3Vic3RyaW5nKGUpfSx0LnByb3RvdHlwZS51cGRhdGVMYXN0SW5kZXg9ZnVuY3Rpb24odCxlKXt0Lmxhc3RJbmRleD1lO30sdC5wcm90b3R5cGUudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb249ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHMsdTt2b2lkIDAhPT1lJiYodT0ocz1uPT09YS0xKT8tMTowLDE9PT1yJiYhMD09PXN8fCh0LmVuZExpbmU9aSt1LHQuZW5kQ29sdW1uPW8tMS11KSk7fSx0LnByb3RvdHlwZS5jb21wdXRlTmV3Q29sdW1uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0sdC5wcm90b3R5cGUuY3JlYXRlVG9rZW5JbnN0YW5jZT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2VdPWFyZ3VtZW50c1tlXTtyZXR1cm4gbnVsbH0sdC5wcm90b3R5cGUuY3JlYXRlT2Zmc2V0T25seVRva2VuPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB7aW1hZ2U6dCxzdGFydE9mZnNldDplLHRva2VuVHlwZUlkeDpuLHRva2VuVHlwZTpyfX0sdC5wcm90b3R5cGUuY3JlYXRlU3RhcnRPbmx5VG9rZW49ZnVuY3Rpb24odCxlLG4scixpLG8pe3JldHVybiB7aW1hZ2U6dCxzdGFydE9mZnNldDplLHN0YXJ0TGluZTppLHN0YXJ0Q29sdW1uOm8sdG9rZW5UeXBlSWR4Om4sdG9rZW5UeXBlOnJ9fSx0LnByb3RvdHlwZS5jcmVhdGVGdWxsVG9rZW49ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7cmV0dXJuIHtpbWFnZTp0LHN0YXJ0T2Zmc2V0OmUsZW5kT2Zmc2V0OmUrYS0xLHN0YXJ0TGluZTppLGVuZExpbmU6aSxzdGFydENvbHVtbjpvLGVuZENvbHVtbjpvK2EtMSx0b2tlblR5cGVJZHg6bix0b2tlblR5cGU6cn19LHQucHJvdG90eXBlLmFkZFRva2VuPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gNjY2fSx0LnByb3RvdHlwZS5hZGRUb2tlblVzaW5nUHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHQucHVzaChuKSxlfSx0LnByb3RvdHlwZS5hZGRUb2tlblVzaW5nTWVtYmVyQWNjZXNzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdFtlXT1uLCsrZX0sdC5wcm90b3R5cGUubWF0Y2g9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBudWxsfSx0LnByb3RvdHlwZS5tYXRjaFdpdGhUZXN0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gITA9PT10LnRlc3QoZSk/ZS5zdWJzdHJpbmcobix0Lmxhc3RJbmRleCk6bnVsbH0sdC5wcm90b3R5cGUubWF0Y2hXaXRoRXhlYz1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZXhlYyhlKTtyZXR1cm4gbnVsbCE9PW4/blswXTpufSx0LlNLSVBQRUQ9XCJUaGlzIG1hcmtzIGEgc2tpcHBlZCBUb2tlbiBwYXR0ZXJuLCB0aGlzIG1lYW5zIGVhY2ggdG9rZW4gaWRlbnRpZmllZCBieSBpdCB3aWxsYmUgY29uc3VtZWQgYW5kIHRoZW4gdGhyb3duIGludG8gb2JsaXZpb24sIHRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgdG8gY29tcGxldGVseSBpZ25vcmUgd2hpdGVzcGFjZS5cIix0Lk5BPS9OT1RfQVBQTElDQUJMRS8sdH0oKTtlLkxleGVyPXU7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDApLGE9big0KSxzPW4oOSksdT1uKDEpLGM9big1KTtlLmFkZFRlcm1pbmFsVG9Dc3Q9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PXQuY2hpbGRyZW5bbl0/dC5jaGlsZHJlbltuXT1bZV06dC5jaGlsZHJlbltuXS5wdXNoKGUpO30sZS5hZGROb25lVGVybWluYWxUb0NzdD1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09dC5jaGlsZHJlbltlXT90LmNoaWxkcmVuW2VdPVtuXTp0LmNoaWxkcmVuW2VdLnB1c2gobik7fTt2YXIgcD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUpe3ZhciBuPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gbi5yZXN1bHQ9W10sbi5ydWxlSWR4PWUsbn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLmNvbGxlY3ROYW1lZERTTE1ldGhvZD1mdW5jdGlvbih0LGUsbil7aWYoIW8uaXNVbmRlZmluZWQodC5uYW1lKSl7dmFyIHI9dm9pZCAwO2lmKHQgaW5zdGFuY2VvZiB1Lk9wdGlvbnx8dCBpbnN0YW5jZW9mIHUuUmVwZXRpdGlvbnx8dCBpbnN0YW5jZW9mIHUuUmVwZXRpdGlvbk1hbmRhdG9yeXx8dCBpbnN0YW5jZW9mIHUuQWx0ZXJuYXRpb24pcj1uZXcgZSh7ZGVmaW5pdGlvbjp0LmRlZmluaXRpb24saWR4OnQuaWR4fSk7ZWxzZSB7aWYoISh0IGluc3RhbmNlb2YgdS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcnx8dCBpbnN0YW5jZW9mIHUuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpKXRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7cj1uZXcgZSh7ZGVmaW5pdGlvbjp0LmRlZmluaXRpb24saWR4OnQuaWR4LHNlcGFyYXRvcjp0LnNlcGFyYXRvcn0pO312YXIgaT1bcl0sYT1zLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCh0aGlzLnJ1bGVJZHgsbix0LmlkeCk7dGhpcy5yZXN1bHQucHVzaCh7ZGVmOmksa2V5OmEsbmFtZTp0Lm5hbWUsb3JnUHJvZDp0fSk7fX0sZS5wcm90b3R5cGUudmlzaXRPcHRpb249ZnVuY3Rpb24odCl7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1Lk9wdGlvbixzLk9QVElPTl9JRFgpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uPWZ1bmN0aW9uKHQpe3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5SZXBldGl0aW9uLHMuTUFOWV9JRFgpO30sZS5wcm90b3R5cGUudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5PWZ1bmN0aW9uKHQpe3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5SZXBldGl0aW9uTWFuZGF0b3J5LHMuQVRfTEVBU1RfT05FX0lEWCk7fSxlLnByb3RvdHlwZS52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yPWZ1bmN0aW9uKHQpe3RoaXMuY29sbGVjdE5hbWVkRFNMTWV0aG9kKHQsdS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcixzLkFUX0xFQVNUX09ORV9TRVBfSURYKTt9LGUucHJvdG90eXBlLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3I9ZnVuY3Rpb24odCl7dGhpcy5jb2xsZWN0TmFtZWREU0xNZXRob2QodCx1LlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLHMuTUFOWV9TRVBfSURYKTt9LGUucHJvdG90eXBlLnZpc2l0QWx0ZXJuYXRpb249ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLmNvbGxlY3ROYW1lZERTTE1ldGhvZCh0LHUuQWx0ZXJuYXRpb24scy5PUl9JRFgpO3ZhciBuPXQuZGVmaW5pdGlvbi5sZW5ndGg+MTtvLmZvckVhY2godC5kZWZpbml0aW9uLGZ1bmN0aW9uKHIsaSl7aWYoIW8uaXNVbmRlZmluZWQoci5uYW1lKSl7dmFyIGE9ci5kZWZpbml0aW9uO2E9bj9bbmV3IHUuT3B0aW9uKHtkZWZpbml0aW9uOnIuZGVmaW5pdGlvbn0pXTpyLmRlZmluaXRpb247dmFyIGM9cy5nZXRLZXlGb3JBbHRJbmRleChlLnJ1bGVJZHgscy5PUl9JRFgsdC5pZHgsaSk7ZS5yZXN1bHQucHVzaCh7ZGVmOmEsa2V5OmMsbmFtZTpyLm5hbWUsb3JnUHJvZDpyfSk7fX0pO30sZX0oYy5HQXN0VmlzaXRvcik7ZS5OYW1lZERTTE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yPXAsZS5hbmFseXplQ3N0PWZ1bmN0aW9uKHQsZSl7dmFyIG49e2RpY3REZWY6bmV3IGEuSGFzaFRhYmxlLGFsbFJ1bGVOYW1lczpbXX07cmV0dXJuIG8uZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciByPWUuZ2V0KHQubmFtZSk7bi5hbGxSdWxlTmFtZXMucHVzaCh0Lm5hbWUpO3ZhciBpPW5ldyBwKHIpO3QuYWNjZXB0KGkpLG8uZm9yRWFjaChpLnJlc3VsdCxmdW5jdGlvbihlKXtlLmRlZixlLmtleTt2YXIgcj1lLm5hbWU7bi5hbGxSdWxlTmFtZXMucHVzaCh0Lm5hbWUrcik7fSk7fSksbn07fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WRVJTSU9OPVwiNC42LjBcIjt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDMpLGk9bigxNSksbz1uKDIpLGE9big2KSxzPW4oMTcpLHU9bigxMCksYz1uKDM5KSxwPW4oNSksbD1uKDEpLGg9bigyNCksZj1uKDQwKSxkPW4oMjApLEU9e307RS5WRVJTSU9OPXMuVkVSU0lPTixFLlBhcnNlcj1yLlBhcnNlcixFLkNzdFBhcnNlcj1yLkNzdFBhcnNlcixFLkVtYmVkZGVkQWN0aW9uc1BhcnNlcj1yLkVtYmVkZGVkQWN0aW9uc1BhcnNlcjtFLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGU9ci5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLEUuTGV4ZXI9aS5MZXhlcixFLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZT1pLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZSxFLkVPRj1vLkVPRixFLnRva2VuTmFtZT1vLnRva2VuTmFtZSxFLnRva2VuTGFiZWw9by50b2tlbkxhYmVsLEUudG9rZW5NYXRjaGVyPW8udG9rZW5NYXRjaGVyLEUuY3JlYXRlVG9rZW49by5jcmVhdGVUb2tlbixFLmNyZWF0ZVRva2VuSW5zdGFuY2U9by5jcmVhdGVUb2tlbkluc3RhbmNlLEUuRU1QVFlfQUxUPXIuRU1QVFlfQUxULEUuZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXI9dS5kZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlcixFLmlzUmVjb2duaXRpb25FeGNlcHRpb249YS5pc1JlY29nbml0aW9uRXhjZXB0aW9uLEUuRWFybHlFeGl0RXhjZXB0aW9uPWEuRWFybHlFeGl0RXhjZXB0aW9uLEUuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uPWEuTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uLEUuTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb249YS5Ob3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbixFLk5vVmlhYmxlQWx0RXhjZXB0aW9uPWEuTm9WaWFibGVBbHRFeGNlcHRpb24sRS5kZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyPWQuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcixFLkZsYXQ9bC5GbGF0LEUuUmVwZXRpdGlvbj1sLlJlcGV0aXRpb24sRS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcj1sLlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLEUuUmVwZXRpdGlvbk1hbmRhdG9yeT1sLlJlcGV0aXRpb25NYW5kYXRvcnksRS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcj1sLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLEUuT3B0aW9uPWwuT3B0aW9uLEUuQWx0ZXJuYXRpb249bC5BbHRlcm5hdGlvbixFLk5vblRlcm1pbmFsPWwuTm9uVGVybWluYWwsRS5UZXJtaW5hbD1sLlRlcm1pbmFsLEUuUnVsZT1sLlJ1bGUsRS5HQXN0VmlzaXRvcj1wLkdBc3RWaXNpdG9yLEUuc2VyaWFsaXplR3JhbW1hcj1sLnNlcmlhbGl6ZUdyYW1tYXIsRS5zZXJpYWxpemVQcm9kdWN0aW9uPWwuc2VyaWFsaXplUHJvZHVjdGlvbixFLnJlc29sdmVHcmFtbWFyPWgucmVzb2x2ZUdyYW1tYXIsRS5kZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlcj11LmRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLEUudmFsaWRhdGVHcmFtbWFyPWgudmFsaWRhdGVHcmFtbWFyLEUuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyPXUuZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLEUuYXNzaWduT2NjdXJyZW5jZUluZGljZXM9aC5hc3NpZ25PY2N1cnJlbmNlSW5kaWNlcyxFLmNsZWFyQ2FjaGU9ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJUaGUgY2xlYXJDYWNoZSBmdW5jdGlvbiB3YXMgJ3NvZnQnIHJlbW92ZWQgZnJvbSB0aGUgQ2hldnJvdGFpbiBBUEkuXFxuXFx0IEl0IHBlcmZvcm1zIG5vIGFjdGlvbiBvdGhlciB0aGFuIHByaW50aW5nIHRoaXMgbWVzc2FnZS5cXG5cXHQgUGxlYXNlIGF2b2lkIHVzaW5nIGl0IGFzIGl0IHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkIGluIHRoZSBmdXR1cmVcIik7fSxFLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZT1jLmNyZWF0ZVN5bnRheERpYWdyYW1zQ29kZSxFLmdlbmVyYXRlUGFyc2VyRmFjdG9yeT1mLmdlbmVyYXRlUGFyc2VyRmFjdG9yeSxFLmdlbmVyYXRlUGFyc2VyTW9kdWxlPWYuZ2VuZXJhdGVQYXJzZXJNb2R1bGUsdC5leHBvcnRzPUU7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaSxvO2k9W10sdm9pZCAwPT09KG89XCJmdW5jdGlvblwiPT10eXBlb2Yocj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9dC5wcm90b3R5cGUuc2F2ZVN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHtpZHg6dGhpcy5pZHgsaW5wdXQ6dGhpcy5pbnB1dCxncm91cElkeDp0aGlzLmdyb3VwSWR4fX0sdC5wcm90b3R5cGUucmVzdG9yZVN0YXRlPWZ1bmN0aW9uKHQpe3RoaXMuaWR4PXQuaWR4LHRoaXMuaW5wdXQ9dC5pbnB1dCx0aGlzLmdyb3VwSWR4PXQuZ3JvdXBJZHg7fSx0LnByb3RvdHlwZS5wYXR0ZXJuPWZ1bmN0aW9uKHQpe3RoaXMuaWR4PTAsdGhpcy5pbnB1dD10LHRoaXMuZ3JvdXBJZHg9MCx0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKTt2YXIgZT10aGlzLmRpc2p1bmN0aW9uKCk7dGhpcy5jb25zdW1lQ2hhcihcIi9cIik7Zm9yKHZhciBuPXt0eXBlOlwiRmxhZ3NcIixnbG9iYWw6ITEsaWdub3JlQ2FzZTohMSxtdWx0aUxpbmU6ITEsdW5pY29kZTohMSxzdGlja3k6ITF9O3RoaXMuaXNSZWdFeHBGbGFnKCk7KXN3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiZ1wiOnMobixcImdsb2JhbFwiKTticmVhaztjYXNlXCJpXCI6cyhuLFwiaWdub3JlQ2FzZVwiKTticmVhaztjYXNlXCJtXCI6cyhuLFwibXVsdGlMaW5lXCIpO2JyZWFrO2Nhc2VcInVcIjpzKG4sXCJ1bmljb2RlXCIpO2JyZWFrO2Nhc2VcInlcIjpzKG4sXCJzdGlja3lcIik7fWlmKHRoaXMuaWR4IT09dGhpcy5pbnB1dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJSZWR1bmRhbnQgaW5wdXQ6IFwiK3RoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaWR4KSk7cmV0dXJuIHt0eXBlOlwiUGF0dGVyblwiLGZsYWdzOm4sdmFsdWU6ZX19LHQucHJvdG90eXBlLmRpc2p1bmN0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9W107Zm9yKHQucHVzaCh0aGlzLmFsdGVybmF0aXZlKCkpO1wifFwiPT09dGhpcy5wZWVrQ2hhcigpOyl0aGlzLmNvbnN1bWVDaGFyKFwifFwiKSx0LnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKTtyZXR1cm4ge3R5cGU6XCJEaXNqdW5jdGlvblwiLHZhbHVlOnR9fSx0LnByb3RvdHlwZS5hbHRlcm5hdGl2ZT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXTt0aGlzLmlzVGVybSgpOyl0LnB1c2godGhpcy50ZXJtKCkpO3JldHVybiB7dHlwZTpcIkFsdGVybmF0aXZlXCIsdmFsdWU6dH19LHQucHJvdG90eXBlLnRlcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Fzc2VydGlvbigpP3RoaXMuYXNzZXJ0aW9uKCk6dGhpcy5hdG9tKCl9LHQucHJvdG90eXBlLmFzc2VydGlvbj1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiXlwiOnJldHVybiB7dHlwZTpcIlN0YXJ0QW5jaG9yXCJ9O2Nhc2VcIiRcIjpyZXR1cm4ge3R5cGU6XCJFbmRBbmNob3JcIn07Y2FzZVwiXFxcXFwiOnN3aXRjaCh0aGlzLnBvcENoYXIoKSl7Y2FzZVwiYlwiOnJldHVybiB7dHlwZTpcIldvcmRCb3VuZGFyeVwifTtjYXNlXCJCXCI6cmV0dXJuIHt0eXBlOlwiTm9uV29yZEJvdW5kYXJ5XCJ9fXRocm93IEVycm9yKFwiSW52YWxpZCBBc3NlcnRpb24gRXNjYXBlXCIpO2Nhc2VcIihcIjp2YXIgdDtzd2l0Y2godGhpcy5jb25zdW1lQ2hhcihcIj9cIiksdGhpcy5wb3BDaGFyKCkpe2Nhc2VcIj1cIjp0PVwiTG9va2FoZWFkXCI7YnJlYWs7Y2FzZVwiIVwiOnQ9XCJOZWdhdGl2ZUxvb2thaGVhZFwiO311KHQpO3ZhciBlPXRoaXMuZGlzanVuY3Rpb24oKTtyZXR1cm4gdGhpcy5jb25zdW1lQ2hhcihcIilcIikse3R5cGU6dCx2YWx1ZTplfX0hZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKX0oKTt9LHQucHJvdG90eXBlLnF1YW50aWZpZXI9ZnVuY3Rpb24odCl7dmFyIGU7c3dpdGNoKHRoaXMucG9wQ2hhcigpKXtjYXNlXCIqXCI6ZT17YXRMZWFzdDowLGF0TW9zdDoxLzB9O2JyZWFrO2Nhc2VcIitcIjplPXthdExlYXN0OjEsYXRNb3N0OjEvMH07YnJlYWs7Y2FzZVwiP1wiOmU9e2F0TGVhc3Q6MCxhdE1vc3Q6MX07YnJlYWs7Y2FzZVwie1wiOnZhciBuPXRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKTtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcIn1cIjplPXthdExlYXN0Om4sYXRNb3N0Om59O2JyZWFrO2Nhc2VcIixcIjp2YXIgcjt0aGlzLmlzRGlnaXQoKT8ocj10aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKCksZT17YXRMZWFzdDpuLGF0TW9zdDpyfSk6ZT17YXRMZWFzdDpuLGF0TW9zdDoxLzB9LHRoaXMuY29uc3VtZUNoYXIoXCJ9XCIpO31pZighMD09PXQmJnZvaWQgMD09PWUpcmV0dXJuO3UoZSk7fWlmKCEwIT09dHx8dm9pZCAwIT09ZSlyZXR1cm4gdShlKSxcIj9cIj09PXRoaXMucGVla0NoYXIoMCk/KHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpLGUuZ3JlZWR5PSExKTplLmdyZWVkeT0hMCxlLnR5cGU9XCJRdWFudGlmaWVyXCIsZX0sdC5wcm90b3R5cGUuYXRvbT1mdW5jdGlvbigpe3ZhciB0O3N3aXRjaCh0aGlzLnBlZWtDaGFyKCkpe2Nhc2VcIi5cIjp0PXRoaXMuZG90QWxsKCk7YnJlYWs7Y2FzZVwiXFxcXFwiOnQ9dGhpcy5hdG9tRXNjYXBlKCk7YnJlYWs7Y2FzZVwiW1wiOnQ9dGhpcy5jaGFyYWN0ZXJDbGFzcygpO2JyZWFrO2Nhc2VcIihcIjp0PXRoaXMuZ3JvdXAoKTt9cmV0dXJuIHZvaWQgMD09PXQmJnRoaXMuaXNQYXR0ZXJuQ2hhcmFjdGVyKCkmJih0PXRoaXMucGF0dGVybkNoYXJhY3RlcigpKSx1KHQpLHRoaXMuaXNRdWFudGlmaWVyKCkmJih0LnF1YW50aWZpZXI9dGhpcy5xdWFudGlmaWVyKCkpLHR9LHQucHJvdG90eXBlLmRvdEFsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiLlwiKSx7dHlwZTpcIlNldFwiLGNvbXBsZW1lbnQ6ITAsdmFsdWU6W28oXCJcXG5cIiksbyhcIlxcclwiKSxvKFwiXFx1MjAyOFwiKSxvKFwiXFx1MjAyOVwiKV19fSx0LnByb3RvdHlwZS5hdG9tRXNjYXBlPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpLHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiMVwiOmNhc2VcIjJcIjpjYXNlXCIzXCI6Y2FzZVwiNFwiOmNhc2VcIjVcIjpjYXNlXCI2XCI6Y2FzZVwiN1wiOmNhc2VcIjhcIjpjYXNlXCI5XCI6cmV0dXJuIHRoaXMuZGVjaW1hbEVzY2FwZUF0b20oKTtjYXNlXCJkXCI6Y2FzZVwiRFwiOmNhc2VcInNcIjpjYXNlXCJTXCI6Y2FzZVwid1wiOmNhc2VcIldcIjpyZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpO2Nhc2VcImZcIjpjYXNlXCJuXCI6Y2FzZVwiclwiOmNhc2VcInRcIjpjYXNlXCJ2XCI6cmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKTtjYXNlXCJjXCI6cmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKTtjYXNlXCIwXCI6cmV0dXJuIHRoaXMubnVsQ2hhcmFjdGVyQXRvbSgpO2Nhc2VcInhcIjpyZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKTtjYXNlXCJ1XCI6cmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuaWRlbnRpdHlFc2NhcGVBdG9tKCl9fSx0LnByb3RvdHlwZS5kZWNpbWFsRXNjYXBlQXRvbT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucG9zaXRpdmVJbnRlZ2VyKCk7cmV0dXJuIHt0eXBlOlwiR3JvdXBCYWNrUmVmZXJlbmNlXCIsdmFsdWU6dH19LHQucHJvdG90eXBlLmNoYXJhY3RlckNsYXNzRXNjYXBlPWZ1bmN0aW9uKCl7dmFyIHQsZT0hMTtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcImRcIjp0PWM7YnJlYWs7Y2FzZVwiRFwiOnQ9YyxlPSEwO2JyZWFrO2Nhc2VcInNcIjp0PWw7YnJlYWs7Y2FzZVwiU1wiOnQ9bCxlPSEwO2JyZWFrO2Nhc2VcIndcIjp0PXA7YnJlYWs7Y2FzZVwiV1wiOnQ9cCxlPSEwO31yZXR1cm4gdSh0KSx7dHlwZTpcIlNldFwiLHZhbHVlOnQsY29tcGxlbWVudDplfX0sdC5wcm90b3R5cGUuY29udHJvbEVzY2FwZUF0b209ZnVuY3Rpb24oKXt2YXIgdDtzd2l0Y2godGhpcy5wb3BDaGFyKCkpe2Nhc2VcImZcIjp0PW8oXCJcXGZcIik7YnJlYWs7Y2FzZVwiblwiOnQ9byhcIlxcblwiKTticmVhaztjYXNlXCJyXCI6dD1vKFwiXFxyXCIpO2JyZWFrO2Nhc2VcInRcIjp0PW8oXCJcXHRcIik7YnJlYWs7Y2FzZVwidlwiOnQ9byhcIlxcdlwiKTt9cmV0dXJuIHUodCkse3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTp0fX0sdC5wcm90b3R5cGUuY29udHJvbExldHRlckVzY2FwZUF0b209ZnVuY3Rpb24oKXt0aGlzLmNvbnN1bWVDaGFyKFwiY1wiKTt2YXIgdD10aGlzLnBvcENoYXIoKTtpZighMT09PS9bYS16QS1aXS8udGVzdCh0KSl0aHJvdyBFcnJvcihcIkludmFsaWQgXCIpO3ZhciBlPXQudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApLTY0O3JldHVybiB7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOmV9fSx0LnByb3RvdHlwZS5udWxDaGFyYWN0ZXJBdG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCIwXCIpLHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6byhcIlxcMFwiKX19LHQucHJvdG90eXBlLmhleEVzY2FwZVNlcXVlbmNlQXRvbT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwieFwiKSx0aGlzLnBhcnNlSGV4RGlnaXRzKDIpfSx0LnByb3RvdHlwZS5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJ1XCIpLHRoaXMucGFyc2VIZXhEaWdpdHMoNCl9LHQucHJvdG90eXBlLmlkZW50aXR5RXNjYXBlQXRvbT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucG9wQ2hhcigpO3JldHVybiB7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm8odCl9fSx0LnByb3RvdHlwZS5jbGFzc1BhdHRlcm5DaGFyYWN0ZXJBdG9tPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiXFxuXCI6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpjYXNlXCJcXFxcXCI6Y2FzZVwiXVwiOnRocm93IEVycm9yKFwiVEJEXCIpO2RlZmF1bHQ6dmFyIHQ9dGhpcy5wb3BDaGFyKCk7cmV0dXJuIHt0eXBlOlwiQ2hhcmFjdGVyXCIsdmFsdWU6byh0KX19fSx0LnByb3RvdHlwZS5jaGFyYWN0ZXJDbGFzcz1mdW5jdGlvbigpe3ZhciB0PVtdLGU9ITE7Zm9yKHRoaXMuY29uc3VtZUNoYXIoXCJbXCIpLFwiXlwiPT09dGhpcy5wZWVrQ2hhcigwKSYmKHRoaXMuY29uc3VtZUNoYXIoXCJeXCIpLGU9ITApO3RoaXMuaXNDbGFzc0F0b20oKTspe3ZhciBuPXRoaXMuY2xhc3NBdG9tKCkscj1cIkNoYXJhY3RlclwiPT09bi50eXBlO2lmKHImJnRoaXMuaXNSYW5nZURhc2goKSl7dGhpcy5jb25zdW1lQ2hhcihcIi1cIik7dmFyIGk9dGhpcy5jbGFzc0F0b20oKSxzPVwiQ2hhcmFjdGVyXCI9PT1pLnR5cGU7aWYocyl7aWYoaS52YWx1ZTxuLnZhbHVlKXRocm93IEVycm9yKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTt0LnB1c2goe2Zyb206bi52YWx1ZSx0bzppLnZhbHVlfSk7fWVsc2UgYShuLnZhbHVlLHQpLHQucHVzaChvKFwiLVwiKSksYShpLnZhbHVlLHQpO31lbHNlIGEobi52YWx1ZSx0KTt9cmV0dXJuIHRoaXMuY29uc3VtZUNoYXIoXCJdXCIpLHt0eXBlOlwiU2V0XCIsY29tcGxlbWVudDplLHZhbHVlOnR9fSx0LnByb3RvdHlwZS5jbGFzc0F0b209ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5wZWVrQ2hhcigpKXtjYXNlXCJdXCI6Y2FzZVwiXFxuXCI6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjp0aHJvdyBFcnJvcihcIlRCRFwiKTtjYXNlXCJcXFxcXCI6cmV0dXJuIHRoaXMuY2xhc3NFc2NhcGUoKTtkZWZhdWx0OnJldHVybiB0aGlzLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20oKX19LHQucHJvdG90eXBlLmNsYXNzRXNjYXBlPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpLHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiYlwiOnJldHVybiB0aGlzLmNvbnN1bWVDaGFyKFwiYlwiKSx7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm8oXCJcXGJcIil9O2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwic1wiOmNhc2VcIlNcIjpjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiB0aGlzLmNoYXJhY3RlckNsYXNzRXNjYXBlKCk7Y2FzZVwiZlwiOmNhc2VcIm5cIjpjYXNlXCJyXCI6Y2FzZVwidFwiOmNhc2VcInZcIjpyZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpO2Nhc2VcImNcIjpyZXR1cm4gdGhpcy5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpO2Nhc2VcIjBcIjpyZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKCk7Y2FzZVwieFwiOnJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpO2Nhc2VcInVcIjpyZXR1cm4gdGhpcy5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKX19LHQucHJvdG90eXBlLmdyb3VwPWZ1bmN0aW9uKCl7dmFyIHQ9ITA7c3dpdGNoKHRoaXMuY29uc3VtZUNoYXIoXCIoXCIpLHRoaXMucGVla0NoYXIoMCkpe2Nhc2VcIj9cIjp0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKSx0aGlzLmNvbnN1bWVDaGFyKFwiOlwiKSx0PSExO2JyZWFrO2RlZmF1bHQ6dGhpcy5ncm91cElkeCsrO312YXIgZT10aGlzLmRpc2p1bmN0aW9uKCk7dGhpcy5jb25zdW1lQ2hhcihcIilcIik7dmFyIG49e3R5cGU6XCJHcm91cFwiLGNhcHR1cmluZzp0LHZhbHVlOmV9O3JldHVybiB0JiYobi5pZHg9dGhpcy5ncm91cElkeCksbn0sdC5wcm90b3R5cGUucG9zaXRpdmVJbnRlZ2VyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb3BDaGFyKCk7aWYoITE9PT1pLnRlc3QodCkpdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO2Zvcig7ci50ZXN0KHRoaXMucGVla0NoYXIoMCkpOyl0Kz10aGlzLnBvcENoYXIoKTtyZXR1cm4gcGFyc2VJbnQodCwxMCl9LHQucHJvdG90eXBlLmludGVnZXJJbmNsdWRpbmdaZXJvPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb3BDaGFyKCk7aWYoITE9PT1yLnRlc3QodCkpdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYW4gaW50ZWdlclwiKTtmb3IoO3IudGVzdCh0aGlzLnBlZWtDaGFyKDApKTspdCs9dGhpcy5wb3BDaGFyKCk7cmV0dXJuIHBhcnNlSW50KHQsMTApfSx0LnByb3RvdHlwZS5wYXR0ZXJuQ2hhcmFjdGVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb3BDaGFyKCk7c3dpdGNoKHQpe2Nhc2VcIlxcblwiOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6Y2FzZVwiXlwiOmNhc2VcIiRcIjpjYXNlXCJcXFxcXCI6Y2FzZVwiLlwiOmNhc2VcIipcIjpjYXNlXCIrXCI6Y2FzZVwiP1wiOmNhc2VcIihcIjpjYXNlXCIpXCI6Y2FzZVwiW1wiOmNhc2VcInxcIjp0aHJvdyBFcnJvcihcIlRCRFwiKTtkZWZhdWx0OnJldHVybiB7dHlwZTpcIkNoYXJhY3RlclwiLHZhbHVlOm8odCl9fX0sdC5wcm90b3R5cGUuaXNSZWdFeHBGbGFnPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoMCkpe2Nhc2VcImdcIjpjYXNlXCJpXCI6Y2FzZVwibVwiOmNhc2VcInVcIjpjYXNlXCJ5XCI6cmV0dXJuICEwO2RlZmF1bHQ6cmV0dXJuICExfX0sdC5wcm90b3R5cGUuaXNSYW5nZURhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gXCItXCI9PT10aGlzLnBlZWtDaGFyKCkmJnRoaXMuaXNDbGFzc0F0b20oMSl9LHQucHJvdG90eXBlLmlzRGlnaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gci50ZXN0KHRoaXMucGVla0NoYXIoMCkpfSx0LnByb3RvdHlwZS5pc0NsYXNzQXRvbT1mdW5jdGlvbih0KXtzd2l0Y2godm9pZCAwPT09dCYmKHQ9MCksdGhpcy5wZWVrQ2hhcih0KSl7Y2FzZVwiXVwiOmNhc2VcIlxcblwiOmNhc2VcIlxcclwiOmNhc2VcIlxcdTIwMjhcIjpjYXNlXCJcXHUyMDI5XCI6cmV0dXJuICExO2RlZmF1bHQ6cmV0dXJuICEwfX0sdC5wcm90b3R5cGUuaXNUZXJtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNBdG9tKCl8fHRoaXMuaXNBc3NlcnRpb24oKX0sdC5wcm90b3R5cGUuaXNBdG9tPWZ1bmN0aW9uKCl7aWYodGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSlyZXR1cm4gITA7c3dpdGNoKHRoaXMucGVla0NoYXIoMCkpe2Nhc2VcIi5cIjpjYXNlXCJcXFxcXCI6Y2FzZVwiW1wiOmNhc2VcIihcIjpyZXR1cm4gITA7ZGVmYXVsdDpyZXR1cm4gITF9fSx0LnByb3RvdHlwZS5pc0Fzc2VydGlvbj1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnBlZWtDaGFyKDApKXtjYXNlXCJeXCI6Y2FzZVwiJFwiOnJldHVybiAhMDtjYXNlXCJcXFxcXCI6c3dpdGNoKHRoaXMucGVla0NoYXIoMSkpe2Nhc2VcImJcIjpjYXNlXCJCXCI6cmV0dXJuICEwO2RlZmF1bHQ6cmV0dXJuICExfWNhc2VcIihcIjpyZXR1cm4gXCI/XCI9PT10aGlzLnBlZWtDaGFyKDEpJiYoXCI9XCI9PT10aGlzLnBlZWtDaGFyKDIpfHxcIiFcIj09PXRoaXMucGVla0NoYXIoMikpO2RlZmF1bHQ6cmV0dXJuICExfX0sdC5wcm90b3R5cGUuaXNRdWFudGlmaWVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zYXZlU3RhdGUoKTt0cnl7cmV0dXJuIHZvaWQgMCE9PXRoaXMucXVhbnRpZmllcighMCl9Y2F0Y2godCl7cmV0dXJuICExfWZpbmFsbHl7dGhpcy5yZXN0b3JlU3RhdGUodCk7fX0sdC5wcm90b3R5cGUuaXNQYXR0ZXJuQ2hhcmFjdGVyPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMucGVla0NoYXIoKSl7Y2FzZVwiXlwiOmNhc2VcIiRcIjpjYXNlXCJcXFxcXCI6Y2FzZVwiLlwiOmNhc2VcIipcIjpjYXNlXCIrXCI6Y2FzZVwiP1wiOmNhc2VcIihcIjpjYXNlXCIpXCI6Y2FzZVwiW1wiOmNhc2VcInxcIjpjYXNlXCIvXCI6Y2FzZVwiXFxuXCI6Y2FzZVwiXFxyXCI6Y2FzZVwiXFx1MjAyOFwiOmNhc2VcIlxcdTIwMjlcIjpyZXR1cm4gITE7ZGVmYXVsdDpyZXR1cm4gITB9fSx0LnByb3RvdHlwZS5wYXJzZUhleERpZ2l0cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9XCJcIixyPTA7cjx0O3IrKyl7dmFyIGk9dGhpcy5wb3BDaGFyKCk7aWYoITE9PT1uLnRlc3QoaSkpdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBIZXhEZWNpbWFsIGRpZ2l0c1wiKTtlKz1pO312YXIgbz1wYXJzZUludChlLDE2KTtyZXR1cm4ge3R5cGU6XCJDaGFyYWN0ZXJcIix2YWx1ZTpvfX0sdC5wcm90b3R5cGUucGVla0NoYXI9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PTApLHRoaXMuaW5wdXRbdGhpcy5pZHgrdF19LHQucHJvdG90eXBlLnBvcENoYXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBlZWtDaGFyKDApO3JldHVybiB0aGlzLmNvbnN1bWVDaGFyKCksdH0sdC5wcm90b3R5cGUuY29uc3VtZUNoYXI9ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dCYmdGhpcy5pbnB1dFt0aGlzLmlkeF0hPT10KXRocm93IEVycm9yKFwiRXhwZWN0ZWQ6ICdcIit0K1wiJyBidXQgZm91bmQ6ICdcIit0aGlzLmlucHV0W3RoaXMuaWR4XStcIicgYXQgb2Zmc2V0OiBcIit0aGlzLmlkeCk7aWYodGhpcy5pZHg+PXRoaXMuaW5wdXQubGVuZ3RoKXRocm93IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIik7dGhpcy5pZHgrKzt9O3ZhciBlLG49L1swLTlhLWZBLUZdLyxyPS9bMC05XS8saT0vWzEtOV0vO2Z1bmN0aW9uIG8odCl7cmV0dXJuIHQuY2hhckNvZGVBdCgwKX1mdW5jdGlvbiBhKHQsZSl7dm9pZCAwIT09dC5sZW5ndGg/dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UucHVzaCh0KTt9KTplLnB1c2godCk7fWZ1bmN0aW9uIHModCxlKXtpZighMD09PXRbZV0pdGhyb3cgXCJkdXBsaWNhdGUgZmxhZyBcIitlO3RbZV09ITA7fWZ1bmN0aW9uIHUodCl7aWYodm9pZCAwPT09dCl0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKX12YXIgYz1bXTtmb3IoZT1vKFwiMFwiKTtlPD1vKFwiOVwiKTtlKyspYy5wdXNoKGUpO3ZhciBwPVtvKFwiX1wiKV0uY29uY2F0KGMpO2ZvcihlPW8oXCJhXCIpO2U8PW8oXCJ6XCIpO2UrKylwLnB1c2goZSk7Zm9yKGU9byhcIkFcIik7ZTw9byhcIlpcIik7ZSsrKXAucHVzaChlKTt2YXIgbD1bbyhcIiBcIiksbyhcIlxcZlwiKSxvKFwiXFxuXCIpLG8oXCJcXHJcIiksbyhcIlxcdFwiKSxvKFwiXFx2XCIpLG8oXCJcXHRcIiksbyhcIsKgXCIpLG8oXCLhmoBcIiksbyhcIuKAgFwiKSxvKFwi4oCBXCIpLG8oXCLigIJcIiksbyhcIuKAg1wiKSxvKFwi4oCEXCIpLG8oXCLigIVcIiksbyhcIuKAhlwiKSxvKFwi4oCHXCIpLG8oXCLigIhcIiksbyhcIuKAiVwiKSxvKFwi4oCKXCIpLG8oXCJcXHUyMDI4XCIpLG8oXCJcXHUyMDI5XCIpLG8oXCLigK9cIiksbyhcIuKBn1wiKSxvKFwi44CAXCIpLG8oXCJcXHVmZWZmXCIpXTtmdW5jdGlvbiBoKCl7fXJldHVybiBoLnByb3RvdHlwZS52aXNpdENoaWxkcmVuPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXt2YXIgbj10W2VdO3QuaGFzT3duUHJvcGVydHkoZSkmJih2b2lkIDAhPT1uLnR5cGU/dGhpcy52aXNpdChuKTpBcnJheS5pc0FycmF5KG4pJiZuLmZvckVhY2goZnVuY3Rpb24odCl7dGhpcy52aXNpdCh0KTt9LHRoaXMpKTt9fSxoLnByb3RvdHlwZS52aXNpdD1mdW5jdGlvbih0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJQYXR0ZXJuXCI6dGhpcy52aXNpdFBhdHRlcm4odCk7YnJlYWs7Y2FzZVwiRmxhZ3NcIjp0aGlzLnZpc2l0RmxhZ3ModCk7YnJlYWs7Y2FzZVwiRGlzanVuY3Rpb25cIjp0aGlzLnZpc2l0RGlzanVuY3Rpb24odCk7YnJlYWs7Y2FzZVwiQWx0ZXJuYXRpdmVcIjp0aGlzLnZpc2l0QWx0ZXJuYXRpdmUodCk7YnJlYWs7Y2FzZVwiU3RhcnRBbmNob3JcIjp0aGlzLnZpc2l0U3RhcnRBbmNob3IodCk7YnJlYWs7Y2FzZVwiRW5kQW5jaG9yXCI6dGhpcy52aXNpdEVuZEFuY2hvcih0KTticmVhaztjYXNlXCJXb3JkQm91bmRhcnlcIjp0aGlzLnZpc2l0V29yZEJvdW5kYXJ5KHQpO2JyZWFrO2Nhc2VcIk5vbldvcmRCb3VuZGFyeVwiOnRoaXMudmlzaXROb25Xb3JkQm91bmRhcnkodCk7YnJlYWs7Y2FzZVwiTG9va2FoZWFkXCI6dGhpcy52aXNpdExvb2thaGVhZCh0KTticmVhaztjYXNlXCJOZWdhdGl2ZUxvb2thaGVhZFwiOnRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZCh0KTticmVhaztjYXNlXCJDaGFyYWN0ZXJcIjp0aGlzLnZpc2l0Q2hhcmFjdGVyKHQpO2JyZWFrO2Nhc2VcIlNldFwiOnRoaXMudmlzaXRTZXQodCk7YnJlYWs7Y2FzZVwiR3JvdXBcIjp0aGlzLnZpc2l0R3JvdXAodCk7YnJlYWs7Y2FzZVwiR3JvdXBCYWNrUmVmZXJlbmNlXCI6dGhpcy52aXNpdEdyb3VwQmFja1JlZmVyZW5jZSh0KTticmVhaztjYXNlXCJRdWFudGlmaWVyXCI6dGhpcy52aXNpdFF1YW50aWZpZXIodCk7fXRoaXMudmlzaXRDaGlsZHJlbih0KTt9LGgucHJvdG90eXBlLnZpc2l0UGF0dGVybj1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0RmxhZ3M9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdERpc2p1bmN0aW9uPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRBbHRlcm5hdGl2ZT1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0U3RhcnRBbmNob3I9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdEVuZEFuY2hvcj1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0V29yZEJvdW5kYXJ5PWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXROb25Xb3JkQm91bmRhcnk9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdExvb2thaGVhZD1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0TmVnYXRpdmVMb29rYWhlYWQ9ZnVuY3Rpb24odCl7fSxoLnByb3RvdHlwZS52aXNpdENoYXJhY3Rlcj1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0U2V0PWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRHcm91cD1mdW5jdGlvbih0KXt9LGgucHJvdG90eXBlLnZpc2l0R3JvdXBCYWNrUmVmZXJlbmNlPWZ1bmN0aW9uKHQpe30saC5wcm90b3R5cGUudmlzaXRRdWFudGlmaWVyPWZ1bmN0aW9uKHQpe30se1JlZ0V4cFBhcnNlcjp0LEJhc2VSZWdFeHBWaXNpdG9yOmgsVkVSU0lPTjpcIjAuNC4wXCJ9fSk/ci5hcHBseShlLGkpOnIpfHwodC5leHBvcnRzPW8pO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdExleGVyRXJyb3JQcm92aWRlcj17YnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIFwiVW5hYmxlIHRvIHBvcCBMZXhlciBNb2RlIGFmdGVyIGVuY291bnRlcmluZyBUb2tlbiAtPlwiK3QuaW1hZ2UrXCI8LSBUaGUgTW9kZSBTdGFjayBpcyBlbXB0eVwifSxidWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZTpmdW5jdGlvbih0LGUsbixyLGkpe3JldHVybiBcInVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAtPlwiK3QuY2hhckF0KGUpK1wiPC0gYXQgb2Zmc2V0OiBcIitlK1wiLCBza2lwcGVkIFwiK24rXCIgY2hhcmFjdGVycy5cIn19O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDEpLG89big4KTtmdW5jdGlvbiBhKHQpe2lmKHQgaW5zdGFuY2VvZiBpLk5vblRlcm1pbmFsKXJldHVybiBhKHQucmVmZXJlbmNlZFJ1bGUpO2lmKHQgaW5zdGFuY2VvZiBpLlRlcm1pbmFsKXJldHVybiBjKHQpO2lmKG8uaXNTZXF1ZW5jZVByb2QodCkpcmV0dXJuIHModCk7aWYoby5pc0JyYW5jaGluZ1Byb2QodCkpcmV0dXJuIHUodCk7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1mdW5jdGlvbiBzKHQpe2Zvcih2YXIgZSxuPVtdLGk9dC5kZWZpbml0aW9uLHM9MCx1PWkubGVuZ3RoPnMsYz0hMDt1JiZjOyllPWlbc10sYz1vLmlzT3B0aW9uYWxQcm9kKGUpLG49bi5jb25jYXQoYShlKSkscys9MSx1PWkubGVuZ3RoPnM7cmV0dXJuIHIudW5pcShuKX1mdW5jdGlvbiB1KHQpe3ZhciBlPXIubWFwKHQuZGVmaW5pdGlvbixmdW5jdGlvbih0KXtyZXR1cm4gYSh0KX0pO3JldHVybiByLnVuaXEoci5mbGF0dGVuKGUpKX1mdW5jdGlvbiBjKHQpe3JldHVybiBbdC50ZXJtaW5hbFR5cGVdfWUuZmlyc3Q9YSxlLmZpcnN0Rm9yU2VxdWVuY2U9cyxlLmZpcnN0Rm9yQnJhbmNoaW5nPXUsZS5maXJzdEZvclRlcm1pbmFsPWM7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5JTj1cIl9+SU5+X1wiO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByLGk9bigyOSksbz1uKDApLGE9bigxKTshZnVuY3Rpb24odCl7dFt0Lk9QVElPTj0wXT1cIk9QVElPTlwiLHRbdC5PUj0xXT1cIk9SXCIsdFt0Lk1BTlk9Ml09XCJNQU5ZXCIsdFt0Lk1BTllfU0VQPTNdPVwiTUFOWV9TRVBcIix0W3QuQVRfTEVBU1RfT05FPTRdPVwiQVRfTEVBU1RfT05FXCIsdFt0LkFUX0xFQVNUX09ORV9TRVA9NV09XCJBVF9MRUFTVF9PTkVfU0VQXCIsdFt0LlJFRj02XT1cIlJFRlwiLHRbdC5URVJNSU5BTD03XT1cIlRFUk1JTkFMXCIsdFt0LkZMQVQ9OF09XCJGTEFUXCI7fShyPWUuUHJvZFR5cGV8fChlLlByb2RUeXBlPXt9KSk7dmFyIHM9Lyg/Olxccyp7XFxzKk5BTUVcXHMqOlxccypbXCInYF0oW1xcdyRdKilbXCInYF0pPy8sdT1uZXcgUmVnRXhwKHMuc291cmNlLnJlcGxhY2UoXCJ7XCIsXCJcIikucmVwbGFjZShcIik/XCIsXCJcXFxccyosKT9cIikpLGM9L1xcLlxccypDT05TVU1FKFxcZCspP1xccypcXChcXHMqKD86W2EtekEtWl8kXVxcdypcXHMqXFwuXFxzKikqKFthLXpBLVpfJF1cXHcqKS8scD1uZXcgUmVnRXhwKGMuc291cmNlLFwiZ1wiKSxsPS9cXC5cXHMqU1VCUlVMRShcXGQrKT9cXHMqXFwoXFxzKig/OlthLXpBLVpfJF1cXHcqXFxzKlxcLlxccyopKihbYS16QS1aXyRdXFx3KikvLGg9bmV3IFJlZ0V4cChsLnNvdXJjZSxcImdcIiksZj0vXFwuXFxzKk9QVElPTihcXGQrKT9cXHMqXFwoLyxkPW5ldyBSZWdFeHAoZi5zb3VyY2Urcy5zb3VyY2UpLEU9bmV3IFJlZ0V4cChmLnNvdXJjZSxcImdcIiksbT0vXFwuXFxzKk1BTlkoXFxkKyk/XFxzKlxcKC8seT1uZXcgUmVnRXhwKG0uc291cmNlK3Muc291cmNlKSxUPW5ldyBSZWdFeHAobS5zb3VyY2UsXCJnXCIpLHY9L1xccypTRVBcXHMqOlxccyooPzpbYS16QS1aXyRdXFx3KlxccypcXC5cXHMqKSooW2EtekEtWl8kXVxcdyopLyxnPW5ldyBSZWdFeHAoL1xcLlxccypNQU5ZX1NFUChcXGQrKT9cXHMqXFwoXFxzKnsvLnNvdXJjZSt1LnNvdXJjZSt2LnNvdXJjZSksXz1uZXcgUmVnRXhwKGcuc291cmNlLFwiZ1wiKSxSPW5ldyBSZWdFeHAoL1xcLlxccypBVF9MRUFTVF9PTkVfU0VQKFxcZCspP1xccypcXChcXHMqey8uc291cmNlK3Uuc291cmNlK3Yuc291cmNlKSxBPW5ldyBSZWdFeHAoUi5zb3VyY2UsXCJnXCIpLE49L1xcLlxccypBVF9MRUFTVF9PTkUoXFxkKyk/XFxzKlxcKC8sTz1uZXcgUmVnRXhwKE4uc291cmNlK3Muc291cmNlKSxTPW5ldyBSZWdFeHAoTi5zb3VyY2UsXCJnXCIpLEk9L1xcLlxccypPUihcXGQrKT9cXHMqXFwoLyxMPW5ldyBSZWdFeHAoSS5zb3VyY2Urcy5zb3VyY2UpLGs9bmV3IFJlZ0V4cChJLnNvdXJjZSxcImdcIiksUD1uZXcgUmVnRXhwKHUuc291cmNlKy9cXHMqKEFMVClcXHMqOi8uc291cmNlKSx4PW5ldyBSZWdFeHAoUC5zb3VyY2UsXCJnXCIpO2Z1bmN0aW9uIEModCxuLGkpe3N3aXRjaCh0LnR5cGUpe2Nhc2Ugci5BVF9MRUFTVF9PTkU6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTShPLG5ldyBhLlJlcGV0aXRpb25NYW5kYXRvcnkoe2RlZmluaXRpb246W119KSx0LGUsbil9KHQsbixpKTtjYXNlIHIuQVRfTEVBU1RfT05FX1NFUDpyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3JldHVybiBGKHQsZSxhLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLFIsbil9KHQsbixpKTtjYXNlIHIuTUFOWV9TRVA6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gRih0LGUsYS5SZXBldGl0aW9uV2l0aFNlcGFyYXRvcixnLG4pfSh0LG4saSk7Y2FzZSByLk1BTlk6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTSh5LG5ldyBhLlJlcGV0aXRpb24oe2RlZmluaXRpb246W119KSx0LGUsbil9KHQsbixpKTtjYXNlIHIuT1BUSU9OOnJldHVybiBmdW5jdGlvbih0LGUsbil7cmV0dXJuIE0oZCxuZXcgYS5PcHRpb24oe2RlZmluaXRpb246W119KSx0LGUsbil9KHQsbixpKTtjYXNlIHIuT1I6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTShMLG5ldyBhLkFsdGVybmF0aW9uKHtkZWZpbml0aW9uOltdfSksdCxlLG4pfSh0LG4saSk7Y2FzZSByLkZMQVQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgYS5GbGF0KHtkZWZpbml0aW9uOltdfSksaT1QLmV4ZWModC50ZXh0KVsxXTtvLmlzVW5kZWZpbmVkKGkpfHwoci5uYW1lPWkpO3JldHVybiBiKHIsdC5yYW5nZSxlLG4pfSh0LG4saSk7Y2FzZSByLlJFRjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9bC5leGVjKHQudGV4dCksbj12b2lkIDA9PT1lWzFdPzA6cGFyc2VJbnQoZVsxXSwxMCkscj1lWzJdO3JldHVybiBuZXcgYS5Ob25UZXJtaW5hbCh7bm9uVGVybWluYWxOYW1lOnIsaWR4Om59KX0odCk7Y2FzZSByLlRFUk1JTkFMOnJldHVybiBmdW5jdGlvbih0LG4pe3ZhciByPWMuZXhlYyh0LnRleHQpLGk9dm9pZCAwPT09clsxXT8wOnBhcnNlSW50KHJbMV0sMTApLG89clsyXSxzPWUudGVybWluYWxOYW1lVG9Db25zdHJ1Y3RvcltvXTtpZighcyl0aHJvdyBFcnJvcihcIlRlcm1pbmFsIFRva2VuIG5hbWU6IDxcIitvK1wiPiBub3QgZm91bmQgaW4gcnVsZTogPFwiK24rXCI+ICBcXG5cXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjVEVSTUlOQUxfTkFNRV9OT1RfRk9VTkRcXG5cXHRGb3IgRnVydGhlciBkZXRhaWxzLlwiKTtyZXR1cm4gbmV3IGEuVGVybWluYWwoe3Rlcm1pbmFsVHlwZTpzLGlkeDppfSl9KHQsaSk7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfX1mdW5jdGlvbiBNKHQsZSxuLHIsaSl7dmFyIGE9dC5leGVjKG4udGV4dCkscz12b2lkIDA9PT1hWzFdO2UuaWR4PXM/MDpwYXJzZUludChhWzFdLDEwKTt2YXIgdT1hWzJdO3JldHVybiBvLmlzVW5kZWZpbmVkKHUpfHwoZS5uYW1lPXUpLGIoZSxuLnJhbmdlLHIsaSl9ZnVuY3Rpb24gRih0LG4scixpLGEpe3ZhciBzPWkuZXhlYyh0LnRleHQpLHU9dm9pZCAwPT09c1sxXT8wOnBhcnNlSW50KHNbMV0sMTApLGM9c1szXSxwPWUudGVybWluYWxOYW1lVG9Db25zdHJ1Y3RvcltjXTtpZighcCl0aHJvdyBFcnJvcihcIlNlcGFyYXRvciBUZXJtaW5hbCBUb2tlbiBuYW1lOiBcIitjK1wiIG5vdCBmb3VuZFwiKTt2YXIgbD1uZXcgcih7ZGVmaW5pdGlvbjpbXSxzZXBhcmF0b3I6cCxpZHg6dX0pLGg9c1syXTtyZXR1cm4gby5pc1VuZGVmaW5lZChoKXx8KGwubmFtZT1oKSxiKGwsdC5yYW5nZSxuLGEpfWZ1bmN0aW9uIGIodCxlLG4scil7dmFyIGk9RChlLG4pLGE9by5zb3J0QnkoaSxmdW5jdGlvbih0KXtyZXR1cm4gdC5yYW5nZS5zdGFydH0pLHM9W107cmV0dXJuIG8uZm9yRWFjaChhLGZ1bmN0aW9uKHQpe3MucHVzaChDKHQsbixyKSk7fSksdC5kZWZpbml0aW9uPXMsdH1mdW5jdGlvbiBEKHQsZSl7cmV0dXJuIG8uZmlsdGVyKGUsZnVuY3Rpb24obil7dmFyIHI9dC5zdHJpY3RseUNvbnRhaW5zUmFuZ2Uobi5yYW5nZSksaT1vLmV2ZXJ5KGUsZnVuY3Rpb24oZSl7dmFyIHI9ZS5yYW5nZS5zdHJpY3RseUNvbnRhaW5zUmFuZ2Uobi5yYW5nZSksaT1lLnJhbmdlLmlzU3RyaWN0bHlDb250YWluZWRJblJhbmdlKHQpO3JldHVybiAhKHImJmkpfSk7cmV0dXJuIHImJml9KX1lLnRlcm1pbmFsTmFtZVRvQ29uc3RydWN0b3I9e30sZS5idWlsZFRvcFByb2R1Y3Rpb249ZnVuY3Rpb24odCxuLHIpe2UudGVybWluYWxOYW1lVG9Db25zdHJ1Y3Rvcj1yO3ZhciBvPVYoaihLKFwiICBcIit0KSkpO3JldHVybiBmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gYihuZXcgYS5SdWxlKHtuYW1lOnQsZGVmaW5pdGlvbjpbXSxvcmdUZXh0OnJ9KSxlLG4sdCl9KG4sbmV3IGkuUmFuZ2UoMCx0Lmxlbmd0aCsyKSxvLHQpfSxlLmJ1aWxkUHJvZEdhc3Q9QyxlLmdldERpcmVjdGx5Q29udGFpbmVkUmFuZ2VzPUQ7dmFyIHc9L1xcL1xcLy4qL2csVT0vXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qXFwvXXxbXFxyXFxuXSkpKSpcXCorXFwvL2csRz0vKE5BTUVcXHMqOlxccyopP1wiKFteXFxcXFwiXXxcXFxcKFtiZm5ydHZcIlxcXFxcXC9dfHVbMC05YS1mQS1GXXs0fSkpKlwiL2csQj0vKE5BTUVcXHMqOlxccyopPycoW15cXFxcJ118XFxcXChbYmZucnR2J1xcXFxcXC9dfHVbMC05YS1mQS1GXXs0fSkpKicvZztmdW5jdGlvbiBLKHQpe3JldHVybiB0LnJlcGxhY2UodyxcIlwiKS5yZXBsYWNlKFUsXCJcIil9ZnVuY3Rpb24gVyh0LGUpe3JldHVybiB2b2lkIDAhPT1lP3Q6XCJcIn1mdW5jdGlvbiBqKHQpe3JldHVybiB0LnJlcGxhY2UoRyxXKS5yZXBsYWNlKEIsVyl9ZnVuY3Rpb24gVih0KXt2YXIgZT1ZKHQpLG49SCh0KSxyPVgodCksaT16KHQpLG89cSh0KSxhPSQodCkscz1aKHQpLHU9USh0KTtyZXR1cm4gW10uY29uY2F0KGUsbixyLGksbyxhLHMsdSl9ZnVuY3Rpb24gWSh0KXtyZXR1cm4gbnQodCxyLlRFUk1JTkFMLHApfWZ1bmN0aW9uIEgodCl7cmV0dXJuIG50KHQsci5SRUYsaCl9ZnVuY3Rpb24gWCh0KXtyZXR1cm4gcnQodCxyLkFUX0xFQVNUX09ORSxTKX1mdW5jdGlvbiB6KHQpe3JldHVybiBydCh0LHIuQVRfTEVBU1RfT05FX1NFUCxBKX1mdW5jdGlvbiBxKHQpe3JldHVybiBydCh0LHIuTUFOWSxUKX1mdW5jdGlvbiAkKHQpe3JldHVybiBydCh0LHIuTUFOWV9TRVAsXyl9ZnVuY3Rpb24gWih0KXtyZXR1cm4gcnQodCxyLk9QVElPTixFKX1mdW5jdGlvbiBRKHQpe3ZhciBlPXJ0KHQsci5PUixrKSxuPWV0KGUpO3JldHVybiBlLmNvbmNhdChuKX1lLnJlbW92ZUNvbW1lbnRzPUssZS5yZW1vdmVTdHJpbmdMaXRlcmFscz1qLGUuY3JlYXRlUmFuZ2VzPVYsZS5jcmVhdGVUZXJtaW5hbFJhbmdlcz1ZLGUuY3JlYXRlUmVmc1Jhbmdlcz1ILGUuY3JlYXRlQXRMZWFzdE9uZVJhbmdlcz1YLGUuY3JlYXRlQXRMZWFzdE9uZVNlcFJhbmdlcz16LGUuY3JlYXRlTWFueVJhbmdlcz1xLGUuY3JlYXRlTWFueVNlcFJhbmdlcz0kLGUuY3JlYXRlT3B0aW9uUmFuZ2VzPVosZS5jcmVhdGVPclJhbmdlcz1RO3ZhciBKPW8ucGFydGlhbChvdCxcIntcIixcIn1cIiksdHQ9by5wYXJ0aWFsKG90LFwiKFwiLFwiKVwiKTtmdW5jdGlvbiBldCh0KXt2YXIgZT1bXTtyZXR1cm4gby5mb3JFYWNoKHQsZnVuY3Rpb24odCl7dmFyIG49aXQodC50ZXh0LHIuRkxBVCx4LEopLGk9dC5yYW5nZS5zdGFydDtvLmZvckVhY2gobixmdW5jdGlvbih0KXt0LnJhbmdlLnN0YXJ0Kz1pLHQucmFuZ2UuZW5kKz1pO30pLGU9ZS5jb25jYXQobik7fSksby51bmlxKGUsZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZStcIn5cIit0LnJhbmdlLnN0YXJ0K1wiflwiK3QucmFuZ2UuZW5kK1wiflwiK3QudGV4dH0pfWZ1bmN0aW9uIG50KHQsZSxuKXtmb3IodmFyIHIsbz1bXTtyPW4uZXhlYyh0KTspe3ZhciBhPXIuaW5kZXgscz1uLmxhc3RJbmRleCx1PW5ldyBpLlJhbmdlKGEscyksYz1yWzBdO28ucHVzaCh7cmFuZ2U6dSx0ZXh0OmMsdHlwZTplfSk7fXJldHVybiBvfWZ1bmN0aW9uIHJ0KHQsZSxuKXtyZXR1cm4gaXQodCxlLG4sdHQpfWZ1bmN0aW9uIGl0KHQsZSxuLHIpe2Zvcih2YXIgbyxhPVtdO289bi5leGVjKHQpOyl7dmFyIHM9by5pbmRleCx1PXIocytvWzBdLmxlbmd0aCx0KSxjPW5ldyBpLlJhbmdlKHMsdSkscD10LnN1YnN0cihzLHUtcysxKTthLnB1c2goe3JhbmdlOmMsdGV4dDpwLHR5cGU6ZX0pO31yZXR1cm4gYX1mdW5jdGlvbiBvdCh0LGUsbixyKXtmb3IodmFyIGk9WzFdLGE9LTE7IW8uaXNFbXB0eShpKSYmYStuPHIubGVuZ3RoOyl7YSsrO3ZhciBzPXIuY2hhckF0KG4rYSk7cz09PXQ/aS5wdXNoKDEpOnM9PT1lJiZpLnBvcCgpO31pZihvLmlzRW1wdHkoaSkpcmV0dXJuIGErbjt0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEIElOUFVUIFRFWFQsIFVOVEVSTUlOQVRFRCBQQVJFTlRIRVNJU1wiKX1mdW5jdGlvbiBhdCh0LGUpe3JldHVybiBvLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiBzdCh0LGUpfSl9ZnVuY3Rpb24gc3QodCxlKXtzd2l0Y2godC50eXBlKXtjYXNlXCJOb25UZXJtaW5hbFwiOnJldHVybiBuZXcgYS5Ob25UZXJtaW5hbCh7bm9uVGVybWluYWxOYW1lOnQubmFtZSxpZHg6dC5pZHh9KTtjYXNlXCJGbGF0XCI6cmV0dXJuIG5ldyBhLkZsYXQoe25hbWU6dC5uYW1lLGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiT3B0aW9uXCI6cmV0dXJuIG5ldyBhLk9wdGlvbih7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiOnJldHVybiBuZXcgYS5SZXBldGl0aW9uTWFuZGF0b3J5KHtuYW1lOnQubmFtZSxpZHg6dC5pZHgsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTtjYXNlXCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiOnJldHVybiBuZXcgYS5SZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcih7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LHNlcGFyYXRvcjplW3Quc2VwYXJhdG9yLm5hbWVdLGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIjpyZXR1cm4gbmV3IGEuUmVwZXRpdGlvbldpdGhTZXBhcmF0b3Ioe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxzZXBhcmF0b3I6ZVt0LnNlcGFyYXRvci5uYW1lXSxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIlJlcGV0aXRpb25cIjpyZXR1cm4gbmV3IGEuUmVwZXRpdGlvbih7bmFtZTp0Lm5hbWUsaWR4OnQuaWR4LGRlZmluaXRpb246YXQodC5kZWZpbml0aW9uLGUpfSk7Y2FzZVwiQWx0ZXJuYXRpb25cIjpyZXR1cm4gbmV3IGEuQWx0ZXJuYXRpb24oe25hbWU6dC5uYW1lLGlkeDp0LmlkeCxkZWZpbml0aW9uOmF0KHQuZGVmaW5pdGlvbixlKX0pO2Nhc2VcIlRlcm1pbmFsXCI6cmV0dXJuIG5ldyBhLlRlcm1pbmFsKHt0ZXJtaW5hbFR5cGU6ZVt0Lm5hbWVdLGlkeDp0LmlkeH0pO2Nhc2VcIlJ1bGVcIjpyZXR1cm4gbmV3IGEuUnVsZSh7bmFtZTp0Lm5hbWUsb3JnVGV4dDp0Lm9yZ1RleHQsZGVmaW5pdGlvbjphdCh0LmRlZmluaXRpb24sZSl9KTt9fWUuY3JlYXRlT3JQYXJ0UmFuZ2VzPWV0LGUuZmluZENsb3NpbmdPZmZzZXQ9b3QsZS5kZXNlcmlhbGl6ZUdyYW1tYXI9YXQsZS5kZXNlcmlhbGl6ZVByb2R1Y3Rpb249c3Q7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigwKSxpPW4oNCksbz1uKDMwKSxhPW4oMTEpLHM9bigxMCksdT1uKDgpO2UucmVzb2x2ZUdyYW1tYXI9ZnVuY3Rpb24odCl7dD1yLmRlZmF1bHRzKHQse2Vyck1zZ1Byb3ZpZGVyOnMuZGVmYXVsdEdyYW1tYXJSZXNvbHZlckVycm9yUHJvdmlkZXJ9KTt2YXIgZT1uZXcgaS5IYXNoVGFibGU7cmV0dXJuIHIuZm9yRWFjaCh0LnJ1bGVzLGZ1bmN0aW9uKHQpe2UucHV0KHQubmFtZSx0KTt9KSxvLnJlc29sdmVHcmFtbWFyKGUsdC5lcnJNc2dQcm92aWRlcil9LGUudmFsaWRhdGVHcmFtbWFyPWZ1bmN0aW9uKHQpe3JldHVybiB0PXIuZGVmYXVsdHModCx7ZXJyTXNnUHJvdmlkZXI6cy5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsaWdub3JlZElzc3Vlczp7fX0pLGEudmFsaWRhdGVHcmFtbWFyKHQucnVsZXMsdC5tYXhMb29rYWhlYWQsdC50b2tlblR5cGVzLHQuaWdub3JlZElzc3Vlcyx0LmVyck1zZ1Byb3ZpZGVyLHQuZ3JhbW1hck5hbWUpfSxlLmFzc2lnbk9jY3VycmVuY2VJbmRpY2VzPWZ1bmN0aW9uKHQpe3IuZm9yRWFjaCh0LnJ1bGVzLGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB1LkRzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yO3QuYWNjZXB0KGUpLHIuZm9yRWFjaChlLmRzbE1ldGhvZHMsZnVuY3Rpb24odCl7ci5mb3JFYWNoKHQsZnVuY3Rpb24odCxlKXt0LmlkeD1lKzE7fSk7fSk7fSk7fTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDIpLGk9bigwKSxvPW4oNiksYT1uKDIyKSxzPW4oNCksdT1uKDMpO2Z1bmN0aW9uIGModCl7dGhpcy5uYW1lPWUuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04sdGhpcy5tZXNzYWdlPXQ7fWUuRU9GX0ZPTExPV19LRVk9e30sZS5JTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTj1cIkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uXCIsZS5JblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbj1jLGMucHJvdG90eXBlPUVycm9yLnByb3RvdHlwZTt2YXIgcD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRSZWNvdmVyYWJsZT1mdW5jdGlvbih0KXt0aGlzLmZpcnN0QWZ0ZXJSZXBNYXA9bmV3IHMuSGFzaFRhYmxlLHRoaXMucmVzeW5jRm9sbG93cz1uZXcgcy5IYXNoVGFibGUsdGhpcy5yZWNvdmVyeUVuYWJsZWQ9aS5oYXModCxcInJlY292ZXJ5RW5hYmxlZFwiKT90LnJlY292ZXJ5RW5hYmxlZDp1LkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5yZWNvdmVyeUVuYWJsZWQsdGhpcy5yZWNvdmVyeUVuYWJsZWQmJih0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeT1sKTt9LHQucHJvdG90eXBlLmdldFRva2VuVG9JbnNlcnQ9ZnVuY3Rpb24odCl7dmFyIGU9ci5jcmVhdGVUb2tlbkluc3RhbmNlKHQsXCJcIixOYU4sTmFOLE5hTixOYU4sTmFOLE5hTik7cmV0dXJuIGUuaXNJbnNlcnRlZEluUmVjb3Zlcnk9ITAsZX0sdC5wcm90b3R5cGUuY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3Zlcnk9ZnVuY3Rpb24odCl7cmV0dXJuICEwfSx0LnByb3RvdHlwZS50cnlJblJlcGV0aXRpb25SZWNvdmVyeT1mdW5jdGlvbih0LGUsbixyKXtmb3IodmFyIGE9dGhpcyxzPXRoaXMuZmluZFJlU3luY1Rva2VuVHlwZSgpLHU9dGhpcy5leHBvcnRMZXhlclN0YXRlKCksYz1bXSxwPSExLGw9dGhpcy5MQSgxKSxoPXRoaXMuTEEoMSksZj1mdW5jdGlvbigpe3ZhciB0PWEuTEEoMCksZT1hLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uoe2V4cGVjdGVkOnIsYWN0dWFsOmwscHJldmlvdXM6dCxydWxlTmFtZTphLmdldEN1cnJSdWxlRnVsbE5hbWUoKX0pLG49bmV3IG8uTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKGUsbCxhLkxBKDApKTtuLnJlc3luY2VkVG9rZW5zPWkuZHJvcFJpZ2h0KGMpLGEuU0FWRV9FUlJPUihuKTt9OyFwOyl7aWYodGhpcy50b2tlbk1hdGNoZXIoaCxyKSlyZXR1cm4gdm9pZCBmKCk7aWYobi5jYWxsKHRoaXMpKXJldHVybiBmKCksdm9pZCB0LmFwcGx5KHRoaXMsZSk7dGhpcy50b2tlbk1hdGNoZXIoaCxzKT9wPSEwOihoPXRoaXMuU0tJUF9UT0tFTigpLHRoaXMuYWRkVG9SZXN5bmNUb2tlbnMoaCxjKSk7fXRoaXMuaW1wb3J0TGV4ZXJTdGF0ZSh1KTt9LHQucHJvdG90eXBlLnNob3VsZEluUmVwZXRpdGlvblJlY292ZXJ5QmVUcmllZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDAhPT10JiZ2b2lkIDAhPT1lJiYoIXRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksdCkmJighdGhpcy5pc0JhY2tUcmFja2luZygpJiYhdGhpcy5jYW5QZXJmb3JtSW5SdWxlUmVjb3ZlcnkodCx0aGlzLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeSh0LGUpKSkpfSx0LnByb3RvdHlwZS5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3Zlcnk9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEN1cnJlbnRHcmFtbWFyUGF0aCh0LGUpO3JldHVybiB0aGlzLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMobil9LHQucHJvdG90eXBlLnRyeUluUnVsZVJlY292ZXJ5PWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKHQsZSkpcmV0dXJuIHRoaXMuZ2V0VG9rZW5Ub0luc2VydCh0KTtpZih0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbih0KSl7dmFyIG49dGhpcy5TS0lQX1RPS0VOKCk7cmV0dXJuIHRoaXMuY29uc3VtZVRva2VuKCksbn10aHJvdyBuZXcgYyhcInNhZCBzYWQgcGFuZGFcIil9LHQucHJvdG90eXBlLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24odCxlKXx8dGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24odCl9LHQucHJvdG90eXBlLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO2lmKCF0aGlzLmNhblRva2VuVHlwZUJlSW5zZXJ0ZWRJblJlY292ZXJ5KHQpKXJldHVybiAhMTtpZihpLmlzRW1wdHkoZSkpcmV0dXJuICExO3ZhciByPXRoaXMuTEEoMSk7cmV0dXJuIHZvaWQgMCE9PWkuZmluZChlLGZ1bmN0aW9uKHQpe3JldHVybiBuLnRva2VuTWF0Y2hlcihyLHQpfSl9LHQucHJvdG90eXBlLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgyKSx0KX0sdC5wcm90b3R5cGUuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q3VyckZvbGxvd0tleSgpLG49dGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGUpO3JldHVybiBpLmNvbnRhaW5zKG4sdCl9LHQucHJvdG90eXBlLmZpbmRSZVN5bmNUb2tlblR5cGU9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5mbGF0dGVuRm9sbG93U2V0KCksZT10aGlzLkxBKDEpLG49Mjs7KXt2YXIgcj1lLnRva2VuVHlwZTtpZihpLmNvbnRhaW5zKHQscikpcmV0dXJuIHI7ZT10aGlzLkxBKG4pLG4rKzt9fSx0LnByb3RvdHlwZS5nZXRDdXJyRm9sbG93S2V5PWZ1bmN0aW9uKCl7aWYoMT09PXRoaXMuUlVMRV9TVEFDSy5sZW5ndGgpcmV0dXJuIGUuRU9GX0ZPTExPV19LRVk7dmFyIHQ9dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCksbj10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXgoKSxyPXRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtyZXR1cm4ge3J1bGVOYW1lOnRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUodCksaWR4SW5DYWxsaW5nUnVsZTpuLGluUnVsZTp0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHIpfX0sdC5wcm90b3R5cGUuYnVpbGRGdWxsRm9sbG93S2V5U3RhY2s9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49dGhpcy5SVUxFX1NUQUNLLHI9dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s7cmV0dXJuIGkuaXNFbXB0eSh0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSyl8fChuPWkubWFwKHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLGZ1bmN0aW9uKGUpe3JldHVybiB0LlJVTEVfU1RBQ0tbZV19KSxyPWkubWFwKHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLGZ1bmN0aW9uKGUpe3JldHVybiB0LlJVTEVfT0NDVVJSRU5DRV9TVEFDS1tlXX0pKSxpLm1hcChuLGZ1bmN0aW9uKGksbyl7cmV0dXJuIDA9PT1vP2UuRU9GX0ZPTExPV19LRVk6e3J1bGVOYW1lOnQuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUoaSksaWR4SW5DYWxsaW5nUnVsZTpyW29dLGluUnVsZTp0LnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKG5bby0xXSl9fSl9LHQucHJvdG90eXBlLmZsYXR0ZW5Gb2xsb3dTZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9aS5tYXAodGhpcy5idWlsZEZ1bGxGb2xsb3dLZXlTdGFjaygpLGZ1bmN0aW9uKGUpe3JldHVybiB0LmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoZSl9KTtyZXR1cm4gaS5mbGF0dGVuKGUpfSx0LnByb3RvdHlwZS5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5PWZ1bmN0aW9uKHQpe2lmKHQ9PT1lLkVPRl9GT0xMT1dfS0VZKXJldHVybiBbci5FT0ZdO3ZhciBuPXQucnVsZU5hbWUrdC5pZHhJbkNhbGxpbmdSdWxlK2EuSU4rdC5pblJ1bGU7cmV0dXJuIHRoaXMucmVzeW5jRm9sbG93cy5nZXQobil9LHQucHJvdG90eXBlLmFkZFRvUmVzeW5jVG9rZW5zPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHQsci5FT0YpfHxlLnB1c2godCksZX0sdC5wcm90b3R5cGUucmVTeW5jVG89ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49dGhpcy5MQSgxKTshMT09PXRoaXMudG9rZW5NYXRjaGVyKG4sdCk7KW49dGhpcy5TS0lQX1RPS0VOKCksdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhuLGUpO3JldHVybiBpLmRyb3BSaWdodChlKX0sdC5wcm90b3R5cGUuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5PWZ1bmN0aW9uKHQsZSxuLHIsaSxvKXt9LHQucHJvdG90eXBlLmdldEN1cnJlbnRHcmFtbWFyUGF0aD1mdW5jdGlvbih0LGUpe3JldHVybiB7cnVsZVN0YWNrOnRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpLG9jY3VycmVuY2VTdGFjazppLmNsb25lQXJyKHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLKSxsYXN0VG9rOnQsbGFzdFRva09jY3VycmVuY2U6ZX19LHQucHJvdG90eXBlLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2s9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBpLmlzRW1wdHkodGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0spP2kubWFwKHRoaXMuUlVMRV9TVEFDSyxmdW5jdGlvbihlKXtyZXR1cm4gdC5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShlKX0pOmkubWFwKHRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLGZ1bmN0aW9uKGUpe3JldHVybiB0LnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHQuUlVMRV9TVEFDS1tlXSl9KX0sdH0oKTtmdW5jdGlvbiBsKHQsZSxuLGksbyxhKXt2YXIgcz10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLG8pLHU9dGhpcy5maXJzdEFmdGVyUmVwTWFwLmdldChzKTtpZih2b2lkIDA9PT11KXt2YXIgYz10aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKTt1PW5ldyBhKHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KGMpLG8pLnN0YXJ0V2Fsa2luZygpLHRoaXMuZmlyc3RBZnRlclJlcE1hcC5wdXQocyx1KTt9dmFyIHA9dS50b2tlbixsPXUub2NjdXJyZW5jZSxoPXUuaXNFbmRPZlJ1bGU7MT09PXRoaXMuUlVMRV9TVEFDSy5sZW5ndGgmJmgmJnZvaWQgMD09PXAmJihwPXIuRU9GLGw9MSksdGhpcy5zaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQocCxsKSYmdGhpcy50cnlJblJlcGV0aXRpb25SZWNvdmVyeSh0LGUsbixwKTt9ZS5SZWNvdmVyYWJsZT1wLGUuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5PWw7fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDE0KSxhPW4oNCkscz1uKDIxKSx1PW4oMCksYz1uKDIyKSxwPW4oMiksbD1uKDEpLGg9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udG9wUHJvZD1lLG4uZm9sbG93cz1uZXcgYS5IYXNoVGFibGUsbn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnN0YXJ0V2Fsa2luZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLndhbGsodGhpcy50b3BQcm9kKSx0aGlzLmZvbGxvd3N9LGUucHJvdG90eXBlLndhbGtUZXJtaW5hbD1mdW5jdGlvbih0LGUsbil7fSxlLnByb3RvdHlwZS53YWxrUHJvZFJlZj1mdW5jdGlvbih0LGUsbil7dmFyIHI9Zih0LnJlZmVyZW5jZWRSdWxlLHQuaWR4KSt0aGlzLnRvcFByb2QubmFtZSxpPWUuY29uY2F0KG4pLG89bmV3IGwuRmxhdCh7ZGVmaW5pdGlvbjppfSksYT1zLmZpcnN0KG8pO3RoaXMuZm9sbG93cy5wdXQocixhKTt9LGV9KG8uUmVzdFdhbGtlcik7ZnVuY3Rpb24gZih0LGUpe3JldHVybiB0Lm5hbWUrZStjLklOfWUuUmVzeW5jRm9sbG93c1dhbGtlcj1oLGUuY29tcHV0ZUFsbFByb2RzRm9sbG93cz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYS5IYXNoVGFibGU7cmV0dXJuIHUuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBoKHQpLnN0YXJ0V2Fsa2luZygpO2UucHV0QWxsKG4pO30pLGV9LGUuYnVpbGRCZXR3ZWVuUHJvZHNGb2xsb3dQcmVmaXg9ZixlLmJ1aWxkSW5Qcm9kRm9sbG93UHJlZml4PWZ1bmN0aW9uKHQpe3JldHVybiBwLnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSkrdC5pZHgrYy5JTn07fSxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8KHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gKHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZTt9fHxmdW5jdGlvbih0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pO30pKHQsZSl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbigpe3RoaXMuY29uc3RydWN0b3I9dDt9cih0LGUpLHQucHJvdG90eXBlPW51bGw9PT1lP09iamVjdC5jcmVhdGUoZSk6KG4ucHJvdG90eXBlPWUucHJvdG90eXBlLG5ldyBuKTt9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1uKDE5KSxhPW4oMikscz1uKDE1KSx1PW4oMCksYz1uKDI4KSxwPW5ldyBvLlJlZ0V4cFBhcnNlcixsPVwiUEFUVEVSTlwiO2Z1bmN0aW9uIGgodCl7dmFyIGU9dS5maWx0ZXIodCxmdW5jdGlvbih0KXtyZXR1cm4gIXUuaGFzKHQsbCl9KTtyZXR1cm4ge2Vycm9yczp1Lm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBtaXNzaW5nIHN0YXRpYyAnUEFUVEVSTicgcHJvcGVydHlcIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1JU1NJTkdfUEFUVEVSTix0b2tlblR5cGVzOlt0XX19KSx2YWxpZDp1LmRpZmZlcmVuY2UodCxlKX19ZnVuY3Rpb24gZih0KXt2YXIgZT11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3ZhciBlPXRbbF07cmV0dXJuICEodS5pc1JlZ0V4cChlKXx8dS5pc0Z1bmN0aW9uKGUpfHx1LmhhcyhlLFwiZXhlY1wiKXx8dS5pc1N0cmluZyhlKSl9KTtyZXR1cm4ge2Vycm9yczp1Lm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbiBvbmx5IGJlIGEgUmVnRXhwLCBhIEZ1bmN0aW9uIG1hdGNoaW5nIHRoZSB7Q3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jfSB0eXBlIG9yIGFuIE9iamVjdCBtYXRjaGluZyB0aGUge0lDdXN0b21QYXR0ZXJufSBpbnRlcmZhY2UuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX1BBVFRFUk4sdG9rZW5UeXBlczpbdF19fSksdmFsaWQ6dS5kaWZmZXJlbmNlKHQsZSl9fWUuREVGQVVMVF9NT0RFPVwiZGVmYXVsdE1vZGVcIixlLk1PREVTPVwibW9kZXNcIixlLlNVUFBPUlRfU1RJQ0tZPVwiYm9vbGVhblwiPT10eXBlb2YgbmV3IFJlZ0V4cChcIig/OilcIikuc3RpY2t5LGUuZGlzYWJsZVN0aWNreT1mdW5jdGlvbigpe2UuU1VQUE9SVF9TVElDS1k9ITE7fSxlLmVuYWJsZVN0aWNreT1mdW5jdGlvbigpe2UuU1VQUE9SVF9TVElDS1k9ITA7fSxlLmFuYWx5emVUb2tlblR5cGVzPWZ1bmN0aW9uKHQsbil7bj11LmRlZmF1bHRzKG4se3VzZVN0aWNreTplLlNVUFBPUlRfU1RJQ0tZLGRlYnVnOiExLHNhZmVNb2RlOiExLHBvc2l0aW9uVHJhY2tpbmc6XCJmdWxsXCIsbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOltcIlxcclwiLFwiXFxuXCJdfSk7dmFyIHI9dS5yZWplY3QodCxmdW5jdGlvbih0KXtyZXR1cm4gdFtsXT09PXMuTGV4ZXIuTkF9KSxpPSExLG89dS5tYXAocixmdW5jdGlvbih0KXt2YXIgZT10W2xdO2lmKHUuaXNSZWdFeHAoZSkpe3ZhciByPWUuc291cmNlO3JldHVybiAxPT09ci5sZW5ndGgmJlwiXlwiIT09ciYmXCIkXCIhPT1yJiZcIi5cIiE9PXI/cjoyIT09ci5sZW5ndGh8fFwiXFxcXFwiIT09clswXXx8dS5jb250YWlucyhbXCJkXCIsXCJEXCIsXCJzXCIsXCJTXCIsXCJ0XCIsXCJyXCIsXCJuXCIsXCJ0XCIsXCIwXCIsXCJjXCIsXCJiXCIsXCJCXCIsXCJmXCIsXCJ2XCIsXCJ3XCIsXCJXXCJdLHJbMV0pP24udXNlU3RpY2t5P08oZSk6TihlKTpyWzFdfWlmKHUuaXNGdW5jdGlvbihlKSlyZXR1cm4gaT0hMCx7ZXhlYzplfTtpZih1LmhhcyhlLFwiZXhlY1wiKSlyZXR1cm4gaT0hMCxlO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGU7dmFyIG89ZS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcIlxcXFwkJlwiKSxhPW5ldyBSZWdFeHAobyk7cmV0dXJuIG4udXNlU3RpY2t5P08oYSk6TihhKX10aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfSkscD11Lm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiB0LnRva2VuVHlwZUlkeH0pLGg9dS5tYXAocixmdW5jdGlvbih0KXt2YXIgZT10LkdST1VQO2lmKGUhPT1zLkxleGVyLlNLSVBQRUQpe2lmKHUuaXNTdHJpbmcoZSkpcmV0dXJuIGU7aWYodS5pc1VuZGVmaW5lZChlKSlyZXR1cm4gITE7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX19KSxmPXUubWFwKHIsZnVuY3Rpb24odCl7dmFyIGU9dC5MT05HRVJfQUxUO2lmKGUpcmV0dXJuIHUuaW5kZXhPZihyLGUpfSksZD11Lm1hcChyLGZ1bmN0aW9uKHQpe3JldHVybiB0LlBVU0hfTU9ERX0pLEU9dS5tYXAocixmdW5jdGlvbih0KXtyZXR1cm4gdS5oYXModCxcIlBPUF9NT0RFXCIpfSksbT1QKG4ubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSx5PXUubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuICExfSk7XCJvbmx5T2Zmc2V0XCIhPT1uLnBvc2l0aW9uVHJhY2tpbmcmJih5PXUubWFwKHIsZnVuY3Rpb24odCl7cmV0dXJuIHUuaGFzKHQsXCJMSU5FX0JSRUFLU1wiKT90LkxJTkVfQlJFQUtTOiExPT09TCh0LG0pP2MuY2FuTWF0Y2hDaGFyQ29kZShtLHQuUEFUVEVSTik6dm9pZCAwfSkpO3ZhciBUPXUubWFwKHIsUyksdj11Lm1hcChvLEkpLGc9dS5yZWR1Y2UocixmdW5jdGlvbih0LGUpe3ZhciBuPWUuR1JPVVA7cmV0dXJuIHUuaXNTdHJpbmcobikmJm4hPT1zLkxleGVyLlNLSVBQRUQmJih0W25dPVtdKSx0fSx7fSksXz11Lm1hcChvLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHtwYXR0ZXJuOm9bZV0sbG9uZ2VyQWx0OmZbZV0sY2FuTGluZVRlcm1pbmF0b3I6eVtlXSxpc0N1c3RvbTpUW2VdLHNob3J0OnZbZV0sZ3JvdXA6aFtlXSxwdXNoOmRbZV0scG9wOkVbZV0sdG9rZW5UeXBlSWR4OnBbZV0sdG9rZW5UeXBlOnJbZV19fSk7ZnVuY3Rpb24gUih0LGUsbil7dm9pZCAwPT09dFtlXSYmKHRbZV09W10pLHRbZV0ucHVzaChuKTt9dmFyIEE9ITAsaz1bXTtyZXR1cm4gbi5zYWZlTW9kZXx8KGs9dS5yZWR1Y2UocixmdW5jdGlvbih0LGUscil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUuUEFUVEVSTil7dmFyIGk9ZS5QQVRURVJOLmNoYXJDb2RlQXQoMCk7Uih0LGksX1tyXSk7fWVsc2UgaWYodS5pc0FycmF5KGUuU1RBUlRfQ0hBUlNfSElOVCkpdS5mb3JFYWNoKGUuU1RBUlRfQ0hBUlNfSElOVCxmdW5jdGlvbihlKXt2YXIgbj1cInN0cmluZ1wiPT10eXBlb2YgZT9lLmNoYXJDb2RlQXQoMCk6ZTtSKHQsbixfW3JdKTt9KTtlbHNlIGlmKHUuaXNSZWdFeHAoZS5QQVRURVJOKSlpZihlLlBBVFRFUk4udW5pY29kZSlBPSExLG4uZW5zdXJlT3B0aW1pemF0aW9ucyYmdS5QUklOVF9FUlJPUihjLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZytcIlxcdFVuYWJsZSB0byBhbmFseXplIDwgXCIrZS5QQVRURVJOLnRvU3RyaW5nKCkrXCIgPiBwYXR0ZXJuLlxcblxcdFRoZSByZWdleHAgdW5pY29kZSBmbGFnIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkuXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5JQ09ERV9PUFRJTUlaRVwiKTtlbHNlIHt2YXIgbz1jLmdldFN0YXJ0Q29kZXMoZS5QQVRURVJOLG4uZW5zdXJlT3B0aW1pemF0aW9ucyk7dS5pc0VtcHR5KG8pJiYoQT0hMSksdS5mb3JFYWNoKG8sZnVuY3Rpb24oZSl7Uih0LGUsX1tyXSk7fSk7fWVsc2Ugbi5lbnN1cmVPcHRpbWl6YXRpb25zJiZ1LlBSSU5UX0VSUk9SKGMuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnK1wiXFx0VG9rZW5UeXBlOiA8XCIrYS50b2tlbk5hbWUoZSkrXCI+IGlzIHVzaW5nIGEgY3VzdG9tIHRva2VuIHBhdHRlcm4gd2l0aG91dCBwcm92aWRpbmcgPHN0YXJ0X2NoYXJzX2hpbnQ+IHBhcmFtZXRlci5cXG5cXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL3NhcC5naXRodWIuaW8vY2hldnJvdGFpbi9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fT1BUSU1JWkVcIiksQT0hMTtyZXR1cm4gdH0sW10pKSxBJiZrLmxlbmd0aDw2NTUzNiYmKGs9dS5wYWNrQXJyYXkoaykpLHtlbXB0eUdyb3VwczpnLHBhdHRlcm5JZHhUb0NvbmZpZzpfLGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc6ayxoYXNDdXN0b206aSxjYW5CZU9wdGltaXplZDpBfX0sZS52YWxpZGF0ZVBhdHRlcm5zPWZ1bmN0aW9uKHQsZSl7dmFyIG49W10scj1oKHQpO249bi5jb25jYXQoci5lcnJvcnMpO3ZhciBpPWYoci52YWxpZCksbz1pLnZhbGlkO3JldHVybiBuPShuPShuPShuPShuPW4uY29uY2F0KGkuZXJyb3JzKSkuY29uY2F0KGZ1bmN0aW9uKHQpe3ZhciBlPVtdLG49dS5maWx0ZXIodCxmdW5jdGlvbih0KXtyZXR1cm4gdS5pc1JlZ0V4cCh0W2xdKX0pO3JldHVybiBlPShlPShlPShlPShlPWUuY29uY2F0KEUobikpKS5jb25jYXQoVChuKSkpLmNvbmNhdCh2KG4pKSkuY29uY2F0KGcobikpKS5jb25jYXQobShuKSl9KG8pKSkuY29uY2F0KF8obykpKS5jb25jYXQoUihvLGUpKSkuY29uY2F0KEEobykpfSxlLmZpbmRNaXNzaW5nUGF0dGVybnM9aCxlLmZpbmRJbnZhbGlkUGF0dGVybnM9Zjt2YXIgZD0vW15cXFxcXVtcXCRdLztmdW5jdGlvbiBFKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuZm91bmQ9ITEsZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0RW5kQW5jaG9yPWZ1bmN0aW9uKHQpe3RoaXMuZm91bmQ9ITA7fSxlfShvLkJhc2VSZWdFeHBWaXNpdG9yKSxuPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7dmFyIG49dFtsXTt0cnl7dmFyIHI9cC5wYXR0ZXJuKG4udG9TdHJpbmcoKSksaT1uZXcgZTtyZXR1cm4gaS52aXNpdChyKSxpLmZvdW5kfWNhdGNoKHQpe3JldHVybiBkLnRlc3Qobi5zb3VyY2UpfX0pO3JldHVybiB1Lm1hcChuLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlVuZXhwZWN0ZWQgUmVnRXhwIEFuY2hvciBFcnJvcjpcXG5cXHRUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBlbmQgb2YgaW5wdXQgYW5jaG9yICckJ1xcblxcdFNlZSBzYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1xcdGZvciBkZXRhaWxzLlwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuRU9JX0FOQ0hPUl9GT1VORCx0b2tlblR5cGVzOlt0XX19KX1mdW5jdGlvbiBtKHQpe3ZhciBlPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7cmV0dXJuIHRbbF0udGVzdChcIlwiKX0pO3JldHVybiB1Lm1hcChlLGZ1bmN0aW9uKHQpe3JldHVybiB7bWVzc2FnZTpcIlRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG11c3Qgbm90IG1hdGNoIGFuIGVtcHR5IHN0cmluZ1wiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuRU1QVFlfTUFUQ0hfUEFUVEVSTix0b2tlblR5cGVzOlt0XX19KX1lLmZpbmRFbmRPZklucHV0QW5jaG9yPUUsZS5maW5kRW1wdHlNYXRjaFJlZ0V4cHM9bTt2YXIgeT0vW15cXFxcW11bXFxeXXxeXFxeLztmdW5jdGlvbiBUKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1udWxsIT09dCYmdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7cmV0dXJuIGUuZm91bmQ9ITEsZX1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnZpc2l0U3RhcnRBbmNob3I9ZnVuY3Rpb24odCl7dGhpcy5mb3VuZD0hMDt9LGV9KG8uQmFzZVJlZ0V4cFZpc2l0b3IpLG49dS5maWx0ZXIodCxmdW5jdGlvbih0KXt2YXIgbj10W2xdO3RyeXt2YXIgcj1wLnBhdHRlcm4obi50b1N0cmluZygpKSxpPW5ldyBlO3JldHVybiBpLnZpc2l0KHIpLGkuZm91bmR9Y2F0Y2godCl7cmV0dXJuIHkudGVzdChuLnNvdXJjZSl9fSk7cmV0dXJuIHUubWFwKG4sZnVuY3Rpb24odCl7cmV0dXJuIHttZXNzYWdlOlwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblxcdFRva2VuIFR5cGU6IC0+XCIrYS50b2tlbk5hbWUodCkrXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIHN0YXJ0IG9mIGlucHV0IGFuY2hvciAnXidcXG5cXHRTZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1xcdGZvciBkZXRhaWxzLlwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuU09JX0FOQ0hPUl9GT1VORCx0b2tlblR5cGVzOlt0XX19KX1mdW5jdGlvbiB2KHQpe3ZhciBlPXUuZmlsdGVyKHQsZnVuY3Rpb24odCl7dmFyIGU9dFtsXTtyZXR1cm4gZSBpbnN0YW5jZW9mIFJlZ0V4cCYmKGUubXVsdGlsaW5lfHxlLmdsb2JhbCl9KTtyZXR1cm4gdS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQQVRURVJOJyBtYXkgTk9UIGNvbnRhaW4gZ2xvYmFsKCdnJykgb3IgbXVsdGlsaW5lKCdtJylcIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5ELHRva2VuVHlwZXM6W3RdfX0pfWZ1bmN0aW9uIGcodCl7dmFyIGU9W10sbj11Lm1hcCh0LGZ1bmN0aW9uKG4pe3JldHVybiB1LnJlZHVjZSh0LGZ1bmN0aW9uKHQscil7cmV0dXJuIG4uUEFUVEVSTi5zb3VyY2UhPT1yLlBBVFRFUk4uc291cmNlfHx1LmNvbnRhaW5zKGUscil8fHIuUEFUVEVSTj09PXMuTGV4ZXIuTkE/dDooZS5wdXNoKHIpLHQucHVzaChyKSx0KX0sW10pfSk7bj11LmNvbXBhY3Qobik7dmFyIHI9dS5maWx0ZXIobixmdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg+MX0pO3JldHVybiB1Lm1hcChyLGZ1bmN0aW9uKHQpe3ZhciBlPXUubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIGEudG9rZW5OYW1lKHQpfSk7cmV0dXJuIHttZXNzYWdlOlwiVGhlIHNhbWUgUmVnRXhwIHBhdHRlcm4gLT5cIit1LmZpcnN0KHQpLlBBVFRFUk4rXCI8LWhhcyBiZWVuIHVzZWQgaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcgVG9rZW4gVHlwZXM6IFwiK2Uuam9pbihcIiwgXCIpK1wiIDwtXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkQsdG9rZW5UeXBlczp0fX0pfWZ1bmN0aW9uIF8odCl7dmFyIGU9dS5maWx0ZXIodCxmdW5jdGlvbih0KXtpZighdS5oYXModCxcIkdST1VQXCIpKXJldHVybiAhMTt2YXIgZT10LkdST1VQO3JldHVybiBlIT09cy5MZXhlci5TS0lQUEVEJiZlIT09cy5MZXhlci5OQSYmIXUuaXNTdHJpbmcoZSl9KTtyZXR1cm4gdS5tYXAoZSxmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdHUk9VUCcgY2FuIG9ubHkgYmUgTGV4ZXIuU0tJUFBFRC9MZXhlci5OQS9BIFN0cmluZ1wiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELHRva2VuVHlwZXM6W3RdfX0pfWZ1bmN0aW9uIFIodCxlKXt2YXIgbj11LmZpbHRlcih0LGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10LlBVU0hfTU9ERSYmIXUuY29udGFpbnMoZSx0LlBVU0hfTU9ERSl9KTtyZXR1cm4gdS5tYXAobixmdW5jdGlvbih0KXtyZXR1cm4ge21lc3NhZ2U6XCJUb2tlbiBUeXBlOiAtPlwiK2EudG9rZW5OYW1lKHQpK1wiPC0gc3RhdGljICdQVVNIX01PREUnIHZhbHVlIGNhbm5vdCByZWZlciB0byBhIExleGVyIE1vZGUgLT5cIit0LlBVU0hfTU9ERStcIjwtd2hpY2ggZG9lcyBub3QgZXhpc3RcIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVCx0b2tlblR5cGVzOlt0XX19KX1mdW5jdGlvbiBBKHQpe3ZhciBlPVtdLG49dS5yZWR1Y2UodCxmdW5jdGlvbih0LGUsbil7dmFyIHIsaT1lLlBBVFRFUk47cmV0dXJuIGk9PT1zLkxleGVyLk5BP3Q6KHUuaXNTdHJpbmcoaSk/dC5wdXNoKHtzdHI6aSxpZHg6bix0b2tlblR5cGU6ZX0pOnUuaXNSZWdFeHAoaSkmJihyPWksdm9pZCAwPT09dS5maW5kKFtcIi5cIixcIlxcXFxcIixcIltcIixcIl1cIixcInxcIixcIl5cIixcIiRcIixcIihcIixcIilcIixcIj9cIixcIipcIixcIitcIixcIntcIl0sZnVuY3Rpb24odCl7cmV0dXJuIC0xIT09ci5zb3VyY2UuaW5kZXhPZih0KX0pKSYmdC5wdXNoKHtzdHI6aS5zb3VyY2UsaWR4Om4sdG9rZW5UeXBlOmV9KSx0KX0sW10pO3JldHVybiB1LmZvckVhY2godCxmdW5jdGlvbih0LHIpe3UuZm9yRWFjaChuLGZ1bmN0aW9uKG4pe3ZhciBpPW4uc3RyLG89bi5pZHgsYz1uLnRva2VuVHlwZTtpZihyPG8mJmZ1bmN0aW9uKHQsZSl7aWYodS5pc1JlZ0V4cChlKSl7dmFyIG49ZS5leGVjKHQpO3JldHVybiBudWxsIT09biYmMD09PW4uaW5kZXh9aWYodS5pc0Z1bmN0aW9uKGUpKXJldHVybiBlKHQsMCxbXSx7fSk7aWYodS5oYXMoZSxcImV4ZWNcIikpcmV0dXJuIGUuZXhlYyh0LDAsW10se30pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBlPT09dDt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfShpLHQuUEFUVEVSTikpe3ZhciBwPVwiVG9rZW46IC0+XCIrYS50b2tlbk5hbWUoYykrXCI8LSBjYW4gbmV2ZXIgYmUgbWF0Y2hlZC5cXG5CZWNhdXNlIGl0IGFwcGVhcnMgQUZURVIgdGhlIFRva2VuIFR5cGUgLT5cIithLnRva2VuTmFtZSh0KStcIjwtaW4gdGhlIGxleGVyJ3MgZGVmaW5pdGlvbi5cXG5TZWUgaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5SRUFDSEFCTEVcIjtlLnB1c2goe21lc3NhZ2U6cCx0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOUkVBQ0hBQkxFX1BBVFRFUk4sdG9rZW5UeXBlczpbdCxjXX0pO319KTt9KSxlfWZ1bmN0aW9uIE4odCl7dmFyIGU9dC5pZ25vcmVDYXNlP1wiaVwiOlwiXCI7cmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIrdC5zb3VyY2UrXCIpXCIsZSl9ZnVuY3Rpb24gTyh0KXt2YXIgZT10Lmlnbm9yZUNhc2U/XCJpeVwiOlwieVwiO3JldHVybiBuZXcgUmVnRXhwKFwiXCIrdC5zb3VyY2UsZSl9ZnVuY3Rpb24gUyh0KXt2YXIgZT10LlBBVFRFUk47aWYodS5pc1JlZ0V4cChlKSlyZXR1cm4gITE7aWYodS5pc0Z1bmN0aW9uKGUpKXJldHVybiAhMDtpZih1LmhhcyhlLFwiZXhlY1wiKSlyZXR1cm4gITA7aWYodS5pc1N0cmluZyhlKSlyZXR1cm4gITE7dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1mdW5jdGlvbiBJKHQpe3JldHVybiAhKCF1LmlzU3RyaW5nKHQpfHwxIT09dC5sZW5ndGgpJiZ0LmNoYXJDb2RlQXQoMCl9ZnVuY3Rpb24gTCh0LGUpe2lmKHUuaGFzKHQsXCJMSU5FX0JSRUFLU1wiKSlyZXR1cm4gITE7aWYodS5pc1JlZ0V4cCh0LlBBVFRFUk4pKXt0cnl7Yy5jYW5NYXRjaENoYXJDb2RlKGUsdC5QQVRURVJOKTt9Y2F0Y2godCl7cmV0dXJuIHtpc3N1ZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SLGVyck1zZzp0Lm1lc3NhZ2V9fXJldHVybiAhMX1pZih1LmlzU3RyaW5nKHQuUEFUVEVSTikpcmV0dXJuICExO2lmKFModCkpcmV0dXJuIHtpc3N1ZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBS307dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKX1mdW5jdGlvbiBrKHQsZSl7aWYoZS5pc3N1ZT09PXMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IpcmV0dXJuIFwiV2FybmluZzogdW5hYmxlIHRvIGlkZW50aWZ5IGxpbmUgdGVybWluYXRvciB1c2FnZSBpbiBwYXR0ZXJuLlxcblxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8XCIrdC5uYW1lK1wiPiBUb2tlbiBUeXBlXFxuXFx0IFJvb3QgY2F1c2U6IFwiK2UuZXJyTXNnK1wiLlxcblxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjSURFTlRJRllfVEVSTUlOQVRPUlwiO2lmKGUuaXNzdWU9PT1zLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBSylyZXR1cm4gXCJXYXJuaW5nOiBBIEN1c3RvbSBUb2tlbiBQYXR0ZXJuIHNob3VsZCBzcGVjaWZ5IHRoZSA8bGluZV9icmVha3M+IG9wdGlvbi5cXG5cXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPFwiK3QubmFtZStcIj4gVG9rZW4gVHlwZVxcblxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ1VTVE9NX0xJTkVfQlJFQUtcIjt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfWZ1bmN0aW9uIFAodCl7cmV0dXJuIHUubWFwKHQsZnVuY3Rpb24odCl7cmV0dXJuIHUuaXNTdHJpbmcodCkmJnQubGVuZ3RoPjA/dC5jaGFyQ29kZUF0KDApOnR9KX1lLmZpbmRTdGFydE9mSW5wdXRBbmNob3I9VCxlLmZpbmRVbnN1cHBvcnRlZEZsYWdzPXYsZS5maW5kRHVwbGljYXRlUGF0dGVybnM9ZyxlLmZpbmRJbnZhbGlkR3JvdXBUeXBlPV8sZS5maW5kTW9kZXNUaGF0RG9Ob3RFeGlzdD1SLGUuZmluZFVucmVhY2hhYmxlUGF0dGVybnM9QSxlLmFkZFN0YXJ0T2ZJbnB1dD1OLGUuYWRkU3RpY2t5RmxhZz1PLGUucGVyZm9ybVJ1bnRpbWVDaGVja3M9ZnVuY3Rpb24odCxuLHIpe3ZhciBpPVtdO3JldHVybiB1Lmhhcyh0LGUuREVGQVVMVF9NT0RFKXx8aS5wdXNoKHttZXNzYWdlOlwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIrZS5ERUZBVUxUX01PREUrXCI+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXFxuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFfSksdS5oYXModCxlLk1PREVTKXx8aS5wdXNoKHttZXNzYWdlOlwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIrZS5NT0RFUytcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWX0pLHUuaGFzKHQsZS5NT0RFUykmJnUuaGFzKHQsZS5ERUZBVUxUX01PREUpJiYhdS5oYXModC5tb2Rlcyx0LmRlZmF1bHRNb2RlKSYmaS5wdXNoKHttZXNzYWdlOlwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGggYSBcIitlLkRFRkFVTFRfTU9ERStcIjogPFwiK3QuZGVmYXVsdE1vZGUrXCI+d2hpY2ggZG9lcyBub3QgZXhpc3RcXG5cIix0eXBlOnMuTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUfSksdS5oYXModCxlLk1PREVTKSYmdS5mb3JFYWNoKHQubW9kZXMsZnVuY3Rpb24odCxlKXt1LmZvckVhY2godCxmdW5jdGlvbih0LG4pe3UuaXNVbmRlZmluZWQodCkmJmkucHVzaCh7bWVzc2FnZTpcIkEgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHVzaW5nIGFuIHVuZGVmaW5lZCBUb2tlbiBUeXBlLiBNb2RlOjxcIitlK1wiPiBhdCBpbmRleDogPFwiK24rXCI+XFxuXCIsdHlwZTpzLkxleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5MRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRH0pO30pO30pLGl9LGUucGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bXSxpPSExLG89dS5jb21wYWN0KHUuZmxhdHRlbih1Lm1hcFZhbHVlcyh0Lm1vZGVzLGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpKSxhPXUucmVqZWN0KG8sZnVuY3Rpb24odCl7cmV0dXJuIHRbbF09PT1zLkxleGVyLk5BfSkscD1QKG4pO3JldHVybiBlJiZ1LmZvckVhY2goYSxmdW5jdGlvbih0KXt2YXIgZT1MKHQscCk7aWYoITEhPT1lKXt2YXIgbj17bWVzc2FnZTprKHQsZSksdHlwZTplLmlzc3VlLHRva2VuVHlwZTp0fTtyLnB1c2gobik7fWVsc2UgdS5oYXModCxcIkxJTkVfQlJFQUtTXCIpPyEwPT09dC5MSU5FX0JSRUFLUyYmKGk9ITApOmMuY2FuTWF0Y2hDaGFyQ29kZShwLHQuUEFUVEVSTikmJihpPSEwKTt9KSxlJiYhaSYmci5wdXNoKHttZXNzYWdlOlwiV2FybmluZzogTm8gTElORV9CUkVBS1MgRm91bmQuXFxuXFx0VGhpcyBMZXhlciBoYXMgYmVlbiBkZWZpbmVkIHRvIHRyYWNrIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbixcXG5cXHRCdXQgbm9uZSBvZiB0aGUgVG9rZW4gVHlwZXMgY2FuIGJlIGlkZW50aWZpZWQgYXMgbWF0Y2hpbmcgYSBsaW5lIHRlcm1pbmF0b3IuXFxuXFx0U2VlIGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0xJTkVfQlJFQUtTIFxcblxcdGZvciBkZXRhaWxzLlwiLHR5cGU6cy5MZXhlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTElORV9CUkVBS1NfRkxBR1N9KSxyfSxlLmNsb25lRW1wdHlHcm91cHM9ZnVuY3Rpb24odCl7dmFyIGU9e30sbj11LmtleXModCk7cmV0dXJuIHUuZm9yRWFjaChuLGZ1bmN0aW9uKG4pe3ZhciByPXRbbl07aWYoIXUuaXNBcnJheShyKSl0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO2Vbbl09W107fSksZX0sZS5pc0N1c3RvbVBhdHRlcm49UyxlLmlzU2hvcnRQYXR0ZXJuPUksZS5MaW5lVGVybWluYXRvck9wdGltaXplZFRlc3Rlcj17dGVzdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgsbj10aGlzLmxhc3RJbmRleDtuPGU7bisrKXt2YXIgcj10LmNoYXJDb2RlQXQobik7aWYoMTA9PT1yKXJldHVybiB0aGlzLmxhc3RJbmRleD1uKzEsITA7aWYoMTM9PT1yKXJldHVybiAxMD09PXQuY2hhckNvZGVBdChuKzEpP3RoaXMubGFzdEluZGV4PW4rMjp0aGlzLmxhc3RJbmRleD1uKzEsITB9cmV0dXJuICExfSxsYXN0SW5kZXg6MH0sZS5idWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZT1rO30sZnVuY3Rpb24odCxlLG4pe3ZhciByLGk9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fChyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIChyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LGUpe3QuX19wcm90b19fPWU7fXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKTt9KSh0LGUpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPXQ7fXIodCxlKSx0LnByb3RvdHlwZT1udWxsPT09ZT9PYmplY3QuY3JlYXRlKGUpOihuLnByb3RvdHlwZT1lLnByb3RvdHlwZSxuZXcgbik7fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89bigxOSksYT1uKDApLHM9bmV3IG8uUmVnRXhwUGFyc2VyLHU9XCJDb21wbGVtZW50IFNldHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9uXCI7ZnVuY3Rpb24gYyh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJEaXNqdW5jdGlvblwiOnJldHVybiBhLmZsYXR0ZW4oYS5tYXAodC52YWx1ZSxjKSk7Y2FzZVwiQWx0ZXJuYXRpdmVcIjpmb3IodmFyIGU9W10sbj10LnZhbHVlLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXTtpZighYS5jb250YWlucyhbXCJHcm91cEJhY2tSZWZlcmVuY2VcIixcIkxvb2thaGVhZFwiLFwiTmVnYXRpdmVMb29rYWhlYWRcIixcIlN0YXJ0QW5jaG9yXCIsXCJFbmRBbmNob3JcIixcIldvcmRCb3VuZGFyeVwiLFwiTm9uV29yZEJvdW5kYXJ5XCJdLGkudHlwZSkpe3ZhciBvPWk7c3dpdGNoKG8udHlwZSl7Y2FzZVwiQ2hhcmFjdGVyXCI6ZS5wdXNoKG8udmFsdWUpO2JyZWFrO2Nhc2VcIlNldFwiOmlmKCEwPT09by5jb21wbGVtZW50KXRocm93IEVycm9yKHUpO2EuZm9yRWFjaChvLnZhbHVlLGZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KWUucHVzaCh0KTtlbHNlIGZvcih2YXIgbj10LHI9bi5mcm9tO3I8PW4udG87cisrKWUucHVzaChyKTt9KTticmVhaztjYXNlXCJHcm91cFwiOnZhciBzPWMoby52YWx1ZSk7YS5mb3JFYWNoKHMsZnVuY3Rpb24odCl7cmV0dXJuIGUucHVzaCh0KX0pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJOb24gRXhoYXVzdGl2ZSBNYXRjaFwiKX12YXIgcD12b2lkIDAhPT1vLnF1YW50aWZpZXImJjA9PT1vLnF1YW50aWZpZXIuYXRMZWFzdDtpZihcIkdyb3VwXCI9PT1vLnR5cGUmJiExPT09aChvKXx8XCJHcm91cFwiIT09by50eXBlJiYhMT09PXApYnJlYWt9fXJldHVybiBlO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaCFcIil9fWZ1bmN0aW9uIHAodCl7dmFyIGU9W107cmV0dXJuIGEuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe2UucHVzaCh0KTt2YXIgbj1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO24udG9VcHBlckNhc2UoKSE9PW4/ZS5wdXNoKG4udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApKTpuLnRvTG93ZXJDYXNlKCkhPT1uJiZlLnB1c2gobi50b0xvd2VyQ2FzZSgpLmNoYXJDb2RlQXQoMCkpO30pLGV9ZnVuY3Rpb24gbCh0LGUpe3JldHVybiBhLmZpbmQodC52YWx1ZSxmdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gYS5jb250YWlucyhlLHQpO3ZhciBuPXQ7cmV0dXJuIHZvaWQgMCE9PWEuZmluZChlLGZ1bmN0aW9uKHQpe3JldHVybiBuLmZyb208PXQmJnQ8PW4udG99KX0pfWZ1bmN0aW9uIGgodCl7cmV0dXJuICEoIXQucXVhbnRpZmllcnx8MCE9PXQucXVhbnRpZmllci5hdExlYXN0KXx8ISF0LnZhbHVlJiYoYS5pc0FycmF5KHQudmFsdWUpP2EuZXZlcnkodC52YWx1ZSxoKTpoKHQudmFsdWUpKX1lLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZz0nVW5hYmxlIHRvIHVzZSBcImZpcnN0IGNoYXJcIiBsZXhlciBvcHRpbWl6YXRpb25zOlxcbicsZS5nZXRTdGFydENvZGVzPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49ITEpO3RyeXt2YXIgcj1zLnBhdHRlcm4odC50b1N0cmluZygpKSxpPWMoci52YWx1ZSk7cmV0dXJuIHIuZmxhZ3MuaWdub3JlQ2FzZSYmKGk9cChpKSksaX1jYXRjaChyKXtpZihyLm1lc3NhZ2U9PT11KW4mJmEuUFJJTlRfV0FSTklORyhlLmZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZytcIlxcdFVuYWJsZSB0byBvcHRpbWl6ZTogPCBcIit0LnRvU3RyaW5nKCkrXCIgPlxcblxcdENvbXBsZW1lbnQgU2V0cyBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBvcHRpbWl6ZWQuXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblxcdFNlZTogaHR0cHM6Ly9zYXAuZ2l0aHViLmlvL2NoZXZyb3RhaW4vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQ09NUExFTUVOVCBmb3IgZGV0YWlscy5cIik7ZWxzZSB7dmFyIGw9XCJcIjtuJiYobD1cIlxcblxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI1JFR0VYUF9QQVJTSU5HIGZvciBkZXRhaWxzLlwiKSxhLlBSSU5UX0VSUk9SKGUuZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnK1wiXFxuXFx0RmFpbGVkIHBhcnNpbmc6IDwgXCIrdC50b1N0cmluZygpK1wiID5cXG5cXHRVc2luZyB0aGUgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5IHZlcnNpb246IFwiK28uVkVSU0lPTitcIlxcblxcdFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0OiBodHRwczovL2dpdGh1Yi5jb20vYmQ4Mi9yZWdleHAtdG8tYXN0L2lzc3Vlc1wiK2wpO319cmV0dXJuIFtdfSxlLmZpcnN0Q2hhcj1jLGUuYXBwbHlJZ25vcmVDYXNlPXA7dmFyIGY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4udGFyZ2V0Q2hhckNvZGVzPWUsbi5mb3VuZD0hMSxufXJldHVybiBpKGUsdCksZS5wcm90b3R5cGUudmlzaXRDaGlsZHJlbj1mdW5jdGlvbihlKXtzd2l0Y2goZS50eXBlKXtjYXNlXCJMb29rYWhlYWRcIjpyZXR1cm4gdm9pZCB0aGlzLnZpc2l0TG9va2FoZWFkKGUpO2Nhc2VcIk5lZ2F0aXZlTG9va2FoZWFkXCI6cmV0dXJuIHZvaWQgdGhpcy52aXNpdE5lZ2F0aXZlTG9va2FoZWFkKGUpfXQucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4uY2FsbCh0aGlzLGUpO30sZS5wcm90b3R5cGUudmlzaXRDaGFyYWN0ZXI9ZnVuY3Rpb24odCl7YS5jb250YWlucyh0aGlzLnRhcmdldENoYXJDb2Rlcyx0LnZhbHVlKSYmKHRoaXMuZm91bmQ9ITApO30sZS5wcm90b3R5cGUudmlzaXRTZXQ9ZnVuY3Rpb24odCl7dC5jb21wbGVtZW50P3ZvaWQgMD09PWwodCx0aGlzLnRhcmdldENoYXJDb2RlcykmJih0aGlzLmZvdW5kPSEwKTp2b2lkIDAhPT1sKHQsdGhpcy50YXJnZXRDaGFyQ29kZXMpJiYodGhpcy5mb3VuZD0hMCk7fSxlfShvLkJhc2VSZWdFeHBWaXNpdG9yKTtlLmNhbk1hdGNoQ2hhckNvZGU9ZnVuY3Rpb24odCxlKXtpZihlIGluc3RhbmNlb2YgUmVnRXhwKXt2YXIgbj1zLnBhdHRlcm4oZS50b1N0cmluZygpKSxyPW5ldyBmKHQpO3JldHVybiByLnZpc2l0KG4pLHIuZm91bmR9cmV0dXJuIHZvaWQgMCE9PWEuZmluZChlLGZ1bmN0aW9uKGUpe3JldHVybiBhLmNvbnRhaW5zKHQsZS5jaGFyQ29kZUF0KDApKX0pfTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtpZih0aGlzLnN0YXJ0PXQsdGhpcy5lbmQ9ZSwhaSh0LGUpKXRocm93IG5ldyBFcnJvcihcIklOVkFMSUQgUkFOR0VcIil9cmV0dXJuIHQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0PD10JiZ0aGlzLmVuZD49dH0sdC5wcm90b3R5cGUuY29udGFpbnNSYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGFydDw9dC5zdGFydCYmdGhpcy5lbmQ+PXQuZW5kfSx0LnByb3RvdHlwZS5pc0NvbnRhaW5lZEluUmFuZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29udGFpbnNSYW5nZSh0aGlzKX0sdC5wcm90b3R5cGUuc3RyaWN0bHlDb250YWluc1JhbmdlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXJ0PHQuc3RhcnQmJnRoaXMuZW5kPnQuZW5kfSx0LnByb3RvdHlwZS5pc1N0cmljdGx5Q29udGFpbmVkSW5SYW5nZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5zdHJpY3RseUNvbnRhaW5zUmFuZ2UodGhpcyl9LHR9KCk7ZnVuY3Rpb24gaSh0LGUpe3JldHVybiAhKHQ8MHx8ZTx0KX1lLlJhbmdlPXIsZS5pc1ZhbGlkUmFuZ2U9aTt9LGZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMmJnRoaXMuX19leHRlbmRzfHwocj1mdW5jdGlvbih0LGUpe3JldHVybiAocj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lO318fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSk7fSkodCxlKX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10O31yKHQsZSksdC5wcm90b3R5cGU9bnVsbD09PWU/T2JqZWN0LmNyZWF0ZShlKToobi5wcm90b3R5cGU9ZS5wcm90b3R5cGUsbmV3IG4pO30pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBvPW4oMyksYT1uKDApLHM9big1KTtlLnJlc29sdmVHcmFtbWFyPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IHUodCxlKTtyZXR1cm4gbi5yZXNvbHZlUmVmcygpLG4uZXJyb3JzfTt2YXIgdT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUsbil7dmFyIHI9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiByLm5hbWVUb1RvcFJ1bGU9ZSxyLmVyck1zZ1Byb3ZpZGVyPW4sci5lcnJvcnM9W10scn1yZXR1cm4gaShlLHQpLGUucHJvdG90eXBlLnJlc29sdmVSZWZzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczthLmZvckVhY2godGhpcy5uYW1lVG9Ub3BSdWxlLnZhbHVlcygpLGZ1bmN0aW9uKGUpe3QuY3VyclRvcExldmVsPWUsZS5hY2NlcHQodCk7fSk7fSxlLnByb3RvdHlwZS52aXNpdE5vblRlcm1pbmFsPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubmFtZVRvVG9wUnVsZS5nZXQodC5ub25UZXJtaW5hbE5hbWUpO2lmKGUpdC5yZWZlcmVuY2VkUnVsZT1lO2Vsc2Uge3ZhciBuPXRoaXMuZXJyTXNnUHJvdmlkZXIuYnVpbGRSdWxlTm90Rm91bmRFcnJvcih0aGlzLmN1cnJUb3BMZXZlbCx0KTt0aGlzLmVycm9ycy5wdXNoKHttZXNzYWdlOm4sdHlwZTpvLlBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRVNPTFZFRF9TVUJSVUxFX1JFRixydWxlTmFtZTp0aGlzLmN1cnJUb3BMZXZlbC5uYW1lLHVucmVzb2x2ZWRSZWZOYW1lOnQubm9uVGVybWluYWxOYW1lfSk7fX0sZX0ocy5HQXN0VmlzaXRvcik7ZS5HYXN0UmVmUmVzb2x2ZXJWaXNpdG9yPXU7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigxMiksaT1uKDApLG89bigzKSxhPW4oOSkscz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRMb29rc0FoZWFkPWZ1bmN0aW9uKHQpe3RoaXMuZHluYW1pY1Rva2Vuc0VuYWJsZWQ9aS5oYXModCxcImR5bmFtaWNUb2tlbnNFbmFibGVkXCIpP3QuZHluYW1pY1Rva2Vuc0VuYWJsZWQ6by5ERUZBVUxUX1BBUlNFUl9DT05GSUcuZHluYW1pY1Rva2Vuc0VuYWJsZWQsdGhpcy5tYXhMb29rYWhlYWQ9aS5oYXModCxcIm1heExvb2thaGVhZFwiKT90Lm1heExvb2thaGVhZDpvLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5tYXhMb29rYWhlYWQsdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlPWkuaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKT9uZXcgTWFwOltdLGkuaXNFUzIwMTVNYXBTdXBwb3J0ZWQoKT8odGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGU9dGhpcy5nZXRMYUZ1bmNGcm9tTWFwLHRoaXMuc2V0TGFGdW5jQ2FjaGU9dGhpcy5zZXRMYUZ1bmNDYWNoZVVzaW5nTWFwKToodGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGU9dGhpcy5nZXRMYUZ1bmNGcm9tT2JqLHRoaXMuc2V0TGFGdW5jQ2FjaGU9dGhpcy5zZXRMYUZ1bmNVc2luZ09iaik7fSx0LnByb3RvdHlwZS5sb29rQWhlYWRCdWlsZGVyRm9yT3B0aW9uYWw9ZnVuY3Rpb24odCxlLG4pe3JldHVybiByLmJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbih0LGUsbil9LHQucHJvdG90eXBlLmxvb2tBaGVhZEJ1aWxkZXJGb3JBbHRlcm5hdGl2ZXM9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIHIuYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jKHQsZSxuLGkpfSx0LnByb3RvdHlwZS5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtyZXR1cm4gYS5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQobix0LGUpfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yT3I9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChhLk9SX0lEWCx0KSxvPXRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKG4pO2lmKHZvaWQgMD09PW8pe3ZhciBzPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLHU9dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQocyksYz1pLnNvbWUoZSxmdW5jdGlvbih0KXtyZXR1cm4gaS5pc0Z1bmN0aW9uKHQuR0FURSl9KTtyZXR1cm4gbz1yLmJ1aWxkTG9va2FoZWFkRnVuY0Zvck9yKHQsdSx0aGlzLm1heExvb2thaGVhZCxjLHRoaXMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsdGhpcy5sb29rQWhlYWRCdWlsZGVyRm9yQWx0ZXJuYXRpdmVzKSx0aGlzLnNldExhRnVuY0NhY2hlKG4sbyksb31yZXR1cm4gb30sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0Zvck9wdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmdldExvb2thaGVhZEZ1bmNGb3IodCxlLHRoaXMubWF4TG9va2FoZWFkLHIuUFJPRF9UWVBFLk9QVElPTil9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JNYW55PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvcih0LGUsdGhpcy5tYXhMb29rYWhlYWQsci5QUk9EX1RZUEUuUkVQRVRJVElPTil9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JNYW55U2VwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvcih0LGUsdGhpcy5tYXhMb29rYWhlYWQsci5QUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUil9LHQucHJvdG90eXBlLmdldExvb2thaGVhZEZ1bmNGb3JBdExlYXN0T25lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvcih0LGUsdGhpcy5tYXhMb29rYWhlYWQsci5QUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlkpfSx0LnByb3RvdHlwZS5nZXRMb29rYWhlYWRGdW5jRm9yQXRMZWFzdE9uZVNlcD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmdldExvb2thaGVhZEZ1bmNGb3IodCxlLHRoaXMubWF4TG9va2FoZWFkLHIuUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKX0sdC5wcm90b3R5cGUuZ2V0TG9va2FoZWFkRnVuY0Zvcj1mdW5jdGlvbih0LGUsbixpKXt2YXIgbz10aGlzLmdldExhRnVuY0Zyb21DYWNoZSh0KTtpZih2b2lkIDA9PT1vKXt2YXIgYT10aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxzPXRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCkuZ2V0KGEpO3JldHVybiBvPXIuYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKGUscyxuLHRoaXMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsaSx0aGlzLmxvb2tBaGVhZEJ1aWxkZXJGb3JPcHRpb25hbCksdGhpcy5zZXRMYUZ1bmNDYWNoZSh0LG8pLG99cmV0dXJuIG99LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21DYWNoZT1mdW5jdGlvbih0KXt9LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21NYXA9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5nZXQodCl9LHQucHJvdG90eXBlLmdldExhRnVuY0Zyb21PYmo9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZVt0XX0sdC5wcm90b3R5cGUuc2V0TGFGdW5jQ2FjaGU9ZnVuY3Rpb24odCxlKXt9LHQucHJvdG90eXBlLnNldExhRnVuY0NhY2hlVXNpbmdNYXA9ZnVuY3Rpb24odCxlKXt0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuc2V0KHQsZSk7fSx0LnByb3RvdHlwZS5zZXRMYUZ1bmNVc2luZ09iaj1mdW5jdGlvbih0LGUpe3RoaXMubG9va0FoZWFkRnVuY3NDYWNoZVt0XT1lO30sdH0oKTtlLkxvb2tzQWhlYWQ9czt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDE2KSxpPW4oMCksbz1uKDMzKSxhPW4oOSkscz1uKDMpLHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0VHJlZUJ1aWxkZXI9ZnVuY3Rpb24odCl7dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0s9W10sdGhpcy5DU1RfU1RBQ0s9W10sdGhpcy5vdXRwdXRDc3Q9aS5oYXModCxcIm91dHB1dENzdFwiKT90Lm91dHB1dENzdDpzLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5vdXRwdXRDc3QsdGhpcy5vdXRwdXRDc3R8fCh0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZT1pLk5PT1AsdGhpcy5jc3RGaW5hbGx5U3RhdGVVcGRhdGU9aS5OT09QLHRoaXMuY3N0UG9zdFRlcm1pbmFsPWkuTk9PUCx0aGlzLmNzdFBvc3ROb25UZXJtaW5hbD1pLk5PT1AsdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lPXRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0LHRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWU9dGhpcy5nZXRQcmV2aW91c0V4cGxpY2l0UnVsZVNob3J0TmFtZU5vQ3N0LHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleD10aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXhOb0NzdCx0aGlzLm1hbnlJbnRlcm5hbD10aGlzLm1hbnlJbnRlcm5hbE5vQ3N0LHRoaXMub3JJbnRlcm5hbD10aGlzLm9ySW50ZXJuYWxOb0NzdCx0aGlzLm9wdGlvbkludGVybmFsPXRoaXMub3B0aW9uSW50ZXJuYWxOb0NzdCx0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbD10aGlzLmF0TGVhc3RPbmVJbnRlcm5hbE5vQ3N0LHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWw9dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbE5vQ3N0LHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWw9dGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbE5vQ3N0KTt9LHQucHJvdG90eXBlLmNzdE5lc3RlZEludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbih0LGUpe3RoaXMuQ1NUX1NUQUNLLnB1c2goe25hbWU6dCxmdWxsTmFtZTp0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwuZ2V0KHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpKSt0LGNoaWxkcmVuOnt9fSk7fSx0LnByb3RvdHlwZS5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGU9ZnVuY3Rpb24odCxlKXt0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5wdXNoKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGgtMSksdGhpcy5DU1RfU1RBQ0sucHVzaCh7bmFtZTp0LGNoaWxkcmVuOnt9fSk7fSx0LnByb3RvdHlwZS5jc3RGaW5hbGx5U3RhdGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5wb3AoKSx0aGlzLkNTVF9TVEFDSy5wb3AoKTt9LHQucHJvdG90eXBlLmNzdE5lc3RlZEZpbmFsbHlTdGF0ZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuQ1NUX1NUQUNLLnBvcCgpO30sdC5wcm90b3R5cGUuY3N0UG9zdFRlcm1pbmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdO3IuYWRkVGVybWluYWxUb0NzdChuLGUsdCk7fSx0LnByb3RvdHlwZS5jc3RQb3N0Tm9uVGVybWluYWw9ZnVuY3Rpb24odCxlKXtyLmFkZE5vbmVUZXJtaW5hbFRvQ3N0KHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXSxlLHQpO30sdC5wcm90b3R5cGUuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3Rvcj1mdW5jdGlvbigpe2lmKGkuaXNVbmRlZmluZWQodGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yKSl7dmFyIHQ9by5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IodGhpcy5jbGFzc05hbWUsdGhpcy5hbGxSdWxlTmFtZXMpO3JldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I9dCx0fXJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3J9LHQucHJvdG90eXBlLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHM9ZnVuY3Rpb24oKXtpZihpLmlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3Rvcikpe3ZhciB0PW8uY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cyh0aGlzLmNsYXNzTmFtZSx0aGlzLmFsbFJ1bGVOYW1lcyx0aGlzLmdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IoKSk7cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3Rvcj10LHR9cmV0dXJuIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3Rvcn0sdC5wcm90b3R5cGUubmVzdGVkUnVsZUJlZm9yZUNsYXVzZT1mdW5jdGlvbih0LGUpe3ZhciBuO3JldHVybiB2b2lkIDAhPT10Lk5BTUU/KG49dC5OQU1FLHRoaXMubmVzdGVkUnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShuLGUpLG4pOnZvaWQgMH0sdC5wcm90b3R5cGUubmVzdGVkQWx0QmVmb3JlQ2xhdXNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpLG89dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCkscz1hLmdldEtleUZvckFsdEluZGV4KG8sbixlLHIpO3JldHVybiB2b2lkIDAhPT10Lk5BTUU/KGk9dC5OQU1FLHRoaXMubmVzdGVkUnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShpLHMpLHtzaG9ydE5hbWU6cyxuZXN0ZWROYW1lOml9KTp2b2lkIDB9LHQucHJvdG90eXBlLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5DU1RfU1RBQ0ssaT1uW24ubGVuZ3RoLTFdO3RoaXMubmVzdGVkUnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpO3ZhciBvPW5bbi5sZW5ndGgtMV07ci5hZGROb25lVGVybWluYWxUb0NzdChvLGUsaSk7fSx0LnByb3RvdHlwZS5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0tbdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0subGVuZ3RoLTFdO3JldHVybiB0aGlzLlJVTEVfU1RBQ0tbdF19LHQucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuUlVMRV9TVEFDSztyZXR1cm4gdFt0Lmxlbmd0aC0xXX0sdC5wcm90b3R5cGUuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDS1t0aGlzLkxBU1RfRVhQTElDSVRfUlVMRV9TVEFDSy5sZW5ndGgtMl07cmV0dXJuIHRoaXMuUlVMRV9TVEFDS1t0XX0sdC5wcm90b3R5cGUuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWVOb0NzdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuUlVMRV9TVEFDSztyZXR1cm4gdFt0Lmxlbmd0aC0yXX0sdC5wcm90b3R5cGUuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLW3RoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0tbdF19LHQucHJvdG90eXBlLmdldExhc3RFeHBsaWNpdFJ1bGVPY2N1cnJlbmNlSW5kZXhOb0NzdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO3JldHVybiB0W3QubGVuZ3RoLTFdfSx0LnByb3RvdHlwZS5uZXN0ZWRSdWxlSW52b2NhdGlvblN0YXRlVXBkYXRlPWZ1bmN0aW9uKHQsZSl7dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaCgxKSx0aGlzLlJVTEVfU1RBQ0sucHVzaChlKSx0aGlzLmNzdE5lc3RlZEludm9jYXRpb25TdGF0ZVVwZGF0ZSh0LGUpO30sdC5wcm90b3R5cGUubmVzdGVkUnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuUlVMRV9TVEFDSy5wb3AoKSx0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKSx0aGlzLmNzdE5lc3RlZEZpbmFsbHlTdGF0ZVVwZGF0ZSgpO30sdH0oKTtlLlRyZWVCdWlsZGVyPXU7fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHIsaT1uKDApLG89big0KSxhPW4oMTEpO2Z1bmN0aW9uIHModCxlKXtmb3IodmFyIG49aS5rZXlzKHQpLHI9bi5sZW5ndGgsbz0wO288cjtvKyspZm9yKHZhciBhPXRbbltvXV0scz1hLmxlbmd0aCx1PTA7dTxzO3UrKyl7dmFyIGM9YVt1XTt2b2lkIDA9PT1jLnRva2VuVHlwZUlkeCYmKHZvaWQgMCE9PWMuZnVsbE5hbWU/dGhpc1tjLmZ1bGxOYW1lXShjLmNoaWxkcmVuLGUpOnRoaXNbYy5uYW1lXShjLmNoaWxkcmVuLGUpKTt9fWZ1bmN0aW9uIHUodCxlKXt2YXIgbj1jKHQsZSkscj1sKHQsZSk7cmV0dXJuIG4uY29uY2F0KHIpfWZ1bmN0aW9uIGModCxlKXt2YXIgbj1pLm1hcChlLGZ1bmN0aW9uKGUpe2lmKCFpLmlzRnVuY3Rpb24odFtlXSkpcmV0dXJuIHttc2c6XCJNaXNzaW5nIHZpc2l0b3IgbWV0aG9kOiA8XCIrZStcIj4gb24gXCIrby5mdW5jdGlvbk5hbWUodC5jb25zdHJ1Y3RvcikrXCIgQ1NUIFZpc2l0b3IuXCIsdHlwZTpyLk1JU1NJTkdfTUVUSE9ELG1ldGhvZE5hbWU6ZX19KTtyZXR1cm4gaS5jb21wYWN0KG4pfWUuZGVmYXVsdFZpc2l0PXMsZS5jcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3I9ZnVuY3Rpb24odCxlKXt2YXIgbj1mdW5jdGlvbigpe307cmV0dXJuIG8uZGVmaW5lTmFtZVByb3Aobix0K1wiQmFzZVNlbWFudGljc1wiKSwobi5wcm90b3R5cGU9e3Zpc2l0OmZ1bmN0aW9uKHQsZSl7aWYoaS5pc0FycmF5KHQpJiYodD10WzBdKSwhaS5pc1VuZGVmaW5lZCh0KSlyZXR1cm4gdm9pZCAwIT09dC5mdWxsTmFtZT90aGlzW3QuZnVsbE5hbWVdKHQuY2hpbGRyZW4sZSk6dGhpc1t0Lm5hbWVdKHQuY2hpbGRyZW4sZSl9LHZhbGlkYXRlVmlzaXRvcjpmdW5jdGlvbigpe3ZhciB0PXUodGhpcyxlKTtpZighaS5pc0VtcHR5KHQpKXt2YXIgbj1pLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1zZ30pO3Rocm93IEVycm9yKFwiRXJyb3JzIERldGVjdGVkIGluIENTVCBWaXNpdG9yIDxcIitvLmZ1bmN0aW9uTmFtZSh0aGlzLmNvbnN0cnVjdG9yKStcIj46XFxuXFx0XCIrbi5qb2luKFwiXFxuXFxuXCIpLnJlcGxhY2UoL1xcbi9nLFwiXFxuXFx0XCIpKX19fSkuY29uc3RydWN0b3I9bixuLl9SVUxFX05BTUVTPWUsbn0sZS5jcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1mdW5jdGlvbigpe307by5kZWZpbmVOYW1lUHJvcChyLHQrXCJCYXNlU2VtYW50aWNzV2l0aERlZmF1bHRzXCIpO3ZhciBhPU9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpO3JldHVybiBpLmZvckVhY2goZSxmdW5jdGlvbih0KXthW3RdPXM7fSksKHIucHJvdG90eXBlPWEpLmNvbnN0cnVjdG9yPXIscn0sZnVuY3Rpb24odCl7dFt0LlJFRFVOREFOVF9NRVRIT0Q9MF09XCJSRURVTkRBTlRfTUVUSE9EXCIsdFt0Lk1JU1NJTkdfTUVUSE9EPTFdPVwiTUlTU0lOR19NRVRIT0RcIjt9KHI9ZS5Dc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yfHwoZS5Dc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yPXt9KSksZS52YWxpZGF0ZVZpc2l0b3I9dSxlLnZhbGlkYXRlTWlzc2luZ0NzdE1ldGhvZHM9Yzt2YXIgcD1bXCJjb25zdHJ1Y3RvclwiLFwidmlzaXRcIixcInZhbGlkYXRlVmlzaXRvclwiXTtmdW5jdGlvbiBsKHQsZSl7dmFyIG49W107Zm9yKHZhciBzIGluIHQpYS52YWxpZFRlcm1zUGF0dGVybi50ZXN0KHMpJiZpLmlzRnVuY3Rpb24odFtzXSkmJiFpLmNvbnRhaW5zKHAscykmJiFpLmNvbnRhaW5zKGUscykmJm4ucHVzaCh7bXNnOlwiUmVkdW5kYW50IHZpc2l0b3IgbWV0aG9kOiA8XCIrcytcIj4gb24gXCIrby5mdW5jdGlvbk5hbWUodC5jb25zdHJ1Y3RvcikrXCIgQ1NUIFZpc2l0b3JcXG5UaGVyZSBpcyBubyBHcmFtbWFyIFJ1bGUgY29ycmVzcG9uZGluZyB0byB0aGlzIG1ldGhvZCdzIG5hbWUuXFxuRm9yIHV0aWxpdHkgbWV0aG9kcyBvbiB2aXNpdG9yIGNsYXNzZXMgdXNlIG1ldGhvZHMgbmFtZXMgdGhhdCBkbyBub3QgbWF0Y2ggL1wiK2EudmFsaWRUZXJtc1BhdHRlcm4uc291cmNlK1wiLy5cIix0eXBlOnIuUkVEVU5EQU5UX01FVEhPRCxtZXRob2ROYW1lOnN9KTtyZXR1cm4gbn1lLnZhbGlkYXRlUmVkdW5kYW50TWV0aG9kcz1sO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMyksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRMZXhlckFkYXB0ZXI9ZnVuY3Rpb24oKXt0aGlzLnRva1ZlY3Rvcj1bXSx0aGlzLnRva1ZlY3Rvckxlbmd0aD0wLHRoaXMuY3VycklkeD0tMTt9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlucHV0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRva1ZlY3Rvcn0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMucmVzZXQoKSx0aGlzLnRva1ZlY3Rvcj10LHRoaXMudG9rVmVjdG9yTGVuZ3RoPXQubGVuZ3RoO30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5TS0lQX1RPS0VOPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycklkeDw9dGhpcy50b2tWZWN0b3IubGVuZ3RoLTI/KHRoaXMuY29uc3VtZVRva2VuKCksdGhpcy5MQSgxKSk6ci5FTkRfT0ZfRklMRX0sdC5wcm90b3R5cGUuTEE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3VycklkeCt0PDB8fHRoaXMudG9rVmVjdG9yTGVuZ3RoPD10aGlzLmN1cnJJZHgrdD9yLkVORF9PRl9GSUxFOnRoaXMudG9rVmVjdG9yW3RoaXMuY3VycklkeCt0XX0sdC5wcm90b3R5cGUuY29uc3VtZVRva2VuPWZ1bmN0aW9uKCl7dGhpcy5jdXJySWR4Kys7fSx0LnByb3RvdHlwZS5leHBvcnRMZXhlclN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycklkeH0sdC5wcm90b3R5cGUuaW1wb3J0TGV4ZXJTdGF0ZT1mdW5jdGlvbih0KXt0aGlzLmN1cnJJZHg9dDt9LHQucHJvdG90eXBlLnJlc2V0TGV4ZXJTdGF0ZT1mdW5jdGlvbigpe3RoaXMuY3VycklkeD0tMTt9LHQucHJvdG90eXBlLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZT1mdW5jdGlvbigpe3RoaXMuY3VycklkeD10aGlzLnRva1ZlY3Rvci5sZW5ndGgtMTt9LHQucHJvdG90eXBlLmdldExleGVyUG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHBvcnRMZXhlclN0YXRlKCl9LHR9KCk7ZS5MZXhlckFkYXB0ZXI9aTt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDApLGk9big2KSxvPW4oMyksYT1uKDEwKSxzPW4oMjMpLHU9bigxMSksYz1uKDEpLHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5DT05TVU1FPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsMCxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCwxLGUpfSx0LnByb3RvdHlwZS5DT05TVU1FMj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDIsZSl9LHQucHJvdG90eXBlLkNPTlNVTUUzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsMyxlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw0LGUpfSx0LnByb3RvdHlwZS5DT05TVU1FNT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDUsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU2PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsNixlKX0sdC5wcm90b3R5cGUuQ09OU1VNRTc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodCw3LGUpfSx0LnByb3RvdHlwZS5DT05TVU1FOD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0LDgsZSl9LHQucHJvdG90eXBlLkNPTlNVTUU5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHQsOSxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDAsZSl9LHQucHJvdG90eXBlLlNVQlJVTEUxPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsMSxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCwyLGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFMz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDMsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsNCxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw1LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFNj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDYsZSl9LHQucHJvdG90eXBlLlNVQlJVTEU3PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHQsNyxlKX0sdC5wcm90b3R5cGUuU1VCUlVMRTg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwodCw4LGUpfSx0LnByb3RvdHlwZS5TVUJSVUxFOT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbCh0LDksZSl9LHQucHJvdG90eXBlLk9QVElPTj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDApfSx0LnByb3RvdHlwZS5PUFRJT04xPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsMSl9LHQucHJvdG90eXBlLk9QVElPTjI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCwyKX0sdC5wcm90b3R5cGUuT1BUSU9OMz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDMpfSx0LnByb3RvdHlwZS5PUFRJT040PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsNCl9LHQucHJvdG90eXBlLk9QVElPTjU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw1KX0sdC5wcm90b3R5cGUuT1BUSU9ONj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDYpfSx0LnByb3RvdHlwZS5PUFRJT043PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsKHQsNyl9LHQucHJvdG90eXBlLk9QVElPTjg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwodCw4KX0sdC5wcm90b3R5cGUuT1BUSU9OOT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbCh0LDkpfSx0LnByb3RvdHlwZS5PUj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsMCl9LHQucHJvdG90eXBlLk9SMT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsMSl9LHQucHJvdG90eXBlLk9SMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsMil9LHQucHJvdG90eXBlLk9SMz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsMyl9LHQucHJvdG90eXBlLk9SND1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsNCl9LHQucHJvdG90eXBlLk9SNT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsNSl9LHQucHJvdG90eXBlLk9SNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsNil9LHQucHJvdG90eXBlLk9SNz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsNyl9LHQucHJvdG90eXBlLk9SOD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsOCl9LHQucHJvdG90eXBlLk9SOT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vckludGVybmFsKHQsOSl9LHQucHJvdG90eXBlLk1BTlk9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoMCx0KTt9LHQucHJvdG90eXBlLk1BTlkxPWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDEsdCk7fSx0LnByb3RvdHlwZS5NQU5ZMj1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCgyLHQpO30sdC5wcm90b3R5cGUuTUFOWTM9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoMyx0KTt9LHQucHJvdG90eXBlLk1BTlk0PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDQsdCk7fSx0LnByb3RvdHlwZS5NQU5ZNT1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg1LHQpO30sdC5wcm90b3R5cGUuTUFOWTY9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoNix0KTt9LHQucHJvdG90eXBlLk1BTlk3PWZ1bmN0aW9uKHQpe3RoaXMubWFueUludGVybmFsKDcsdCk7fSx0LnByb3RvdHlwZS5NQU5ZOD1mdW5jdGlvbih0KXt0aGlzLm1hbnlJbnRlcm5hbCg4LHQpO30sdC5wcm90b3R5cGUuTUFOWTk9ZnVuY3Rpb24odCl7dGhpcy5tYW55SW50ZXJuYWwoOSx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQPWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMCx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQMT1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDEsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDI9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgyLHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVAzPWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoMyx0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQND1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDQsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDU9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg1LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA2PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoNix0KTt9LHQucHJvdG90eXBlLk1BTllfU0VQNz1mdW5jdGlvbih0KXt0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDcsdCk7fSx0LnByb3RvdHlwZS5NQU5ZX1NFUDg9ZnVuY3Rpb24odCl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg4LHQpO30sdC5wcm90b3R5cGUuTUFOWV9TRVA5PWZ1bmN0aW9uKHQpe3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWwoOSx0KTt9LHQucHJvdG90eXBlLkFUX0xFQVNUX09ORT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgwLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FMT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMSx0KX0sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FMj1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgyLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FMz1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgzLHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FND1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg0LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FNT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg1LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FNj1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg2LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FNz1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg3LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FOD1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg4LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FOT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg5LHQpO30sdC5wcm90b3R5cGUuQVRfTEVBU1RfT05FX1NFUD1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDAsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDEsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMj1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDIsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQMz1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDMsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQND1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDQsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDUsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNj1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDYsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQNz1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDcsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQOD1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDgsdCk7fSx0LnByb3RvdHlwZS5BVF9MRUFTVF9PTkVfU0VQOT1mdW5jdGlvbih0KXt0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDksdCk7fSx0LnByb3RvdHlwZS5SVUxFPWZ1bmN0aW9uKHQsZSxuKXtpZih2b2lkIDA9PT1uJiYobj1vLkRFRkFVTFRfUlVMRV9DT05GSUcpLHIuY29udGFpbnModGhpcy5kZWZpbmVkUnVsZXNOYW1lcyx0KSl7dmFyIGk9e21lc3NhZ2U6YS5kZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIuYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKHt0b3BMZXZlbFJ1bGU6dCxncmFtbWFyTmFtZTp0aGlzLmNsYXNzTmFtZX0pLHR5cGU6by5QYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9SVUxFX05BTUUscnVsZU5hbWU6dH07dGhpcy5kZWZpbml0aW9uRXJyb3JzLnB1c2goaSk7fWlmKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMucHVzaCh0KSwhdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZS5jb250YWluc0tleSh0KSYmIXRoaXMuc2VyaWFsaXplZEdyYW1tYXIpe3ZhciB1PXMuYnVpbGRUb3BQcm9kdWN0aW9uKGUudG9TdHJpbmcoKSx0LHRoaXMudG9rZW5zTWFwKTt0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlLnB1dCh0LHUpO312YXIgYz10aGlzLmRlZmluZVJ1bGUodCxlLG4pO3JldHVybiB0aGlzW3RdPWMsY30sdC5wcm90b3R5cGUuT1ZFUlJJREVfUlVMRT1mdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49by5ERUZBVUxUX1JVTEVfQ09ORklHKTt2YXIgcj1bXTtpZihyPXIuY29uY2F0KHUudmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuKHQsdGhpcy5kZWZpbmVkUnVsZXNOYW1lcyx0aGlzLmNsYXNzTmFtZSkpLHRoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoLmFwcGx5KHRoaXMuZGVmaW5pdGlvbkVycm9ycyxyKSwhdGhpcy5zZXJpYWxpemVkR3JhbW1hcil7dmFyIGk9cy5idWlsZFRvcFByb2R1Y3Rpb24oZS50b1N0cmluZygpLHQsdGhpcy50b2tlbnNNYXApO3RoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUucHV0KHQsaSk7fXZhciBhPXRoaXMuZGVmaW5lUnVsZSh0LGUsbik7cmV0dXJuIHRoaXNbdF09YSxhfSx0LnByb3RvdHlwZS5CQUNLVFJBQ0s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucHVzaCgxKTt2YXIgbj10aGlzLnNhdmVSZWNvZ1N0YXRlKCk7dHJ5e3JldHVybiB0LmFwcGx5KHRoaXMsZSksITB9Y2F0Y2godCl7aWYoaS5pc1JlY29nbml0aW9uRXhjZXB0aW9uKHQpKXJldHVybiAhMTt0aHJvdyB0fWZpbmFsbHl7dGhpcy5yZWxvYWRSZWNvZ1N0YXRlKG4pLHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wb3AoKTt9fX0sdC5wcm90b3R5cGUuZ2V0R0FzdFByb2R1Y3Rpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGV9LHQucHJvdG90eXBlLmdldFNlcmlhbGl6ZWRHYXN0UHJvZHVjdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gYy5zZXJpYWxpemVHcmFtbWFyKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUudmFsdWVzKCkpfSx0fSgpO2UuUmVjb2duaXplckFwaT1wO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDkpLG89big2KSxhPW4oMTIpLHM9bigxMyksdT1uKDMpLGM9bigyNSkscD1uKDIpLGw9big3KSxoPW4oNCksZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRSZWNvZ25pemVyRW5naW5lPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5jbGFzc05hbWU9aC5jbGFzc05hbWVGcm9tSW5zdGFuY2UodGhpcyksdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsPW5ldyBoLkhhc2hUYWJsZSx0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQ9bmV3IGguSGFzaFRhYmxlLHRoaXMucnVsZVNob3J0TmFtZUlkeD0yNTYsdGhpcy50b2tlbk1hdGNoZXI9bC50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzLHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXM9W10sdGhpcy50b2tlbnNNYXA9e30sdGhpcy5hbGxSdWxlTmFtZXM9W10sdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrPVtdLHRoaXMuUlVMRV9TVEFDSz1bXSx0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSz1bXSx0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlPW5ldyBoLkhhc2hUYWJsZSx0aGlzLnNlcmlhbGl6ZWRHcmFtbWFyPXIuaGFzKGUsXCJzZXJpYWxpemVkR3JhbW1hclwiKT9lLnNlcmlhbGl6ZWRHcmFtbWFyOnUuREVGQVVMVF9QQVJTRVJfQ09ORklHLnNlcmlhbGl6ZWRHcmFtbWFyLHIuaXNBcnJheSh0KSl7aWYoci5pc0VtcHR5KHQpKXRocm93IEVycm9yKFwiQSBUb2tlbiBWb2NhYnVsYXJ5IGNhbm5vdCBiZSBlbXB0eS5cXG5cXHROb3RlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGZvciB0aGUgcGFyc2VyIGNvbnN0cnVjdG9yXFxuXFx0aXMgbm8gbG9uZ2VyIGEgVG9rZW4gdmVjdG9yIChzaW5jZSB2NC4wKS5cIik7aWYoXCJudW1iZXJcIj09dHlwZW9mIHRbMF0uc3RhcnRPZmZzZXQpdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyIGNvbnN0cnVjdG9yIG5vIGxvbmdlciBhY2NlcHRzIGEgdG9rZW4gdmVjdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXHRTZWU6IGh0dHBzOi8vc2FwLmdpdGh1Yi5pby9jaGV2cm90YWluL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzQtMC0wXFxuXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIil9aWYoci5pc0FycmF5KHQpKXRoaXMudG9rZW5zTWFwPXIucmVkdWNlKHQsZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtwLnRva2VuTmFtZShlKV09ZSx0fSx7fSk7ZWxzZSBpZihyLmhhcyh0LFwibW9kZXNcIikmJnIuZXZlcnkoci5mbGF0dGVuKHIudmFsdWVzKHQubW9kZXMpKSxsLmlzVG9rZW5UeXBlKSl7dmFyIG49ci5mbGF0dGVuKHIudmFsdWVzKHQubW9kZXMpKSxpPXIudW5pcShuKTt0aGlzLnRva2Vuc01hcD1yLnJlZHVjZShpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbcC50b2tlbk5hbWUoZSldPWUsdH0se30pO31lbHNlIHtpZighci5pc09iamVjdCh0KSl0aHJvdyBuZXcgRXJyb3IoXCI8dG9rZW5zRGljdGlvbmFyeT4gYXJndW1lbnQgbXVzdCBiZSBBbiBBcnJheSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMsIEEgZGljdGlvbmFyeSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMgb3IgYW4gSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblwiKTt0aGlzLnRva2Vuc01hcD1yLmNsb25lT2JqKHQpO310aGlzLnRva2Vuc01hcC5FT0Y9cC5FT0Y7dmFyIG89ci5ldmVyeShyLnZhbHVlcyh0KSxmdW5jdGlvbih0KXtyZXR1cm4gci5pc0VtcHR5KHQuY2F0ZWdvcnlNYXRjaGVzKX0pO3RoaXMudG9rZW5NYXRjaGVyPW8/bC50b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzOmwudG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcixsLmF1Z21lbnRUb2tlblR5cGVzKHIudmFsdWVzKHRoaXMudG9rZW5zTWFwKSk7fSx0LnByb3RvdHlwZS5kZWZpbmVSdWxlPWZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLnNlbGZBbmFseXNpc0RvbmUpdGhyb3cgRXJyb3IoXCJHcmFtbWFyIHJ1bGUgPFwiK3QrXCI+IG1heSBub3QgYmUgZGVmaW5lZCBhZnRlciB0aGUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQnXFxuTWFrZSBzdXJlIHRoYXQgYWxsIGdyYW1tYXIgcnVsZSBkZWZpbml0aW9ucyBhcmUgZG9uZSBiZWZvcmUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIGlzIGNhbGxlZC5cIik7dmFyIGEscz1yLmhhcyhuLFwicmVzeW5jRW5hYmxlZFwiKT9uLnJlc3luY0VuYWJsZWQ6dS5ERUZBVUxUX1JVTEVfQ09ORklHLnJlc3luY0VuYWJsZWQsYz1yLmhhcyhuLFwicmVjb3ZlcnlWYWx1ZUZ1bmNcIik/bi5yZWNvdmVyeVZhbHVlRnVuYzp1LkRFRkFVTFRfUlVMRV9DT05GSUcucmVjb3ZlcnlWYWx1ZUZ1bmMscD10aGlzLnJ1bGVTaG9ydE5hbWVJZHg8PGkuQklUU19GT1JfTUVUSE9EX0lEWCtpLkJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO3RoaXMucnVsZVNob3J0TmFtZUlkeCsrLHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbC5wdXQocCx0KSx0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQucHV0KHQscCk7cmV0dXJuIChhPWZ1bmN0aW9uKG4scil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTApLHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShwLHQsbiksZnVuY3Rpb24odCl7dHJ5e3JldHVybiAhMD09PXRoaXMub3V0cHV0Q3N0PyhlLmFwcGx5KHRoaXMsdCksdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdKTplLmFwcGx5KHRoaXMsdCl9Y2F0Y2godCl7dmFyIG49MT09PXRoaXMuUlVMRV9TVEFDSy5sZW5ndGgscj1zJiYhdGhpcy5pc0JhY2tUcmFja2luZygpJiZ0aGlzLnJlY292ZXJ5RW5hYmxlZDtpZihvLmlzUmVjb2duaXRpb25FeGNlcHRpb24odCkpe2lmKHIpe3ZhciBpLGE9dGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7aWYodGhpcy5pc0luQ3VycmVudFJ1bGVSZVN5bmNTZXQoYSkpcmV0dXJuIHQucmVzeW5jZWRUb2tlbnM9dGhpcy5yZVN5bmNUbyhhKSx0aGlzLm91dHB1dENzdD8oKGk9dGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoLTFdKS5yZWNvdmVyZWROb2RlPSEwLGkpOmMoKTt0aHJvdyB0aGlzLm91dHB1dENzdCYmKChpPXRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aC0xXSkucmVjb3ZlcmVkTm9kZT0hMCx0LnBhcnRpYWxDc3RSZXN1bHQ9aSksdH1pZihuKXJldHVybiB0aGlzLm1vdmVUb1Rlcm1pbmF0ZWRTdGF0ZSgpLGMoKTt0aHJvdyB0fXRocm93IHR9ZmluYWxseXt0aGlzLnJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTt9fS5jYWxsKHRoaXMscil9KS5ydWxlTmFtZT10LGF9LHQucHJvdG90eXBlLm9wdGlvbkludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5PUFRJT05fSURYLGUpLHI9dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKHQsbik7dHJ5e3JldHVybiB0aGlzLm9wdGlvbkludGVybmFsTG9naWModCxlLG4pfWZpbmFsbHl7dm9pZCAwIT09ciYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLHIpO319LHQucHJvdG90eXBlLm9wdGlvbkludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk9QVElPTl9JRFgsZSk7cmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxMb2dpYyh0LGUsbil9LHQucHJvdG90eXBlLm9wdGlvbkludGVybmFsTG9naWM9ZnVuY3Rpb24odCxlLG4pe3ZhciByLGksbz10aGlzLGE9dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yT3B0aW9uKG4sZSk7aWYodm9pZCAwIT09dC5ERUYpe2lmKHI9dC5ERUYsdm9pZCAwIT09KGk9dC5HQVRFKSl7dmFyIHM9YTthPWZ1bmN0aW9uKCl7cmV0dXJuIGkuY2FsbChvKSYmcy5jYWxsKG8pfTt9fWVsc2Ugcj10O2lmKCEwPT09YS5jYWxsKHRoaXMpKXJldHVybiByLmNhbGwodGhpcyl9LHQucHJvdG90eXBlLmF0TGVhc3RPbmVJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuQVRfTEVBU1RfT05FX0lEWCx0KSxyPXRoaXMubmVzdGVkUnVsZUJlZm9yZUNsYXVzZShlLG4pO3RyeXtyZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWxMb2dpYyh0LGUsbil9ZmluYWxseXt2b2lkIDAhPT1yJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4scik7fX0sdC5wcm90b3R5cGUuYXRMZWFzdE9uZUludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLkFUX0xFQVNUX09ORV9JRFgsdCk7dGhpcy5hdExlYXN0T25lSW50ZXJuYWxMb2dpYyh0LGUsbik7fSx0LnByb3RvdHlwZS5hdExlYXN0T25lSW50ZXJuYWxMb2dpYz1mdW5jdGlvbih0LGUsbil7dmFyIHIsbyx1PXRoaXMsYz10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JBdExlYXN0T25lKG4sdCk7aWYodm9pZCAwIT09ZS5ERUYpe2lmKHI9ZS5ERUYsdm9pZCAwIT09KG89ZS5HQVRFKSl7dmFyIHA9YztjPWZ1bmN0aW9uKCl7cmV0dXJuIG8uY2FsbCh1KSYmcC5jYWxsKHUpfTt9fWVsc2Ugcj1lO2lmKCEwIT09Yy5jYWxsKHRoaXMpKXRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24odCxhLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSxlLkVSUl9NU0cpO2Zvcih2YXIgbD10aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihyKTshMD09PWMuY2FsbCh0aGlzKSYmITA9PT1sOylsPXRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKHIpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMuYXRMZWFzdE9uZUludGVybmFsLFt0LGVdLGMsaS5BVF9MRUFTVF9PTkVfSURYLHQscy5OZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIpO30sdC5wcm90b3R5cGUuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLkFUX0xFQVNUX09ORV9TRVBfSURYLHQpLHI9dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGUsbik7dHJ5e3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyh0LGUsbik7fWZpbmFsbHl7dm9pZCAwIT09ciYmdGhpcy5uZXN0ZWRSdWxlRmluYWxseUNsYXVzZShuLHIpO319LHQucHJvdG90eXBlLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTm9Dc3Q9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLkFUX0xFQVNUX09ORV9TRVBfSURYLHQpO3RoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyh0LGUsbik7fSx0LnByb3RvdHlwZS5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLG89ZS5ERUYsdT1lLlNFUDtpZighMCE9PXRoaXMuZ2V0TG9va2FoZWFkRnVuY0ZvckF0TGVhc3RPbmVTZXAobix0KS5jYWxsKHRoaXMpKXRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24odCxhLlBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUixlLkVSUl9NU0cpO28uY2FsbCh0aGlzKTtmb3IodmFyIGM9ZnVuY3Rpb24oKXtyZXR1cm4gci50b2tlbk1hdGNoZXIoci5MQSgxKSx1KX07ITA9PT10aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLHUpOyl0aGlzLkNPTlNVTUUodSksby5jYWxsKHRoaXMpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLFt0LHUsYyxvLHMuTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyXSxjLGkuQVRfTEVBU1RfT05FX1NFUF9JRFgsdCxzLk5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcik7fSx0LnByb3RvdHlwZS5tYW55SW50ZXJuYWw9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChpLk1BTllfSURYLHQpLHI9dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKGUsbik7dHJ5e3JldHVybiB0aGlzLm1hbnlJbnRlcm5hbExvZ2ljKHQsZSxuKX1maW5hbGx5e3ZvaWQgMCE9PXImJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixyKTt9fSx0LnByb3RvdHlwZS5tYW55SW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuTUFOWV9JRFgsdCk7cmV0dXJuIHRoaXMubWFueUludGVybmFsTG9naWModCxlLG4pfSx0LnByb3RvdHlwZS5tYW55SW50ZXJuYWxMb2dpYz1mdW5jdGlvbih0LGUsbil7dmFyIHIsbyxhPXRoaXMsdT10aGlzLmdldExvb2thaGVhZEZ1bmNGb3JNYW55KG4sdCk7aWYodm9pZCAwIT09ZS5ERUYpe2lmKHI9ZS5ERUYsdm9pZCAwIT09KG89ZS5HQVRFKSl7dmFyIGM9dTt1PWZ1bmN0aW9uKCl7cmV0dXJuIG8uY2FsbChhKSYmYy5jYWxsKGEpfTt9fWVsc2Ugcj1lO2Zvcih2YXIgcD0hMDshMD09PXUuY2FsbCh0aGlzKSYmITA9PT1wOylwPXRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKHIpO3RoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMubWFueUludGVybmFsLFt0LGVdLHUsaS5NQU5ZX0lEWCx0LHMuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyKTt9LHQucHJvdG90eXBlLm1hbnlTZXBGaXJzdEludGVybmFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoaS5NQU5ZX1NFUF9JRFgsdCkscj10aGlzLm5lc3RlZFJ1bGVCZWZvcmVDbGF1c2UoZSxuKTt0cnl7dGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHQsZSxuKTt9ZmluYWxseXt2b2lkIDAhPT1yJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKG4scik7fX0sdC5wcm90b3R5cGUubWFueVNlcEZpcnN0SW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuTUFOWV9TRVBfSURYLHQpO3RoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyh0LGUsbik7fSx0LnByb3RvdHlwZS5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLG89ZS5ERUYsYT1lLlNFUDtpZighMD09PXRoaXMuZ2V0TG9va2FoZWFkRnVuY0Zvck1hbnlTZXAobix0KS5jYWxsKHRoaXMpKXtvLmNhbGwodGhpcyk7Zm9yKHZhciB1PWZ1bmN0aW9uKCl7cmV0dXJuIHIudG9rZW5NYXRjaGVyKHIuTEEoMSksYSl9OyEwPT09dGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSxhKTspdGhpcy5DT05TVU1FKGEpLG8uY2FsbCh0aGlzKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCxbdCxhLHUsbyxzLk5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcl0sdSxpLk1BTllfU0VQX0lEWCx0LHMuTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyKTt9fSx0LnByb3RvdHlwZS5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWw9ZnVuY3Rpb24odCxlLG4scixvKXtmb3IoO24oKTspdGhpcy5DT05TVU1FKGUpLHIuY2FsbCh0aGlzKTt0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCxbdCxlLG4scixvXSxuLGkuQVRfTEVBU1RfT05FX1NFUF9JRFgsdCxvKTt9LHQucHJvdG90eXBlLmRvU2luZ2xlUmVwZXRpdGlvbj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldExleGVyUG9zaXRpb24oKTtyZXR1cm4gdC5jYWxsKHRoaXMpLHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpPmV9LHQucHJvdG90eXBlLm9ySW50ZXJuYWxOb0NzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXIuaXNBcnJheSh0KT90OnQuREVGLGk9dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yT3IoZSxuKS5jYWxsKHRoaXMsbik7aWYodm9pZCAwIT09aSlyZXR1cm4gbltpXS5BTFQuY2FsbCh0aGlzKTt0aGlzLnJhaXNlTm9BbHRFeGNlcHRpb24oZSx0LkVSUl9NU0cpO30sdC5wcm90b3R5cGUub3JJbnRlcm5hbD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGkuT1JfSURYLGUpLG89dGhpcy5uZXN0ZWRSdWxlQmVmb3JlQ2xhdXNlKHQsbik7dHJ5e3ZhciBhPXIuaXNBcnJheSh0KT90OnQuREVGLHM9dGhpcy5nZXRMb29rYWhlYWRGdW5jRm9yT3IoZSxhKS5jYWxsKHRoaXMsYSk7aWYodm9pZCAwIT09cyl7dmFyIHU9YVtzXSxjPXRoaXMubmVzdGVkQWx0QmVmb3JlQ2xhdXNlKHUsZSxpLk9SX0lEWCxzKTt0cnl7cmV0dXJuIHUuQUxULmNhbGwodGhpcyl9ZmluYWxseXt2b2lkIDAhPT1jJiZ0aGlzLm5lc3RlZFJ1bGVGaW5hbGx5Q2xhdXNlKGMuc2hvcnROYW1lLGMubmVzdGVkTmFtZSk7fX10aGlzLnJhaXNlTm9BbHRFeGNlcHRpb24oZSx0LkVSUl9NU0cpO31maW5hbGx5e3ZvaWQgMCE9PW8mJnRoaXMubmVzdGVkUnVsZUZpbmFsbHlDbGF1c2UobixvKTt9fSx0LnByb3RvdHlwZS5ydWxlRmluYWxseVN0YXRlVXBkYXRlPWZ1bmN0aW9uKCl7aWYodGhpcy5SVUxFX1NUQUNLLnBvcCgpLHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnBvcCgpLHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlKCksMD09PXRoaXMuUlVMRV9TVEFDSy5sZW5ndGgmJiF0aGlzLmlzQXRFbmRPZklucHV0KCkpe3ZhciB0PXRoaXMuTEEoMSksZT10aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlKHtmaXJzdFJlZHVuZGFudDp0LHJ1bGVOYW1lOnRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpfSk7dGhpcy5TQVZFX0VSUk9SKG5ldyBvLk5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKGUsdCkpO319LHQucHJvdG90eXBlLnN1YnJ1bGVJbnRlcm5hbD1mdW5jdGlvbih0LGUsbil7dmFyIHI7dHJ5e3ZhciBpPXZvaWQgMCE9PW4/bi5BUkdTOnZvaWQgMDtyZXR1cm4gcj10LmNhbGwodGhpcyxlLGkpLHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKHIsdm9pZCAwIT09biYmdm9pZCAwIT09bi5MQUJFTD9uLkxBQkVMOnQucnVsZU5hbWUpLHJ9Y2F0Y2goZSl7dGhyb3cgby5pc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpJiZ2b2lkIDAhPT1lLnBhcnRpYWxDc3RSZXN1bHQmJih0aGlzLmNzdFBvc3ROb25UZXJtaW5hbChlLnBhcnRpYWxDc3RSZXN1bHQsdm9pZCAwIT09biYmdm9pZCAwIT09bi5MQUJFTD9uLkxBQkVMOnQucnVsZU5hbWUpLGRlbGV0ZSBlLnBhcnRpYWxDc3RSZXN1bHQpLGV9fSx0LnByb3RvdHlwZS5jb25zdW1lSW50ZXJuYWw9ZnVuY3Rpb24odCxlLG4pe3ZhciByO3RyeXt2YXIgaT10aGlzLkxBKDEpO2lmKCEwIT09dGhpcy50b2tlbk1hdGNoZXIoaSx0KSl7dmFyIGE9dm9pZCAwLHM9dGhpcy5MQSgwKTt0aHJvdyBhPXZvaWQgMCE9PW4mJm4uRVJSX01TRz9uLkVSUl9NU0c6dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtleHBlY3RlZDp0LGFjdHVhbDppLHByZXZpb3VzOnMscnVsZU5hbWU6dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCl9KSx0aGlzLlNBVkVfRVJST1IobmV3IG8uTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKGEsaSxzKSl9dGhpcy5jb25zdW1lVG9rZW4oKSxyPWk7fWNhdGNoKG4pe2lmKCF0aGlzLnJlY292ZXJ5RW5hYmxlZHx8XCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIiE9PW4ubmFtZXx8dGhpcy5pc0JhY2tUcmFja2luZygpKXRocm93IG47dmFyIHU9dGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkodCxlKTt0cnl7cj10aGlzLnRyeUluUnVsZVJlY292ZXJ5KHQsdSk7fWNhdGNoKHQpe3Rocm93IHQubmFtZT09PWMuSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04/bjp0fX1yZXR1cm4gdGhpcy5jc3RQb3N0VGVybWluYWwodm9pZCAwIT09biYmdm9pZCAwIT09bi5MQUJFTD9uLkxBQkVMOnQudG9rZW5OYW1lLHIpLHJ9LHQucHJvdG90eXBlLnNhdmVSZWNvZ1N0YXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lcnJvcnMsZT1yLmNsb25lQXJyKHRoaXMuUlVMRV9TVEFDSyk7cmV0dXJuIHtlcnJvcnM6dCxsZXhlclN0YXRlOnRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLFJVTEVfU1RBQ0s6ZSxDU1RfU1RBQ0s6dGhpcy5DU1RfU1RBQ0ssTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLOnRoaXMuTEFTVF9FWFBMSUNJVF9SVUxFX1NUQUNLfX0sdC5wcm90b3R5cGUucmVsb2FkUmVjb2dTdGF0ZT1mdW5jdGlvbih0KXt0aGlzLmVycm9ycz10LmVycm9ycyx0aGlzLmltcG9ydExleGVyU3RhdGUodC5sZXhlclN0YXRlKSx0aGlzLlJVTEVfU1RBQ0s9dC5SVUxFX1NUQUNLO30sdC5wcm90b3R5cGUucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZT1mdW5jdGlvbih0LGUsbil7dGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucHVzaChuKSx0aGlzLlJVTEVfU1RBQ0sucHVzaCh0KSx0aGlzLmNzdEludm9jYXRpb25TdGF0ZVVwZGF0ZShlLHQpO30sdC5wcm90b3R5cGUuaXNCYWNrVHJhY2tpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gIXIuaXNFbXB0eSh0aGlzLmlzQmFja1RyYWNraW5nU3RhY2spfSx0LnByb3RvdHlwZS5nZXRDdXJyUnVsZUZ1bGxOYW1lPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7cmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbC5nZXQodCl9LHQucHJvdG90eXBlLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwuZ2V0KHQpfSx0LnByb3RvdHlwZS5pc0F0RW5kT2ZJbnB1dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLHAuRU9GKX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpLHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjaz1bXSx0aGlzLmVycm9ycz1bXSx0aGlzLlJVTEVfU1RBQ0s9W10sdGhpcy5MQVNUX0VYUExJQ0lUX1JVTEVfU1RBQ0s9W10sdGhpcy5DU1RfU1RBQ0s9W10sdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0s9W107fSx0fSgpO2UuUmVjb2duaXplckVuZ2luZT1mO30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oNiksaT1uKDApLG89bigxMiksYT1uKDMpLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5pbml0RXJyb3JIYW5kbGVyPWZ1bmN0aW9uKHQpe3RoaXMuX2Vycm9ycz1bXSx0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyPWkuZGVmYXVsdHModC5lcnJvck1lc3NhZ2VQcm92aWRlcixhLkRFRkFVTFRfUEFSU0VSX0NPTkZJRy5lcnJvck1lc3NhZ2VQcm92aWRlcik7fSx0LnByb3RvdHlwZS5TQVZFX0VSUk9SPWZ1bmN0aW9uKHQpe2lmKHIuaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbih0KSlyZXR1cm4gdC5jb250ZXh0PXtydWxlU3RhY2s6dGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCkscnVsZU9jY3VycmVuY2VTdGFjazppLmNsb25lQXJyKHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLKX0sdGhpcy5fZXJyb3JzLnB1c2godCksdDt0aHJvdyBFcnJvcihcIlRyeWluZyB0byBzYXZlIGFuIEVycm9yIHdoaWNoIGlzIG5vdCBhIFJlY29nbml0aW9uRXhjZXB0aW9uXCIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJlcnJvcnNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuY2xvbmVBcnIodGhpcy5fZXJyb3JzKX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX2Vycm9ycz10O30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbj1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLGE9dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQoaSkscz1vLmdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKHQsYSxlLHRoaXMubWF4TG9va2FoZWFkKVswXSx1PVtdLGM9MTtjPHRoaXMubWF4TG9va2FoZWFkO2MrKyl1LnB1c2godGhpcy5MQShjKSk7dmFyIHA9dGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZEVhcmx5RXhpdE1lc3NhZ2Uoe2V4cGVjdGVkSXRlcmF0aW9uUGF0aHM6cyxhY3R1YWw6dSxwcmV2aW91czp0aGlzLkxBKDApLGN1c3RvbVVzZXJEZXNjcmlwdGlvbjpuLHJ1bGVOYW1lOml9KTt0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IHIuRWFybHlFeGl0RXhjZXB0aW9uKHAsdGhpcy5MQSgxKSx0aGlzLkxBKDApKSl9LHQucHJvdG90eXBlLnJhaXNlTm9BbHRFeGNlcHRpb249ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCksaT10aGlzLmdldEdBc3RQcm9kdWN0aW9ucygpLmdldChuKSxhPW8uZ2V0TG9va2FoZWFkUGF0aHNGb3JPcih0LGksdGhpcy5tYXhMb29rYWhlYWQpLHM9W10sdT0xO3U8PXRoaXMubWF4TG9va2FoZWFkO3UrKylzLnB1c2godGhpcy5MQSh1KSk7dmFyIGM9dGhpcy5MQSgwKSxwPXRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uoe2V4cGVjdGVkUGF0aHNQZXJBbHQ6YSxhY3R1YWw6cyxwcmV2aW91czpjLGN1c3RvbVVzZXJEZXNjcmlwdGlvbjplLHJ1bGVOYW1lOnRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpfSk7dGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyByLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHAsdGhpcy5MQSgxKSxjKSl9LHR9KCk7ZS5FcnJvckhhbmRsZXI9czt9LGZ1bmN0aW9uKHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1uKDEzKSxpPW4oMCksbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmluaXRDb250ZW50QXNzaXN0PWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5jb21wdXRlQ29udGVudEFzc2lzdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUuZ2V0KHQpO2lmKGkuaXNVbmRlZmluZWQobikpdGhyb3cgRXJyb3IoXCJSdWxlIC0+XCIrdCtcIjwtIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JhbW1hci5cIik7cmV0dXJuIHIubmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW25dLGUsdGhpcy50b2tlbk1hdGNoZXIsdGhpcy5tYXhMb29rYWhlYWQpfSx0LnByb3RvdHlwZS5nZXROZXh0UG9zc2libGVUb2tlblR5cGVzPWZ1bmN0aW9uKHQpe3ZhciBlPWkuZmlyc3QodC5ydWxlU3RhY2spLG49dGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKS5nZXQoZSk7cmV0dXJuIG5ldyByLk5leHRBZnRlclRva2VuV2Fsa2VyKG4sdCkuc3RhcnRXYWxraW5nKCl9LHR9KCk7ZS5Db250ZW50QXNzaXN0PW87fSxmdW5jdGlvbih0LGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigxNyk7ZS5jcmVhdGVTeW50YXhEaWFncmFtc0NvZGU9ZnVuY3Rpb24odCxlKXt2YXIgbj12b2lkIDA9PT1lP3t9OmUsaT1uLnJlc291cmNlQmFzZSxvPXZvaWQgMD09PWk/XCJodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQFwiK3IuVkVSU0lPTitcIi9kaWFncmFtcy9cIjppLGE9bi5jc3M7cmV0dXJuIFwiXFxuXFx4M2MhLS0gVGhpcyBpcyBhIGdlbmVyYXRlZCBmaWxlIC0tXFx4M2VcXG48IURPQ1RZUEUgaHRtbD5cXG48bWV0YSBjaGFyc2V0PVxcXCJ1dGYtOFxcXCI+XFxuPHN0eWxlPlxcbiAgYm9keSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGhzbCgzMCwgMjAlLCA5NSUpXFxuICB9XFxuPC9zdHlsZT5cXG5cXG5cXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J1wiKyh2b2lkIDA9PT1hP1wiaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkBcIityLlZFUlNJT04rXCIvZGlhZ3JhbXMvZGlhZ3JhbXMuY3NzXCI6YSkrXCInPlxcblxcbjxzY3JpcHQgc3JjPSdcIitvK1widmVuZG9yL3JhaWxyb2FkLWRpYWdyYW1zLmpzJz48XFwvc2NyaXB0PlxcbjxzY3JpcHQgc3JjPSdcIitvK1wic3JjL2RpYWdyYW1zX2J1aWxkZXIuanMnPjxcXC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiK28rXCJzcmMvZGlhZ3JhbXNfYmVoYXZpb3IuanMnPjxcXC9zY3JpcHQ+XFxuPHNjcmlwdCBzcmM9J1wiK28rJ3NyYy9tYWluLmpzXFwnPjxcXC9zY3JpcHQ+XFxuXFxuPGRpdiBpZD1cImRpYWdyYW1zXCIgYWxpZ249XCJjZW50ZXJcIj48L2Rpdj4gICAgXFxuXFxuPHNjcmlwdD5cXG4gICAgd2luZG93LnNlcmlhbGl6ZWRHcmFtbWFyID0gJytKU09OLnN0cmluZ2lmeSh0LG51bGwsXCIgIFwiKSsnO1xcbjxcXC9zY3JpcHQ+XFxuXFxuPHNjcmlwdD5cXG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaWFncmFtc1wiKTtcXG4gICAgbWFpbi5kcmF3RGlhZ3JhbXNGcm9tU2VyaWFsaXplZEdyYW1tYXIoc2VyaWFsaXplZEdyYW1tYXIsIGRpYWdyYW1zRGl2KTtcXG48XFwvc2NyaXB0Plxcbid9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oNDEpO2UuZ2VuZXJhdGVQYXJzZXJGYWN0b3J5PWZ1bmN0aW9uKHQpe3ZhciBlPXIuZ2VuV3JhcHBlckZ1bmN0aW9uKHtuYW1lOnQubmFtZSxydWxlczp0LnJ1bGVzfSksaT1uZXcgRnVuY3Rpb24oXCJ0b2tlblZvY2FidWxhcnlcIixcImNvbmZpZ1wiLFwiY2hldnJvdGFpblwiLGUpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gaSh0LnRva2VuVm9jYWJ1bGFyeSxlLG4oMTgpKX19LGUuZ2VuZXJhdGVQYXJzZXJNb2R1bGU9ZnVuY3Rpb24odCl7cmV0dXJuIHIuZ2VuVW1kTW9kdWxlKHtuYW1lOnQubmFtZSxydWxlczp0LnJ1bGVzfSl9O30sZnVuY3Rpb24odCxlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPW4oMCksaT1uKDIpLG89bigxKSxhPVwiXFxuXCI7ZnVuY3Rpb24gcyh0KXtyZXR1cm4gXCJcXG5mdW5jdGlvbiBcIit0Lm5hbWUrXCIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcXG4gICAgLy8gaW52b2tlIHN1cGVyIGNvbnN0cnVjdG9yXFxuICAgIC8vIE5vIHN1cHBvcnQgZm9yIGVtYmVkZGVkIGFjdGlvbnMgY3VycmVudGx5LCBzbyB3ZSBjYW4gJ2hhcmRjb2RlJ1xcbiAgICAvLyBUaGUgdXNlIG9mIENzdFBhcnNlci5cXG4gICAgY2hldnJvdGFpbi5Dc3RQYXJzZXIuY2FsbCh0aGlzLCB0b2tlblZvY2FidWxhcnksIGNvbmZpZylcXG5cXG4gICAgY29uc3QgJCA9IHRoaXNcXG5cXG4gICAgXCIrdSh0LnJ1bGVzKStcIlxcblxcbiAgICAvLyB2ZXJ5IGltcG9ydGFudCB0byBjYWxsIHRoaXMgYWZ0ZXIgYWxsIHRoZSBydWxlcyBoYXZlIGJlZW4gZGVmaW5lZC5cXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSBwYXJzZXIgbWF5IG5vdCB3b3JrIGNvcnJlY3RseSBhcyBpdCB3aWxsIGxhY2sgaW5mb3JtYXRpb25cXG4gICAgLy8gZGVyaXZlZCBkdXJpbmcgdGhlIHNlbGYgYW5hbHlzaXMgcGhhc2UuXFxuICAgIHRoaXMucGVyZm9ybVNlbGZBbmFseXNpcyh0aGlzKVxcbn1cXG5cXG4vLyBpbmhlcml0YW5jZSBhcyBpbXBsZW1lbnRlZCBpbiBqYXZhc2NyaXB0IGluIHRoZSBwcmV2aW91cyBkZWNhZGUuLi4gOihcXG5cIit0Lm5hbWUrXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShjaGV2cm90YWluLkNzdFBhcnNlci5wcm90b3R5cGUpXFxuXCIrdC5uYW1lK1wiLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFwiK3QubmFtZStcIiAgICBcXG4gICAgXCJ9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gci5tYXAodCxmdW5jdGlvbih0KXtyZXR1cm4gYyh0LDEpfSkuam9pbihcIlxcblwiKX1mdW5jdGlvbiBjKHQsZSl7dmFyIG49eShlLCckLlJVTEUoXCInK3QubmFtZSsnXCIsIGZ1bmN0aW9uKCkgeycpK2E7cmV0dXJuIG4rPW0odC5kZWZpbml0aW9uLGUrMSksbis9eShlKzEsXCJ9KVwiKSthfWZ1bmN0aW9uIHAodCxlKXt2YXIgbj1pLnRva2VuTmFtZSh0LnRlcm1pbmFsVHlwZSk7cmV0dXJuIHkoZSxcIiQuQ09OU1VNRVwiK3QuaWR4K1wiKHRoaXMudG9rZW5zTWFwLlwiK24rXCIpXCIrYSl9ZnVuY3Rpb24gbCh0LGUpe3JldHVybiB5KGUsXCIkLlNVQlJVTEVcIit0LmlkeCtcIigkLlwiK3Qubm9uVGVybWluYWxOYW1lK1wiKVwiK2EpfWZ1bmN0aW9uIGgodCxlKXt2YXIgbj15KGUsXCIkLk9SXCIrdC5pZHgrXCIoW1wiKSthO3JldHVybiBuKz1yLm1hcCh0LmRlZmluaXRpb24sZnVuY3Rpb24odCl7cmV0dXJuIGYodCxlKzEpfSkuam9pbihcIixcIithKSxuKz1hK3koZSxcIl0pXCIrYSl9ZnVuY3Rpb24gZih0LGUpe3ZhciBuPXkoZSxcIntcIikrYTtyZXR1cm4gdC5uYW1lJiYobis9eShlKzEsJ05BTUU6IFwiJyt0Lm5hbWUrJ1wiLCcpK2EpLG4rPXkoZSsxLFwiQUxUOiBmdW5jdGlvbigpIHtcIikrYSxuKz1tKHQuZGVmaW5pdGlvbixlKzEpLG4rPXkoZSsxLFwifVwiKSthLG4rPXkoZSxcIn1cIil9ZnVuY3Rpb24gZCh0LGUsbil7dmFyIHI9eShuLFwiJC5cIisodCtlLmlkeCkrXCIoXCIpO3JldHVybiBlLm5hbWV8fGUuc2VwYXJhdG9yPyhyKz1cIntcIithLGUubmFtZSYmKHIrPXkobisxLCdOQU1FOiBcIicrZS5uYW1lKydcIicpK1wiLFwiK2EpLGUuc2VwYXJhdG9yJiYocis9eShuKzEsXCJTRVA6IHRoaXMudG9rZW5zTWFwLlwiK2kudG9rZW5OYW1lKGUuc2VwYXJhdG9yKSkrXCIsXCIrYSkscis9XCJERUY6IFwiK0UoZS5kZWZpbml0aW9uLG4rMikrYSxyKz15KG4sXCJ9XCIpK2EpOnIrPUUoZS5kZWZpbml0aW9uLG4rMSkscis9eShuLFwiKVwiKSthfWZ1bmN0aW9uIEUodCxlKXt2YXIgbj1cImZ1bmN0aW9uKCkge1wiK2E7cmV0dXJuIG4rPW0odCxlKSxuKz15KGUsXCJ9XCIpK2F9ZnVuY3Rpb24gbSh0LGUpe3ZhciBuPVwiXCI7cmV0dXJuIHIuZm9yRWFjaCh0LGZ1bmN0aW9uKHQpe24rPWZ1bmN0aW9uKHQsZSl7aWYodCBpbnN0YW5jZW9mIG8uTm9uVGVybWluYWwpcmV0dXJuIGwodCxlKTtpZih0IGluc3RhbmNlb2Ygby5PcHRpb24pcmV0dXJuIGQoXCJPUFRJT05cIix0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLlJlcGV0aXRpb25NYW5kYXRvcnkpcmV0dXJuIGQoXCJBVF9MRUFTVF9PTkVcIix0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKXJldHVybiBkKFwiQVRfTEVBU1RfT05FX1NFUFwiLHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpcmV0dXJuIGQoXCJNQU5ZX1NFUFwiLHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uUmVwZXRpdGlvbilyZXR1cm4gZChcIk1BTllcIix0LGUpO2lmKHQgaW5zdGFuY2VvZiBvLkFsdGVybmF0aW9uKXJldHVybiBoKHQsZSk7aWYodCBpbnN0YW5jZW9mIG8uVGVybWluYWwpcmV0dXJuIHAodCxlKTtpZih0IGluc3RhbmNlb2Ygby5GbGF0KXJldHVybiBtKHQuZGVmaW5pdGlvbixlKTt0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpfSh0LGUrMSk7fSksbn1mdW5jdGlvbiB5KHQsZSl7cmV0dXJuIEFycmF5KDQqdCsxKS5qb2luKFwiIFwiKStlfWUuZ2VuVW1kTW9kdWxlPWZ1bmN0aW9uKHQpe3JldHVybiBcIlxcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XFxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXFxuICAgICAgICBkZWZpbmUoWydjaGV2cm90YWluJ10sIGZhY3RvcnkpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcXG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2NoZXZyb3RhaW4nKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeShyb290LmIpO1xcbiAgICB9XFxufSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKGNoZXZyb3RhaW4pIHtcXG5cXG5cIitzKHQpK1wiXFxuICAgIFxcbnJldHVybiB7XFxuICAgIFwiK3QubmFtZStcIjogXCIrdC5uYW1lK1wiIFxcbn1cXG59KSk7XFxuXCJ9LGUuZ2VuV3JhcHBlckZ1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBcIiAgICBcXG5cIitzKHQpK1wiXFxucmV0dXJuIG5ldyBcIit0Lm5hbWUrXCIodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpICAgIFxcblwifSxlLmdlbkNsYXNzPXMsZS5nZW5BbGxSdWxlcz11LGUuZ2VuUnVsZT1jLGUuZ2VuVGVybWluYWw9cCxlLmdlbk5vblRlcm1pbmFsPWwsZS5nZW5BbHRlcm5hdGlvbj1oLGUuZ2VuU2luZ2xlQWx0PWY7fV0pfSk7XG52YXIgY2hldnJvdGFpbiA9IHdpbmRvdy5jaGV2cm90YWluO1xuXG52YXIgVlJNTExvYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdC8vIGRlcGVuZGVuY3kgY2hlY2tcblxuXHRpZiAoIHR5cGVvZiBjaGV2cm90YWluID09PSAndW5kZWZpbmVkJyApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTG9hZGVyOiBFeHRlcm5hbCBsaWJyYXJ5IGNoZXZyb3RhaW4ubWluLmpzIHJlcXVpcmVkLicgKTtcblxuXHR9XG5cblx0Ly8gY2xhc3MgZGVmaW5pdGlvbnNcblxuXHRmdW5jdGlvbiBWUk1MTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdH1cblxuXHRWUk1MTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0XHRjb25zdHJ1Y3RvcjogVlJNTExvYWRlcixcblxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBwYXRoID0gKCBzY29wZS5wYXRoID09PSAnJyApID8gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApIDogc2NvcGUucGF0aDtcblxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0LCBwYXRoICkgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEsIHBhdGggKSB7XG5cblx0XHRcdHZhciBub2RlTWFwID0ge307XG5cblx0XHRcdGZ1bmN0aW9uIGdlbmVyYXRlVlJNTFRyZWUoIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGxleGVyLCBwYXJzZXIgYW5kIHZpc2l0b3JcblxuXHRcdFx0XHR2YXIgdG9rZW5EYXRhID0gY3JlYXRlVG9rZW5zKCk7XG5cblx0XHRcdFx0dmFyIGxleGVyID0gbmV3IFZSTUxMZXhlciggdG9rZW5EYXRhLnRva2VucyApO1xuXHRcdFx0XHR2YXIgcGFyc2VyID0gbmV3IFZSTUxQYXJzZXIoIHRva2VuRGF0YS50b2tlblZvY2FidWxhcnkgKTtcblx0XHRcdFx0dmFyIHZpc2l0b3IgPSBjcmVhdGVWaXNpdG9yKCBwYXJzZXIuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpICk7XG5cblx0XHRcdFx0Ly8gbGV4aW5nXG5cblx0XHRcdFx0dmFyIGxleGluZ1Jlc3VsdCA9IGxleGVyLmxleCggZGF0YSApO1xuXHRcdFx0XHRwYXJzZXIuaW5wdXQgPSBsZXhpbmdSZXN1bHQudG9rZW5zO1xuXG5cdFx0XHRcdC8vIHBhcnNpbmdcblxuXHRcdFx0XHR2YXIgY3N0T3V0cHV0ID0gcGFyc2VyLnZybWwoKTtcblxuXHRcdFx0XHRpZiAoIHBhcnNlci5lcnJvcnMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIHBhcnNlci5lcnJvcnMgKTtcblxuXHRcdFx0XHRcdHRocm93IEVycm9yKCAnVEhSRUUuVlJNTExvYWRlcjogUGFyc2luZyBlcnJvcnMgZGV0ZWN0ZWQuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhY3Rpb25zXG5cblx0XHRcdFx0dmFyIGFzdCA9IHZpc2l0b3IudmlzaXQoIGNzdE91dHB1dCApO1xuXG5cdFx0XHRcdHJldHVybiBhc3Q7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlVG9rZW5zKCkge1xuXG5cdFx0XHRcdHZhciBjcmVhdGVUb2tlbiA9IGNoZXZyb3RhaW4uY3JlYXRlVG9rZW47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHRcdFx0XHQvLyBmcm9tIGh0dHA6Ly9ndW4udGVpcGlyLmdyL1ZSTUwtYW1nZW0vc3BlYy9wYXJ0MS9jb25jZXB0cy5odG1sI1N5bnRheEJhc2ljc1xuXG5cdFx0XHRcdHZhciBSb3V0ZUlkZW50aWZpZXIgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnUm91dGVJZGVudGlmaWVyJywgcGF0dGVybjogL1teXFx4MzAtXFx4MzlcXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdW15cXDAtXFx4MjBcXHgyMlxceDI3XFx4MjNcXHgyYlxceDJjXFx4MmRcXHgyZVxceDViXFx4NWRcXHg1Y1xceDdiXFx4N2RdKltcXC5dW15cXHgzMC1cXHgzOVxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF1bXlxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF0qLyB9ICk7XG5cdFx0XHRcdHZhciBJZGVudGlmaWVyID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0lkZW50aWZpZXInLCBwYXR0ZXJuOiAvW15cXHgzMC1cXHgzOVxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF1bXlxcMC1cXHgyMFxceDIyXFx4MjdcXHgyM1xceDJiXFx4MmNcXHgyZFxceDJlXFx4NWJcXHg1ZFxceDVjXFx4N2JcXHg3ZF0qLywgbG9uZ2VyX2FsdDogUm91dGVJZGVudGlmaWVyIH0gKTtcblxuXHRcdFx0XHQvLyBmcm9tIGh0dHA6Ly9ndW4udGVpcGlyLmdyL1ZSTUwtYW1nZW0vc3BlYy9wYXJ0MS9ub2Rlc1JlZi5odG1sXG5cblx0XHRcdFx0dmFyIG5vZGVUeXBlcyA9IFtcblx0XHRcdFx0XHQnQW5jaG9yJywgJ0JpbGxib2FyZCcsICdDb2xsaXNpb24nLCAnR3JvdXAnLCAnVHJhbnNmb3JtJywgLy8gZ3JvdXBpbmcgbm9kZXNcblx0XHRcdFx0XHQnSW5saW5lJywgJ0xPRCcsICdTd2l0Y2gnLCAvLyBzcGVjaWFsIGdyb3Vwc1xuXHRcdFx0XHRcdCdBdWRpb0NsaXAnLCAnRGlyZWN0aW9uYWxMaWdodCcsICdQb2ludExpZ2h0JywgJ1NjcmlwdCcsICdTaGFwZScsICdTb3VuZCcsICdTcG90TGlnaHQnLCAnV29ybGRJbmZvJywgLy8gY29tbW9uIG5vZGVzXG5cdFx0XHRcdFx0J0N5bGluZGVyU2Vuc29yJywgJ1BsYW5lU2Vuc29yJywgJ1Byb3hpbWl0eVNlbnNvcicsICdTcGhlcmVTZW5zb3InLCAnVGltZVNlbnNvcicsICdUb3VjaFNlbnNvcicsICdWaXNpYmlsaXR5U2Vuc29yJywgLy8gc2Vuc29yc1xuXHRcdFx0XHRcdCdCb3gnLCAnQ29uZScsICdDeWxpbmRlcicsICdFbGV2YXRpb25HcmlkJywgJ0V4dHJ1c2lvbicsICdJbmRleGVkRmFjZVNldCcsICdJbmRleGVkTGluZVNldCcsICdQb2ludFNldCcsICdTcGhlcmUnLCAvLyBnZW9tZXRyaWVzXG5cdFx0XHRcdFx0J0NvbG9yJywgJ0Nvb3JkaW5hdGUnLCAnTm9ybWFsJywgJ1RleHR1cmVDb29yZGluYXRlJywgLy8gZ2VvbWV0cmljIHByb3BlcnRpZXNcblx0XHRcdFx0XHQnQXBwZWFyYW5jZScsICdGb250U3R5bGUnLCAnSW1hZ2VUZXh0dXJlJywgJ01hdGVyaWFsJywgJ01vdmllVGV4dHVyZScsICdQaXhlbFRleHR1cmUnLCAnVGV4dHVyZVRyYW5zZm9ybScsIC8vIGFwcGVhcmFuY2Vcblx0XHRcdFx0XHQnQ29sb3JJbnRlcnBvbGF0b3InLCAnQ29vcmRpbmF0ZUludGVycG9sYXRvcicsICdOb3JtYWxJbnRlcnBvbGF0b3InLCAnT3JpZW50YXRpb25JbnRlcnBvbGF0b3InLCAnUG9zaXRpb25JbnRlcnBvbGF0b3InLCAnU2NhbGFySW50ZXJwb2xhdG9yJywgLy8gaW50ZXJwb2xhdG9yc1xuXHRcdFx0XHRcdCdCYWNrZ3JvdW5kJywgJ0ZvZycsICdOYXZpZ2F0aW9uSW5mbycsICdWaWV3cG9pbnQnLCAvLyBiaW5kYWJsZSBub2Rlc1xuXHRcdFx0XHRcdCdUZXh0JyAvLyBUZXh0IG11c3QgYmUgcGxhY2VkIGF0IHRoZSBlbmQgb2YgdGhlIHJlZ2V4IHNvIHRoZXJlIGFyZSBubyBtYXRjaGVzIGZvciBUZXh0dXJlVHJhbnNmb3JtIGFuZCBUZXh0dXJlQ29vcmRpbmF0ZVxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIFZlcnNpb24gPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdWZXJzaW9uJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvI1ZSTUwuKi8sXG5cdFx0XHRcdFx0bG9uZ2VyX2FsdDogSWRlbnRpZmllclxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIE5vZGVOYW1lID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnTm9kZU5hbWUnLFxuXHRcdFx0XHRcdHBhdHRlcm46IG5ldyBSZWdFeHAoIG5vZGVUeXBlcy5qb2luKCAnfCcgKSApLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciBERUYgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdERUYnLFxuXHRcdFx0XHRcdHBhdHRlcm46IC9ERUYvLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciBVU0UgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdVU0UnLFxuXHRcdFx0XHRcdHBhdHRlcm46IC9VU0UvLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciBST1VURSA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ1JPVVRFJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvUk9VVEUvLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHZhciBUTyA9IGNyZWF0ZVRva2VuKCB7XG5cdFx0XHRcdFx0bmFtZTogJ1RPJyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvVE8vLFxuXHRcdFx0XHRcdGxvbmdlcl9hbHQ6IElkZW50aWZpZXJcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIFN0cmluZ0xpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnU3RyaW5nTGl0ZXJhbCcsIHBhdHRlcm46IC9cIig6P1teXFxcXFwiXFxuXFxyXSt8XFxcXCg6P1tiZm5ydHZcIlxcXFwvXXx1WzAtOWEtZkEtRl17NH0pKSpcIi8gfSApO1xuXHRcdFx0XHR2YXIgSGV4TGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdIZXhMaXRlcmFsJywgcGF0dGVybjogLzBbeFhdWzAtOWEtZkEtRl0rLyB9ICk7XG5cdFx0XHRcdHZhciBOdW1iZXJMaXRlcmFsID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ051bWJlckxpdGVyYWwnLCBwYXR0ZXJuOiAvWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/LyB9ICk7XG5cdFx0XHRcdHZhciBUcnVlTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdUcnVlTGl0ZXJhbCcsIHBhdHRlcm46IC9UUlVFLyB9ICk7XG5cdFx0XHRcdHZhciBGYWxzZUxpdGVyYWwgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnRmFsc2VMaXRlcmFsJywgcGF0dGVybjogL0ZBTFNFLyB9ICk7XG5cdFx0XHRcdHZhciBOdWxsTGl0ZXJhbCA9IGNyZWF0ZVRva2VuKCB7IG5hbWU6ICdOdWxsTGl0ZXJhbCcsIHBhdHRlcm46IC9OVUxMLyB9ICk7XG5cdFx0XHRcdHZhciBMU3F1YXJlID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0xTcXVhcmUnLCBwYXR0ZXJuOiAvXFxbLyB9ICk7XG5cdFx0XHRcdHZhciBSU3F1YXJlID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ1JTcXVhcmUnLCBwYXR0ZXJuOiAvXS8gfSApO1xuXHRcdFx0XHR2YXIgTEN1cmx5ID0gY3JlYXRlVG9rZW4oIHsgbmFtZTogJ0xDdXJseScsIHBhdHRlcm46IC97LyB9ICk7XG5cdFx0XHRcdHZhciBSQ3VybHkgPSBjcmVhdGVUb2tlbiggeyBuYW1lOiAnUkN1cmx5JywgcGF0dGVybjogL30vIH0gKTtcblx0XHRcdFx0dmFyIENvbW1lbnQgPSBjcmVhdGVUb2tlbigge1xuXHRcdFx0XHRcdG5hbWU6ICdDb21tZW50Jyxcblx0XHRcdFx0XHRwYXR0ZXJuOiAvIy4qLyxcblx0XHRcdFx0XHRncm91cDogY2hldnJvdGFpbi5MZXhlci5TS0lQUEVEIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIGNvbW1hcywgYmxhbmtzLCB0YWJzLCBuZXdsaW5lcyBhbmQgY2FycmlhZ2UgcmV0dXJucyBhcmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHdoZXJldmVyIHRoZXkgYXBwZWFyIG91dHNpZGUgb2Ygc3RyaW5nIGZpZWxkc1xuXG5cdFx0XHRcdHZhciBXaGl0ZVNwYWNlID0gY3JlYXRlVG9rZW4oIHtcblx0XHRcdFx0XHRuYW1lOiAnV2hpdGVTcGFjZScsXG5cdFx0XHRcdFx0cGF0dGVybjogL1sgLFxcc10vLFxuXHRcdFx0XHRcdGdyb3VwOiBjaGV2cm90YWluLkxleGVyLlNLSVBQRUQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0dmFyIHRva2VucyA9IFtcblx0XHRcdFx0XHRXaGl0ZVNwYWNlLFxuXHRcdFx0XHRcdC8vIGtleXdvcmRzIGFwcGVhciBiZWZvcmUgdGhlIElkZW50aWZpZXJcblx0XHRcdFx0XHROb2RlTmFtZSxcblx0XHRcdFx0XHRERUYsXG5cdFx0XHRcdFx0VVNFLFxuXHRcdFx0XHRcdFJPVVRFLFxuXHRcdFx0XHRcdFRPLFxuXHRcdFx0XHRcdFRydWVMaXRlcmFsLFxuXHRcdFx0XHRcdEZhbHNlTGl0ZXJhbCxcblx0XHRcdFx0XHROdWxsTGl0ZXJhbCxcblx0XHRcdFx0XHQvLyB0aGUgSWRlbnRpZmllciBtdXN0IGFwcGVhciBhZnRlciB0aGUga2V5d29yZHMgYmVjYXVzZSBhbGwga2V5d29yZHMgYXJlIHZhbGlkIGlkZW50aWZpZXJzXG5cdFx0XHRcdFx0VmVyc2lvbixcblx0XHRcdFx0XHRJZGVudGlmaWVyLFxuXHRcdFx0XHRcdFJvdXRlSWRlbnRpZmllcixcblx0XHRcdFx0XHRTdHJpbmdMaXRlcmFsLFxuXHRcdFx0XHRcdEhleExpdGVyYWwsXG5cdFx0XHRcdFx0TnVtYmVyTGl0ZXJhbCxcblx0XHRcdFx0XHRMU3F1YXJlLFxuXHRcdFx0XHRcdFJTcXVhcmUsXG5cdFx0XHRcdFx0TEN1cmx5LFxuXHRcdFx0XHRcdFJDdXJseSxcblx0XHRcdFx0XHRDb21tZW50XG5cdFx0XHRcdF07XG5cblx0XHRcdFx0dmFyIHRva2VuVm9jYWJ1bGFyeSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdFx0XHR0b2tlblZvY2FidWxhcnlbIHRva2VuLm5hbWUgXSA9IHRva2VuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geyB0b2tlbnM6IHRva2VucywgdG9rZW5Wb2NhYnVsYXJ5OiB0b2tlblZvY2FidWxhcnkgfTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZVZpc2l0b3IoIEJhc2VWUk1MVmlzaXRvciApIHtcblxuXHRcdFx0XHQvLyB0aGUgdmlzaXRvciBpcyBjcmVhdGVkIGR5bm1haWNhbGx5IGJhc2VkIG9uIHRoZSBnaXZlbiBiYXNlIGNsYXNzXG5cblx0XHRcdFx0ZnVuY3Rpb24gVlJNTFRvQVNUVmlzaXRvcigpIHtcblxuXHRcdFx0XHRcdEJhc2VWUk1MVmlzaXRvci5jYWxsKCB0aGlzICk7XG5cblx0XHRcdFx0XHR0aGlzLnZhbGlkYXRlVmlzaXRvcigpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRWUk1MVG9BU1RWaXNpdG9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEJhc2VWUk1MVmlzaXRvci5wcm90b3R5cGUgKSwge1xuXG5cdFx0XHRcdFx0Y29uc3RydWN0b3I6IFZSTUxUb0FTVFZpc2l0b3IsXG5cblx0XHRcdFx0XHR2cm1sOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdHZlcnNpb246IHRoaXMudmlzaXQoIGN0eC52ZXJzaW9uICksXG5cdFx0XHRcdFx0XHRcdG5vZGVzOiBbXSxcblx0XHRcdFx0XHRcdFx0cm91dGVzOiBbXVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4Lm5vZGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbm9kZSA9IGN0eC5ub2RlWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZGF0YS5ub2Rlcy5wdXNoKCB0aGlzLnZpc2l0KCBub2RlICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGN0eC5yb3V0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHgucm91dGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciByb3V0ZSA9IGN0eC5yb3V0ZVsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yb3V0ZXMucHVzaCggdGhpcy52aXNpdCggcm91dGUgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHR2ZXJzaW9uOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGN0eC5WZXJzaW9uWyAwIF0uaW1hZ2U7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0bm9kZTogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiBjdHguTm9kZU5hbWVbIDAgXS5pbWFnZSxcblx0XHRcdFx0XHRcdFx0ZmllbGRzOiBbXVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjdHguZmllbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LmZpZWxkLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgZmllbGQgPSBjdHguZmllbGRbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZmllbGRzLnB1c2goIHRoaXMudmlzaXQoIGZpZWxkICkgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gREVGXG5cblx0XHRcdFx0XHRcdGlmICggY3R4LmRlZiApIHtcblxuXHRcdFx0XHRcdFx0XHRkYXRhLkRFRiA9IHRoaXMudmlzaXQoIGN0eC5kZWZbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdGZpZWxkOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IGN0eC5JZGVudGlmaWVyWyAwIF0uaW1hZ2UsXG5cdFx0XHRcdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdFx0XHRcdHZhbHVlczogbnVsbFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0XHRcdFx0Ly8gU0ZWYWx1ZVxuXG5cdFx0XHRcdFx0XHRpZiAoIGN0eC5zaW5nbGVGaWVsZFZhbHVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdCA9IHRoaXMudmlzaXQoIGN0eC5zaW5nbGVGaWVsZFZhbHVlWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNRlZhbHVlXG5cblx0XHRcdFx0XHRcdGlmICggY3R4Lm11bHRpRmllbGRWYWx1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB0aGlzLnZpc2l0KCBjdHgubXVsdGlGaWVsZFZhbHVlWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkYXRhLnR5cGUgPSByZXN1bHQudHlwZTtcblx0XHRcdFx0XHRcdGRhdGEudmFsdWVzID0gcmVzdWx0LnZhbHVlcztcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0ZGVmOiBmdW5jdGlvbiAoIGN0eCApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuICggY3R4LklkZW50aWZpZXIgfHwgY3R4Lk5vZGVOYW1lIClbIDAgXS5pbWFnZTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHR1c2U6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4geyBVU0U6ICggY3R4LklkZW50aWZpZXIgfHwgY3R4Lk5vZGVOYW1lIClbIDAgXS5pbWFnZSB9O1xuXG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdHNpbmdsZUZpZWxkVmFsdWU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0ZpZWxkKCB0aGlzLCBjdHggKTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRtdWx0aUZpZWxkVmFsdWU6IGZ1bmN0aW9uICggY3R4ICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0ZpZWxkKCB0aGlzLCBjdHggKTtcblxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRyb3V0ZTogZnVuY3Rpb24gKCBjdHggKSB7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRGUk9NOiBjdHguUm91dGVJZGVudGlmaWVyWyAwIF0uaW1hZ2UsXG5cdFx0XHRcdFx0XHRcdFRPOiBjdHguUm91dGVJZGVudGlmaWVyWyAxIF0uaW1hZ2Vcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRmdW5jdGlvbiBwcm9jZXNzRmllbGQoIHNjb3BlLCBjdHggKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSB7XG5cdFx0XHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRcdFx0dmFsdWVzOiBbXVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5ub2RlICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ25vZGUnO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHgubm9kZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBub2RlID0gY3R4Lm5vZGVbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggc2NvcGUudmlzaXQoIG5vZGUgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC51c2UgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAndXNlJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LnVzZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB1c2UgPSBjdHgudXNlWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIHNjb3BlLnZpc2l0KCB1c2UgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGN0eC5TdHJpbmdMaXRlcmFsICkge1xuXG5cdFx0XHRcdFx0XHRmaWVsZC50eXBlID0gJ3N0cmluZyc7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5TdHJpbmdMaXRlcmFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSBjdHguU3RyaW5nTGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGZpZWxkLnZhbHVlcy5wdXNoKCBzdHJpbmdMaXRlcmFsLmltYWdlLnJlcGxhY2UoIC8nfFwiL2csICcnICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguTnVtYmVyTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdudW1iZXInO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjdHguTnVtYmVyTGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBudW1iZXJMaXRlcmFsID0gY3R4Lk51bWJlckxpdGVyYWxbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRmaWVsZC52YWx1ZXMucHVzaCggcGFyc2VGbG9hdCggbnVtYmVyTGl0ZXJhbC5pbWFnZSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4LkhleExpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnaGV4JztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LkhleExpdGVyYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgaGV4TGl0ZXJhbCA9IGN0eC5IZXhMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIGhleExpdGVyYWwuaW1hZ2UgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguVHJ1ZUxpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnYm9vbGVhbic7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGN0eC5UcnVlTGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciB0cnVlTGl0ZXJhbCA9IGN0eC5UcnVlTGl0ZXJhbFsgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHJ1ZUxpdGVyYWwuaW1hZ2UgPT09ICdUUlVFJyApIGZpZWxkLnZhbHVlcy5wdXNoKCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggY3R4LkZhbHNlTGl0ZXJhbCApIHtcblxuXHRcdFx0XHRcdFx0ZmllbGQudHlwZSA9ICdib29sZWFuJztcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY3R4LkZhbHNlTGl0ZXJhbC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBmYWxzZUxpdGVyYWwgPSBjdHguRmFsc2VMaXRlcmFsWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBmYWxzZUxpdGVyYWwuaW1hZ2UgPT09ICdGQUxTRScgKSBmaWVsZC52YWx1ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBjdHguTnVsbExpdGVyYWwgKSB7XG5cblx0XHRcdFx0XHRcdGZpZWxkLnR5cGUgPSAnbnVsbCc7XG5cblx0XHRcdFx0XHRcdGN0eC5OdWxsTGl0ZXJhbC5mb3JFYWNoKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdFx0ZmllbGQudmFsdWVzLnB1c2goIG51bGwgKTtcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZpZWxkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IFZSTUxUb0FTVFZpc2l0b3IoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBwYXJzZVRyZWUoIHRyZWUgKSB7XG5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIEpTT04uc3RyaW5naWZ5KCB0cmVlLCBudWxsLCAyICkgKTtcblxuXHRcdFx0XHR2YXIgbm9kZXMgPSB0cmVlLm5vZGVzO1xuXHRcdFx0XHR2YXIgc2NlbmUgPSBuZXcgU2NlbmUoKTtcblxuXHRcdFx0XHQvLyBmaXJzdCBpdGVyYXRpb246IGJ1aWxkIG5vZGVtYXAgYmFzZWQgb24gREVGIHN0YXRlbWVudHNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIG5vZGUgPSBub2Rlc1sgaSBdO1xuXG5cdFx0XHRcdFx0YnVpbGROb2RlTWFwKCBub2RlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlY29uZCBpdGVyYXRpb246IGJ1aWxkIG5vZGVzXG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBub2RlID0gbm9kZXNbIGkgXTtcblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gZ2V0Tm9kZSggbm9kZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QzRCApIHNjZW5lLmFkZCggb2JqZWN0ICk7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGUubmFtZSA9PT0gJ1dvcmxkSW5mbycgKSBzY2VuZS51c2VyRGF0YS53b3JsZEluZm8gPSBvYmplY3Q7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzY2VuZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZE5vZGVNYXAoIG5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLkRFRiApIHtcblxuXHRcdFx0XHRcdG5vZGVNYXBbIG5vZGUuREVGIF0gPSBub2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggZmllbGQudHlwZSA9PT0gJ25vZGUnICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmaWVsZFZhbHVlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRidWlsZE5vZGVNYXAoIGZpZWxkVmFsdWVzWyBqIF0gKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0Tm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVyZSBhIG5vZGUgcmVmZXJzIHRvIGEgZGlmZmVyZW50IG9uZVxuXG5cdFx0XHRcdGlmICggbm9kZS5VU0UgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZVVTRSggbm9kZS5VU0UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBub2RlLmJ1aWxkICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbm9kZS5idWlsZDtcblxuXHRcdFx0XHRub2RlLmJ1aWxkID0gYnVpbGROb2RlKCBub2RlICk7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGUuYnVpbGQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gbm9kZSBidWlsZGVyXG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG5cdFx0XHRcdHZhciBidWlsZDtcblxuXHRcdFx0XHRzd2l0Y2ggKCBub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ0dyb3VwJzpcblx0XHRcdFx0XHRjYXNlICdUcmFuc2Zvcm0nOlxuXHRcdFx0XHRcdGNhc2UgJ0NvbGxpc2lvbic6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkR3JvdXBpbmdOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0JhY2tncm91bmQnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEJhY2tncm91bmROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NoYXBlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRTaGFwZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQXBwZWFyYW5jZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQXBwZWFyYW5jZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnTWF0ZXJpYWwnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZE1hdGVyaWFsTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdJbWFnZVRleHR1cmUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEltYWdlVGV4dHVyZU5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUGl4ZWxUZXh0dXJlJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRQaXhlbFRleHR1cmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RleHR1cmVUcmFuc2Zvcm0nOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZFRleHR1cmVUcmFuc2Zvcm1Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0luZGV4ZWRGYWNlU2V0Jzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRJbmRleGVkRmFjZVNldE5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnSW5kZXhlZExpbmVTZXQnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEluZGV4ZWRMaW5lU2V0Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdQb2ludFNldCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkUG9pbnRTZXROb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0JveCc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQm94Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDb25lJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRDb25lTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlcic6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkQ3lsaW5kZXJOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZSc6XG5cdFx0XHRcdFx0XHRidWlsZCA9IGJ1aWxkU3BoZXJlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdFbGV2YXRpb25HcmlkJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRFbGV2YXRpb25HcmlkTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdFeHRydXNpb24nOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEV4dHJ1c2lvbk5vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ29sb3InOlxuXHRcdFx0XHRcdGNhc2UgJ0Nvb3JkaW5hdGUnOlxuXHRcdFx0XHRcdGNhc2UgJ05vcm1hbCc6XG5cdFx0XHRcdFx0Y2FzZSAnVGV4dHVyZUNvb3JkaW5hdGUnOlxuXHRcdFx0XHRcdFx0YnVpbGQgPSBidWlsZEdlb21ldHJpY05vZGUoIG5vZGUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnV29ybGRJbmZvJzpcblx0XHRcdFx0XHRcdGJ1aWxkID0gYnVpbGRXb3JsZEluZm9Ob2RlKCBub2RlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0FuY2hvcic6XG5cdFx0XHRcdFx0Y2FzZSAnQmlsbGJvYXJkJzpcblxuXHRcdFx0XHRcdGNhc2UgJ0lubGluZSc6XG5cdFx0XHRcdFx0Y2FzZSAnTE9EJzpcblx0XHRcdFx0XHRjYXNlICdTd2l0Y2gnOlxuXG5cdFx0XHRcdFx0Y2FzZSAnQXVkaW9DbGlwJzpcblx0XHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0Jzpcblx0XHRcdFx0XHRjYXNlICdQb2ludExpZ2h0Jzpcblx0XHRcdFx0XHRjYXNlICdTY3JpcHQnOlxuXHRcdFx0XHRcdGNhc2UgJ1NvdW5kJzpcblx0XHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuXG5cdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1BsYW5lU2Vuc29yJzpcblx0XHRcdFx0XHRjYXNlICdQcm94aW1pdHlTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZVNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnVGltZVNlbnNvcic6XG5cdFx0XHRcdFx0Y2FzZSAnVG91Y2hTZW5zb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1Zpc2liaWxpdHlTZW5zb3InOlxuXG5cdFx0XHRcdFx0Y2FzZSAnVGV4dCc6XG5cblx0XHRcdFx0XHRjYXNlICdGb250U3R5bGUnOlxuXHRcdFx0XHRcdGNhc2UgJ01vdmllVGV4dHVyZSc6XG5cblx0XHRcdFx0XHRjYXNlICdDb2xvckludGVycG9sYXRvcic6XG5cdFx0XHRcdFx0Y2FzZSAnQ29vcmRpbmF0ZUludGVycG9sYXRvcic6XG5cdFx0XHRcdFx0Y2FzZSAnTm9ybWFsSW50ZXJwb2xhdG9yJzpcblx0XHRcdFx0XHRjYXNlICdPcmllbnRhdGlvbkludGVycG9sYXRvcic6XG5cdFx0XHRcdFx0Y2FzZSAnUG9zaXRpb25JbnRlcnBvbGF0b3InOlxuXHRcdFx0XHRcdGNhc2UgJ1NjYWxhckludGVycG9sYXRvcic6XG5cblx0XHRcdFx0XHRjYXNlICdGb2cnOlxuXHRcdFx0XHRcdGNhc2UgJ05hdmlnYXRpb25JbmZvJzpcblx0XHRcdFx0XHRjYXNlICdWaWV3cG9pbnQnOlxuXHRcdFx0XHRcdFx0Ly8gbm9kZSBub3Qgc3VwcG9ydGVkIHlldFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBub2RlOicsIG5vZGVOYW1lICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBidWlsZCAhPT0gdW5kZWZpbmVkICYmIG5vZGUuREVGICE9PSB1bmRlZmluZWQgJiYgYnVpbGQuaGFzT3duUHJvcGVydHkoICduYW1lJyApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0YnVpbGQubmFtZSA9IG5vZGUuREVGO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYnVpbGQ7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRHcm91cGluZ05vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIG9iamVjdCA9IG5ldyBHcm91cCgpO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiYm94Q2VudGVyJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnYmJveFNpemUnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjZW50ZXInOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjaGlsZHJlbic6XG5cdFx0XHRcdFx0XHRcdHBhcnNlRmllbGRDaGlsZHJlbiggZmllbGRWYWx1ZXMsIG9iamVjdCApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sbGlkZSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JvdGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMyggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSwgZmllbGRWYWx1ZXNbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR2YXIgYW5nbGUgPSBmaWVsZFZhbHVlc1sgMyBdO1xuXHRcdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzY2FsZU9yaWVudGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0Ly8gZmllbGQgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRpb24nOlxuXHRcdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdwcm94eSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkQmFja2dyb3VuZE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cblx0XHRcdFx0dmFyIGdyb3VuZEFuZ2xlLCBncm91bmRDb2xvcjtcblx0XHRcdFx0dmFyIHNreUFuZ2xlLCBza3lDb2xvcjtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2dyb3VuZEFuZ2xlJzpcblx0XHRcdFx0XHRcdFx0Z3JvdW5kQW5nbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2dyb3VuZENvbG9yJzpcblx0XHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3IgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JhY2tVcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdib3R0b21VcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdmcm9udFVybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2xlZnRVcmwnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyaWdodFVybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RvcFVybCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NreUFuZ2xlJzpcblx0XHRcdFx0XHRcdFx0c2t5QW5nbGUgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NreUNvbG9yJzpcblx0XHRcdFx0XHRcdFx0c2t5Q29sb3IgPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmFkaXVzID0gMTAwMDA7XG5cblx0XHRcdFx0Ly8gc2t5XG5cblx0XHRcdFx0aWYgKCBza3lDb2xvciApIHtcblxuXHRcdFx0XHRcdHZhciBza3lHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSggcmFkaXVzLCAzMiwgMTYgKTtcblx0XHRcdFx0XHR2YXIgc2t5TWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSwgc2lkZTogQmFja1NpZGUsIGRlcHRoV3JpdGU6IGZhbHNlLCBkZXB0aFRlc3Q6IGZhbHNlIH0gKTtcblxuXHRcdFx0XHRcdGlmICggc2t5Q29sb3IubGVuZ3RoID4gMyApIHtcblxuXHRcdFx0XHRcdFx0cGFpbnRGYWNlcyggc2t5R2VvbWV0cnksIHJhZGl1cywgc2t5QW5nbGUsIHRvQ29sb3JBcnJheSggc2t5Q29sb3IgKSwgdHJ1ZSApO1xuXHRcdFx0XHRcdFx0c2t5TWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNreU1hdGVyaWFsLmNvbG9yLnNldFJHQiggc2t5Q29sb3JbIDAgXSwgc2t5Q29sb3JbIDEgXSwgc2t5Q29sb3JbIDIgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHNreSA9IG5ldyBNZXNoKCBza3lHZW9tZXRyeSwgc2t5TWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRncm91cC5hZGQoIHNreSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBncm91bmRcblxuXHRcdFx0XHRpZiAoIGdyb3VuZENvbG9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBncm91bmRDb2xvci5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZ3JvdW5kR2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgMzIsIDE2LCAwLCAyICogTWF0aC5QSSwgMC41ICogTWF0aC5QSSwgMS41ICogTWF0aC5QSSApO1xuXHRcdFx0XHRcdFx0dmFyIGdyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UsIHNpZGU6IEJhY2tTaWRlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUsIGRlcHRoV3JpdGU6IGZhbHNlLCBkZXB0aFRlc3Q6IGZhbHNlIH0gKTtcblxuXHRcdFx0XHRcdFx0cGFpbnRGYWNlcyggZ3JvdW5kR2VvbWV0cnksIHJhZGl1cywgZ3JvdW5kQW5nbGUsIHRvQ29sb3JBcnJheSggZ3JvdW5kQ29sb3IgKSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdFx0dmFyIGdyb3VuZCA9IG5ldyBNZXNoKCBncm91bmRHZW9tZXRyeSwgZ3JvdW5kTWF0ZXJpYWwgKTtcblx0XHRcdFx0XHRcdGdyb3VwLmFkZCggZ3JvdW5kICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHJlbmRlciBiYWNrZ3JvdW5kIGdyb3VwIGZpcnN0XG5cblx0XHRcdFx0Z3JvdXAucmVuZGVyT3JkZXIgPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdHJldHVybiBncm91cDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFNoYXBlTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Ly8gaWYgdGhlIGFwcGVhcmFuY2UgZmllbGQgaXMgTlVMTCBvciB1bnNwZWNpZmllZCwgbGlnaHRpbmcgaXMgb2ZmIGFuZCB0aGUgdW5saXQgb2JqZWN0IGNvbG9yIGlzICgwLCAwLCAwKVxuXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMDAwMDAgfSApO1xuXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2FwcGVhcmFuY2UnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldE5vZGUoIGZpZWxkVmFsdWVzWyAwIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2dlb21ldHJ5Jzpcblx0XHRcdFx0XHRcdFx0aWYgKCBmaWVsZFZhbHVlc1sgMCBdICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZXROb2RlKCBmaWVsZFZhbHVlc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYnVpbGQgM0Qgb2JqZWN0XG5cblx0XHRcdFx0dmFyIG9iamVjdDtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHR2YXIgdHlwZSA9IGdlb21ldHJ5Ll90eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAncG9pbnRzJyApIHsgLy8gcG9pbnRzXG5cblx0XHRcdFx0XHRcdHZhciBwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYgfSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludHNNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvciBmaWVsZCBpcyBOVUxMIGFuZCB0aGVyZSBpcyBhIG1hdGVyaWFsIGRlZmluZWQgZm9yIHRoZSBhcHBlYXJhbmNlIGFmZmVjdGluZyB0aGlzIFBvaW50U2V0LCB0aGVuIHVzZSB0aGUgZW1pc3NpdmVDb2xvciBvZiB0aGUgbWF0ZXJpYWwgdG8gZHJhdyB0aGUgcG9pbnRzXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFBvaW50cyggZ2VvbWV0cnksIHBvaW50c01hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnbGluZScgKSB7IC8vIGxpbmVzXG5cblx0XHRcdFx0XHRcdHZhciBsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmIH0gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGluZU1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9yIGZpZWxkIGlzIE5VTEwgYW5kIHRoZXJlIGlzIGEgbWF0ZXJpYWwgZGVmaW5lZCBmb3IgdGhlIGFwcGVhcmFuY2UgYWZmZWN0aW5nIHRoaXMgSW5kZXhlZExpbmVTZXQsIHRoZW4gdXNlIHRoZSBlbWlzc2l2ZUNvbG9yIG9mIHRoZSBtYXRlcmlhbCB0byBkcmF3IHRoZSBsaW5lc1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbGluZU1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgeyAvLyBjb25zaWRlciBtZXNoZXNcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgXCJzb2xpZFwiIGhpbnQgKGl0J3MgcGxhY2VkIGluIHRoZSBnZW9tZXRyeSBidXQgYWZmZWN0cyB0aGUgbWF0ZXJpYWwpXG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuX3NvbGlkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwuc2lkZSA9ICggZ2VvbWV0cnkuX3NvbGlkICkgPyBGcm9udFNpZGUgOiBEb3VibGVTaWRlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGZvciB2ZXJ0ZXggY29sb3JzXG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBmaWVsZCBpcyBOVUxMIG9yIG5vIHZlcnRpY2VzIGFyZSBkZWZpbmVkIHRoZSBvYmplY3QgaXMgbm90IGRyYXduXG5cblx0XHRcdFx0XHRvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkQXBwZWFyYW5jZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0XHRcdHZhciB0cmFuc2Zvcm1EYXRhO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWwnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxEYXRhID0gZ2V0Tm9kZSggZmllbGRWYWx1ZXNbIDAgXSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEuZGlmZnVzZUNvbG9yICkgbWF0ZXJpYWwuY29sb3IuY29weSggbWF0ZXJpYWxEYXRhLmRpZmZ1c2VDb2xvciApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLmVtaXNzaXZlQ29sb3IgKSBtYXRlcmlhbC5lbWlzc2l2ZS5jb3B5KCBtYXRlcmlhbERhdGEuZW1pc3NpdmVDb2xvciApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnNoaW5pbmVzcyApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IG1hdGVyaWFsRGF0YS5zaGluaW5lc3M7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEuc3BlY3VsYXJDb2xvciApIG1hdGVyaWFsLnNwZWN1bGFyLmNvcHkoIG1hdGVyaWFsRGF0YS5zcGVjdWxhckNvbG9yICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbERhdGEudHJhbnNwYXJlbmN5ICkgbWF0ZXJpYWwub3BhY2l0eSA9IDEgLSBtYXRlcmlhbERhdGEudHJhbnNwYXJlbmN5O1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWxEYXRhLnRyYW5zcGFyZW5jeSA+IDAgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBtYXRlcmlhbCBmaWVsZCBpcyBOVUxMIG9yIHVuc3BlY2lmaWVkLCBsaWdodGluZyBpcyBvZmYgYW5kIHRoZSB1bmxpdCBvYmplY3QgY29sb3IgaXMgKDAsIDAsIDApXG5cblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMDAwMDAgfSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGV4dHVyZSc6XG5cdFx0XHRcdFx0XHRcdHZhciB0ZXh0dXJlTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZU5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRleHR1cmVOb2RlLm5hbWUgPT09ICdJbWFnZVRleHR1cmUnIHx8IHRleHR1cmVOb2RlLm5hbWUgPT09ICdQaXhlbFRleHR1cmUnICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAgPSBnZXROb2RlKCB0ZXh0dXJlTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAndGV4dHVyZVRyYW5zZm9ybSc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEgPSBnZXROb2RlKCBmaWVsZFZhbHVlc1sgMCBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gb25seSBhcHBseSB0ZXh0dXJlIHRyYW5zZm9ybSBkYXRhIGlmIGEgdGV4dHVyZSB3YXMgZGVmaW5lZFxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHRcdFx0Ly8gcmVzcGVjdCBWUk1MIGxpZ2h0aW5nIG1vZGVsXG5cblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcC5fX3R5cGUgKSB7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLm1hcC5fX3R5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuSU5URU5TSVRZX0FMUEhBOlxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxOyAvLyBpZ25vcmUgdHJhbnNwYXJlbmN5XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuUkdCOlxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmNvbG9yLnNldCggMHhmZmZmZmYgKTsgLy8gaWdub3JlIG1hdGVyaWFsIGNvbG9yXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuUkdCQTpcblx0XHRcdFx0XHRcdFx0XHRtYXRlcmlhbC5jb2xvci5zZXQoIDB4ZmZmZmZmICk7IC8vIGlnbm9yZSBtYXRlcmlhbCBjb2xvclxuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLm9wYWNpdHkgPSAxOyAvLyBpZ25vcmUgdHJhbnNwYXJlbmN5XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGVsZXRlIG1hdGVyaWFsLm1hcC5fX3R5cGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBhcHBseSB0ZXh0dXJlIHRyYW5zZm9ybVxuXG5cdFx0XHRcdFx0aWYgKCB0cmFuc2Zvcm1EYXRhICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAuY2VudGVyLmNvcHkoIHRyYW5zZm9ybURhdGEuY2VudGVyICk7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAucm90YXRpb24gPSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwubWFwLnJlcGVhdC5jb3B5KCB0cmFuc2Zvcm1EYXRhLnNjYWxlICk7XG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5tYXAub2Zmc2V0LmNvcHkoIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTWF0ZXJpYWxOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBtYXRlcmlhbERhdGEgPSB7fTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2FtYmllbnRJbnRlbnNpdHknOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdkaWZmdXNlQ29sb3InOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEuZGlmZnVzZUNvbG9yID0gbmV3IENvbG9yKCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdlbWlzc2l2ZUNvbG9yJzpcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWxEYXRhLmVtaXNzaXZlQ29sb3IgPSBuZXcgQ29sb3IoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0sIGZpZWxkVmFsdWVzWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NoaW5pbmVzcyc6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS5zaGluaW5lc3MgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXJDb2xvcic6XG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsRGF0YS5lbWlzc2l2ZUNvbG9yID0gbmV3IENvbG9yKCBmaWVsZFZhbHVlc1sgMCBdLCBmaWVsZFZhbHVlc1sgMSBdLCBmaWVsZFZhbHVlc1sgMiBdICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVuY3knOlxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbERhdGEudHJhbnNwYXJlbmN5ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxEYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlSGV4Q29sb3IoIGhleCwgdGV4dHVyZVR5cGUsIGNvbG9yICkge1xuXG5cdFx0XHRcdHN3aXRjaCAoIHRleHR1cmVUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBURVhUVVJFX1RZUEUuSU5URU5TSVRZOlxuXHRcdFx0XHRcdFx0Ly8gSW50ZW5zaXR5IHRleHR1cmU6IEEgb25lLWNvbXBvbmVudCBpbWFnZSBzcGVjaWZpZXMgb25lLWJ5dGUgaGV4YWRlY2ltYWwgb3IgaW50ZWdlciB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGltYWdlXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludCggaGV4ICk7XG5cdFx0XHRcdFx0XHRjb2xvci5yID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRjb2xvci5nID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRjb2xvci5iID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLklOVEVOU0lUWV9BTFBIQTpcblx0XHRcdFx0XHRcdC8vIEludGVuc2l0eStBbHBoYSB0ZXh0dXJlOiBBIHR3by1jb21wb25lbnQgaW1hZ2Ugc3BlY2lmaWVzIHRoZSBpbnRlbnNpdHkgaW4gdGhlIGZpcnN0IChoaWdoKSBieXRlIGFuZCB0aGUgYWxwaGEgb3BhY2l0eSBpbiB0aGUgc2Vjb25kIChsb3cpIGJ5dGUuXG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDIsIDQgKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuciA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29sb3IuZyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29sb3IuYiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0Y29sb3IuYSA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggNCwgNiApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLlJHQjpcblx0XHRcdFx0XHRcdC8vIFJHQiB0ZXh0dXJlOiBQaXhlbHMgaW4gYSB0aHJlZS1jb21wb25lbnQgaW1hZ2Ugc3BlY2lmeSB0aGUgcmVkIGNvbXBvbmVudCBpbiB0aGUgZmlyc3QgKGhpZ2gpIGJ5dGUsIGZvbGxvd2VkIGJ5IHRoZSBncmVlbiBhbmQgYmx1ZSBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHRjb2xvci5yID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCAyLCA0ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLmcgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDQsIDYgKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuYiA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggNiwgOCApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgVEVYVFVSRV9UWVBFLlJHQkE6XG5cdFx0XHRcdFx0XHQvLyBSR0JBIHRleHR1cmU6IEZvdXItY29tcG9uZW50IGltYWdlcyBzcGVjaWZ5IHRoZSBhbHBoYSBvcGFjaXR5IGJ5dGUgYWZ0ZXIgcmVkL2dyZWVuL2JsdWVcblx0XHRcdFx0XHRcdGNvbG9yLnIgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDIsIDQgKSApO1xuXHRcdFx0XHRcdFx0Y29sb3IuZyA9IHBhcnNlSW50KCAnMHgnICsgaGV4LnN1YnN0cmluZyggNCwgNiApICk7XG5cdFx0XHRcdFx0XHRjb2xvci5iID0gcGFyc2VJbnQoICcweCcgKyBoZXguc3Vic3RyaW5nKCA2LCA4ICkgKTtcblx0XHRcdFx0XHRcdGNvbG9yLmEgPSBwYXJzZUludCggJzB4JyArIGhleC5zdWJzdHJpbmcoIDgsIDEwICkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlVHlwZSggbnVtX2NvbXBvbmVudHMgKSB7XG5cblx0XHRcdFx0dmFyIHR5cGU7XG5cblx0XHRcdFx0c3dpdGNoICggbnVtX2NvbXBvbmVudHMgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHR0eXBlID0gVEVYVFVSRV9UWVBFLklOVEVOU0lUWTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdFx0dHlwZSA9IFRFWFRVUkVfVFlQRS5JTlRFTlNJVFlfQUxQSEE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRcdHR5cGUgPSBURVhUVVJFX1RZUEUuUkdCO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHR0eXBlID0gVEVYVFVSRV9UWVBFLlJHQkE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHR5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRQaXhlbFRleHR1cmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciB0ZXh0dXJlO1xuXHRcdFx0XHR2YXIgd3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0dmFyIHdyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdpbWFnZSc6XG5cdFx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdHZhciBoZWlnaHQgPSBmaWVsZFZhbHVlc1sgMSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgbnVtX2NvbXBvbmVudHMgPSBmaWVsZFZhbHVlc1sgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdHZhciB1c2VBbHBoYSA9ICggbnVtX2NvbXBvbmVudHMgPT09IDIgfHwgbnVtX2NvbXBvbmVudHMgPT09IDQgKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRleHR1cmVUeXBlID0gZ2V0VGV4dHVyZVR5cGUoIG51bV9jb21wb25lbnRzICk7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHNpemUgPSAoICggdXNlQWxwaGEgPT09IHRydWUgKSA/IDQgOiAzICkgKiAoIHdpZHRoICogaGVpZ2h0ICk7XG5cdFx0XHRcdFx0XHRcdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIHNpemUgKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3IgPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDMsIGsgPSAwLCBqbCA9IGZpZWxkVmFsdWVzLmxlbmd0aDsgaiA8IGpsOyBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VIZXhDb2xvciggZmllbGRWYWx1ZXNbIGogXSwgdGV4dHVyZVR5cGUsIGNvbG9yICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUFscGhhID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc3RyaWRlID0gayAqIDQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDAgXSA9IGNvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAxIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMiBdID0gY29sb3IuYjtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDMgXSA9IGNvbG9yLmE7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc3RyaWRlID0gayAqIDM7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFbIHN0cmlkZSArIDAgXSA9IGNvbG9yLnI7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhWyBzdHJpZGUgKyAxIF0gPSBjb2xvci5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVsgc3RyaWRlICsgMiBdID0gY29sb3IuYjtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggZGF0YSwgd2lkdGgsIGhlaWdodCwgKCB1c2VBbHBoYSA9PT0gdHJ1ZSApID8gUkdCQUZvcm1hdCA6IFJHQkZvcm1hdCApO1xuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLl9fdHlwZSA9IHRleHR1cmVUeXBlOyAvLyBuZWVkZWQgZm9yIG1hdGVyaWFsIG1vZGlmaWNhdGlvbnNcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFMnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gPT09IGZhbHNlICkgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmVwZWF0VCc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSA9PT0gZmFsc2UgKSB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHdyYXBTO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSB3cmFwVDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRJbWFnZVRleHR1cmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciB0ZXh0dXJlO1xuXHRcdFx0XHR2YXIgd3JhcFMgPSBSZXBlYXRXcmFwcGluZztcblx0XHRcdFx0dmFyIHdyYXBUID0gUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICd1cmwnOlxuXHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB1cmwgKSB0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCB1cmwgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JlcGVhdFMnOlxuXHRcdFx0XHRcdFx0XHRpZiAoIGZpZWxkVmFsdWVzWyAwIF0gPT09IGZhbHNlICkgd3JhcFMgPSBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmVwZWF0VCc6XG5cdFx0XHRcdFx0XHRcdGlmICggZmllbGRWYWx1ZXNbIDAgXSA9PT0gZmFsc2UgKSB3cmFwVCA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHdyYXBTO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSB3cmFwVDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRUZXh0dXJlVHJhbnNmb3JtTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgdHJhbnNmb3JtRGF0YSA9IHtcblx0XHRcdFx0XHRjZW50ZXI6IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0cm90YXRpb246IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0c2NhbGU6IG5ldyBWZWN0b3IyKCksXG5cdFx0XHRcdFx0dHJhbnNsYXRpb246IG5ldyBWZWN0b3IyKClcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NlbnRlcic6XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybURhdGEuY2VudGVyLnNldCggZmllbGRWYWx1ZXNbIDAgXSwgZmllbGRWYWx1ZXNbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAncm90YXRpb24nOlxuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YS5zY2FsZS5zZXQoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbi5zZXQoIGZpZWxkVmFsdWVzWyAwIF0sIGZpZWxkVmFsdWVzWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJhbnNmb3JtRGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEdlb21ldHJpY05vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGUuZmllbGRzWyAwIF0udmFsdWVzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkV29ybGRJbmZvTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgd29ybGRJbmZvID0ge307XG5cblx0XHRcdFx0dmFyIGZpZWxkcyA9IG5vZGUuZmllbGRzO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gZmllbGRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIGZpZWxkTmFtZSA9IGZpZWxkLm5hbWU7XG5cdFx0XHRcdFx0dmFyIGZpZWxkVmFsdWVzID0gZmllbGQudmFsdWVzO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggZmllbGROYW1lICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0aXRsZSc6XG5cdFx0XHRcdFx0XHRcdHdvcmxkSW5mby50aXRsZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdpbmZvJzpcblx0XHRcdFx0XHRcdFx0d29ybGRJbmZvLmluZm8gPSBmaWVsZFZhbHVlcztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gd29ybGRJbmZvO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkSW5kZXhlZEZhY2VTZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBjb2xvciwgY29vcmQsIG5vcm1hbCwgdGV4Q29vcmQ7XG5cdFx0XHRcdHZhciBjY3cgPSB0cnVlLCBzb2xpZCA9IHRydWUsIGNyZWFzZUFuZ2xlID0gMDtcblx0XHRcdFx0dmFyIGNvbG9ySW5kZXgsIGNvb3JkSW5kZXgsIG5vcm1hbEluZGV4LCB0ZXhDb29yZEluZGV4O1xuXHRcdFx0XHR2YXIgY29sb3JQZXJWZXJ0ZXggPSB0cnVlLCBub3JtYWxQZXJWZXJ0ZXggPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3JOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yID0gZ2V0Tm9kZSggY29sb3JOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb29yZCc6XG5cdFx0XHRcdFx0XHRcdHZhciBjb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29vcmROb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29vcmQgPSBnZXROb2RlKCBjb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ25vcm1hbCc6XG5cdFx0XHRcdFx0XHRcdHZhciBub3JtYWxOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vcm1hbE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRub3JtYWwgPSBnZXROb2RlKCBub3JtYWxOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0ZXhDb29yZCc6XG5cdFx0XHRcdFx0XHRcdHZhciB0ZXhDb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdGV4Q29vcmROb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dGV4Q29vcmQgPSBnZXROb2RlKCB0ZXhDb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Njdyc6XG5cdFx0XHRcdFx0XHRcdGNjdyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvckluZGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0XHRjb2xvclBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb252ZXgnOlxuXHRcdFx0XHRcdFx0XHQvLyBmaWVsZCBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb29yZEluZGV4Jzpcblx0XHRcdFx0XHRcdFx0Y29vcmRJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY3JlYXNlQW5nbGUnOlxuXHRcdFx0XHRcdFx0XHRjcmVhc2VBbmdsZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdub3JtYWxJbmRleCc6XG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdub3JtYWxQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0XHRub3JtYWxQZXJWZXJ0ZXggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0XHRzb2xpZCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICd0ZXhDb29yZEluZGV4Jzpcblx0XHRcdFx0XHRcdFx0dGV4Q29vcmRJbmRleCA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY29vcmRJbmRleCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogTWlzc2luZyBjb29yZEluZGV4LicgKTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKTsgLy8gaGFuZGxlIFZSTUwgZmlsZXMgd2l0aCBpbmNvbXBsZXRlIGdlb21ldHJ5IGRlZmluaXRpb25cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXggPSB0cmlhbmd1bGF0ZUZhY2VJbmRleCggY29vcmRJbmRleCwgY2N3ICk7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlO1xuXHRcdFx0XHR2YXIgY29sb3JBdHRyaWJ1dGU7XG5cdFx0XHRcdHZhciBub3JtYWxBdHRyaWJ1dGU7XG5cdFx0XHRcdHZhciB1dkF0dHJpYnV0ZTtcblxuXHRcdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvclBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4ICYmIGNvbG9ySW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBub3QgZW1wdHksIHRoZW4gaXQgaXMgdXNlZCB0byBjaG9vc2UgY29sb3JzIGZvciBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZEZhY2VTZXQuXG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZENvbG9ySW5kZXggPSB0cmlhbmd1bGF0ZUZhY2VJbmRleCggY29sb3JJbmRleCwgY2N3ICk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkQ29sb3JJbmRleCwgY29sb3IsIDMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29vcmRJbmRleCBmaWVsZCBpcyB1c2VkIHRvIGNob29zZSBjb2xvcnMgZnJvbSB0aGUgQ29sb3Igbm9kZVxuXG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3IsIDMgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9ySW5kZXggJiYgY29sb3JJbmRleC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBjb2xvckluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiB0aGV5IGFyZSB1c2VkIHRvIGNob29zZSBvbmUgY29sb3IgZm9yIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXRcblxuXHRcdFx0XHRcdFx0XHR2YXIgZmxhdHRlbkZhY2VDb2xvcnMgPSBmbGF0dGVuRGF0YSggY29sb3IsIGNvbG9ySW5kZXggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZEZhY2VDb2xvcnMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBmbGF0dGVuRmFjZUNvbG9ycywgY29vcmRJbmRleCApO1xuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZEZhY2VDb2xvcnMgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29sb3IgYXJlIGFwcGxpZWQgdG8gZWFjaCBmYWNlIG9mIHRoZSBJbmRleGVkRmFjZVNldCBpbiBvcmRlclxuXG5cdFx0XHRcdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggY29sb3IsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCB0cmlhbmd1bGF0ZWRGYWNlQ29sb3JzICk7XG5cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0XHRcdGlmICggbm9ybWFsUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zaWRlciB2ZXJ0ZXggbm9ybWFsc1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vcm1hbEluZGV4ICYmIG5vcm1hbEluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIG5vdCBlbXB0eSwgdGhlbiBpdCBpcyB1c2VkIHRvIGNob29zZSBub3JtYWxzIGZvciBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZEZhY2VTZXQuXG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZE5vcm1hbEluZGV4ID0gdHJpYW5ndWxhdGVGYWNlSW5kZXgoIG5vcm1hbEluZGV4LCBjY3cgKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21JbmRleGVkRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkTm9ybWFsSW5kZXgsIG5vcm1hbCwgMyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIHRoZSBub3JtYWxJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29vcmRJbmRleCBmaWVsZCBpcyB1c2VkIHRvIGNob29zZSBub3JtYWxzIGZyb20gdGhlIE5vcm1hbCBub2RlXG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCAzICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gY29uc2lkZXIgZmFjZSBub3JtYWxzXG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsSW5kZXggJiYgbm9ybWFsSW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsSW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIHRoZXkgYXJlIHVzZWQgdG8gY2hvb3NlIG9uZSBub3JtYWwgZm9yIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXRcblxuXHRcdFx0XHRcdFx0XHR2YXIgZmxhdHRlbkZhY2VOb3JtYWxzID0gZmxhdHRlbkRhdGEoIG5vcm1hbCwgbm9ybWFsSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzID0gdHJpYW5ndWxhdGVGYWNlRGF0YSggZmxhdHRlbkZhY2VOb3JtYWxzLCBjb29yZEluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tRmFjZURhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZEZhY2VOb3JtYWxzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG5vcm1hbEluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBub3JtYWxzIGFyZSBhcHBsaWVkIHRvIGVhY2ggZmFjZSBvZiB0aGUgSW5kZXhlZEZhY2VTZXQgaW4gb3JkZXJcblxuXHRcdFx0XHRcdFx0XHR2YXIgdHJpYW5ndWxhdGVkRmFjZU5vcm1hbHMgPSB0cmlhbmd1bGF0ZUZhY2VEYXRhKCBub3JtYWwsIGNvb3JkSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gY29tcHV0ZUF0dHJpYnV0ZUZyb21GYWNlRGF0YSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgdHJpYW5ndWxhdGVkRmFjZU5vcm1hbHMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgbm9ybWFsIGZpZWxkIGlzIE5VTEwsIHRoZW4gdGhlIGxvYWRlciBzaG91bGQgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBub3JtYWxzLCB1c2luZyBjcmVhc2VBbmdsZSB0byBkZXRlcm1pbmUgaWYgYW5kIGhvdyBub3JtYWxzIGFyZSBzbW9vdGhlZCBhY3Jvc3Mgc2hhcmVkIHZlcnRpY2VzXG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBjb29yZCwgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXhDb29yZCApIHtcblxuXHRcdFx0XHRcdC8vIHRleHR1cmUgY29vcmRpbmF0ZXMgYXJlIGFsd2F5cyBkZWZpbmVkIG9uIHZlcnRleCBsZXZlbFxuXG5cdFx0XHRcdFx0aWYgKCB0ZXhDb29yZEluZGV4ICYmIHRleENvb3JkSW5kZXgubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHRleENvb3JkSW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGl0IGlzIHVzZWQgdG8gY2hvb3NlIHRleHR1cmUgY29vcmRpbmF0ZXMgZm9yIGVhY2ggdmVydGV4IG9mIHRoZSBJbmRleGVkRmFjZVNldC5cblxuXHRcdFx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZFRleENvb3JkSW5kZXggPSB0cmlhbmd1bGF0ZUZhY2VJbmRleCggdGV4Q29vcmRJbmRleCwgY2N3ICk7XG5cdFx0XHRcdFx0XHR1dkF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIHRyaWFuZ3VsYXRlZENvb3JkSW5kZXgsIHRyaWFuZ3VsYXRlZFRleENvb3JkSW5kZXgsIHRleENvb3JkLCAyICk7XG5cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSB0ZXhDb29yZEluZGV4IGZpZWxkIGlzIGVtcHR5LCB0aGVuIHRoZSBjb29yZEluZGV4IGFycmF5IGlzIHVzZWQgdG8gY2hvb3NlIHRleHR1cmUgY29vcmRpbmF0ZXMgZnJvbSB0aGUgVGV4dHVyZUNvb3JkaW5hdGUgbm9kZVxuXG5cdFx0XHRcdFx0XHR1dkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggdHJpYW5ndWxhdGVkQ29vcmRJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHRleENvb3JkLCAyICkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRcdHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCB0cmlhbmd1bGF0ZWRDb29yZEluZGV4LCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29vcmQsIDMgKSApO1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25BdHRyaWJ1dGUgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlICk7XG5cblx0XHRcdFx0Ly8gb3B0aW9uYWwgYXR0cmlidXRlc1xuXG5cdFx0XHRcdGlmICggY29sb3JBdHRyaWJ1dGUgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9yQXR0cmlidXRlICk7XG5cdFx0XHRcdGlmICggdXZBdHRyaWJ1dGUgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd1dicsIHV2QXR0cmlidXRlICk7XG5cblx0XHRcdFx0Ly8gXCJzb2xpZFwiIGluZmx1ZW5jZXMgdGhlIG1hdGVyaWFsIHNvIGxldCdzIHN0b3JlIGl0IGZvciBsYXRlciB1c2VcblxuXHRcdFx0XHRnZW9tZXRyeS5fc29saWQgPSBzb2xpZDtcblx0XHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAnbWVzaCc7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkSW5kZXhlZExpbmVTZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBjb2xvciwgY29vcmQ7XG5cdFx0XHRcdHZhciBjb2xvckluZGV4LCBjb29yZEluZGV4O1xuXHRcdFx0XHR2YXIgY29sb3JQZXJWZXJ0ZXggPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3InOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29sb3JOb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbG9yTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbG9yID0gZ2V0Tm9kZSggY29sb3JOb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb29yZCc6XG5cdFx0XHRcdFx0XHRcdHZhciBjb29yZE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggY29vcmROb2RlICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29vcmQgPSBnZXROb2RlKCBjb29yZE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9ySW5kZXgnOlxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvclBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRcdGNvbG9yUGVyVmVydGV4ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2Nvb3JkSW5kZXgnOlxuXHRcdFx0XHRcdFx0XHRjb29yZEluZGV4ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYnVpbGQgbGluZXNcblxuXHRcdFx0XHR2YXIgY29sb3JBdHRyaWJ1dGU7XG5cblx0XHRcdFx0dmFyIGV4cGFuZGVkTGluZUluZGV4ID0gZXhwYW5kTGluZUluZGV4KCBjb29yZEluZGV4ICk7IC8vIGNyZWF0ZSBhbiBpbmRleCBmb3IgdGhyZWUuanMncyBsaW5lc2VnbWVudCBwcmltaXRpdmVcblxuXHRcdFx0XHRpZiAoIGNvbG9yICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb2xvclBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIG9uZSBjb2xvciBpcyB1c2VkIGZvciBlYWNoIHBvbHlsaW5lIG9mIHRoZSBJbmRleGVkTGluZVNldC5cblxuXHRcdFx0XHRcdFx0XHR2YXIgZXhwYW5kZWRDb2xvckluZGV4ID0gZXhwYW5kTGluZUluZGV4KCBjb2xvckluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIGxpbmUgc2VnbWVudCAocmVuZGVyaW5nIHByaW1pdHZlKVxuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIGV4cGFuZGVkTGluZUluZGV4LCBleHBhbmRlZENvbG9ySW5kZXgsIGNvbG9yLCAzICk7IC8vIGNvbXB1dGUgZGF0YSBvbiB2ZXJ0ZXggbGV2ZWxcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgY29sb3JJbmRleCBmaWVsZCBpcyBlbXB0eSwgdGhlbiB0aGUgY29sb3JzIGFyZSBhcHBsaWVkIHRvIGVhY2ggcG9seWxpbmUgb2YgdGhlIEluZGV4ZWRMaW5lU2V0IGluIG9yZGVyLlxuXG5cdFx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBleHBhbmRlZExpbmVJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9yLCAzICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvckluZGV4Lmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgbm90IGVtcHR5LCB0aGVuIGNvbG9ycyBhcmUgYXBwbGllZCB0byBlYWNoIHZlcnRleCBvZiB0aGUgSW5kZXhlZExpbmVTZXRcblxuXHRcdFx0XHRcdFx0XHR2YXIgZmxhdHRlbkxpbmVDb2xvcnMgPSBmbGF0dGVuRGF0YSggY29sb3IsIGNvbG9ySW5kZXggKTsgLy8gY29tcHV0ZSBjb2xvcnMgZm9yIGVhY2ggVlJNTCBwcmltaXR2ZVxuXHRcdFx0XHRcdFx0XHR2YXIgZXhwYW5kZWRMaW5lQ29sb3JzID0gZXhwYW5kTGluZURhdGEoIGZsYXR0ZW5MaW5lQ29sb3JzLCBjb29yZEluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIGxpbmUgc2VnbWVudCAocmVuZGVyaW5nIHByaW1pdHZlKVxuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tTGluZURhdGEoIGV4cGFuZGVkTGluZUluZGV4LCBleHBhbmRlZExpbmVDb2xvcnMgKTsgLy8gY29tcHV0ZSBkYXRhIG9uIHZlcnRleCBsZXZlbFxuXG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGNvbG9ySW5kZXggZmllbGQgaXMgZW1wdHksIHRoZW4gdGhlIGNvb3JkSW5kZXggZmllbGQgaXMgdXNlZCB0byBjaG9vc2UgY29sb3JzIGZyb20gdGhlIENvbG9yIG5vZGVcblxuXHRcdFx0XHRcdFx0XHR2YXIgZXhwYW5kZWRMaW5lQ29sb3JzID0gZXhwYW5kTGluZURhdGEoIGNvbG9yLCBjb29yZEluZGV4ICk7IC8vIGNvbXB1dGUgY29sb3JzIGZvciBlYWNoIGxpbmUgc2VnbWVudCAocmVuZGVyaW5nIHByaW1pdHZlKVxuXHRcdFx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZSA9IGNvbXB1dGVBdHRyaWJ1dGVGcm9tTGluZURhdGEoIGV4cGFuZGVkTGluZUluZGV4LCBleHBhbmRlZExpbmVDb2xvcnMgKTsgLy8gY29tcHV0ZSBkYXRhIG9uIHZlcnRleCBsZXZlbFxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBleHBhbmRlZExpbmVJbmRleCwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkLCAzICkgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdGlmICggY29sb3JBdHRyaWJ1dGUgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9yQXR0cmlidXRlICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAnbGluZSc7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkUG9pbnRTZXROb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeTtcblx0XHRcdFx0dmFyIGNvbG9yLCBjb29yZDtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvck5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29vcmQnOlxuXHRcdFx0XHRcdFx0XHR2YXIgY29vcmROb2RlID0gZmllbGRWYWx1ZXNbIDAgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvb3JkTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvb3JkID0gZ2V0Tm9kZSggY29vcmROb2RlICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb29yZCwgMyApICk7XG5cdFx0XHRcdGlmICggY29sb3IgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvciwgMyApICk7XG5cblx0XHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAncG9pbnRzJztcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRCb3hOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciBzaXplID0gbmV3IFZlY3RvcjMoIDIsIDIsIDIgKTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3NpemUnOlxuXHRcdFx0XHRcdFx0XHRzaXplLnggPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRzaXplLnkgPSBmaWVsZFZhbHVlc1sgMSBdO1xuXHRcdFx0XHRcdFx0XHRzaXplLnogPSBmaWVsZFZhbHVlc1sgMiBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVlJNTExvYWRlcjogVW5rbm93biBmaWVsZDonLCBmaWVsZE5hbWUgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSggc2l6ZS54LCBzaXplLnksIHNpemUueiApO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZENvbmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciByYWRpdXMgPSAxLCBoZWlnaHQgPSAyLCBvcGVuRW5kZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JvdHRvbSc6XG5cdFx0XHRcdFx0XHRcdG9wZW5FbmRlZCA9ICEgZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JvdHRvbVJhZGl1cyc6XG5cdFx0XHRcdFx0XHRcdHJhZGl1cyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdoZWlnaHQnOlxuXHRcdFx0XHRcdFx0XHRoZWlnaHQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2lkZSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQ29uZUdlb21ldHJ5KCByYWRpdXMsIGhlaWdodCwgMTYsIDEsIG9wZW5FbmRlZCApO1xuXG5cdFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZEN5bGluZGVyTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgcmFkaXVzID0gMSwgaGVpZ2h0ID0gMjtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JvdHRvbSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3JhZGl1cyc6XG5cdFx0XHRcdFx0XHRcdHJhZGl1cyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdoZWlnaHQnOlxuXHRcdFx0XHRcdFx0XHRoZWlnaHQgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2lkZSc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RvcCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggcmFkaXVzLCByYWRpdXMsIGhlaWdodCwgMTYsIDEgKTtcblxuXHRcdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYnVpbGRTcGhlcmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHRcdHZhciByYWRpdXMgPSAxO1xuXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBub2RlLmZpZWxkcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmaWVsZHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lO1xuXHRcdFx0XHRcdHZhciBmaWVsZFZhbHVlcyA9IGZpZWxkLnZhbHVlcztcblxuXHRcdFx0XHRcdHN3aXRjaCAoIGZpZWxkTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAncmFkaXVzJzpcblx0XHRcdFx0XHRcdFx0cmFkaXVzID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgMTYsIDE2ICk7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkRWxldmF0aW9uR3JpZE5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGNvbG9yO1xuXHRcdFx0XHR2YXIgbm9ybWFsO1xuXHRcdFx0XHR2YXIgdGV4Q29vcmQ7XG5cdFx0XHRcdHZhciBoZWlnaHQ7XG5cblx0XHRcdFx0dmFyIGNvbG9yUGVyVmVydGV4ID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG5vcm1hbFBlclZlcnRleCA9IHRydWU7XG5cdFx0XHRcdHZhciBzb2xpZCA9IHRydWU7XG5cdFx0XHRcdHZhciBjY3cgPSB0cnVlO1xuXHRcdFx0XHR2YXIgY3JlYXNlQW5nbGUgPSAwO1xuXHRcdFx0XHR2YXIgeERpbWVuc2lvbiA9IDI7XG5cdFx0XHRcdHZhciB6RGltZW5zaW9uID0gMjtcblx0XHRcdFx0dmFyIHhTcGFjaW5nID0gMTtcblx0XHRcdFx0dmFyIHpTcGFjaW5nID0gMTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjb2xvck5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvciA9IGdldE5vZGUoIGNvbG9yTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsJzpcblx0XHRcdFx0XHRcdFx0dmFyIG5vcm1hbE5vZGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9ybWFsTm9kZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbCA9IGdldE5vZGUoIG5vcm1hbE5vZGUgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3RleENvb3JkJzpcblx0XHRcdFx0XHRcdFx0dmFyIHRleENvb3JkTm9kZSA9IGZpZWxkVmFsdWVzWyAwIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXhDb29yZE5vZGUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0ZXhDb29yZCA9IGdldE5vZGUoIHRleENvb3JkTm9kZSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnaGVpZ2h0Jzpcblx0XHRcdFx0XHRcdFx0aGVpZ2h0ID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjY3cnOlxuXHRcdFx0XHRcdFx0XHRjY3cgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JQZXJWZXJ0ZXgnOlxuXHRcdFx0XHRcdFx0XHRjb2xvclBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdjcmVhc2VBbmdsZSc6XG5cdFx0XHRcdFx0XHRcdGNyZWFzZUFuZ2xlID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ25vcm1hbFBlclZlcnRleCc6XG5cdFx0XHRcdFx0XHRcdG5vcm1hbFBlclZlcnRleCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzb2xpZCc6XG5cdFx0XHRcdFx0XHRcdHNvbGlkID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3hEaW1lbnNpb24nOlxuXHRcdFx0XHRcdFx0XHR4RGltZW5zaW9uID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ3hTcGFjaW5nJzpcblx0XHRcdFx0XHRcdFx0eFNwYWNpbmcgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnekRpbWVuc2lvbic6XG5cdFx0XHRcdFx0XHRcdHpEaW1lbnNpb24gPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnelNwYWNpbmcnOlxuXHRcdFx0XHRcdFx0XHR6U3BhY2luZyA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUk1MTG9hZGVyOiBVbmtub3duIGZpZWxkOicsIGZpZWxkTmFtZSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdmVydGV4IGRhdGFcblxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBbXTtcblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcblx0XHRcdFx0dmFyIGNvbG9ycyA9IFtdO1xuXHRcdFx0XHR2YXIgdXZzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgekRpbWVuc2lvbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHhEaW1lbnNpb247IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbXB1dGUgYSByb3cgbWFqb3IgaW5kZXhcblxuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gKCBpICogeERpbWVuc2lvbiApICsgajtcblxuXHRcdFx0XHRcdFx0Ly8gdmVydGljZXNcblxuXHRcdFx0XHRcdFx0dmFyIHggPSB4U3BhY2luZyAqIGk7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IGhlaWdodFsgaW5kZXggXTtcblx0XHRcdFx0XHRcdHZhciB6ID0gelNwYWNpbmcgKiBqO1xuXG5cdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdFx0XHRcdC8vIGNvbG9yc1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9yICYmIGNvbG9yUGVyVmVydGV4ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciByID0gY29sb3JbIGluZGV4ICogMyArIDAgXTtcblx0XHRcdFx0XHRcdFx0dmFyIGcgPSBjb2xvclsgaW5kZXggKiAzICsgMSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgYiA9IGNvbG9yWyBpbmRleCAqIDMgKyAyIF07XG5cblx0XHRcdFx0XHRcdFx0Y29sb3JzLnB1c2goIHIsIGcsIGIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBub3JtYWxzXG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsICYmIG5vcm1hbFBlclZlcnRleCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgeG4gPSBub3JtYWxbIGluZGV4ICogMyArIDAgXTtcblx0XHRcdFx0XHRcdFx0dmFyIHluID0gbm9ybWFsWyBpbmRleCAqIDMgKyAxIF07XG5cdFx0XHRcdFx0XHRcdHZhciB6biA9IG5vcm1hbFsgaW5kZXggKiAzICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHV2c1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRleENvb3JkICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzID0gdGV4Q29vcmRbIGluZGV4ICogMiArIDAgXTtcblx0XHRcdFx0XHRcdFx0dmFyIHQgPSB0ZXhDb29yZFsgaW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdHV2cy5wdXNoKCBzLCB0ICk7XG5cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHR1dnMucHVzaCggaSAvICggeERpbWVuc2lvbiAtIDEgKSwgaiAvICggekRpbWVuc2lvbiAtIDEgKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhEaW1lbnNpb24gLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgekRpbWVuc2lvbiAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGZyb20gaHR0cHM6Ly90ZWNmYS51bmlnZS5jaC9ndWlkZXMvdnJtbC92cm1sOTcvc3BlYy9wYXJ0MS9ub2Rlc1JlZi5odG1sI0VsZXZhdGlvbkdyaWRcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBpICsgaiAqIHhEaW1lbnNpb247XG5cdFx0XHRcdFx0XHR2YXIgYiA9IGkgKyAoIGogKyAxICkgKiB4RGltZW5zaW9uO1xuXHRcdFx0XHRcdFx0dmFyIGMgPSAoIGkgKyAxICkgKyAoIGogKyAxICkgKiB4RGltZW5zaW9uO1xuXHRcdFx0XHRcdFx0dmFyIGQgPSAoIGkgKyAxICkgKyBqICogeERpbWVuc2lvbjtcblxuXHRcdFx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBjLCBiICk7XG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgYSwgZCApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGMsIGQsIGEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1xuXG5cdFx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdFx0dmFyIHV2QXR0cmlidXRlID0gdG9Ob25JbmRleGVkQXR0cmlidXRlKCBpbmRpY2VzLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblx0XHRcdFx0dmFyIGNvbG9yQXR0cmlidXRlO1xuXHRcdFx0XHR2YXIgbm9ybWFsQXR0cmlidXRlO1xuXG5cdFx0XHRcdC8vIGNvbG9yIGF0dHJpYnV0ZVxuXG5cdFx0XHRcdGlmICggY29sb3IgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yUGVyVmVydGV4ID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgeERpbWVuc2lvbiAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgekRpbWVuc2lvbiAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBpICsgaiAqICggeERpbWVuc2lvbiAtIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciByID0gY29sb3JbIGluZGV4ICogMyArIDAgXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZyA9IGNvbG9yWyBpbmRleCAqIDMgKyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGIgPSBjb2xvclsgaW5kZXggKiAzICsgMiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb25lIGNvbG9yIHBlciBxdWFkXG5cblx0XHRcdFx0XHRcdFx0XHRjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApOyBjb2xvcnMucHVzaCggciwgZywgYiApO1xuXHRcdFx0XHRcdFx0XHRcdGNvbG9ycy5wdXNoKCByLCBnLCBiICk7IGNvbG9ycy5wdXNoKCByLCBnLCBiICk7IGNvbG9ycy5wdXNoKCByLCBnLCBiICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbG9yQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JBdHRyaWJ1dGUgPSB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3JtYWwgYXR0cmlidXRlXG5cblx0XHRcdFx0aWYgKCBub3JtYWwgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vcm1hbFBlclZlcnRleCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHhEaW1lbnNpb24gLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHpEaW1lbnNpb24gLSAxOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gaSArIGogKiAoIHhEaW1lbnNpb24gLSAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgeG4gPSBub3JtYWxbIGluZGV4ICogMyArIDAgXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeW4gPSBub3JtYWxbIGluZGV4ICogMyArIDEgXTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgem4gPSBub3JtYWxbIGluZGV4ICogMyArIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIG9uZSBub3JtYWwgcGVyIHF1YWRcblxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTsgbm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7XG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFscy5wdXNoKCB4biwgeW4sIHpuICk7IG5vcm1hbHMucHVzaCggeG4sIHluLCB6biApOyBub3JtYWxzLnB1c2goIHhuLCB5biwgem4gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUgPSBjb21wdXRlTm9ybWFsQXR0cmlidXRlKCBpbmRpY2VzLCB2ZXJ0aWNlcywgY3JlYXNlQW5nbGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbkF0dHJpYnV0ZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCB1dkF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdGlmICggY29sb3JBdHRyaWJ1dGUgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9yQXR0cmlidXRlICk7XG5cblx0XHRcdFx0Ly8gXCJzb2xpZFwiIGluZmx1ZW5jZXMgdGhlIG1hdGVyaWFsIHNvIGxldCdzIHN0b3JlIGl0IGZvciBsYXRlciB1c2VcblxuXHRcdFx0XHRnZW9tZXRyeS5fc29saWQgPSBzb2xpZDtcblx0XHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAnbWVzaCc7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkRXh0cnVzaW9uTm9kZSggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgY3Jvc3NTZWN0aW9uID0gWyAxLCAxLCAxLCAtIDEsIC0gMSwgLSAxLCAtIDEsIDEsIDEsIDEgXTtcblx0XHRcdFx0dmFyIHNwaW5lID0gWyAwLCAwLCAwLCAwLCAxLCAwIF07XG5cdFx0XHRcdHZhciBzY2FsZTtcblx0XHRcdFx0dmFyIG9yaWVudGF0aW9uO1xuXG5cdFx0XHRcdHZhciBiZWdpbkNhcCA9IHRydWU7XG5cdFx0XHRcdHZhciBjY3cgPSB0cnVlO1xuXHRcdFx0XHR2YXIgY3JlYXNlQW5nbGUgPSAwO1xuXHRcdFx0XHR2YXIgZW5kQ2FwID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHNvbGlkID0gdHJ1ZTtcblxuXHRcdFx0XHR2YXIgZmllbGRzID0gbm9kZS5maWVsZHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgZmllbGQgPSBmaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR2YXIgZmllbGROYW1lID0gZmllbGQubmFtZTtcblx0XHRcdFx0XHR2YXIgZmllbGRWYWx1ZXMgPSBmaWVsZC52YWx1ZXM7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCBmaWVsZE5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JlZ2luQ2FwJzpcblx0XHRcdFx0XHRcdFx0YmVnaW5DYXAgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY2N3Jzpcblx0XHRcdFx0XHRcdFx0Y2N3ID0gZmllbGRWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NvbnZleCc6XG5cdFx0XHRcdFx0XHRcdC8vIGZpZWxkIG5vdCBzdXBwb3J0ZWRcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2NyZWFzZUFuZ2xlJzpcblx0XHRcdFx0XHRcdFx0Y3JlYXNlQW5nbGUgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnY3Jvc3NTZWN0aW9uJzpcblx0XHRcdFx0XHRcdFx0Y3Jvc3NTZWN0aW9uID0gZmllbGRWYWx1ZXM7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdlbmRDYXAnOlxuXHRcdFx0XHRcdFx0XHRlbmRDYXAgPSBmaWVsZFZhbHVlc1sgMCBdO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnb3JpZW50YXRpb24nOlxuXHRcdFx0XHRcdFx0XHRvcmllbnRhdGlvbiA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRcdFx0XHRzY2FsZSA9IGZpZWxkVmFsdWVzO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnc29saWQnOlxuXHRcdFx0XHRcdFx0XHRzb2xpZCA9IGZpZWxkVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdzcGluZSc6XG5cdFx0XHRcdFx0XHRcdHNwaW5lID0gZmllbGRWYWx1ZXM7IC8vIG9ubHkgZXh0cnVzaW9uIGFsb25nIHRoZSBZLWF4aXMgYXJlIHN1cHBvcnRlZCBzbyBmYXJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZSTUxMb2FkZXI6IFVua25vd24gZmllbGQ6JywgZmllbGROYW1lICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY3Jvc3NTZWN0aW9uQ2xvc2VkID0gKCBjcm9zc1NlY3Rpb25bIDAgXSA9PT0gY3Jvc3NTZWN0aW9uWyBjcm9zc1NlY3Rpb24ubGVuZ3RoIC0gMiBdICYmIGNyb3NzU2VjdGlvblsgMSBdID09PSBjcm9zc1NlY3Rpb25bIGNyb3NzU2VjdGlvbi5sZW5ndGggLSAxIF0gKTtcblxuXHRcdFx0XHQvLyB2ZXJ0aWNlc1xuXG5cdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0XHR2YXIgc3BpbmVWZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgc2NhbGluZyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdFx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIG8gPSAwLCBpbCA9IHNwaW5lLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMsIGogKz0gMiwgbyArPSA0ICkge1xuXG5cdFx0XHRcdFx0c3BpbmVWZWN0b3IuZnJvbUFycmF5KCBzcGluZSwgaSApO1xuXG5cdFx0XHRcdFx0c2NhbGluZy54ID0gc2NhbGUgPyBzY2FsZVsgaiArIDAgXSA6IDE7XG5cdFx0XHRcdFx0c2NhbGluZy55ID0gMTtcblx0XHRcdFx0XHRzY2FsaW5nLnogPSBzY2FsZSA/IHNjYWxlWyBqICsgMSBdIDogMTtcblxuXHRcdFx0XHRcdGF4aXMueCA9IG9yaWVudGF0aW9uID8gb3JpZW50YXRpb25bIG8gKyAwIF0gOiAwO1xuXHRcdFx0XHRcdGF4aXMueSA9IG9yaWVudGF0aW9uID8gb3JpZW50YXRpb25bIG8gKyAxIF0gOiAwO1xuXHRcdFx0XHRcdGF4aXMueiA9IG9yaWVudGF0aW9uID8gb3JpZW50YXRpb25bIG8gKyAyIF0gOiAxO1xuXHRcdFx0XHRcdHZhciBhbmdsZSA9IG9yaWVudGF0aW9uID8gb3JpZW50YXRpb25bIG8gKyAzIF0gOiAwO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IGNyb3NzU2VjdGlvbi5sZW5ndGg7IGsgPCBrbDsgayArPSAyICkge1xuXG5cdFx0XHRcdFx0XHR2ZXJ0ZXgueCA9IGNyb3NzU2VjdGlvblsgayArIDAgXTtcblx0XHRcdFx0XHRcdHZlcnRleC55ID0gMDtcblx0XHRcdFx0XHRcdHZlcnRleC56ID0gY3Jvc3NTZWN0aW9uWyBrICsgMSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBzY2FsZVxuXG5cdFx0XHRcdFx0XHR2ZXJ0ZXgubXVsdGlwbHkoIHNjYWxpbmcgKTtcblxuXHRcdFx0XHRcdFx0Ly8gcm90YXRlXG5cblx0XHRcdFx0XHRcdHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblx0XHRcdFx0XHRcdHZlcnRleC5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNsYXRlXG5cblx0XHRcdFx0XHRcdHZlcnRleC5hZGQoIHNwaW5lVmVjdG9yICk7XG5cblx0XHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdFx0dmFyIHNwaW5lQ291bnQgPSBzcGluZS5sZW5ndGggLyAzO1xuXHRcdFx0XHR2YXIgY3Jvc3NTZWN0aW9uQ291bnQgPSBjcm9zc1NlY3Rpb24ubGVuZ3RoIC8gMjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzcGluZUNvdW50IC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGNyb3NzU2VjdGlvbkNvdW50IC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGEgPSBqICsgaSAqIGNyb3NzU2VjdGlvbkNvdW50O1xuXHRcdFx0XHRcdFx0dmFyIGIgPSAoIGogKyAxICkgKyBpICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cdFx0XHRcdFx0XHR2YXIgYyA9IGogKyAoIGkgKyAxICkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblx0XHRcdFx0XHRcdHZhciBkID0gKCBqICsgMSApICsgKCBpICsgMSApICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cblx0XHRcdFx0XHRcdGlmICggKCBqID09PSBjcm9zc1NlY3Rpb25Db3VudCAtIDIgKSAmJiAoIGNyb3NzU2VjdGlvbkNsb3NlZCA9PT0gdHJ1ZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGIgPSBpICogY3Jvc3NTZWN0aW9uQ291bnQ7XG5cdFx0XHRcdFx0XHRcdGQgPSAoIGkgKyAxICkgKiBjcm9zc1NlY3Rpb25Db3VudDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIGNjdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGMgKTtcblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBiLCBkICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBjLCBiICk7XG5cdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggYywgZCwgYiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRyaWFuZ3VsYXRlIGNhcFxuXG5cdFx0XHRcdGlmICggYmVnaW5DYXAgPT09IHRydWUgfHwgZW5kQ2FwID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0dmFyIGNvbnRvdXIgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNyb3NzU2VjdGlvbi5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnRvdXIucHVzaCggbmV3IFZlY3RvcjIoIGNyb3NzU2VjdGlvblsgaSBdLCBjcm9zc1NlY3Rpb25bIGkgKyAxIF0gKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCBjb250b3VyLCBbXSApO1xuXHRcdFx0XHRcdHZhciBjYXBJbmRpY2VzID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0XHRcdGNhcEluZGljZXMucHVzaCggZmFjZVsgMCBdLCBmYWNlWyAxIF0sIGZhY2VbIDIgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYmVnaW4gY2FwXG5cblx0XHRcdFx0XHRpZiAoIGJlZ2luQ2FwID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjYXBJbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNjdyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGluZGljZXMucHVzaCggY2FwSW5kaWNlc1sgaSArIDAgXSwgY2FwSW5kaWNlc1sgaSArIDEgXSwgY2FwSW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGNhcEluZGljZXNbIGkgKyAwIF0sIGNhcEluZGljZXNbIGkgKyAyIF0sIGNhcEluZGljZXNbIGkgKyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVuZCBjYXBcblxuXHRcdFx0XHRcdGlmICggZW5kQ2FwID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5kZXhPZmZzZXQgPSBjcm9zc1NlY3Rpb25Db3VudCAqICggc3BpbmVDb3VudCAtIDEgKTsgLy8gcmVmZXJlbmNlcyB0byB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBsYXN0IGNyb3NzIHNlY3Rpb25cblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2FwSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBjY3cgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDAgXSwgaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMiBdLCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpbmRleE9mZnNldCArIGNhcEluZGljZXNbIGkgKyAwIF0sIGluZGV4T2Zmc2V0ICsgY2FwSW5kaWNlc1sgaSArIDEgXSwgaW5kZXhPZmZzZXQgKyBjYXBJbmRpY2VzWyBpICsgMiBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRvTm9uSW5kZXhlZEF0dHJpYnV0ZSggaW5kaWNlcywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHRcdFx0dmFyIG5vcm1hbEF0dHJpYnV0ZSA9IGNvbXB1dGVOb3JtYWxBdHRyaWJ1dGUoIGluZGljZXMsIHZlcnRpY2VzLCBjcmVhc2VBbmdsZSApO1xuXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9uQXR0cmlidXRlICk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbEF0dHJpYnV0ZSApO1xuXHRcdFx0XHQvLyBubyB1dnMgeWV0XG5cblx0XHRcdFx0Ly8gXCJzb2xpZFwiIGluZmx1ZW5jZXMgdGhlIG1hdGVyaWFsIHNvIGxldCdzIHN0b3JlIGl0IGZvciBsYXRlciB1c2VcblxuXHRcdFx0XHRnZW9tZXRyeS5fc29saWQgPSBzb2xpZDtcblx0XHRcdFx0Z2VvbWV0cnkuX3R5cGUgPSAnbWVzaCc7XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZVVTRSggaWRlbnRpZmllciApIHtcblxuXHRcdFx0XHR2YXIgbm9kZSA9IG5vZGVNYXBbIGlkZW50aWZpZXIgXTtcblx0XHRcdFx0dmFyIGJ1aWxkID0gZ2V0Tm9kZSggbm9kZSApO1xuXG5cdFx0XHRcdC8vIGJlY2F1c2UgdGhlIHNhbWUgM0Qgb2JqZWN0cyBjYW4gaGF2ZSBkaWZmZXJlbnQgdHJhbnNmb3JtYXRpb25zLCBpdCdzIG5lY2Vzc2FyeSB0byBjbG9uZSB0aGVtLlxuXHRcdFx0XHQvLyBtYXRlcmlhbHMgY2FuIGJlIGluZmx1ZW5jZWQgYnkgdGhlIGdlb21ldHJ5IChlLmcuIHZlcnRleCBub3JtYWxzKS4gY2xvbmluZyBpcyBuZWNlc3NhcnkgdG8gYXZvaWRcblx0XHRcdFx0Ly8gYW55IHNpZGUgZWZmZWN0c1xuXG5cdFx0XHRcdHJldHVybiAoIGJ1aWxkLmlzT2JqZWN0M0QgfHwgYnVpbGQuaXNNYXRlcmlhbCApID8gYnVpbGQuY2xvbmUoKSA6IGJ1aWxkO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlRmllbGRDaGlsZHJlbiggY2hpbGRyZW4sIG93bmVyICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gZ2V0Tm9kZSggY2hpbGRyZW5bIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBPYmplY3QzRCApIG93bmVyLmFkZCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHRyaWFuZ3VsYXRlRmFjZUluZGV4KCBpbmRleCwgY2N3ICkge1xuXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gW107XG5cblx0XHRcdFx0Ly8gc2luY2UgZmFjZSBkZWZpbnRpb25zIGNhbiBoYXZlIG1vcmUgdGhhbiB0aHJlZSB2ZXJ0aWNlcywgaXQncyBuZWNlc3NhcnkgdG9cblx0XHRcdFx0Ly8gcGVyZm9ybSBhIHNpbXBsZSB0cmlhbmd1bGF0aW9uXG5cblx0XHRcdFx0dmFyIHN0YXJ0ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGkxID0gaW5kZXhbIHN0YXJ0IF07XG5cdFx0XHRcdFx0dmFyIGkyID0gaW5kZXhbIGkgKyAoIGNjdyA/IDEgOiAyICkgXTtcblx0XHRcdFx0XHR2YXIgaTMgPSBpbmRleFsgaSArICggY2N3ID8gMiA6IDEgKSBdO1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpMSwgaTIsIGkzICk7XG5cblx0XHRcdFx0XHQvLyBhbiBpbmRleCBvZiAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBmYWNlIGhhcyBlbmRlZCBhbmQgdGhlIG5leHQgb25lIGJlZ2luc1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleFsgaSArIDMgXSA9PT0gLSAxIHx8IGkgKyAzID49IGwgKSB7XG5cblx0XHRcdFx0XHRcdGkgKz0gMztcblx0XHRcdFx0XHRcdHN0YXJ0ID0gaSArIDE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBpbmRpY2VzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHRyaWFuZ3VsYXRlRmFjZURhdGEoIGRhdGEsIGluZGV4ICkge1xuXG5cdFx0XHRcdHZhciB0cmlhbmd1bGF0ZWREYXRhID0gW107XG5cblx0XHRcdFx0dmFyIHN0YXJ0ID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIHN0cmlkZSA9IHN0YXJ0ICogMztcblxuXHRcdFx0XHRcdHZhciB4ID0gZGF0YVsgc3RyaWRlIF07XG5cdFx0XHRcdFx0dmFyIHkgPSBkYXRhWyBzdHJpZGUgKyAxIF07XG5cdFx0XHRcdFx0dmFyIHogPSBkYXRhWyBzdHJpZGUgKyAyIF07XG5cblx0XHRcdFx0XHR0cmlhbmd1bGF0ZWREYXRhLnB1c2goIHgsIHksIHogKTtcblxuXHRcdFx0XHRcdC8vIGFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IGZhY2UgaGFzIGVuZGVkIGFuZCB0aGUgbmV4dCBvbmUgYmVnaW5zXG5cblx0XHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMyBdID09PSAtIDEgfHwgaSArIDMgPj0gbCApIHtcblxuXHRcdFx0XHRcdFx0aSArPSAzO1xuXHRcdFx0XHRcdFx0c3RhcnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cmlhbmd1bGF0ZWREYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGZsYXR0ZW5EYXRhKCBkYXRhLCBpbmRleCApIHtcblxuXHRcdFx0XHR2YXIgZmxhdHRlbkRhdGEgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGkxID0gaW5kZXhbIGkgXTtcblxuXHRcdFx0XHRcdHZhciBzdHJpZGUgPSBpMSAqIDM7XG5cblx0XHRcdFx0XHR2YXIgeCA9IGRhdGFbIHN0cmlkZSBdO1xuXHRcdFx0XHRcdHZhciB5ID0gZGF0YVsgc3RyaWRlICsgMSBdO1xuXHRcdFx0XHRcdHZhciB6ID0gZGF0YVsgc3RyaWRlICsgMiBdO1xuXG5cdFx0XHRcdFx0ZmxhdHRlbkRhdGEucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZmxhdHRlbkRhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kTGluZUluZGV4KCBpbmRleCApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaTEgPSBpbmRleFsgaSBdO1xuXHRcdFx0XHRcdHZhciBpMiA9IGluZGV4WyBpICsgMSBdO1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBpMSwgaTIgKTtcblxuXHRcdFx0XHRcdC8vIGFuIGluZGV4IG9mIC0xIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IGxpbmUgaGFzIGVuZGVkIGFuZCB0aGUgbmV4dCBvbmUgYmVnaW5zXG5cblx0XHRcdFx0XHRpZiAoIGluZGV4WyBpICsgMiBdID09PSAtIDEgfHwgaSArIDIgPj0gbCApIHtcblxuXHRcdFx0XHRcdFx0aSArPSAyO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaW5kaWNlcztcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBleHBhbmRMaW5lRGF0YSggZGF0YSwgaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIHRyaWFuZ3VsYXRlZERhdGEgPSBbXTtcblxuXHRcdFx0XHR2YXIgc3RhcnQgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3RyaWRlID0gc3RhcnQgKiAzO1xuXG5cdFx0XHRcdFx0dmFyIHggPSBkYXRhWyBzdHJpZGUgXTtcblx0XHRcdFx0XHR2YXIgeSA9IGRhdGFbIHN0cmlkZSArIDEgXTtcblx0XHRcdFx0XHR2YXIgeiA9IGRhdGFbIHN0cmlkZSArIDIgXTtcblxuXHRcdFx0XHRcdHRyaWFuZ3VsYXRlZERhdGEucHVzaCggeCwgeSwgeiApO1xuXG5cdFx0XHRcdFx0Ly8gYW4gaW5kZXggb2YgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgbGluZSBoYXMgZW5kZWQgYW5kIHRoZSBuZXh0IG9uZSBiZWdpbnNcblxuXHRcdFx0XHRcdGlmICggaW5kZXhbIGkgKyAyIF0gPT09IC0gMSB8fCBpICsgMiA+PSBsICkge1xuXG5cdFx0XHRcdFx0XHRpICs9IDI7XG5cdFx0XHRcdFx0XHRzdGFydCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRyaWFuZ3VsYXRlZERhdGE7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciB2QiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR2YXIgdkMgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHR2YXIgdXZBID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0dmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVBdHRyaWJ1dGVGcm9tSW5kZXhlZERhdGEoIGNvb3JkSW5kZXgsIGluZGV4LCBkYXRhLCBpdGVtU2l6ZSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHQvLyB3ZSB1c2UgdGhlIGNvb3JkSW5kZXgubGVuZ3RoIGFzIGRlbGltaXRlciBzaW5jZSBub3JtYWxJbmRleCBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgYXMgbWFueSBpbmRpY2VzXG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29vcmRJbmRleC5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgYSA9IGluZGV4WyBpIF07XG5cdFx0XHRcdFx0dmFyIGIgPSBpbmRleFsgaSArIDEgXTtcblx0XHRcdFx0XHR2YXIgYyA9IGluZGV4WyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dXZBLmZyb21BcnJheSggZGF0YSwgYSAqIGl0ZW1TaXplICk7XG5cdFx0XHRcdFx0XHR1dkIuZnJvbUFycmF5KCBkYXRhLCBiICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRcdHV2Qy5mcm9tQXJyYXkoIGRhdGEsIGMgKiBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdFx0XHRhcnJheS5wdXNoKCB1dkEueCwgdXZBLnkgKTtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHV2Qi54LCB1dkIueSApO1xuXHRcdFx0XHRcdFx0YXJyYXkucHVzaCggdXZDLngsIHV2Qy55ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIGRhdGEsIGEgKiBpdGVtU2l6ZSApO1xuXHRcdFx0XHRcdFx0dkIuZnJvbUFycmF5KCBkYXRhLCBiICogaXRlbVNpemUgKTtcblx0XHRcdFx0XHRcdHZDLmZyb21BcnJheSggZGF0YSwgYyAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHZCLngsIHZCLnksIHZCLnogKTtcblx0XHRcdFx0XHRcdGFycmF5LnB1c2goIHZDLngsIHZDLnksIHZDLnogKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlQXR0cmlidXRlRnJvbUZhY2VEYXRhKCBpbmRleCwgZmFjZURhdGEgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgbCA9IGluZGV4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuXHRcdFx0XHRcdHZBLmZyb21BcnJheSggZmFjZURhdGEsIGogKiAzICk7XG5cblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cdFx0XHRcdFx0YXJyYXkucHVzaCggdkEueCwgdkEueSwgdkEueiApO1xuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgMyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVBdHRyaWJ1dGVGcm9tTGluZURhdGEoIGluZGV4LCBsaW5lRGF0YSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kZXgubGVuZ3RoOyBpIDwgbDsgaSArPSAyLCBqICsrICkge1xuXG5cdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBsaW5lRGF0YSwgaiAqIDMgKTtcblxuXHRcdFx0XHRcdGFycmF5LnB1c2goIHZBLngsIHZBLnksIHZBLnogKTtcblx0XHRcdFx0XHRhcnJheS5wdXNoKCB2QS54LCB2QS55LCB2QS56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIDMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0b05vbkluZGV4ZWRBdHRyaWJ1dGUoIGluZGljZXMsIGF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRcdHZhciBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdFx0XHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGFiID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVOb3JtYWxBdHRyaWJ1dGUoIGluZGV4LCBjb29yZCwgY3JlYXNlQW5nbGUgKSB7XG5cblx0XHRcdFx0dmFyIGZhY2VzID0gW107XG5cdFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0ge307XG5cblx0XHRcdFx0Ly8gcHJlcGFyZSBmYWNlIGFuZCByYXcgdmVydGV4IG5vcm1hbHNcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRleC5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2YXIgYSA9IGluZGV4WyBpIF07XG5cdFx0XHRcdFx0dmFyIGIgPSBpbmRleFsgaSArIDEgXTtcblx0XHRcdFx0XHR2YXIgYyA9IGluZGV4WyBpICsgMiBdO1xuXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBuZXcgRmFjZSggYSwgYiwgYyApO1xuXG5cdFx0XHRcdFx0dkEuZnJvbUFycmF5KCBjb29yZCwgYSAqIDMgKTtcblx0XHRcdFx0XHR2Qi5mcm9tQXJyYXkoIGNvb3JkLCBiICogMyApO1xuXHRcdFx0XHRcdHZDLmZyb21BcnJheSggY29vcmQsIGMgKiAzICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuXHRcdFx0XHRcdGlmICggdmVydGV4Tm9ybWFsc1sgYSBdID09PSB1bmRlZmluZWQgKSB2ZXJ0ZXhOb3JtYWxzWyBhIF0gPSBbXTtcblx0XHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHNbIGIgXSA9PT0gdW5kZWZpbmVkICkgdmVydGV4Tm9ybWFsc1sgYiBdID0gW107XG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzWyBjIF0gPT09IHVuZGVmaW5lZCApIHZlcnRleE5vcm1hbHNbIGMgXSA9IFtdO1xuXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgYSBdLnB1c2goIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgYiBdLnB1c2goIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgYyBdLnB1c2goIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdFx0XHRmYWNlcy5wdXNoKCBmYWNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbXB1dGUgdmVydGV4IG5vcm1hbHMgYW5kIGJ1aWxkIGZpbmFsIGdlb21ldHJ5XG5cblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIG5BID0gd2VpZ2h0ZWROb3JtYWwoIHZlcnRleE5vcm1hbHNbIGZhY2UuYSBdLCBmYWNlLm5vcm1hbCwgY3JlYXNlQW5nbGUgKTtcblx0XHRcdFx0XHR2YXIgbkIgPSB3ZWlnaHRlZE5vcm1hbCggdmVydGV4Tm9ybWFsc1sgZmFjZS5iIF0sIGZhY2Uubm9ybWFsLCBjcmVhc2VBbmdsZSApO1xuXHRcdFx0XHRcdHZhciBuQyA9IHdlaWdodGVkTm9ybWFsKCB2ZXJ0ZXhOb3JtYWxzWyBmYWNlLmMgXSwgZmFjZS5ub3JtYWwsIGNyZWFzZUFuZ2xlICk7XG5cblx0XHRcdFx0XHR2QS5mcm9tQXJyYXkoIGNvb3JkLCBmYWNlLmEgKiAzICk7XG5cdFx0XHRcdFx0dkIuZnJvbUFycmF5KCBjb29yZCwgZmFjZS5iICogMyApO1xuXHRcdFx0XHRcdHZDLmZyb21BcnJheSggY29vcmQsIGZhY2UuYyAqIDMgKTtcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbkEueCwgbkEueSwgbkEueiApO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbkIueCwgbkIueSwgbkIueiApO1xuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbkMueCwgbkMueSwgbkMueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB3ZWlnaHRlZE5vcm1hbCggbm9ybWFscywgdmVjdG9yLCBjcmVhc2VBbmdsZSApIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0XHRpZiAoIGNyZWFzZUFuZ2xlID09PSAwICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHZlY3RvciApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBub3JtYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9ybWFsc1sgaSBdLmFuZ2xlVG8oIHZlY3RvciApIDwgY3JlYXNlQW5nbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsLmFkZCggbm9ybWFsc1sgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiB0b0NvbG9yQXJyYXkoIGNvbG9ycyApIHtcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBWZXJ0aWNhbGx5IHBhaW50cyB0aGUgZmFjZXMgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHRoZVxuXHRcdFx0ICogc3BlY2lmaWVkIGNvbG9ycyBhdCB0aGUgc3BlY2lmaWVkIGFuZ2Vscy4gVGhpcyBpcyB1c2VkIGZvciB0aGUgQmFja2dyb3VuZFxuXHRcdFx0ICogbm9kZSwgYnV0IGNvdWxkIGJlIGFwcGxpZWQgdG8gb3RoZXIgbm9kZXMgd2l0aCBtdWx0aXBsZSBmYWNlcyBhcyB3ZWxsLlxuXHRcdFx0ICpcblx0XHRcdCAqIFdoZW4gdXNlZCB3aXRoIHRoZSBCYWNrZ3JvdW5kIG5vZGUsIGRlZmF1bHQgaXMgZGlyZWN0aW9uSXNEb3duIGlzIHRydWUgaWZcblx0XHRcdCAqIGludGVycG9sYXRpbmcgdGhlIHNreUNvbG9yIGRvd24gZnJvbSB0aGUgWmVuaXRoLiBXaGVuIGludGVycG9sYXRpb25nIHVwIGZyb21cblx0XHRcdCAqIHRoZSBOYWRpciBpLmUuIGludGVycG9sYXRpbmcgdGhlIGdyb3VuZENvbG9yLCB0aGUgZGlyZWN0aW9uSXNEb3duIGlzIGZhbHNlLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBmaXJzdCBhbmdsZSBpcyBuZXZlciBzcGVjaWZpZWQsIGl0IGlzIHRoZSBaZW5pdGggKDAgcmFkKS4gQW5nbGVzIGFyZSBzcGVjaWZpZWRcblx0XHRcdCAqIGluIHJhZGlhbnMuIFRoZSBnZW9tZXRyeSBpcyB0aG91Z2h0IGEgc3BoZXJlLCBidXQgY291bGQgYmUgYW55dGhpbmcuIFRoZSBjb2xvciBpbnRlcnBvbGF0aW9uXG5cdFx0XHQgKiBpcyBsaW5lYXIgYWxvbmcgdGhlIFkgYXhpcyBpbiBhbnkgY2FzZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBZb3UgbXVzdCBzcGVjaWZ5IG9uZSBtb3JlIGNvbG9yIHRoYW4geW91IGhhdmUgYW5nbGVzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbG9ycyBhcnJheS5cblx0XHRcdCAqIFRoaXMgaXMgdGhlIGNvbG9yIG9mIHRoZSBaZW5pdGggKHRoZSB0b3Agb2YgdGhlIHNoYXBlKS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0J1ZmZlckdlb21ldHJ5fSBnZW9tZXRyeVxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuXHRcdFx0ICogQHBhcmFtIHthcnJheX0gYW5nbGVzXG5cdFx0XHQgKiBAcGFyYW0ge2FycmF5fSBjb2xvcnNcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9wRG93biAtIFdoZXRoZXIgdG8gd29yayB0b3AgZG93biBvciBib3R0b20gdXAuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHBhaW50RmFjZXMoIGdlb21ldHJ5LCByYWRpdXMsIGFuZ2xlcywgY29sb3JzLCB0b3BEb3duICkge1xuXG5cdFx0XHRcdC8vIGNvbXB1dGUgdGhyZXNob2xkIHZhbHVlc1xuXG5cdFx0XHRcdHZhciB0aHJlc2hvbGRzID0gW107XG5cdFx0XHRcdHZhciBzdGFydEFuZ2xlID0gKCB0b3BEb3duID09PSB0cnVlICkgPyAwIDogTWF0aC5QSTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBhbmdsZSA9ICggaSA9PT0gMCApID8gMCA6IGFuZ2xlc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRhbmdsZSA9ICggdG9wRG93biA9PT0gdHJ1ZSApID8gYW5nbGUgOiAoIHN0YXJ0QW5nbGUgLSBhbmdsZSApO1xuXG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0XHRwb2ludC5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCByYWRpdXMsIGFuZ2xlLCAwICk7XG5cblx0XHRcdFx0XHR0aHJlc2hvbGRzLnB1c2goIHBvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdlbmVyYXRlIHZlcnRleCBjb2xvcnNcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHR2YXIgY29sb3JBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICogMyApLCAzICk7XG5cblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdFx0dmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5jb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IGluZGljZXMuZ2V0WCggaSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0cmlidXRlLCBpbmRleCApO1xuXG5cdFx0XHRcdFx0dmFyIHRocmVzaG9sZEluZGV4QSwgdGhyZXNob2xkSW5kZXhCO1xuXHRcdFx0XHRcdHZhciB0ID0gMTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8IHRocmVzaG9sZHMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR0aHJlc2hvbGRJbmRleEEgPSBqIC0gMTtcblx0XHRcdFx0XHRcdHRocmVzaG9sZEluZGV4QiA9IGo7XG5cblx0XHRcdFx0XHRcdHZhciB0aHJlc2hvbGRBID0gdGhyZXNob2xkc1sgdGhyZXNob2xkSW5kZXhBIF07XG5cdFx0XHRcdFx0XHR2YXIgdGhyZXNob2xkQiA9IHRocmVzaG9sZHNbIHRocmVzaG9sZEluZGV4QiBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRvcERvd24gPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaW50ZXJwb2xhdGlvbiBmb3Igc2t5IGNvbG9yXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55IDw9IHRocmVzaG9sZEEueSAmJiBwb3NpdGlvbi55ID4gdGhyZXNob2xkQi55ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dCA9IE1hdGguYWJzKCB0aHJlc2hvbGRBLnkgLSBwb3NpdGlvbi55ICkgLyBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gdGhyZXNob2xkQi55ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gaW50ZXJwb2xhdGlvbiBmb3IgZ3JvdW5kIGNvbG9yXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBwb3NpdGlvbi55ID49IHRocmVzaG9sZEEueSAmJiBwb3NpdGlvbi55IDwgdGhyZXNob2xkQi55ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dCA9IE1hdGguYWJzKCB0aHJlc2hvbGRBLnkgLSBwb3NpdGlvbi55ICkgLyBNYXRoLmFicyggdGhyZXNob2xkQS55IC0gdGhyZXNob2xkQi55ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBjb2xvckEgPSBjb2xvcnNbIHRocmVzaG9sZEluZGV4QSBdO1xuXHRcdFx0XHRcdHZhciBjb2xvckIgPSBjb2xvcnNbIHRocmVzaG9sZEluZGV4QiBdO1xuXG5cdFx0XHRcdFx0Y29sb3IuY29weSggY29sb3JBICkubGVycCggY29sb3JCLCB0ICk7XG5cblx0XHRcdFx0XHRjb2xvckF0dHJpYnV0ZS5zZXRYWVooIGluZGV4LCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL1xuXG5cdFx0XHR2YXIgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRcdHRleHR1cmVMb2FkZXIuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRcdC8vIGNoZWNrIHZlcnNpb24gKG9ubHkgMi4wIGlzIHN1cHBvcnRlZClcblxuXHRcdFx0aWYgKCBkYXRhLmluZGV4T2YoICcjVlJNTCBWMi4wJyApID09PSAtIDEgKSB7XG5cblx0XHRcdFx0dGhyb3cgRXJyb3IoICdUSFJFRS5WUk1MTGV4ZXI6IFZlcnNpb24gb2YgVlJNTCBhc3NldCBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjcmVhdGUgSlNPTiByZXByZXNlbnRpbmcgdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBWUk1MIGFzc2V0XG5cblx0XHRcdHZhciB0cmVlID0gZ2VuZXJhdGVWUk1MVHJlZSggZGF0YSApO1xuXG5cdFx0XHQvLyBwYXJzZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgdG8gYSB0aHJlZS5qcyBzY2VuZVxuXG5cdFx0XHR2YXIgc2NlbmUgPSBwYXJzZVRyZWUoIHRyZWUgKTtcblxuXHRcdFx0cmV0dXJuIHNjZW5lO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxuXHRmdW5jdGlvbiBWUk1MTGV4ZXIoIHRva2VucyApIHtcblxuXHRcdHRoaXMubGV4ZXIgPSBuZXcgY2hldnJvdGFpbi5MZXhlciggdG9rZW5zICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXHR9XG5cblx0VlJNTExleGVyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBWUk1MTGV4ZXIsXG5cblx0XHRsZXg6IGZ1bmN0aW9uICggaW5wdXRUZXh0ICkge1xuXG5cdFx0XHR2YXIgbGV4aW5nUmVzdWx0ID0gdGhpcy5sZXhlci50b2tlbml6ZSggaW5wdXRUZXh0ICk7XG5cblx0XHRcdGlmICggbGV4aW5nUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGxleGluZ1Jlc3VsdC5lcnJvcnMgKTtcblxuXHRcdFx0XHR0aHJvdyBFcnJvciggJ1RIUkVFLlZSTUxMZXhlcjogTGV4aW5nIGVycm9ycyBkZXRlY3RlZC4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxleGluZ1Jlc3VsdDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZSTUxQYXJzZXIoIHRva2VuVm9jYWJ1bGFyeSApIHtcblxuXHRcdGNoZXZyb3RhaW4uUGFyc2VyLmNhbGwoIHRoaXMsIHRva2VuVm9jYWJ1bGFyeSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblx0XHR2YXIgJCA9IHRoaXM7XG5cblx0XHR2YXIgVmVyc2lvbiA9IHRva2VuVm9jYWJ1bGFyeVsgJ1ZlcnNpb24nIF07XG5cdFx0dmFyIExDdXJseSA9IHRva2VuVm9jYWJ1bGFyeVsgJ0xDdXJseScgXTtcblx0XHR2YXIgUkN1cmx5ID0gdG9rZW5Wb2NhYnVsYXJ5WyAnUkN1cmx5JyBdO1xuXHRcdHZhciBMU3F1YXJlID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTFNxdWFyZScgXTtcblx0XHR2YXIgUlNxdWFyZSA9IHRva2VuVm9jYWJ1bGFyeVsgJ1JTcXVhcmUnIF07XG5cdFx0dmFyIElkZW50aWZpZXIgPSB0b2tlblZvY2FidWxhcnlbICdJZGVudGlmaWVyJyBdO1xuXHRcdHZhciBSb3V0ZUlkZW50aWZpZXIgPSB0b2tlblZvY2FidWxhcnlbICdSb3V0ZUlkZW50aWZpZXInIF07XG5cdFx0dmFyIFN0cmluZ0xpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdTdHJpbmdMaXRlcmFsJyBdO1xuXHRcdHZhciBIZXhMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnSGV4TGl0ZXJhbCcgXTtcblx0XHR2YXIgTnVtYmVyTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ051bWJlckxpdGVyYWwnIF07XG5cdFx0dmFyIFRydWVMaXRlcmFsID0gdG9rZW5Wb2NhYnVsYXJ5WyAnVHJ1ZUxpdGVyYWwnIF07XG5cdFx0dmFyIEZhbHNlTGl0ZXJhbCA9IHRva2VuVm9jYWJ1bGFyeVsgJ0ZhbHNlTGl0ZXJhbCcgXTtcblx0XHR2YXIgTnVsbExpdGVyYWwgPSB0b2tlblZvY2FidWxhcnlbICdOdWxsTGl0ZXJhbCcgXTtcblx0XHR2YXIgREVGID0gdG9rZW5Wb2NhYnVsYXJ5WyAnREVGJyBdO1xuXHRcdHZhciBVU0UgPSB0b2tlblZvY2FidWxhcnlbICdVU0UnIF07XG5cdFx0dmFyIFJPVVRFID0gdG9rZW5Wb2NhYnVsYXJ5WyAnUk9VVEUnIF07XG5cdFx0dmFyIFRPID0gdG9rZW5Wb2NhYnVsYXJ5WyAnVE8nIF07XG5cdFx0dmFyIE5vZGVOYW1lID0gdG9rZW5Wb2NhYnVsYXJ5WyAnTm9kZU5hbWUnIF07XG5cblx0XHQkLlJVTEUoICd2cm1sJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLlNVQlJVTEUoICQudmVyc2lvbiApO1xuXHRcdFx0JC5BVF9MRUFTVF9PTkUoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQubm9kZSApO1xuXG5cdFx0XHR9ICk7XG5cdFx0XHQkLk1BTlkoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHQkLlNVQlJVTEUoICQucm91dGUgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAndmVyc2lvbicsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBWZXJzaW9uICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdub2RlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLk9QVElPTiggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuU1VCUlVMRSggJC5kZWYgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHQkLkNPTlNVTUUoIE5vZGVOYW1lICk7XG5cdFx0XHQkLkNPTlNVTUUoIExDdXJseSApO1xuXHRcdFx0JC5NQU5ZKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5TVUJSVUxFKCAkLmZpZWxkICk7XG5cblx0XHRcdH0gKTtcblx0XHRcdCQuQ09OU1VNRSggUkN1cmx5ICk7XG5cblx0XHR9ICk7XG5cblx0XHQkLlJVTEUoICdmaWVsZCcsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBJZGVudGlmaWVyICk7XG5cblx0XHRcdCQuT1IyKCBbXG5cdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHQkLlNVQlJVTEUoICQuc2luZ2xlRmllbGRWYWx1ZSApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuU1VCUlVMRSggJC5tdWx0aUZpZWxkVmFsdWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ2RlZicsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBERUYgKTtcblx0XHRcdCQuT1IoIFtcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggSWRlbnRpZmllciApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggTm9kZU5hbWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3VzZScsIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0JC5DT05TVU1FKCBVU0UgKTtcblx0XHRcdCQuT1IoIFtcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggSWRlbnRpZmllciApO1xuXG5cdFx0XHRcdH0gfSxcblx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdCQuQ09OU1VNRSggTm9kZU5hbWUgKTtcblxuXHRcdFx0XHR9IH1cblx0XHRcdF0gKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3NpbmdsZUZpZWxkVmFsdWUnLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdCQuQVRfTEVBU1RfT05FKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0JC5PUiggW1xuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC5ub2RlICk7XG5cblx0XHRcdFx0XHR9IH0sXG5cdFx0XHRcdFx0eyBBTFQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdFx0JC5TVUJSVUxFKCAkLnVzZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggU3RyaW5nTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggSGV4TGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVtYmVyTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggVHJ1ZUxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIEZhbHNlTGl0ZXJhbCApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuQ09OU1VNRSggTnVsbExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfVxuXHRcdFx0XHRdICk7XG5cblxuXHRcdFx0fSApO1xuXG5cdFx0fSApO1xuXG5cdFx0JC5SVUxFKCAnbXVsdGlGaWVsZFZhbHVlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIExTcXVhcmUgKTtcblx0XHRcdCQuTUFOWSggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdCQuT1IoIFtcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLlNVQlJVTEUoICQubm9kZSApO1xuXG5cdFx0XHRcdFx0fSB9LFxuXHRcdFx0XHRcdHsgQUxUOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdCQuU1VCUlVMRSggJC51c2UgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIFN0cmluZ0xpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIEhleExpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bWJlckxpdGVyYWwgKTtcblxuXHRcdFx0XHRcdH0gfSxcblx0XHRcdFx0XHR7IEFMVDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0XHQkLkNPTlNVTUUoIE51bGxMaXRlcmFsICk7XG5cblx0XHRcdFx0XHR9IH1cblx0XHRcdFx0XSApO1xuXG5cdFx0XHR9ICk7XG5cdFx0XHQkLkNPTlNVTUUoIFJTcXVhcmUgKTtcblxuXHRcdH0gKTtcblxuXHRcdCQuUlVMRSggJ3JvdXRlJywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQkLkNPTlNVTUUoIFJPVVRFICk7XG5cdFx0XHQkLkNPTlNVTUUoIFJvdXRlSWRlbnRpZmllciApO1xuXHRcdFx0JC5DT05TVU1FKCBUTyApO1xuXHRcdFx0JC5DT05TVU1FMiggUm91dGVJZGVudGlmaWVyICk7XG5cblx0XHR9ICk7XG5cblx0XHR0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXMoKTtcblxuXHR9XG5cblx0VlJNTFBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBjaGV2cm90YWluLlBhcnNlci5wcm90b3R5cGUgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXHRWUk1MUGFyc2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZSTUxQYXJzZXI7XG5cblx0ZnVuY3Rpb24gRmFjZSggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYSA9IGE7XG5cdFx0dGhpcy5iID0gYjtcblx0XHR0aGlzLmMgPSBjO1xuXHRcdHRoaXMubm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHR9XG5cblx0dmFyIFRFWFRVUkVfVFlQRSA9IHtcblx0XHRJTlRFTlNJVFk6IDEsXG5cdFx0SU5URU5TSVRZX0FMUEhBOiAyLFxuXHRcdFJHQjogMyxcblx0XHRSR0JBOiA0XG5cdH07XG5cblx0cmV0dXJuIFZSTUxMb2FkZXI7XG5cbn0gKSgpO1xuXG52YXIgUENETG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHR0aGlzLmxpdHRsZUVuZGlhbiA9IHRydWU7XG5cbn07XG5cblxuUENETG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFBDRExvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKCBzY29wZS5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggc2NvcGUud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0XHR0cnkge1xuXG5cdFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIGRhdGEsIHVybCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGRhdGEsIHVybCApIHtcblxuXHRcdC8vIGZyb20gaHR0cHM6Ly9naXRsYWIuY29tL3Rha2V0d28vdGhyZWUtcGNkLWxvYWRlci9ibG9iL21hc3Rlci9kZWNvbXByZXNzLWx6Zi5qc1xuXG5cdFx0ZnVuY3Rpb24gZGVjb21wcmVzc0xaRiggaW5EYXRhLCBvdXRMZW5ndGggKSB7XG5cblx0XHRcdHZhciBpbkxlbmd0aCA9IGluRGF0YS5sZW5ndGg7XG5cdFx0XHR2YXIgb3V0RGF0YSA9IG5ldyBVaW50OEFycmF5KCBvdXRMZW5ndGggKTtcblx0XHRcdHZhciBpblB0ciA9IDA7XG5cdFx0XHR2YXIgb3V0UHRyID0gMDtcblx0XHRcdHZhciBjdHJsO1xuXHRcdFx0dmFyIGxlbjtcblx0XHRcdHZhciByZWY7XG5cdFx0XHRkbyB7XG5cblx0XHRcdFx0Y3RybCA9IGluRGF0YVsgaW5QdHIgKysgXTtcblx0XHRcdFx0aWYgKCBjdHJsIDwgKCAxIDw8IDUgKSApIHtcblxuXHRcdFx0XHRcdGN0cmwgKys7XG5cdFx0XHRcdFx0aWYgKCBvdXRQdHIgKyBjdHJsID4gb3V0TGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKCAnT3V0cHV0IGJ1ZmZlciBpcyBub3QgbGFyZ2UgZW5vdWdoJyApO1xuXHRcdFx0XHRcdGlmICggaW5QdHIgKyBjdHJsID4gaW5MZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXByZXNzZWQgZGF0YScgKTtcblx0XHRcdFx0XHRkbyB7XG5cblx0XHRcdFx0XHRcdG91dERhdGFbIG91dFB0ciArKyBdID0gaW5EYXRhWyBpblB0ciArKyBdO1xuXG5cdFx0XHRcdFx0fSB3aGlsZSAoIC0tIGN0cmwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bGVuID0gY3RybCA+PiA1O1xuXHRcdFx0XHRcdHJlZiA9IG91dFB0ciAtICggKCBjdHJsICYgMHgxZiApIDw8IDggKSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBpblB0ciA+PSBpbkxlbmd0aCApIHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcHJlc3NlZCBkYXRhJyApO1xuXHRcdFx0XHRcdGlmICggbGVuID09PSA3ICkge1xuXG5cdFx0XHRcdFx0XHRsZW4gKz0gaW5EYXRhWyBpblB0ciArKyBdO1xuXHRcdFx0XHRcdFx0aWYgKCBpblB0ciA+PSBpbkxlbmd0aCApIHRocm93IG5ldyBFcnJvciggJ0ludmFsaWQgY29tcHJlc3NlZCBkYXRhJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVmIC09IGluRGF0YVsgaW5QdHIgKysgXTtcblx0XHRcdFx0XHRpZiAoIG91dFB0ciArIGxlbiArIDIgPiBvdXRMZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoICdPdXRwdXQgYnVmZmVyIGlzIG5vdCBsYXJnZSBlbm91Z2gnICk7XG5cdFx0XHRcdFx0aWYgKCByZWYgPCAwICkgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wcmVzc2VkIGRhdGEnICk7XG5cdFx0XHRcdFx0aWYgKCByZWYgPj0gb3V0UHRyICkgdGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wcmVzc2VkIGRhdGEnICk7XG5cdFx0XHRcdFx0ZG8ge1xuXG5cdFx0XHRcdFx0XHRvdXREYXRhWyBvdXRQdHIgKysgXSA9IG91dERhdGFbIHJlZiArKyBdO1xuXG5cdFx0XHRcdFx0fSB3aGlsZSAoIC0tIGxlbiArIDIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gd2hpbGUgKCBpblB0ciA8IGluTGVuZ3RoICk7XG5cblx0XHRcdHJldHVybiBvdXREYXRhO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VIZWFkZXIoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBQQ0RoZWFkZXIgPSB7fTtcblx0XHRcdHZhciByZXN1bHQxID0gZGF0YS5zZWFyY2goIC9bXFxyXFxuXURBVEFcXHMoXFxTKilcXHMvaSApO1xuXHRcdFx0dmFyIHJlc3VsdDIgPSAvW1xcclxcbl1EQVRBXFxzKFxcUyopXFxzL2kuZXhlYyggZGF0YS5zdWJzdHIoIHJlc3VsdDEgLSAxICkgKTtcblxuXHRcdFx0UENEaGVhZGVyLmRhdGEgPSByZXN1bHQyWyAxIF07XG5cdFx0XHRQQ0RoZWFkZXIuaGVhZGVyTGVuID0gcmVzdWx0MlsgMCBdLmxlbmd0aCArIHJlc3VsdDE7XG5cdFx0XHRQQ0RoZWFkZXIuc3RyID0gZGF0YS5zdWJzdHIoIDAsIFBDRGhlYWRlci5oZWFkZXJMZW4gKTtcblxuXHRcdFx0Ly8gcmVtb3ZlIGNvbW1lbnRzXG5cblx0XHRcdFBDRGhlYWRlci5zdHIgPSBQQ0RoZWFkZXIuc3RyLnJlcGxhY2UoIC9cXCMuKi9naSwgJycgKTtcblxuXHRcdFx0Ly8gcGFyc2VcblxuXHRcdFx0UENEaGVhZGVyLnZlcnNpb24gPSAvVkVSU0lPTiAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLmZpZWxkcyA9IC9GSUVMRFMgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci5zaXplID0gL1NJWkUgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci50eXBlID0gL1RZUEUgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci5jb3VudCA9IC9DT1VOVCAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLndpZHRoID0gL1dJRFRIICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cdFx0XHRQQ0RoZWFkZXIuaGVpZ2h0ID0gL0hFSUdIVCAoLiopL2kuZXhlYyggUENEaGVhZGVyLnN0ciApO1xuXHRcdFx0UENEaGVhZGVyLnZpZXdwb2ludCA9IC9WSUVXUE9JTlQgKC4qKS9pLmV4ZWMoIFBDRGhlYWRlci5zdHIgKTtcblx0XHRcdFBDRGhlYWRlci5wb2ludHMgPSAvUE9JTlRTICguKikvaS5leGVjKCBQQ0RoZWFkZXIuc3RyICk7XG5cblx0XHRcdC8vIGV2YWx1YXRlXG5cblx0XHRcdGlmICggUENEaGVhZGVyLnZlcnNpb24gIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIudmVyc2lvbiA9IHBhcnNlRmxvYXQoIFBDRGhlYWRlci52ZXJzaW9uWyAxIF0gKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIuZmllbGRzICE9PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLmZpZWxkcyA9IFBDRGhlYWRlci5maWVsZHNbIDEgXS5zcGxpdCggJyAnICk7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLnR5cGUgIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIudHlwZSA9IFBDRGhlYWRlci50eXBlWyAxIF0uc3BsaXQoICcgJyApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci53aWR0aCAhPT0gbnVsbCApXG5cdFx0XHRcdFBDRGhlYWRlci53aWR0aCA9IHBhcnNlSW50KCBQQ0RoZWFkZXIud2lkdGhbIDEgXSApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5oZWlnaHQgIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIuaGVpZ2h0ID0gcGFyc2VJbnQoIFBDRGhlYWRlci5oZWlnaHRbIDEgXSApO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci52aWV3cG9pbnQgIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIudmlld3BvaW50ID0gUENEaGVhZGVyLnZpZXdwb2ludFsgMSBdO1xuXG5cdFx0XHRpZiAoIFBDRGhlYWRlci5wb2ludHMgIT09IG51bGwgKVxuXHRcdFx0XHRQQ0RoZWFkZXIucG9pbnRzID0gcGFyc2VJbnQoIFBDRGhlYWRlci5wb2ludHNbIDEgXSwgMTAgKTtcblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIucG9pbnRzID09PSBudWxsIClcblx0XHRcdFx0UENEaGVhZGVyLnBvaW50cyA9IFBDRGhlYWRlci53aWR0aCAqIFBDRGhlYWRlci5oZWlnaHQ7XG5cblx0XHRcdGlmICggUENEaGVhZGVyLnNpemUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0UENEaGVhZGVyLnNpemUgPSBQQ0RoZWFkZXIuc2l6ZVsgMSBdLnNwbGl0KCAnICcgKS5tYXAoIGZ1bmN0aW9uICggeCApIHtcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggeCwgMTAgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBQQ0RoZWFkZXIuY291bnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0UENEaGVhZGVyLmNvdW50ID0gUENEaGVhZGVyLmNvdW50WyAxIF0uc3BsaXQoICcgJyApLm1hcCggZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB4LCAxMCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRQQ0RoZWFkZXIuY291bnQgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBQQ0RoZWFkZXIuZmllbGRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRQQ0RoZWFkZXIuY291bnQucHVzaCggMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRQQ0RoZWFkZXIub2Zmc2V0ID0ge307XG5cblx0XHRcdHZhciBzaXplU3VtID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gUENEaGVhZGVyLmZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggUENEaGVhZGVyLmRhdGEgPT09ICdhc2NpaScgKSB7XG5cblx0XHRcdFx0XHRQQ0RoZWFkZXIub2Zmc2V0WyBQQ0RoZWFkZXIuZmllbGRzWyBpIF0gXSA9IGk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFBDRGhlYWRlci5vZmZzZXRbIFBDRGhlYWRlci5maWVsZHNbIGkgXSBdID0gc2l6ZVN1bTtcblx0XHRcdFx0XHRzaXplU3VtICs9IFBDRGhlYWRlci5zaXplWyBpIF0gKiBQQ0RoZWFkZXIuY291bnRbIGkgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZm9yIGJpbmFyeSBvbmx5XG5cblx0XHRcdFBDRGhlYWRlci5yb3dTaXplID0gc2l6ZVN1bTtcblxuXHRcdFx0cmV0dXJuIFBDRGhlYWRlcjtcblxuXHRcdH1cblxuXHRcdHZhciB0ZXh0RGF0YSA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhICkgKTtcblxuXHRcdC8vIHBhcnNlIGhlYWRlciAoYWx3YXlzIGFzY2lpIGZvcm1hdClcblxuXHRcdHZhciBQQ0RoZWFkZXIgPSBwYXJzZUhlYWRlciggdGV4dERhdGEgKTtcblxuXHRcdC8vIHBhcnNlIGRhdGFcblxuXHRcdHZhciBwb3NpdGlvbiA9IFtdO1xuXHRcdHZhciBub3JtYWwgPSBbXTtcblx0XHR2YXIgY29sb3IgPSBbXTtcblxuXHRcdC8vIGFzY2lpXG5cblx0XHRpZiAoIFBDRGhlYWRlci5kYXRhID09PSAnYXNjaWknICkge1xuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gUENEaGVhZGVyLm9mZnNldDtcblx0XHRcdHZhciBwY2REYXRhID0gdGV4dERhdGEuc3Vic3RyKCBQQ0RoZWFkZXIuaGVhZGVyTGVuICk7XG5cdFx0XHR2YXIgbGluZXMgPSBwY2REYXRhLnNwbGl0KCAnXFxuJyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggbGluZXNbIGkgXSA9PT0gJycgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF0uc3BsaXQoICcgJyApO1xuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC54IF0gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC55IF0gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC56IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5yZ2IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciByZ2IgPSBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQucmdiIF0gKTtcblx0XHRcdFx0XHR2YXIgciA9ICggcmdiID4+IDE2ICkgJiAweDAwMDBmZjtcblx0XHRcdFx0XHR2YXIgZyA9ICggcmdiID4+IDggKSAmIDB4MDAwMGZmO1xuXHRcdFx0XHRcdHZhciBiID0gKCByZ2IgPj4gMCApICYgMHgwMDAwZmY7XG5cdFx0XHRcdFx0Y29sb3IucHVzaCggciAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9mZnNldC5ub3JtYWxfeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIHBhcnNlRmxvYXQoIGxpbmVbIG9mZnNldC5ub3JtYWxfeCBdICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggcGFyc2VGbG9hdCggbGluZVsgb2Zmc2V0Lm5vcm1hbF95IF0gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBwYXJzZUZsb2F0KCBsaW5lWyBvZmZzZXQubm9ybWFsX3ogXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBiaW5hcnktY29tcHJlc3NlZFxuXG5cdFx0Ly8gbm9ybWFsbHkgZGF0YSBpbiBQQ0QgZmlsZXMgYXJlIG9yZ2FuaXplZCBhcyBhcnJheSBvZiBzdHJ1Y3R1cmVzOiBYWVpSR0JYWVpSR0Jcblx0XHQvLyBiaW5hcnkgY29tcHJlc3NlZCBQQ0QgZmlsZXMgb3JnYW5pemUgdGhlaXIgZGF0YSBhcyBzdHJ1Y3R1cmUgb2YgYXJyYXlzOiBYWFlZWlpSR0JSR0Jcblx0XHQvLyB0aGF0IHJlcXVpcmVzIGEgdG90YWxseSBkaWZmZXJlbnQgcGFyc2luZyBhcHByb2FjaCBjb21wYXJlZCB0byBub24tY29tcHJlc3NlZCBkYXRhXG5cblx0XHRpZiAoIFBDRGhlYWRlci5kYXRhID09PSAnYmluYXJ5X2NvbXByZXNzZWQnICkge1xuXG5cdFx0XHR2YXIgc2l6ZXMgPSBuZXcgVWludDMyQXJyYXkoIGRhdGEuc2xpY2UoIFBDRGhlYWRlci5oZWFkZXJMZW4sIFBDRGhlYWRlci5oZWFkZXJMZW4gKyA4ICkgKTtcblx0XHRcdHZhciBjb21wcmVzc2VkU2l6ZSA9IHNpemVzWyAwIF07XG5cdFx0XHR2YXIgZGVjb21wcmVzc2VkU2l6ZSA9IHNpemVzWyAxIF07XG5cdFx0XHR2YXIgZGVjb21wcmVzc2VkID0gZGVjb21wcmVzc0xaRiggbmV3IFVpbnQ4QXJyYXkoIGRhdGEsIFBDRGhlYWRlci5oZWFkZXJMZW4gKyA4LCBjb21wcmVzc2VkU2l6ZSApLCBkZWNvbXByZXNzZWRTaXplICk7XG5cdFx0XHR2YXIgZGF0YXZpZXcgPSBuZXcgRGF0YVZpZXcoIGRlY29tcHJlc3NlZC5idWZmZXIgKTtcblxuXHRcdFx0dmFyIG9mZnNldCA9IFBDRGhlYWRlci5vZmZzZXQ7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IFBDRGhlYWRlci5wb2ludHM7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnggKSArIFBDRGhlYWRlci5zaXplWyAwIF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnkgKSArIFBDRGhlYWRlci5zaXplWyAxIF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnogKSArIFBDRGhlYWRlci5zaXplWyAyIF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0LnJnYiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5yZ2IgKSArIFBDRGhlYWRlci5zaXplWyAzIF0gKiBpICsgMCApIC8gMjU1LjAgKTtcblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0LnJnYiApICsgUENEaGVhZGVyLnNpemVbIDMgXSAqIGkgKyAxICkgLyAyNTUuMCApO1xuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQucmdiICkgKyBQQ0RoZWFkZXIuc2l6ZVsgMyBdICogaSArIDIgKSAvIDI1NS4wICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0Lm5vcm1hbF94ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggKCBQQ0RoZWFkZXIucG9pbnRzICogb2Zmc2V0Lm5vcm1hbF94ICkgKyBQQ0RoZWFkZXIuc2l6ZVsgNCBdICogaSwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCAoIFBDRGhlYWRlci5wb2ludHMgKiBvZmZzZXQubm9ybWFsX3kgKSArIFBDRGhlYWRlci5zaXplWyA1IF0gKiBpLCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoICggUENEaGVhZGVyLnBvaW50cyAqIG9mZnNldC5ub3JtYWxfeiApICsgUENEaGVhZGVyLnNpemVbIDYgXSAqIGksIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJpbmFyeVxuXG5cdFx0aWYgKCBQQ0RoZWFkZXIuZGF0YSA9PT0gJ2JpbmFyeScgKSB7XG5cblx0XHRcdHZhciBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyggZGF0YSwgUENEaGVhZGVyLmhlYWRlckxlbiApO1xuXHRcdFx0dmFyIG9mZnNldCA9IFBDRGhlYWRlci5vZmZzZXQ7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgcm93ID0gMDsgaSA8IFBDRGhlYWRlci5wb2ludHM7IGkgKyssIHJvdyArPSBQQ0RoZWFkZXIucm93U2l6ZSApIHtcblxuXHRcdFx0XHRpZiAoIG9mZnNldC54ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRwb3NpdGlvbi5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQueCwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXHRcdFx0XHRcdHBvc2l0aW9uLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC55LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0cG9zaXRpb24ucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0LnosIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQucmdiICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb2xvci5wdXNoKCBkYXRhdmlldy5nZXRVaW50OCggcm93ICsgb2Zmc2V0LnJnYiArIDIgKSAvIDI1NS4wICk7XG5cdFx0XHRcdFx0Y29sb3IucHVzaCggZGF0YXZpZXcuZ2V0VWludDgoIHJvdyArIG9mZnNldC5yZ2IgKyAxICkgLyAyNTUuMCApO1xuXHRcdFx0XHRcdGNvbG9yLnB1c2goIGRhdGF2aWV3LmdldFVpbnQ4KCByb3cgKyBvZmZzZXQucmdiICsgMCApIC8gMjU1LjAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBvZmZzZXQubm9ybWFsX3ggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vcm1hbC5wdXNoKCBkYXRhdmlldy5nZXRGbG9hdDMyKCByb3cgKyBvZmZzZXQubm9ybWFsX3gsIHRoaXMubGl0dGxlRW5kaWFuICkgKTtcblx0XHRcdFx0XHRub3JtYWwucHVzaCggZGF0YXZpZXcuZ2V0RmxvYXQzMiggcm93ICsgb2Zmc2V0Lm5vcm1hbF95LCB0aGlzLmxpdHRsZUVuZGlhbiApICk7XG5cdFx0XHRcdFx0bm9ybWFsLnB1c2goIGRhdGF2aWV3LmdldEZsb2F0MzIoIHJvdyArIG9mZnNldC5ub3JtYWxfeiwgdGhpcy5saXR0bGVFbmRpYW4gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0aWYgKCBwb3NpdGlvbi5sZW5ndGggPiAwICkgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIDMgKSApO1xuXHRcdGlmICggbm9ybWFsLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCAzICkgKTtcblx0XHRpZiAoIGNvbG9yLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvciwgMyApICk7XG5cblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdC8vIGJ1aWxkIG1hdGVyaWFsXG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgc2l6ZTogMC4wMDUgfSApO1xuXG5cdFx0aWYgKCBjb2xvci5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIHBvaW50IGNsb3VkXG5cblx0XHR2YXIgbWVzaCA9IG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdHZhciBuYW1lID0gdXJsLnNwbGl0KCAnJyApLnJldmVyc2UoKS5qb2luKCAnJyApO1xuXHRcdG5hbWUgPSAvKFteXFwvXSopLy5leGVjKCBuYW1lICk7XG5cdFx0bmFtZSA9IG5hbWVbIDEgXS5zcGxpdCggJycgKS5yZXZlcnNlKCkuam9pbiggJycgKTtcblx0XHRtZXNoLm5hbWUgPSBuYW1lO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cblx0fVxuXG59ICk7XG5cbi8qKlxuICogRGVzY3JpcHRpb246IEEgVEhSRUUgbG9hZGVyIGZvciBQTFkgQVNDSUkgZmlsZXMgKGtub3duIGFzIHRoZSBQb2x5Z29uXG4gKiBGaWxlIEZvcm1hdCBvciB0aGUgU3RhbmZvcmQgVHJpYW5nbGUgRm9ybWF0KS5cbiAqXG4gKiBMaW1pdGF0aW9uczogQVNDSUkgZGVjb2RpbmcgYXNzdW1lcyBmaWxlIGlzIFVURi04LlxuICpcbiAqIFVzYWdlOlxuICpcdHZhciBsb2FkZXIgPSBuZXcgUExZTG9hZGVyKCk7XG4gKlx0bG9hZGVyLmxvYWQoJy4vbW9kZWxzL3BseS9hc2NpaS9kb2xwaGlucy5wbHknLCBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAqXG4gKlx0XHRzY2VuZS5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSApICk7XG4gKlxuICpcdH0gKTtcbiAqXG4gKiBJZiB0aGUgUExZIGZpbGUgdXNlcyBub24gc3RhbmRhcmQgcHJvcGVydHkgbmFtZXMsIHRoZXkgY2FuIGJlIG1hcHBlZCB3aGlsZVxuICogbG9hZGluZy4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgbWFwcyB0aGUgcHJvcGVydGllc1xuICog4oCcZGlmZnVzZV8ocmVkfGdyZWVufGJsdWUp4oCdIGluIHRoZSBmaWxlIHRvIHN0YW5kYXJkIGNvbG9yIG5hbWVzLlxuICpcbiAqIGxvYWRlci5zZXRQcm9wZXJ0eU5hbWVNYXBwaW5nKCB7XG4gKlx0ZGlmZnVzZV9yZWQ6ICdyZWQnLFxuICpcdGRpZmZ1c2VfZ3JlZW46ICdncmVlbicsXG4gKlx0ZGlmZnVzZV9ibHVlOiAnYmx1ZSdcbiAqIH0gKTtcbiAqXG4gKi9cblxuXG52YXIgUExZTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdExvYWRlciQxLmNhbGwoIHRoaXMsIG1hbmFnZXIgKTtcblxuXHR0aGlzLnByb3BlcnR5TmFtZU1hcHBpbmcgPSB7fTtcblxufTtcblxuUExZTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFBMWUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblx0XHRsb2FkZXIuc2V0UmVxdWVzdEhlYWRlciggdGhpcy5yZXF1ZXN0SGVhZGVyICk7XG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldFByb3BlcnR5TmFtZU1hcHBpbmc6IGZ1bmN0aW9uICggbWFwcGluZyApIHtcblxuXHRcdHRoaXMucHJvcGVydHlOYW1lTWFwcGluZyA9IG1hcHBpbmc7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBkYXRhICkge1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VIZWFkZXIoIGRhdGEgKSB7XG5cblx0XHRcdHZhciBwYXR0ZXJuSGVhZGVyID0gL3BseShbXFxzXFxTXSopZW5kX2hlYWRlclxccj9cXG4vO1xuXHRcdFx0dmFyIGhlYWRlclRleHQgPSAnJztcblx0XHRcdHZhciBoZWFkZXJMZW5ndGggPSAwO1xuXHRcdFx0dmFyIHJlc3VsdCA9IHBhdHRlcm5IZWFkZXIuZXhlYyggZGF0YSApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRoZWFkZXJUZXh0ID0gcmVzdWx0WyAxIF07XG5cdFx0XHRcdGhlYWRlckxlbmd0aCA9IG5ldyBCbG9iKCBbIHJlc3VsdFsgMCBdIF0gKS5zaXplO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBoZWFkZXIgPSB7XG5cdFx0XHRcdGNvbW1lbnRzOiBbXSxcblx0XHRcdFx0ZWxlbWVudHM6IFtdLFxuXHRcdFx0XHRoZWFkZXJMZW5ndGg6IGhlYWRlckxlbmd0aCxcblx0XHRcdFx0b2JqSW5mbzogJydcblx0XHRcdH07XG5cblx0XHRcdHZhciBsaW5lcyA9IGhlYWRlclRleHQuc3BsaXQoICdcXG4nICk7XG5cdFx0XHR2YXIgY3VycmVudEVsZW1lbnQ7XG5cdFx0XHR2YXIgbGluZVR5cGUsIGxpbmVWYWx1ZXM7XG5cblx0XHRcdGZ1bmN0aW9uIG1ha2VfcGx5X2VsZW1lbnRfcHJvcGVydHkoIHByb3BlcnRWYWx1ZXMsIHByb3BlcnR5TmFtZU1hcHBpbmcgKSB7XG5cblx0XHRcdFx0dmFyIHByb3BlcnR5ID0geyB0eXBlOiBwcm9wZXJ0VmFsdWVzWyAwIF0gfTtcblxuXHRcdFx0XHRpZiAoIHByb3BlcnR5LnR5cGUgPT09ICdsaXN0JyApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5Lm5hbWUgPSBwcm9wZXJ0VmFsdWVzWyAzIF07XG5cdFx0XHRcdFx0cHJvcGVydHkuY291bnRUeXBlID0gcHJvcGVydFZhbHVlc1sgMSBdO1xuXHRcdFx0XHRcdHByb3BlcnR5Lml0ZW1UeXBlID0gcHJvcGVydFZhbHVlc1sgMiBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwcm9wZXJ0eS5uYW1lID0gcHJvcGVydFZhbHVlc1sgMSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHByb3BlcnR5Lm5hbWUgaW4gcHJvcGVydHlOYW1lTWFwcGluZyApIHtcblxuXHRcdFx0XHRcdHByb3BlcnR5Lm5hbWUgPSBwcm9wZXJ0eU5hbWVNYXBwaW5nWyBwcm9wZXJ0eS5uYW1lIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGxpbmUgPSBsaW5lc1sgaSBdO1xuXHRcdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cblx0XHRcdFx0aWYgKCBsaW5lID09PSAnJyApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGxpbmVWYWx1ZXMgPSBsaW5lLnNwbGl0KCAvXFxzKy8gKTtcblx0XHRcdFx0bGluZVR5cGUgPSBsaW5lVmFsdWVzLnNoaWZ0KCk7XG5cdFx0XHRcdGxpbmUgPSBsaW5lVmFsdWVzLmpvaW4oICcgJyApO1xuXG5cdFx0XHRcdHN3aXRjaCAoIGxpbmVUeXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnZm9ybWF0JzpcblxuXHRcdFx0XHRcdFx0aGVhZGVyLmZvcm1hdCA9IGxpbmVWYWx1ZXNbIDAgXTtcblx0XHRcdFx0XHRcdGhlYWRlci52ZXJzaW9uID0gbGluZVZhbHVlc1sgMSBdO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2NvbW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRoZWFkZXIuY29tbWVudHMucHVzaCggbGluZSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2VsZW1lbnQnOlxuXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnRFbGVtZW50ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0aGVhZGVyLmVsZW1lbnRzLnB1c2goIGN1cnJlbnRFbGVtZW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSB7fTtcblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50Lm5hbWUgPSBsaW5lVmFsdWVzWyAwIF07XG5cdFx0XHRcdFx0XHRjdXJyZW50RWxlbWVudC5jb3VudCA9IHBhcnNlSW50KCBsaW5lVmFsdWVzWyAxIF0gKTtcblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50LnByb3BlcnRpZXMgPSBbXTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwcm9wZXJ0eSc6XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50LnByb3BlcnRpZXMucHVzaCggbWFrZV9wbHlfZWxlbWVudF9wcm9wZXJ0eSggbGluZVZhbHVlcywgc2NvcGUucHJvcGVydHlOYW1lTWFwcGluZyApICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnb2JqX2luZm8nOlxuXG5cdFx0XHRcdFx0XHRoZWFkZXIub2JqSW5mbyA9IGxpbmU7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ3VuaGFuZGxlZCcsIGxpbmVUeXBlLCBsaW5lVmFsdWVzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VycmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRoZWFkZXIuZWxlbWVudHMucHVzaCggY3VycmVudEVsZW1lbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGVhZGVyO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSU51bWJlciggbiwgdHlwZSApIHtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdjaGFyJzogY2FzZSAndWNoYXInOiBjYXNlICdzaG9ydCc6IGNhc2UgJ3VzaG9ydCc6IGNhc2UgJ2ludCc6IGNhc2UgJ3VpbnQnOlxuXHRcdFx0XHRjYXNlICdpbnQ4JzogY2FzZSAndWludDgnOiBjYXNlICdpbnQxNic6IGNhc2UgJ3VpbnQxNic6IGNhc2UgJ2ludDMyJzogY2FzZSAndWludDMyJzpcblxuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggbiApO1xuXG5cdFx0XHRcdGNhc2UgJ2Zsb2F0JzogY2FzZSAnZG91YmxlJzogY2FzZSAnZmxvYXQzMic6IGNhc2UgJ2Zsb2F0NjQnOlxuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQoIG4gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBU0NJSUVsZW1lbnQoIHByb3BlcnRpZXMsIGxpbmUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBsaW5lLnNwbGl0KCAvXFxzKy8gKTtcblxuXHRcdFx0dmFyIGVsZW1lbnQgPSB7fTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzWyBpIF0udHlwZSA9PT0gJ2xpc3QnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdFx0XHR2YXIgbiA9IHBhcnNlQVNDSUlOdW1iZXIoIHZhbHVlcy5zaGlmdCgpLCBwcm9wZXJ0aWVzWyBpIF0uY291bnRUeXBlICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBuOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRsaXN0LnB1c2goIHBhcnNlQVNDSUlOdW1iZXIoIHZhbHVlcy5zaGlmdCgpLCBwcm9wZXJ0aWVzWyBpIF0uaXRlbVR5cGUgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbWVudFsgcHJvcGVydGllc1sgaSBdLm5hbWUgXSA9IGxpc3Q7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGVsZW1lbnRbIHByb3BlcnRpZXNbIGkgXS5uYW1lIF0gPSBwYXJzZUFTQ0lJTnVtYmVyKCB2YWx1ZXMuc2hpZnQoKSwgcHJvcGVydGllc1sgaSBdLnR5cGUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUFTQ0lJKCBkYXRhLCBoZWFkZXIgKSB7XG5cblx0XHRcdC8vIFBMWSBhc2NpaSBmb3JtYXQgc3BlY2lmaWNhdGlvbiwgYXMgcGVyIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUExZXyhmaWxlX2Zvcm1hdClcblxuXHRcdFx0dmFyIGJ1ZmZlciA9IHtcblx0XHRcdFx0aW5kaWNlczogW10sXG5cdFx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdFx0bm9ybWFsczogW10sXG5cdFx0XHRcdHV2czogW10sXG5cdFx0XHRcdGZhY2VWZXJ0ZXhVdnM6IFtdLFxuXHRcdFx0XHRjb2xvcnM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHR2YXIgcGF0dGVybkJvZHkgPSAvZW5kX2hlYWRlclxccyhbXFxzXFxTXSopJC87XG5cdFx0XHR2YXIgYm9keSA9ICcnO1xuXHRcdFx0aWYgKCAoIHJlc3VsdCA9IHBhdHRlcm5Cb2R5LmV4ZWMoIGRhdGEgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGJvZHkgPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGluZXMgPSBib2R5LnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0dmFyIGN1cnJlbnRFbGVtZW50ID0gMDtcblx0XHRcdHZhciBjdXJyZW50RWxlbWVudENvdW50ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXTtcblx0XHRcdFx0bGluZSA9IGxpbmUudHJpbSgpO1xuXHRcdFx0XHRpZiAoIGxpbmUgPT09ICcnICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3VycmVudEVsZW1lbnRDb3VudCA+PSBoZWFkZXIuZWxlbWVudHNbIGN1cnJlbnRFbGVtZW50IF0uY291bnQgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50RWxlbWVudCArKztcblx0XHRcdFx0XHRjdXJyZW50RWxlbWVudENvdW50ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBwYXJzZUFTQ0lJRWxlbWVudCggaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLnByb3BlcnRpZXMsIGxpbmUgKTtcblxuXHRcdFx0XHRoYW5kbGVFbGVtZW50KCBidWZmZXIsIGhlYWRlci5lbGVtZW50c1sgY3VycmVudEVsZW1lbnQgXS5uYW1lLCBlbGVtZW50ICk7XG5cblx0XHRcdFx0Y3VycmVudEVsZW1lbnRDb3VudCArKztcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcG9zdFByb2Nlc3MoIGJ1ZmZlciApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcG9zdFByb2Nlc3MoIGJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdC8vIG1hbmRhdG9yeSBidWZmZXIgZGF0YVxuXG5cdFx0XHRpZiAoIGJ1ZmZlci5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIGJ1ZmZlci5pbmRpY2VzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLnZlcnRpY2VzLCAzICkgKTtcblxuXHRcdFx0Ly8gb3B0aW9uYWwgYnVmZmVyIGRhdGFcblxuXHRcdFx0aWYgKCBidWZmZXIubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXIubm9ybWFscywgMyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWZmZXIudXZzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLnV2cywgMiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWZmZXIuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyLmNvbG9ycywgMyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWZmZXIuZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5ID0gZ2VvbWV0cnkudG9Ob25JbmRleGVkKCk7XG5cdFx0XHRcdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlci5mYWNlVmVydGV4VXZzLCAyICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlRWxlbWVudCggYnVmZmVyLCBlbGVtZW50TmFtZSwgZWxlbWVudCApIHtcblxuXHRcdFx0aWYgKCBlbGVtZW50TmFtZSA9PT0gJ3ZlcnRleCcgKSB7XG5cblx0XHRcdFx0YnVmZmVyLnZlcnRpY2VzLnB1c2goIGVsZW1lbnQueCwgZWxlbWVudC55LCBlbGVtZW50LnogKTtcblxuXHRcdFx0XHRpZiAoICdueCcgaW4gZWxlbWVudCAmJiAnbnknIGluIGVsZW1lbnQgJiYgJ256JyBpbiBlbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLm5vcm1hbHMucHVzaCggZWxlbWVudC5ueCwgZWxlbWVudC5ueSwgZWxlbWVudC5ueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICdzJyBpbiBlbGVtZW50ICYmICd0JyBpbiBlbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLnV2cy5wdXNoKCBlbGVtZW50LnMsIGVsZW1lbnQudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICdyZWQnIGluIGVsZW1lbnQgJiYgJ2dyZWVuJyBpbiBlbGVtZW50ICYmICdibHVlJyBpbiBlbGVtZW50ICkge1xuXG5cdFx0XHRcdFx0YnVmZmVyLmNvbG9ycy5wdXNoKCBlbGVtZW50LnJlZCAvIDI1NS4wLCBlbGVtZW50LmdyZWVuIC8gMjU1LjAsIGVsZW1lbnQuYmx1ZSAvIDI1NS4wICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50TmFtZSA9PT0gJ2ZhY2UnICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaW5kaWNlcyA9IGVsZW1lbnQudmVydGV4X2luZGljZXMgfHwgZWxlbWVudC52ZXJ0ZXhfaW5kZXg7IC8vIGlzc3VlICM5MzM4XG5cdFx0XHRcdHZhciB0ZXhjb29yZCA9IGVsZW1lbnQudGV4Y29vcmQ7XG5cblx0XHRcdFx0aWYgKCB2ZXJ0ZXhfaW5kaWNlcy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdFx0XHRidWZmZXIuaW5kaWNlcy5wdXNoKCB2ZXJ0ZXhfaW5kaWNlc1sgMCBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMSBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIHRleGNvb3JkICYmIHRleGNvb3JkLmxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdFx0YnVmZmVyLmZhY2VWZXJ0ZXhVdnMucHVzaCggdGV4Y29vcmRbIDAgXSwgdGV4Y29vcmRbIDEgXSApO1xuXHRcdFx0XHRcdFx0YnVmZmVyLmZhY2VWZXJ0ZXhVdnMucHVzaCggdGV4Y29vcmRbIDIgXSwgdGV4Y29vcmRbIDMgXSApO1xuXHRcdFx0XHRcdFx0YnVmZmVyLmZhY2VWZXJ0ZXhVdnMucHVzaCggdGV4Y29vcmRbIDQgXSwgdGV4Y29vcmRbIDUgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHZlcnRleF9pbmRpY2VzLmxlbmd0aCA9PT0gNCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlci5pbmRpY2VzLnB1c2goIHZlcnRleF9pbmRpY2VzWyAwIF0sIHZlcnRleF9pbmRpY2VzWyAxIF0sIHZlcnRleF9pbmRpY2VzWyAzIF0gKTtcblx0XHRcdFx0XHRidWZmZXIuaW5kaWNlcy5wdXNoKCB2ZXJ0ZXhfaW5kaWNlc1sgMSBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMiBdLCB2ZXJ0ZXhfaW5kaWNlc1sgMyBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBiaW5hcnlSZWFkKCBkYXRhdmlldywgYXQsIHR5cGUsIGxpdHRsZV9lbmRpYW4gKSB7XG5cblx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0Ly8gY29yZXNwb25kZW5jZXMgZm9yIG5vbi1zcGVjaWZpYyBsZW5ndGggdHlwZXMgaGVyZSBtYXRjaCBycGx5OlxuXHRcdFx0XHRjYXNlICdpbnQ4JzpcdFx0Y2FzZSAnY2hhcic6XHQgcmV0dXJuIFsgZGF0YXZpZXcuZ2V0SW50OCggYXQgKSwgMSBdO1xuXHRcdFx0XHRjYXNlICd1aW50OCc6XHRcdGNhc2UgJ3VjaGFyJzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRVaW50OCggYXQgKSwgMSBdO1xuXHRcdFx0XHRjYXNlICdpbnQxNic6XHRcdGNhc2UgJ3Nob3J0JzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRJbnQxNiggYXQsIGxpdHRsZV9lbmRpYW4gKSwgMiBdO1xuXHRcdFx0XHRjYXNlICd1aW50MTYnOlx0Y2FzZSAndXNob3J0JzogcmV0dXJuIFsgZGF0YXZpZXcuZ2V0VWludDE2KCBhdCwgbGl0dGxlX2VuZGlhbiApLCAyIF07XG5cdFx0XHRcdGNhc2UgJ2ludDMyJzpcdFx0Y2FzZSAnaW50JzpcdFx0IHJldHVybiBbIGRhdGF2aWV3LmdldEludDMyKCBhdCwgbGl0dGxlX2VuZGlhbiApLCA0IF07XG5cdFx0XHRcdGNhc2UgJ3VpbnQzMic6XHRjYXNlICd1aW50JzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRVaW50MzIoIGF0LCBsaXR0bGVfZW5kaWFuICksIDQgXTtcblx0XHRcdFx0Y2FzZSAnZmxvYXQzMic6IGNhc2UgJ2Zsb2F0JzpcdCByZXR1cm4gWyBkYXRhdmlldy5nZXRGbG9hdDMyKCBhdCwgbGl0dGxlX2VuZGlhbiApLCA0IF07XG5cdFx0XHRcdGNhc2UgJ2Zsb2F0NjQnOiBjYXNlICdkb3VibGUnOiByZXR1cm4gWyBkYXRhdmlldy5nZXRGbG9hdDY0KCBhdCwgbGl0dGxlX2VuZGlhbiApLCA4IF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGJpbmFyeVJlYWRFbGVtZW50KCBkYXRhdmlldywgYXQsIHByb3BlcnRpZXMsIGxpdHRsZV9lbmRpYW4gKSB7XG5cblx0XHRcdHZhciBlbGVtZW50ID0ge307XG5cdFx0XHR2YXIgcmVzdWx0LCByZWFkID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzWyBpIF0udHlwZSA9PT0gJ2xpc3QnICkge1xuXG5cdFx0XHRcdFx0dmFyIGxpc3QgPSBbXTtcblxuXHRcdFx0XHRcdHJlc3VsdCA9IGJpbmFyeVJlYWQoIGRhdGF2aWV3LCBhdCArIHJlYWQsIHByb3BlcnRpZXNbIGkgXS5jb3VudFR5cGUsIGxpdHRsZV9lbmRpYW4gKTtcblx0XHRcdFx0XHR2YXIgbiA9IHJlc3VsdFsgMCBdO1xuXHRcdFx0XHRcdHJlYWQgKz0gcmVzdWx0WyAxIF07XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBuOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSBiaW5hcnlSZWFkKCBkYXRhdmlldywgYXQgKyByZWFkLCBwcm9wZXJ0aWVzWyBpIF0uaXRlbVR5cGUsIGxpdHRsZV9lbmRpYW4gKTtcblx0XHRcdFx0XHRcdGxpc3QucHVzaCggcmVzdWx0WyAwIF0gKTtcblx0XHRcdFx0XHRcdHJlYWQgKz0gcmVzdWx0WyAxIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtZW50WyBwcm9wZXJ0aWVzWyBpIF0ubmFtZSBdID0gbGlzdDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmVzdWx0ID0gYmluYXJ5UmVhZCggZGF0YXZpZXcsIGF0ICsgcmVhZCwgcHJvcGVydGllc1sgaSBdLnR5cGUsIGxpdHRsZV9lbmRpYW4gKTtcblx0XHRcdFx0XHRlbGVtZW50WyBwcm9wZXJ0aWVzWyBpIF0ubmFtZSBdID0gcmVzdWx0WyAwIF07XG5cdFx0XHRcdFx0cmVhZCArPSByZXN1bHRbIDEgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFsgZWxlbWVudCwgcmVhZCBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VCaW5hcnkoIGRhdGEsIGhlYWRlciApIHtcblxuXHRcdFx0dmFyIGJ1ZmZlciA9IHtcblx0XHRcdFx0aW5kaWNlczogW10sXG5cdFx0XHRcdHZlcnRpY2VzOiBbXSxcblx0XHRcdFx0bm9ybWFsczogW10sXG5cdFx0XHRcdHV2czogW10sXG5cdFx0XHRcdGZhY2VWZXJ0ZXhVdnM6IFtdLFxuXHRcdFx0XHRjb2xvcnM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbGl0dGxlX2VuZGlhbiA9ICggaGVhZGVyLmZvcm1hdCA9PT0gJ2JpbmFyeV9saXR0bGVfZW5kaWFuJyApO1xuXHRcdFx0dmFyIGJvZHkgPSBuZXcgRGF0YVZpZXcoIGRhdGEsIGhlYWRlci5oZWFkZXJMZW5ndGggKTtcblx0XHRcdHZhciByZXN1bHQsIGxvYyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBjdXJyZW50RWxlbWVudCA9IDA7IGN1cnJlbnRFbGVtZW50IDwgaGVhZGVyLmVsZW1lbnRzLmxlbmd0aDsgY3VycmVudEVsZW1lbnQgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGN1cnJlbnRFbGVtZW50Q291bnQgPSAwOyBjdXJyZW50RWxlbWVudENvdW50IDwgaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLmNvdW50OyBjdXJyZW50RWxlbWVudENvdW50ICsrICkge1xuXG5cdFx0XHRcdFx0cmVzdWx0ID0gYmluYXJ5UmVhZEVsZW1lbnQoIGJvZHksIGxvYywgaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLnByb3BlcnRpZXMsIGxpdHRsZV9lbmRpYW4gKTtcblx0XHRcdFx0XHRsb2MgKz0gcmVzdWx0WyAxIF07XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSByZXN1bHRbIDAgXTtcblxuXHRcdFx0XHRcdGhhbmRsZUVsZW1lbnQoIGJ1ZmZlciwgaGVhZGVyLmVsZW1lbnRzWyBjdXJyZW50RWxlbWVudCBdLm5hbWUsIGVsZW1lbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHBvc3RQcm9jZXNzKCBidWZmZXIgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgZ2VvbWV0cnk7XG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdGlmICggZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHR2YXIgdGV4dCA9IExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBkYXRhICkgKTtcblx0XHRcdHZhciBoZWFkZXIgPSBwYXJzZUhlYWRlciggdGV4dCApO1xuXG5cdFx0XHRnZW9tZXRyeSA9IGhlYWRlci5mb3JtYXQgPT09ICdhc2NpaScgPyBwYXJzZUFTQ0lJKCB0ZXh0LCBoZWFkZXIgKSA6IHBhcnNlQmluYXJ5KCBkYXRhLCBoZWFkZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdlb21ldHJ5ID0gcGFyc2VBU0NJSSggZGF0YSwgcGFyc2VIZWFkZXIoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdH1cblxufSApO1xuXG4vKiFcbmZmbGF0ZSAtIGZhc3QgSmF2YVNjcmlwdCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uXG48aHR0cHM6Ly8xMDFhcnJvd3ouZ2l0aHViLmlvL2ZmbGF0ZT5cbkxpY2Vuc2VkIHVuZGVyIE1JVC4gaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbnZhciBnbj17fSxibj1mdW5jdGlvbihuLHIsdCxlLGkpe3ZhciBhPWduW3JdfHwoZ25bcl09VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbbl0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKSksbz1uZXcgV29ya2VyKGEpO3JldHVybiBvLm9uZXJyb3I9ZnVuY3Rpb24oZil7cmV0dXJuIGkoZi5lcnJvcixudWxsKX0sby5vbm1lc3NhZ2U9ZnVuY3Rpb24oZil7cmV0dXJuIGkobnVsbCxmLmRhdGEpfSxvLnBvc3RNZXNzYWdlKHQsZSksb30sQT1VaW50OEFycmF5LFI9VWludDE2QXJyYXksbnI9VWludDMyQXJyYXksdXI9bmV3IEEoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0pLGxyPW5ldyBBKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLE1yPW5ldyBBKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksd249ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9bmV3IFIoMzEpLGU9MDtlPDMxOysrZSl0W2VdPXIrPTE8PG5bZS0xXTtmb3IodmFyIGk9bmV3IG5yKHRbMzBdKSxlPTE7ZTwzMDsrK2UpZm9yKHZhciBhPXRbZV07YTx0W2UrMV07KythKWlbYV09YS10W2VdPDw1fGU7cmV0dXJuIFt0LGldfSx5bj13bih1ciwyKSxOcj15blswXSxJcj15blsxXTtOclsyOF09MjU4LElyWzI1OF09Mjg7Zm9yKHZhciBtbj13bihsciwwKSx6bj1tblswXSxRcj1tblsxXSxVcj1uZXcgUigzMjc2OCksVD0wO1Q8MzI3Njg7KytUKXt2YXIgaXI9KFQmNDM2OTApPj4+MXwoVCYyMTg0NSk8PDE7aXI9KGlyJjUyNDI4KT4+PjJ8KGlyJjEzMTA3KTw8Mixpcj0oaXImNjE2ODApPj4+NHwoaXImMzg1NSk8PDQsVXJbVF09KChpciY2NTI4MCk+Pj44fChpciYyNTUpPDw4KT4+PjE7fWZvcih2YXIgVj1mdW5jdGlvbihuLHIsdCl7Zm9yKHZhciBlPW4ubGVuZ3RoLGk9MCxhPW5ldyBSKHIpO2k8ZTsrK2kpKythW25baV0tMV07dmFyIG89bmV3IFIocik7Zm9yKGk9MDtpPHI7KytpKW9baV09b1tpLTFdK2FbaS0xXTw8MTt2YXIgZjtpZih0KXtmPW5ldyBSKDE8PHIpO3ZhciBoPTE1LXI7Zm9yKGk9MDtpPGU7KytpKWlmKG5baV0pZm9yKHZhciBzPWk8PDR8bltpXSx1PXItbltpXSxsPW9bbltpXS0xXSsrPDx1LHA9bHwoMTw8dSktMTtsPD1wOysrbClmW1VyW2xdPj4+aF09czt9ZWxzZSBmb3IoZj1uZXcgUihlKSxpPTA7aTxlOysraSluW2ldJiYoZltpXT1VcltvW25baV0tMV0rK10+Pj4xNS1uW2ldKTtyZXR1cm4gZn0sdHI9bmV3IEEoMjg4KSxUPTA7VDwxNDQ7KytUKXRyW1RdPTg7Zm9yKHZhciBUPTE0NDtUPDI1NjsrK1QpdHJbVF09OTtmb3IodmFyIFQ9MjU2O1Q8MjgwOysrVCl0cltUXT03O2Zvcih2YXIgVD0yODA7VDwyODg7KytUKXRyW1RdPTg7Zm9yKHZhciB2cj1uZXcgQSgzMiksVD0wO1Q8MzI7KytUKXZyW1RdPTU7dmFyIHhuPVYodHIsOSwwKSxBbj1WKHRyLDksMSksRG49Vih2ciw1LDApLE1uPVYodnIsNSwxKSxHcj1mdW5jdGlvbihuKXtmb3IodmFyIHI9blswXSx0PTE7dDxuLmxlbmd0aDsrK3Qpblt0XT5yJiYocj1uW3RdKTtyZXR1cm4gcn0sWD1mdW5jdGlvbihuLHIsdCl7dmFyIGU9ci84fDA7cmV0dXJuIChuW2VdfG5bZSsxXTw8OCk+PihyJjcpJnR9LE9yPWZ1bmN0aW9uKG4scil7dmFyIHQ9ci84fDA7cmV0dXJuIChuW3RdfG5bdCsxXTw8OHxuW3QrMl08PDE2KT4+KHImNyl9LENyPWZ1bmN0aW9uKG4pe3JldHVybiAobi84fDApKyhuJjcmJjEpfSwkPWZ1bmN0aW9uKG4scix0KXsocj09bnVsbHx8cjwwKSYmKHI9MCksKHQ9PW51bGx8fHQ+bi5sZW5ndGgpJiYodD1uLmxlbmd0aCk7dmFyIGU9bmV3KG4gaW5zdGFuY2VvZiBSP1I6biBpbnN0YW5jZW9mIG5yP25yOkEpKHQtcik7cmV0dXJuIGUuc2V0KG4uc3ViYXJyYXkocix0KSksZX0sRnI9ZnVuY3Rpb24obixyLHQpe3ZhciBlPW4ubGVuZ3RoO2lmKCFlfHx0JiYhdC5sJiZlPDUpcmV0dXJuIHJ8fG5ldyBBKDApO3ZhciBpPSFyfHx0LGE9IXR8fHQuaTt0fHwodD17fSkscnx8KHI9bmV3IEEoZSozKSk7dmFyIG89ZnVuY3Rpb24oVHIpe3ZhciBEcj1yLmxlbmd0aDtpZihUcj5Ecil7dmFyIGhyPW5ldyBBKE1hdGgubWF4KERyKjIsVHIpKTtoci5zZXQocikscj1ocjt9fSxmPXQuZnx8MCxoPXQucHx8MCxzPXQuYnx8MCx1PXQubCxsPXQuZCxwPXQubSx5PXQubixjPWUqODtkb3tpZighdSl7dC5mPWY9WChuLGgsMSk7dmFyIGc9WChuLGgrMSwzKTtpZihoKz0zLGcpaWYoZz09MSl1PUFuLGw9TW4scD05LHk9NTtlbHNlIGlmKGc9PTIpe3ZhciBtPVgobixoLDMxKSsyNTcsRD1YKG4saCsxMCwxNSkrNCxDPW0rWChuLGgrNSwzMSkrMTtoKz0xNDtmb3IodmFyIFU9bmV3IEEoQykseD1uZXcgQSgxOSksdj0wO3Y8RDsrK3YpeFtNclt2XV09WChuLGgrdiozLDcpO2grPUQqMzt2YXIgRT1Hcih4KSxTPSgxPDxFKS0xO2lmKCFhJiZoK0MqKEUrNyk+YylicmVhaztmb3IodmFyIEs9Vih4LEUsMSksdj0wO3Y8Qzspe3ZhciBJPUtbWChuLGgsUyldO2grPUkmMTU7dmFyIHc9ST4+PjQ7aWYodzwxNilVW3YrK109dztlbHNlIHt2YXIgWj0wLEI9MDtmb3Iodz09MTY/KEI9MytYKG4saCwzKSxoKz0yLFo9VVt2LTFdKTp3PT0xNz8oQj0zK1gobixoLDcpLGgrPTMpOnc9PTE4JiYoQj0xMStYKG4saCwxMjcpLGgrPTcpO0ItLTspVVt2KytdPVo7fX12YXIgRz1VLnN1YmFycmF5KDAsbSksaz1VLnN1YmFycmF5KG0pO3A9R3IoRykseT1HcihrKSx1PVYoRyxwLDEpLGw9VihrLHksMSk7fWVsc2UgdGhyb3cgXCJpbnZhbGlkIGJsb2NrIHR5cGVcIjtlbHNlIHt2YXIgdz1DcihoKSs0LE09blt3LTRdfG5bdy0zXTw8OCx6PXcrTTtpZih6PmUpe2lmKGEpdGhyb3cgXCJ1bmV4cGVjdGVkIEVPRlwiO2JyZWFrfWkmJm8ocytNKSxyLnNldChuLnN1YmFycmF5KHcseikscyksdC5iPXMrPU0sdC5wPWg9eio4O2NvbnRpbnVlfWlmKGg+Yyl0aHJvdyBcInVuZXhwZWN0ZWQgRU9GXCJ9aSYmbyhzKzEzMTA3Mik7Zm9yKHZhciBPPSgxPDxwKS0xLEg9KDE8PHkpLTEsTj1wK3krMTg7YXx8aCtOPGM7KXt2YXIgWj11W09yKG4saCkmT10sUT1aPj4+NDtpZihoKz1aJjE1LGg+Yyl0aHJvdyBcInVuZXhwZWN0ZWQgRU9GXCI7aWYoIVopdGhyb3cgXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCI7aWYoUTwyNTYpcltzKytdPVE7ZWxzZSBpZihRPT0yNTYpe3U9bnVsbDticmVha31lbHNlIHt2YXIgVz1RLTI1NDtpZihRPjI2NCl7dmFyIHY9US0yNTcsZD11clt2XTtXPVgobixoLCgxPDxkKS0xKStOclt2XSxoKz1kO312YXIgXz1sW09yKG4saCkmSF0saj1fPj4+NDtpZighXyl0aHJvdyBcImludmFsaWQgZGlzdGFuY2VcIjtoKz1fJjE1O3ZhciBrPXpuW2pdO2lmKGo+Myl7dmFyIGQ9bHJbal07ays9T3IobixoKSYoMTw8ZCktMSxoKz1kO31pZihoPmMpdGhyb3cgXCJ1bmV4cGVjdGVkIEVPRlwiO2kmJm8ocysxMzEwNzIpO2Zvcih2YXIgcT1zK1c7czxxO3MrPTQpcltzXT1yW3Mta10scltzKzFdPXJbcysxLWtdLHJbcysyXT1yW3MrMi1rXSxyW3MrM109cltzKzMta107cz1xO319dC5sPXUsdC5wPWgsdC5iPXMsdSYmKGY9MSx0Lm09cCx0LmQ9bCx0Lm49eSk7fXdoaWxlKCFmKTtyZXR1cm4gcz09ci5sZW5ndGg/cjokKHIsMCxzKX0sYj1mdW5jdGlvbihuLHIsdCl7dDw8PXImNzt2YXIgZT1yLzh8MDtuW2VdfD10LG5bZSsxXXw9dD4+Pjg7fSxjcj1mdW5jdGlvbihuLHIsdCl7dDw8PXImNzt2YXIgZT1yLzh8MDtuW2VdfD10LG5bZSsxXXw9dD4+PjgsbltlKzJdfD10Pj4+MTY7fSxFcj1mdW5jdGlvbihuLHIpe2Zvcih2YXIgdD1bXSxlPTA7ZTxuLmxlbmd0aDsrK2UpbltlXSYmdC5wdXNoKHtzOmUsZjpuW2VdfSk7dmFyIGk9dC5sZW5ndGgsYT10LnNsaWNlKCk7aWYoIWkpcmV0dXJuIFtlciwwXTtpZihpPT0xKXt2YXIgbz1uZXcgQSh0WzBdLnMrMSk7cmV0dXJuIG9bdFswXS5zXT0xLFtvLDFdfXQuc29ydChmdW5jdGlvbihDLFUpe3JldHVybiBDLmYtVS5mfSksdC5wdXNoKHtzOi0xLGY6MjUwMDF9KTt2YXIgZj10WzBdLGg9dFsxXSxzPTAsdT0xLGw9Mjtmb3IodFswXT17czotMSxmOmYuZitoLmYsbDpmLHI6aH07dSE9aS0xOylmPXRbdFtzXS5mPHRbbF0uZj9zKys6bCsrXSxoPXRbcyE9dSYmdFtzXS5mPHRbbF0uZj9zKys6bCsrXSx0W3UrK109e3M6LTEsZjpmLmYraC5mLGw6ZixyOmh9O2Zvcih2YXIgcD1hWzBdLnMsZT0xO2U8aTsrK2UpYVtlXS5zPnAmJihwPWFbZV0ucyk7dmFyIHk9bmV3IFIocCsxKSxjPVByKHRbdS0xXSx5LDApO2lmKGM+cil7dmFyIGU9MCxnPTAsdz1jLXIsTT0xPDx3O2ZvcihhLnNvcnQoZnVuY3Rpb24oVSx4KXtyZXR1cm4geVt4LnNdLXlbVS5zXXx8VS5mLXguZn0pO2U8aTsrK2Upe3ZhciB6PWFbZV0ucztpZih5W3pdPnIpZys9TS0oMTw8Yy15W3pdKSx5W3pdPXI7ZWxzZSBicmVha31mb3IoZz4+Pj13O2c+MDspe3ZhciBtPWFbZV0uczt5W21dPHI/Zy09MTw8ci15W21dKystMTorK2U7fWZvcig7ZT49MCYmZzstLWUpe3ZhciBEPWFbZV0uczt5W0RdPT1yJiYoLS15W0RdLCsrZyk7fWM9cjt9cmV0dXJuIFtuZXcgQSh5KSxjXX0sUHI9ZnVuY3Rpb24obixyLHQpe3JldHVybiBuLnM9PS0xP01hdGgubWF4KFByKG4ubCxyLHQrMSksUHIobi5yLHIsdCsxKSk6cltuLnNdPXR9LFZyPWZ1bmN0aW9uKG4pe2Zvcih2YXIgcj1uLmxlbmd0aDtyJiYhblstLXJdOyk7Zm9yKHZhciB0PW5ldyBSKCsrciksZT0wLGk9blswXSxhPTEsbz1mdW5jdGlvbihoKXt0W2UrK109aDt9LGY9MTtmPD1yOysrZilpZihuW2ZdPT1pJiZmIT1yKSsrYTtlbHNlIHtpZighaSYmYT4yKXtmb3IoO2E+MTM4O2EtPTEzOClvKDMyNzU0KTthPjImJihvKGE+MTA/YS0xMTw8NXwyODY5MDphLTM8PDV8MTIzMDUpLGE9MCk7fWVsc2UgaWYoYT4zKXtmb3IobyhpKSwtLWE7YT42O2EtPTYpbyg4MzA0KTthPjImJihvKGEtMzw8NXw4MjA4KSxhPTApO31mb3IoO2EtLTspbyhpKTthPTEsaT1uW2ZdO31yZXR1cm4gW3Quc3ViYXJyYXkoMCxlKSxyXX0scHI9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9MCxlPTA7ZTxyLmxlbmd0aDsrK2UpdCs9bltlXSpyW2VdO3JldHVybiB0fSxTcj1mdW5jdGlvbihuLHIsdCl7dmFyIGU9dC5sZW5ndGgsaT1DcihyKzIpO25baV09ZSYyNTUsbltpKzFdPWU+Pj44LG5baSsyXT1uW2ldXjI1NSxuW2krM109bltpKzFdXjI1NTtmb3IodmFyIGE9MDthPGU7KythKW5baSthKzRdPXRbYV07cmV0dXJuIChpKzQrZSkqOH0sWHI9ZnVuY3Rpb24obixyLHQsZSxpLGEsbyxmLGgscyx1KXtiKHIsdSsrLHQpLCsraVsyNTZdO2Zvcih2YXIgbD1FcihpLDE1KSxwPWxbMF0seT1sWzFdLGM9RXIoYSwxNSksZz1jWzBdLHc9Y1sxXSxNPVZyKHApLHo9TVswXSxtPU1bMV0sRD1WcihnKSxDPURbMF0sVT1EWzFdLHg9bmV3IFIoMTkpLHY9MDt2PHoubGVuZ3RoOysrdil4W3pbdl0mMzFdKys7Zm9yKHZhciB2PTA7djxDLmxlbmd0aDsrK3YpeFtDW3ZdJjMxXSsrO2Zvcih2YXIgRT1Fcih4LDcpLFM9RVswXSxLPUVbMV0sST0xOTtJPjQmJiFTW01yW0ktMV1dOy0tSSk7dmFyIFo9cys1PDwzLEI9cHIoaSx0cikrcHIoYSx2cikrbyxHPXByKGkscCkrcHIoYSxnKStvKzE0KzMqSStwcih4LFMpKygyKnhbMTZdKzMqeFsxN10rNyp4WzE4XSk7aWYoWjw9QiYmWjw9RylyZXR1cm4gU3Iocix1LG4uc3ViYXJyYXkoaCxoK3MpKTt2YXIgayxPLEgsTjtpZihiKHIsdSwxKyhHPEIpKSx1Kz0yLEc8Qil7az1WKHAseSwwKSxPPXAsSD1WKGcsdywwKSxOPWc7dmFyIFE9VihTLEssMCk7YihyLHUsbS0yNTcpLGIocix1KzUsVS0xKSxiKHIsdSsxMCxJLTQpLHUrPTE0O2Zvcih2YXIgdj0wO3Y8STsrK3YpYihyLHUrMyp2LFNbTXJbdl1dKTt1Kz0zKkk7Zm9yKHZhciBXPVt6LENdLGQ9MDtkPDI7KytkKWZvcih2YXIgXz1XW2RdLHY9MDt2PF8ubGVuZ3RoOysrdil7dmFyIGo9X1t2XSYzMTtiKHIsdSxRW2pdKSx1Kz1TW2pdLGo+MTUmJihiKHIsdSxfW3ZdPj4+NSYxMjcpLHUrPV9bdl0+Pj4xMik7fX1lbHNlIGs9eG4sTz10cixIPURuLE49dnI7Zm9yKHZhciB2PTA7djxmOysrdilpZihlW3ZdPjI1NSl7dmFyIGo9ZVt2XT4+PjE4JjMxO2NyKHIsdSxrW2orMjU3XSksdSs9T1tqKzI1N10saj43JiYoYihyLHUsZVt2XT4+PjIzJjMxKSx1Kz11cltqXSk7dmFyIHE9ZVt2XSYzMTtjcihyLHUsSFtxXSksdSs9TltxXSxxPjMmJihjcihyLHUsZVt2XT4+PjUmODE5MSksdSs9bHJbcV0pO31lbHNlIGNyKHIsdSxrW2Vbdl1dKSx1Kz1PW2Vbdl1dO3JldHVybiBjcihyLHUsa1syNTZdKSx1K09bMjU2XX0sVW49bmV3IG5yKFs2NTU0MCwxMzEwODAsMTMxMDg4LDEzMTEwNCwyNjIxNzYsMTA0ODcwNCwxMDQ4ODMyLDIxMTQ1NjAsMjExNzYzMl0pLGVyPW5ldyBBKDApLENuPWZ1bmN0aW9uKG4scix0LGUsaSxhKXt2YXIgbz1uLmxlbmd0aCxmPW5ldyBBKGUrbys1KigxK01hdGguY2VpbChvLzdlMykpK2kpLGg9Zi5zdWJhcnJheShlLGYubGVuZ3RoLWkpLHM9MDtpZighcnx8bzw4KWZvcih2YXIgdT0wO3U8PW87dSs9NjU1MzUpe3ZhciBsPXUrNjU1MzU7bDxvP3M9U3IoaCxzLG4uc3ViYXJyYXkodSxsKSk6KGhbdV09YSxzPVNyKGgscyxuLnN1YmFycmF5KHUsbykpKTt9ZWxzZSB7Zm9yKHZhciBwPVVuW3ItMV0seT1wPj4+MTMsYz1wJjgxOTEsZz0oMTw8dCktMSx3PW5ldyBSKDMyNzY4KSxNPW5ldyBSKGcrMSksej1NYXRoLmNlaWwodC8zKSxtPTIqeixEPWZ1bmN0aW9uKEtyKXtyZXR1cm4gKG5bS3JdXm5bS3IrMV08PHpebltLcisyXTw8bSkmZ30sQz1uZXcgbnIoMjVlMyksVT1uZXcgUigyODgpLHg9bmV3IFIoMzIpLHY9MCxFPTAsdT0wLFM9MCxLPTAsST0wO3U8bzsrK3Upe3ZhciBaPUQodSksQj11JjMyNzY3LEc9TVtaXTtpZih3W0JdPUcsTVtaXT1CLEs8PXUpe3ZhciBrPW8tdTtpZigodj43ZTN8fFM+MjQ1NzYpJiZrPjQyMyl7cz1YcihuLGgsMCxDLFUseCxFLFMsSSx1LUkscyksUz12PUU9MCxJPXU7Zm9yKHZhciBPPTA7TzwyODY7KytPKVVbT109MDtmb3IodmFyIE89MDtPPDMwOysrTyl4W09dPTA7fXZhciBIPTIsTj0wLFE9YyxXPUItRyYzMjc2NztpZihrPjImJlo9PUQodS1XKSlmb3IodmFyIGQ9TWF0aC5taW4oeSxrKS0xLF89TWF0aC5taW4oMzI3NjcsdSksaj1NYXRoLm1pbigyNTgsayk7Vzw9XyYmLS1RJiZCIT1HOyl7aWYoblt1K0hdPT1uW3UrSC1XXSl7Zm9yKHZhciBxPTA7cTxqJiZuW3UrcV09PW5bdStxLVddOysrcSk7aWYocT5IKXtpZihIPXEsTj1XLHE+ZClicmVhaztmb3IodmFyIFRyPU1hdGgubWluKFcscS0yKSxEcj0wLE89MDtPPFRyOysrTyl7dmFyIGhyPXUtVytPKzMyNzY4JjMyNzY3LF9uPXdbaHJdLHZuPWhyLV9uKzMyNzY4JjMyNzY3O3ZuPkRyJiYoRHI9dm4sRz1ocik7fX19Qj1HLEc9d1tCXSxXKz1CLUcrMzI3NjgmMzI3Njc7fWlmKE4pe0NbUysrXT0yNjg0MzU0NTZ8SXJbSF08PDE4fFFyW05dO3ZhciBjbj1JcltIXSYzMSxwbj1RcltOXSYzMTtFKz11cltjbl0rbHJbcG5dLCsrVVsyNTcrY25dLCsreFtwbl0sSz11K0gsKyt2O31lbHNlIENbUysrXT1uW3VdLCsrVVtuW3VdXTt9fXM9WHIobixoLGEsQyxVLHgsRSxTLEksdS1JLHMpLCFhJiZzJjcmJihzPVNyKGgscysxLGVyKSk7fXJldHVybiAkKGYsMCxlK0NyKHMpK2kpfSxGbj1mdW5jdGlvbigpe2Zvcih2YXIgbj1uZXcgbnIoMjU2KSxyPTA7cjwyNTY7KytyKXtmb3IodmFyIHQ9cixlPTk7LS1lOyl0PSh0JjEmJjM5ODgyOTIzODQpXnQ+Pj4xO25bcl09dDt9cmV0dXJuIG59KCksZ3I9ZnVuY3Rpb24oKXt2YXIgbj0tMTtyZXR1cm4ge3A6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PW4sZT0wO2U8ci5sZW5ndGg7KytlKXQ9Rm5bdCYyNTVecltlXV1edD4+Pjg7bj10O30sZDpmdW5jdGlvbigpe3JldHVybiB+bn19fSwkcj1mdW5jdGlvbigpe3ZhciBuPTEscj0wO3JldHVybiB7cDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bixpPXIsYT10Lmxlbmd0aCxvPTA7byE9YTspe2Zvcih2YXIgZj1NYXRoLm1pbihvKzI2NTUsYSk7bzxmOysrbylpKz1lKz10W29dO2U9KGUmNjU1MzUpKzE1KihlPj4xNiksaT0oaSY2NTUzNSkrMTUqKGk+PjE2KTt9bj1lLHI9aTt9LGQ6ZnVuY3Rpb24oKXtyZXR1cm4gbiU9NjU1MjEsciU9NjU1MjEsKG4+Pj44PDwxNnwociYyNTUpPDw4fHI+Pj44KSsoKG4mMjU1KTw8MjMpKjJ9fX0sc3I9ZnVuY3Rpb24obixyLHQsZSxpKXtyZXR1cm4gQ24obixyLmxldmVsPT1udWxsPzY6ci5sZXZlbCxyLm1lbT09bnVsbD9NYXRoLmNlaWwoTWF0aC5tYXgoOCxNYXRoLm1pbigxMyxNYXRoLmxvZyhuLmxlbmd0aCkpKSoxLjUpOjEyK3IubWVtLHQsZSwhaSl9LFpyPWZ1bmN0aW9uKG4scil7dmFyIHQ9e307Zm9yKHZhciBlIGluIG4pdFtlXT1uW2VdO2Zvcih2YXIgZSBpbiByKXRbZV09cltlXTtyZXR1cm4gdH0sU249ZnVuY3Rpb24obixyLHQpe2Zvcih2YXIgZT1uKCksaT1uLnRvU3RyaW5nKCksYT1pLnNsaWNlKGkuaW5kZXhPZihcIltcIikrMSxpLmxhc3RJbmRleE9mKFwiXVwiKSkucmVwbGFjZSgvIC9nLFwiXCIpLnNwbGl0KFwiLFwiKSxvPTA7bzxlLmxlbmd0aDsrK28pe3ZhciBmPWVbb10saD1hW29dO2lmKHR5cGVvZiBmPT1cImZ1bmN0aW9uXCIpe3IrPVwiO1wiK2grXCI9XCI7dmFyIHM9Zi50b1N0cmluZygpO2lmKGYucHJvdG90eXBlKWlmKHMuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikhPS0xKXt2YXIgdT1zLmluZGV4T2YoXCIgXCIsOCkrMTtyKz1zLnNsaWNlKHUscy5pbmRleE9mKFwiKFwiLHUpKTt9ZWxzZSB7cis9cztmb3IodmFyIGwgaW4gZi5wcm90b3R5cGUpcis9XCI7XCIraCtcIi5wcm90b3R5cGUuXCIrbCtcIj1cIitmLnByb3RvdHlwZVtsXS50b1N0cmluZygpO31lbHNlIHIrPXM7fWVsc2UgdFtoXT1mO31yZXR1cm4gW3IsdF19LFJyPVtdLHJ0PWZ1bmN0aW9uKG4pe3ZhciByPVtdO2Zvcih2YXIgdCBpbiBuKShuW3RdaW5zdGFuY2VvZiBBfHxuW3RdaW5zdGFuY2VvZiBSfHxuW3RdaW5zdGFuY2VvZiBucikmJnIucHVzaCgoblt0XT1uZXcgblt0XS5jb25zdHJ1Y3RvcihuW3RdKSkuYnVmZmVyKTtyZXR1cm4gcn0sWm49ZnVuY3Rpb24obixyLHQsZSl7dmFyIGk7aWYoIVJyW3RdKXtmb3IodmFyIGE9XCJcIixvPXt9LGY9bi5sZW5ndGgtMSxoPTA7aDxmOysraClpPVNuKG5baF0sYSxvKSxhPWlbMF0sbz1pWzFdO1JyW3RdPVNuKG5bZl0sYSxvKTt9dmFyIHM9WnIoe30sUnJbdF1bMV0pO3JldHVybiBibihSclt0XVswXStcIjtvbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7Zm9yKHZhciBrIGluIGUuZGF0YSlzZWxmW2tdPWUuZGF0YVtrXTtvbm1lc3NhZ2U9XCIrci50b1N0cmluZygpK1wifVwiLHQscyxydChzKSxlKX0sd3I9ZnVuY3Rpb24oKXtyZXR1cm4gW0EsUixucix1cixscixNcixOcix6bixBbixNbixVcixWLEdyLFgsT3IsQ3IsJCxGcix4cixhcixMcl19LHlyPWZ1bmN0aW9uKCl7cmV0dXJuIFtBLFIsbnIsdXIsbHIsTXIsSXIsUXIseG4sdHIsRG4sdnIsVXIsVW4sZXIsVixiLGNyLEVyLFByLFZyLHByLFNyLFhyLENyLCQsQ24sc3Isa3IsYXJdfSxrbj1mdW5jdGlvbigpe3JldHVybiBbX3Iscm4sRixncixGbl19LEJuPWZ1bmN0aW9uKCl7cmV0dXJuIFticixHbl19LFRuPWZ1bmN0aW9uKCl7cmV0dXJuIFtubixGLCRyXX0sSW49ZnVuY3Rpb24oKXtyZXR1cm4gW09uXX0sYXI9ZnVuY3Rpb24obil7cmV0dXJuIHBvc3RNZXNzYWdlKG4sW24uYnVmZmVyXSl9LExyPWZ1bmN0aW9uKG4pe3JldHVybiBuJiZuLnNpemUmJm5ldyBBKG4uc2l6ZSl9LG1yPWZ1bmN0aW9uKG4scix0LGUsaSxhKXt2YXIgbz1abih0LGUsaSxmdW5jdGlvbihmLGgpe28udGVybWluYXRlKCksYShmLGgpO30pO3JldHVybiBvLnBvc3RNZXNzYWdlKFtuLHJdLHIuY29uc3VtZT9bbi5idWZmZXJdOltdKSxmdW5jdGlvbigpe28udGVybWluYXRlKCk7fX0sTD1mdW5jdGlvbihuKXtyZXR1cm4gbi5vbmRhdGE9ZnVuY3Rpb24ocix0KXtyZXR1cm4gcG9zdE1lc3NhZ2UoW3IsdF0sW3IuYnVmZmVyXSl9LGZ1bmN0aW9uKHIpe3JldHVybiBuLnB1c2goci5kYXRhWzBdLHIuZGF0YVsxXSl9fSx6cj1mdW5jdGlvbihuLHIsdCxlLGkpe3ZhciBhLG89Wm4obixlLGksZnVuY3Rpb24oZixoKXtmPyhvLnRlcm1pbmF0ZSgpLHIub25kYXRhLmNhbGwocixmKSk6KGhbMV0mJm8udGVybWluYXRlKCksci5vbmRhdGEuY2FsbChyLGYsaFswXSxoWzFdKSk7fSk7by5wb3N0TWVzc2FnZSh0KSxyLnB1c2g9ZnVuY3Rpb24oZixoKXtpZihhKXRocm93IFwic3RyZWFtIGZpbmlzaGVkXCI7aWYoIXIub25kYXRhKXRocm93IFwibm8gc3RyZWFtIGhhbmRsZXJcIjtvLnBvc3RNZXNzYWdlKFtmLGE9aF0sW2YuYnVmZmVyXSk7fSxyLnRlcm1pbmF0ZT1mdW5jdGlvbigpe28udGVybWluYXRlKCk7fTt9LFk9ZnVuY3Rpb24obixyKXtyZXR1cm4gbltyXXxuW3IrMV08PDh9LFA9ZnVuY3Rpb24obixyKXtyZXR1cm4gKG5bcl18bltyKzFdPDw4fG5bcisyXTw8MTYpKyhuW3IrM108PDIzKSoyfSxkcj1mdW5jdGlvbihuLHIpe3JldHVybiBQKG4scil8UChuLHIpKjQyOTQ5NjcyOTZ9LEY9ZnVuY3Rpb24obixyLHQpe2Zvcig7dDsrK3IpbltyXT10LHQ+Pj49ODt9LF9yPWZ1bmN0aW9uKG4scil7dmFyIHQ9ci5maWxlbmFtZTtpZihuWzBdPTMxLG5bMV09MTM5LG5bMl09OCxuWzhdPXIubGV2ZWw8Mj80OnIubGV2ZWw9PTk/MjowLG5bOV09MyxyLm10aW1lIT0wJiZGKG4sNCxNYXRoLmZsb29yKG5ldyBEYXRlKHIubXRpbWV8fERhdGUubm93KCkpLzFlMykpLHQpe25bM109ODtmb3IodmFyIGU9MDtlPD10Lmxlbmd0aDsrK2UpbltlKzEwXT10LmNoYXJDb2RlQXQoZSk7fX0sYnI9ZnVuY3Rpb24obil7aWYoblswXSE9MzF8fG5bMV0hPTEzOXx8blsyXSE9OCl0aHJvdyBcImludmFsaWQgZ3ppcCBkYXRhXCI7dmFyIHI9blszXSx0PTEwO3ImNCYmKHQrPW5bMTBdfChuWzExXTw8OCkrMik7Zm9yKHZhciBlPShyPj4zJjEpKyhyPj40JjEpO2U+MDtlLT0hblt0KytdKTtyZXR1cm4gdCsociYyKX0sR249ZnVuY3Rpb24obil7dmFyIHI9bi5sZW5ndGg7cmV0dXJuIChuW3ItNF18bltyLTNdPDw4fG5bci0yXTw8MTYpKzIqKG5bci0xXTw8MjMpfSxybj1mdW5jdGlvbihuKXtyZXR1cm4gMTArKG4uZmlsZW5hbWUmJm4uZmlsZW5hbWUubGVuZ3RoKzF8fDApfSxubj1mdW5jdGlvbihuLHIpe3ZhciB0PXIubGV2ZWwsZT10PT0wPzA6dDw2PzE6dD09OT8zOjI7blswXT0xMjAsblsxXT1lPDw2fChlPzMyLTIqZToxKTt9LE9uPWZ1bmN0aW9uKG4pe2lmKChuWzBdJjE1KSE9OHx8blswXT4+PjQ+N3x8KG5bMF08PDh8blsxXSklMzEpdGhyb3cgXCJpbnZhbGlkIHpsaWIgZGF0YVwiO2lmKG5bMV0mMzIpdGhyb3cgXCJpbnZhbGlkIHpsaWIgZGF0YTogcHJlc2V0IGRpY3Rpb25hcmllcyBub3Qgc3VwcG9ydGVkXCJ9O2Z1bmN0aW9uIHRuKG4scil7cmV0dXJuICFyJiZ0eXBlb2Ygbj09XCJmdW5jdGlvblwiJiYocj1uLG49e30pLHRoaXMub25kYXRhPXIsbn12YXIgcnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7IXQmJnR5cGVvZiByPT1cImZ1bmN0aW9uXCImJih0PXIscj17fSksdGhpcy5vbmRhdGE9dCx0aGlzLm89cnx8e307fXJldHVybiBuLnByb3RvdHlwZS5wPWZ1bmN0aW9uKHIsdCl7dGhpcy5vbmRhdGEoc3Iocix0aGlzLm8sMCwwLCF0KSx0KTt9LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZih0aGlzLmQpdGhyb3cgXCJzdHJlYW0gZmluaXNoZWRcIjtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBzdHJlYW0gaGFuZGxlclwiO3RoaXMuZD10LHRoaXMucChyLHR8fCExKTt9LG59KCksRW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7enIoW3lyLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLHJyXX1dLHRoaXMsdG4uY2FsbCh0aGlzLHIsdCksZnVuY3Rpb24oZSl7dmFyIGk9bmV3IHJyKGUuZGF0YSk7b25tZXNzYWdlPUwoaSk7fSw2KTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gUG4obixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbeXJdLGZ1bmN0aW9uKGUpe3JldHVybiBhcihrcihlLmRhdGFbMF0sZS5kYXRhWzFdKSl9LDAsdCl9ZnVuY3Rpb24ga3IobixyKXtyZXR1cm4gc3IobixyfHx7fSwwLDApfXZhciBKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLnM9e30sdGhpcy5wPW5ldyBBKDApLHRoaXMub25kYXRhPXI7fXJldHVybiBuLnByb3RvdHlwZS5lPWZ1bmN0aW9uKHIpe2lmKHRoaXMuZCl0aHJvdyBcInN0cmVhbSBmaW5pc2hlZFwiO2lmKCF0aGlzLm9uZGF0YSl0aHJvdyBcIm5vIHN0cmVhbSBoYW5kbGVyXCI7dmFyIHQ9dGhpcy5wLmxlbmd0aCxlPW5ldyBBKHQrci5sZW5ndGgpO2Uuc2V0KHRoaXMucCksZS5zZXQocix0KSx0aGlzLnA9ZTt9LG4ucHJvdG90eXBlLmM9ZnVuY3Rpb24ocil7dGhpcy5kPXRoaXMucy5pPXJ8fCExO3ZhciB0PXRoaXMucy5iLGU9RnIodGhpcy5wLHRoaXMubyx0aGlzLnMpO3RoaXMub25kYXRhKCQoZSx0LHRoaXMucy5iKSx0aGlzLmQpLHRoaXMubz0kKGUsdGhpcy5zLmItMzI3NjgpLHRoaXMucy5iPXRoaXMuby5sZW5ndGgsdGhpcy5wPSQodGhpcy5wLHRoaXMucy5wLzh8MCksdGhpcy5zLnAmPTc7fSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7dGhpcy5lKHIpLHRoaXMuYyh0KTt9LG59KCksZW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXIsenIoW3dyLGZ1bmN0aW9uKCl7cmV0dXJuIFtMLEpdfV0sdGhpcywwLGZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEo7b25tZXNzYWdlPUwodCk7fSw3KTt9cmV0dXJuIG59KCk7ZnVuY3Rpb24gYW4obixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG1yKG4scixbd3JdLGZ1bmN0aW9uKGUpe3JldHVybiBhcih4cihlLmRhdGFbMF0sTHIoZS5kYXRhWzFdKSkpfSwxLHQpfWZ1bmN0aW9uIHhyKG4scil7cmV0dXJuIEZyKG4scil9dmFyIHFyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3RoaXMuYz1ncigpLHRoaXMubD0wLHRoaXMudj0xLHJyLmNhbGwodGhpcyxyLHQpO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3JyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxyLHQpO30sbi5wcm90b3R5cGUucD1mdW5jdGlvbihyLHQpe3RoaXMuYy5wKHIpLHRoaXMubCs9ci5sZW5ndGg7dmFyIGU9c3Iocix0aGlzLm8sdGhpcy52JiZybih0aGlzLm8pLHQmJjgsIXQpO3RoaXMudiYmKF9yKGUsdGhpcy5vKSx0aGlzLnY9MCksdCYmKEYoZSxlLmxlbmd0aC04LHRoaXMuYy5kKCkpLEYoZSxlLmxlbmd0aC00LHRoaXMubCkpLHRoaXMub25kYXRhKGUsdCk7fSxufSgpLFJuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3pyKFt5cixrbixmdW5jdGlvbigpe3JldHVybiBbTCxycixxcl19XSx0aGlzLHRuLmNhbGwodGhpcyxyLHQpLGZ1bmN0aW9uKGUpe3ZhciBpPW5ldyBxcihlLmRhdGEpO29ubWVzc2FnZT1MKGkpO30sOCk7fXJldHVybiBufSgpO2Z1bmN0aW9uIHFuKG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3lyLGtuLGZ1bmN0aW9uKCl7cmV0dXJuIFtIcl19XSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoSHIoZS5kYXRhWzBdLGUuZGF0YVsxXSkpfSwyLHQpfWZ1bmN0aW9uIEhyKG4scil7cnx8KHI9e30pO3ZhciB0PWdyKCksZT1uLmxlbmd0aDt0LnAobik7dmFyIGk9c3IobixyLHJuKHIpLDgpLGE9aS5sZW5ndGg7cmV0dXJuIF9yKGksciksRihpLGEtOCx0LmQoKSksRihpLGEtNCxlKSxpfXZhciBXcj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy52PTEsSi5jYWxsKHRoaXMscik7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoSi5wcm90b3R5cGUuZS5jYWxsKHRoaXMsciksdGhpcy52KXt2YXIgZT10aGlzLnAubGVuZ3RoPjM/YnIodGhpcy5wKTo0O2lmKGU+PXRoaXMucC5sZW5ndGgmJiF0KXJldHVybjt0aGlzLnA9dGhpcy5wLnN1YmFycmF5KGUpLHRoaXMudj0wO31pZih0KXtpZih0aGlzLnAubGVuZ3RoPDgpdGhyb3cgXCJpbnZhbGlkIGd6aXAgc3RyZWFtXCI7dGhpcy5wPXRoaXMucC5zdWJhcnJheSgwLC04KTt9Si5wcm90b3R5cGUuYy5jYWxsKHRoaXMsdCk7fSxufSgpLEhuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yLHpyKFt3cixCbixmdW5jdGlvbigpe3JldHVybiBbTCxKLFdyXX1dLHRoaXMsMCxmdW5jdGlvbigpe3ZhciB0PW5ldyBXcjtvbm1lc3NhZ2U9TCh0KTt9LDkpO31yZXR1cm4gbn0oKTtmdW5jdGlvbiBXbihuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt3cixCbixmdW5jdGlvbigpe3JldHVybiBbWXJdfV0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKFlyKGUuZGF0YVswXSkpfSwzLHQpfWZ1bmN0aW9uIFlyKG4scil7cmV0dXJuIEZyKG4uc3ViYXJyYXkoYnIobiksLTgpLHJ8fG5ldyBBKEduKG4pKSl9dmFyIG9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3RoaXMuYz0kcigpLHRoaXMudj0xLHJyLmNhbGwodGhpcyxyLHQpO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3JyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxyLHQpO30sbi5wcm90b3R5cGUucD1mdW5jdGlvbihyLHQpe3RoaXMuYy5wKHIpO3ZhciBlPXNyKHIsdGhpcy5vLHRoaXMudiYmMix0JiY0LCF0KTt0aGlzLnYmJihubihlLHRoaXMubyksdGhpcy52PTApLHQmJkYoZSxlLmxlbmd0aC00LHRoaXMuYy5kKCkpLHRoaXMub25kYXRhKGUsdCk7fSxufSgpLG50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyLHQpe3pyKFt5cixUbixmdW5jdGlvbigpe3JldHVybiBbTCxycixvbl19XSx0aGlzLHRuLmNhbGwodGhpcyxyLHQpLGZ1bmN0aW9uKGUpe3ZhciBpPW5ldyBvbihlLmRhdGEpO29ubWVzc2FnZT1MKGkpO30sMTApO31yZXR1cm4gbn0oKTtmdW5jdGlvbiB0dChuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtyZXR1cm4gbXIobixyLFt5cixUbixmdW5jdGlvbigpe3JldHVybiBbZm5dfV0sZnVuY3Rpb24oZSl7cmV0dXJuIGFyKGZuKGUuZGF0YVswXSxlLmRhdGFbMV0pKX0sNCx0KX1mdW5jdGlvbiBmbihuLHIpe3J8fChyPXt9KTt2YXIgdD0kcigpO3QucChuKTt2YXIgZT1zcihuLHIsMiw0KTtyZXR1cm4gbm4oZSxyKSxGKGUsZS5sZW5ndGgtNCx0LmQoKSksZX12YXIganI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMudj0xLEouY2FsbCh0aGlzLHIpO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe2lmKEoucHJvdG90eXBlLmUuY2FsbCh0aGlzLHIpLHRoaXMudil7aWYodGhpcy5wLmxlbmd0aDwyJiYhdClyZXR1cm47dGhpcy5wPXRoaXMucC5zdWJhcnJheSgyKSx0aGlzLnY9MDt9aWYodCl7aWYodGhpcy5wLmxlbmd0aDw0KXRocm93IFwiaW52YWxpZCB6bGliIHN0cmVhbVwiO3RoaXMucD10aGlzLnAuc3ViYXJyYXkoMCwtNCk7fUoucHJvdG90eXBlLmMuY2FsbCh0aGlzLHQpO30sbn0oKSxZbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5vbmRhdGE9cix6cihbd3IsSW4sZnVuY3Rpb24oKXtyZXR1cm4gW0wsSixqcl19XSx0aGlzLDAsZnVuY3Rpb24oKXt2YXIgdD1uZXcganI7b25tZXNzYWdlPUwodCk7fSwxMSk7fXJldHVybiBufSgpO2Z1bmN0aW9uIGpuKG4scix0KXtpZih0fHwodD1yLHI9e30pLHR5cGVvZiB0IT1cImZ1bmN0aW9uXCIpdGhyb3cgXCJubyBjYWxsYmFja1wiO3JldHVybiBtcihuLHIsW3dyLEluLGZ1bmN0aW9uKCl7cmV0dXJuIFtKcl19XSxmdW5jdGlvbihlKXtyZXR1cm4gYXIoSnIoZS5kYXRhWzBdLExyKGUuZGF0YVsxXSkpKX0sNSx0KX1mdW5jdGlvbiBKcihuLHIpe3JldHVybiBGcigoT24obiksbi5zdWJhcnJheSgyLC00KSkscil9dmFyIEpuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLkc9V3IsdGhpcy5JPUosdGhpcy5aPWpyLHRoaXMub25kYXRhPXI7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gc3RyZWFtIGhhbmRsZXJcIjtpZih0aGlzLnMpdGhpcy5zLnB1c2gocix0KTtlbHNlIHtpZih0aGlzLnAmJnRoaXMucC5sZW5ndGgpe3ZhciBlPW5ldyBBKHRoaXMucC5sZW5ndGgrci5sZW5ndGgpO2Uuc2V0KHRoaXMucCksZS5zZXQocix0aGlzLnAubGVuZ3RoKTt9ZWxzZSB0aGlzLnA9cjtpZih0aGlzLnAubGVuZ3RoPjIpe3ZhciBpPXRoaXMsYT1mdW5jdGlvbigpe2kub25kYXRhLmFwcGx5KGksYXJndW1lbnRzKTt9O3RoaXMucz10aGlzLnBbMF09PTMxJiZ0aGlzLnBbMV09PTEzOSYmdGhpcy5wWzJdPT04P25ldyB0aGlzLkcoYSk6KHRoaXMucFswXSYxNSkhPTh8fHRoaXMucFswXT4+ND43fHwodGhpcy5wWzBdPDw4fHRoaXMucFsxXSklMzE/bmV3IHRoaXMuSShhKTpuZXcgdGhpcy5aKGEpLHRoaXMucy5wdXNoKHRoaXMucCx0KSx0aGlzLnA9bnVsbDt9fX0sbn0oKSxldD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocil7dGhpcy5HPUhuLHRoaXMuST1lbix0aGlzLlo9WW4sdGhpcy5vbmRhdGE9cjt9cmV0dXJuIG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtKbi5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMscix0KTt9LG59KCk7ZnVuY3Rpb24gaXQobixyLHQpe2lmKHR8fCh0PXIscj17fSksdHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBcIm5vIGNhbGxiYWNrXCI7cmV0dXJuIG5bMF09PTMxJiZuWzFdPT0xMzkmJm5bMl09PTg/V24obixyLHQpOihuWzBdJjE1KSE9OHx8blswXT4+ND43fHwoblswXTw8OHxuWzFdKSUzMT9hbihuLHIsdCk6am4obixyLHQpfWZ1bmN0aW9uIGF0KG4scil7cmV0dXJuIG5bMF09PTMxJiZuWzFdPT0xMzkmJm5bMl09PTg/WXIobixyKTooblswXSYxNSkhPTh8fG5bMF0+PjQ+N3x8KG5bMF08PDh8blsxXSklMzE/eHIobixyKTpKcihuLHIpfXZhciBzbj1mdW5jdGlvbihuLHIsdCxlKXtmb3IodmFyIGkgaW4gbil7dmFyIGE9bltpXSxvPXIraTthIGluc3RhbmNlb2YgQT90W29dPVthLGVdOkFycmF5LmlzQXJyYXkoYSk/dFtvXT1bYVswXSxacihlLGFbMV0pXTpzbihhLG8rXCIvXCIsdCxlKTt9fSxLbj10eXBlb2YgVGV4dEVuY29kZXIhPVwidW5kZWZpbmVkXCImJm5ldyBUZXh0RW5jb2Rlcixobj10eXBlb2YgVGV4dERlY29kZXIhPVwidW5kZWZpbmVkXCImJm5ldyBUZXh0RGVjb2RlcixObj0wO3RyeXtobi5kZWNvZGUoZXIse3N0cmVhbTohMH0pLE5uPTE7fWNhdGNoKG4pe312YXIgUW49ZnVuY3Rpb24obil7Zm9yKHZhciByPVwiXCIsdD0wOzspe3ZhciBlPW5bdCsrXSxpPShlPjEyNykrKGU+MjIzKSsoZT4yMzkpO2lmKHQraT5uLmxlbmd0aClyZXR1cm4gW3IsJChuLHQtMSldO2k/aT09Mz8oZT0oKGUmMTUpPDwxOHwoblt0KytdJjYzKTw8MTJ8KG5bdCsrXSY2Myk8PDZ8blt0KytdJjYzKS02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGU+PjEwLDU2MzIwfGUmMTAyMykpOmkmMT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChlJjMxKTw8NnxuW3QrK10mNjMpOnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGUmMTUpPDwxMnwoblt0KytdJjYzKTw8NnxuW3QrK10mNjMpOnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7fX0sb3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXIsTm4/dGhpcy50PW5ldyBUZXh0RGVjb2Rlcjp0aGlzLnA9ZXI7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gY2FsbGJhY2tcIjtpZih0fHwodD0hMSksdGhpcy50KXJldHVybiB0aGlzLm9uZGF0YSh0aGlzLnQuZGVjb2RlKHIse3N0cmVhbTohdH0pLHQpO3ZhciBlPW5ldyBBKHRoaXMucC5sZW5ndGgrci5sZW5ndGgpO2Uuc2V0KHRoaXMucCksZS5zZXQocix0aGlzLnAubGVuZ3RoKTt2YXIgaT1RbihlKSxhPWlbMF0sbz1pWzFdO2lmKHQmJm8ubGVuZ3RoKXRocm93IFwiaW52YWxpZCB1dGYtOCBkYXRhXCI7dGhpcy5wPW8sdGhpcy5vbmRhdGEoYSx0KTt9LG59KCksZnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25kYXRhPXI7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7aWYoIXRoaXMub25kYXRhKXRocm93IFwibm8gY2FsbGJhY2tcIjt0aGlzLm9uZGF0YShvcihyKSx0fHwhMSk7fSxufSgpO2Z1bmN0aW9uIG9yKG4scil7aWYocil7Zm9yKHZhciB0PW5ldyBBKG4ubGVuZ3RoKSxlPTA7ZTxuLmxlbmd0aDsrK2UpdFtlXT1uLmNoYXJDb2RlQXQoZSk7cmV0dXJuIHR9aWYoS24pcmV0dXJuIEtuLmVuY29kZShuKTtmb3IodmFyIGk9bi5sZW5ndGgsYT1uZXcgQShuLmxlbmd0aCsobi5sZW5ndGg+PjEpKSxvPTAsZj1mdW5jdGlvbih1KXthW28rK109dTt9LGU9MDtlPGk7KytlKXtpZihvKzU+YS5sZW5ndGgpe3ZhciBoPW5ldyBBKG8rOCsoaS1lPDwxKSk7aC5zZXQoYSksYT1oO312YXIgcz1uLmNoYXJDb2RlQXQoZSk7czwxMjh8fHI/ZihzKTpzPDIwNDg/KGYoMTkyfHM+Pj42KSxmKDEyOHxzJjYzKSk6cz41NTI5NSYmczw1NzM0ND8ocz02NTUzNisocyYxMDIzPDwxMCl8bi5jaGFyQ29kZUF0KCsrZSkmMTAyMyxmKDI0MHxzPj4+MTgpLGYoMTI4fHM+Pj4xMiY2MyksZigxMjh8cz4+PjYmNjMpLGYoMTI4fHMmNjMpKTooZigyMjR8cz4+PjEyKSxmKDEyOHxzPj4+NiY2MyksZigxMjh8cyY2MykpO31yZXR1cm4gJChhLDAsbyl9ZnVuY3Rpb24gdW4obixyKXtpZihyKXtmb3IodmFyIHQ9XCJcIixlPTA7ZTxuLmxlbmd0aDtlKz0xNjM4NCl0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbi5zdWJhcnJheShlLGUrMTYzODQpKTtyZXR1cm4gdH1lbHNlIHtpZihobilyZXR1cm4gaG4uZGVjb2RlKG4pO3ZhciBpPVFuKG4pLGE9aVswXSxvPWlbMV07aWYoby5sZW5ndGgpdGhyb3cgXCJpbnZhbGlkIHV0Zi04IGRhdGFcIjtyZXR1cm4gYX19dmFyIFZuPWZ1bmN0aW9uKG4pe3JldHVybiBuPT0xPzM6bjw2PzI6bj09OT8xOjB9LFhuPWZ1bmN0aW9uKG4scil7cmV0dXJuIHIrMzArWShuLHIrMjYpK1kobixyKzI4KX0sJG49ZnVuY3Rpb24obixyLHQpe3ZhciBlPVkobixyKzI4KSxpPXVuKG4uc3ViYXJyYXkocis0NixyKzQ2K2UpLCEoWShuLHIrOCkmMjA0OCkpLGE9cis0NitlLG89UChuLHIrMjApLGY9dCYmbz09NDI5NDk2NzI5NT9MbihuLGEpOltvLFAobixyKzI0KSxQKG4scis0MildLGg9ZlswXSxzPWZbMV0sdT1mWzJdO3JldHVybiBbWShuLHIrMTApLGgscyxpLGErWShuLHIrMzApK1kobixyKzMyKSx1XX0sTG49ZnVuY3Rpb24obixyKXtmb3IoO1kobixyKSE9MTtyKz00K1kobixyKzIpKTtyZXR1cm4gW2RyKG4scisxMiksZHIobixyKzQpLGRyKG4scisyMCldfSxmcj1mdW5jdGlvbihuKXt2YXIgcj0wO2lmKG4pZm9yKHZhciB0IGluIG4pe3ZhciBlPW5bdF0ubGVuZ3RoO2lmKGU+NjU1MzUpdGhyb3cgXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiO3IrPWUrNDt9cmV0dXJuIHJ9LEFyPWZ1bmN0aW9uKG4scix0LGUsaSxhLG8sZil7dmFyIGg9ZS5sZW5ndGgscz10LmV4dHJhLHU9ZiYmZi5sZW5ndGgsbD1mcihzKTtGKG4scixvIT1udWxsPzMzNjM5MjQ4OjY3MzI0NzUyKSxyKz00LG8hPW51bGwmJihuW3IrK109MjAsbltyKytdPXQub3MpLG5bcl09MjAscis9MixuW3IrK109dC5mbGFnPDwxfChhPT1udWxsJiY4KSxuW3IrK109aSYmOCxuW3IrK109dC5jb21wcmVzc2lvbiYyNTUsbltyKytdPXQuY29tcHJlc3Npb24+Pjg7dmFyIHA9bmV3IERhdGUodC5tdGltZT09bnVsbD9EYXRlLm5vdygpOnQubXRpbWUpLHk9cC5nZXRGdWxsWWVhcigpLTE5ODA7aWYoeTwwfHx5PjExOSl0aHJvdyBcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiO2lmKEYobixyLCh5PDwyNCkqMnxwLmdldE1vbnRoKCkrMTw8MjF8cC5nZXREYXRlKCk8PDE2fHAuZ2V0SG91cnMoKTw8MTF8cC5nZXRNaW51dGVzKCk8PDV8cC5nZXRTZWNvbmRzKCk+Pj4xKSxyKz00LGEhPW51bGwmJihGKG4scix0LmNyYyksRihuLHIrNCxhKSxGKG4scis4LHQuc2l6ZSkpLEYobixyKzEyLGgpLEYobixyKzE0LGwpLHIrPTE2LG8hPW51bGwmJihGKG4scix1KSxGKG4scis2LHQuYXR0cnMpLEYobixyKzEwLG8pLHIrPTE0KSxuLnNldChlLHIpLHIrPWgsbClmb3IodmFyIGMgaW4gcyl7dmFyIGc9c1tjXSx3PWcubGVuZ3RoO0YobixyLCtjKSxGKG4scisyLHcpLG4uc2V0KGcscis0KSxyKz00K3c7fXJldHVybiB1JiYobi5zZXQoZixyKSxyKz11KSxyfSxsbj1mdW5jdGlvbihuLHIsdCxlLGkpe0YobixyLDEwMTAxMDI1NiksRihuLHIrOCx0KSxGKG4scisxMCx0KSxGKG4scisxMixlKSxGKG4scisxNixpKTt9LEJyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLmZpbGVuYW1lPXIsdGhpcy5jPWdyKCksdGhpcy5zaXplPTAsdGhpcy5jb21wcmVzc2lvbj0wO31yZXR1cm4gbi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihyLHQpe3RoaXMub25kYXRhKG51bGwscix0KTt9LG4ucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24ocix0KXtpZighdGhpcy5vbmRhdGEpdGhyb3cgXCJubyBjYWxsYmFjayAtIGFkZCB0byBaSVAgYXJjaGl2ZSBiZWZvcmUgcHVzaGluZ1wiO3RoaXMuYy5wKHIpLHRoaXMuc2l6ZSs9ci5sZW5ndGgsdCYmKHRoaXMuY3JjPXRoaXMuYy5kKCkpLHRoaXMucHJvY2VzcyhyLHR8fCExKTt9LG59KCksc3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7dmFyIGU9dGhpczt0fHwodD17fSksQnIuY2FsbCh0aGlzLHIpLHRoaXMuZD1uZXcgcnIodCxmdW5jdGlvbihpLGEpe2Uub25kYXRhKG51bGwsaSxhKTt9KSx0aGlzLmNvbXByZXNzaW9uPTgsdGhpcy5mbGFnPVZuKHQubGV2ZWwpO31yZXR1cm4gbi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihyLHQpe3RyeXt0aGlzLmQucHVzaChyLHQpO31jYXRjaChlKXt0aGlzLm9uZGF0YShlLG51bGwsdCk7fX0sbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe0JyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcyxyLHQpO30sbn0oKSxodD1mdW5jdGlvbigpe2Z1bmN0aW9uIG4ocix0KXt2YXIgZT10aGlzO3R8fCh0PXt9KSxCci5jYWxsKHRoaXMsciksdGhpcy5kPW5ldyBFbih0LGZ1bmN0aW9uKGksYSxvKXtlLm9uZGF0YShpLGEsbyk7fSksdGhpcy5jb21wcmVzc2lvbj04LHRoaXMuZmxhZz1Wbih0LmxldmVsKSx0aGlzLnRlcm1pbmF0ZT10aGlzLmQudGVybWluYXRlO31yZXR1cm4gbi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihyLHQpe3RoaXMuZC5wdXNoKHIsdCk7fSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7QnIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLHIsdCk7fSxufSgpLHV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihyKXt0aGlzLm9uZGF0YT1yLHRoaXMudT1bXSx0aGlzLmQ9MTt9cmV0dXJuIG4ucHJvdG90eXBlLmFkZD1mdW5jdGlvbihyKXt2YXIgdD10aGlzO2lmKHRoaXMuZCYyKXRocm93IFwic3RyZWFtIGZpbmlzaGVkXCI7dmFyIGU9b3Ioci5maWxlbmFtZSksaT1lLmxlbmd0aCxhPXIuY29tbWVudCxvPWEmJm9yKGEpLGY9aSE9ci5maWxlbmFtZS5sZW5ndGh8fG8mJmEubGVuZ3RoIT1vLmxlbmd0aCxoPWkrZnIoci5leHRyYSkrMzA7aWYoaT42NTUzNSl0aHJvdyBcImZpbGVuYW1lIHRvbyBsb25nXCI7dmFyIHM9bmV3IEEoaCk7QXIocywwLHIsZSxmKTt2YXIgdT1bc10sbD1mdW5jdGlvbigpe2Zvcih2YXIgdz0wLE09dTt3PE0ubGVuZ3RoO3crKyl7dmFyIHo9TVt3XTt0Lm9uZGF0YShudWxsLHosITEpO311PVtdO30scD10aGlzLmQ7dGhpcy5kPTA7dmFyIHk9dGhpcy51Lmxlbmd0aCxjPVpyKHIse2Y6ZSx1OmYsbyx0OmZ1bmN0aW9uKCl7ci50ZXJtaW5hdGUmJnIudGVybWluYXRlKCk7fSxyOmZ1bmN0aW9uKCl7aWYobCgpLHApe3ZhciB3PXQudVt5KzFdO3c/dy5yKCk6dC5kPTE7fXA9MTt9fSksZz0wO3Iub25kYXRhPWZ1bmN0aW9uKHcsTSx6KXtpZih3KXQub25kYXRhKHcsTSx6KSx0LnRlcm1pbmF0ZSgpO2Vsc2UgaWYoZys9TS5sZW5ndGgsdS5wdXNoKE0pLHope3ZhciBtPW5ldyBBKDE2KTtGKG0sMCwxMzQ2OTU3NjApLEYobSw0LHIuY3JjKSxGKG0sOCxnKSxGKG0sMTIsci5zaXplKSx1LnB1c2gobSksYy5jPWcsYy5iPWgrZysxNixjLmNyYz1yLmNyYyxjLnNpemU9ci5zaXplLHAmJmMucigpLHA9MTt9ZWxzZSBwJiZsKCk7fSx0aGlzLnUucHVzaChjKTt9LG4ucHJvdG90eXBlLmVuZD1mdW5jdGlvbigpe3ZhciByPXRoaXM7aWYodGhpcy5kJjIpdGhyb3cgdGhpcy5kJjE/XCJzdHJlYW0gZmluaXNoaW5nXCI6XCJzdHJlYW0gZmluaXNoZWRcIjt0aGlzLmQ/dGhpcy5lKCk6dGhpcy51LnB1c2goe3I6ZnVuY3Rpb24oKXtpZighKHIuZCYxKSlyZXR1cm47ci51LnNwbGljZSgtMSwxKSxyLmUoKTt9LHQ6ZnVuY3Rpb24oKXt9fSksdGhpcy5kPTM7fSxuLnByb3RvdHlwZS5lPWZ1bmN0aW9uKCl7Zm9yKHZhciByPTAsdD0wLGU9MCxpPTAsYT10aGlzLnU7aTxhLmxlbmd0aDtpKyspe3ZhciBvPWFbaV07ZSs9NDYrby5mLmxlbmd0aCtmcihvLmV4dHJhKSsoby5vP28uby5sZW5ndGg6MCk7fWZvcih2YXIgZj1uZXcgQShlKzIyKSxoPTAscz10aGlzLnU7aDxzLmxlbmd0aDtoKyspe3ZhciBvPXNbaF07QXIoZixyLG8sby5mLG8udSxvLmMsdCxvLm8pLHIrPTQ2K28uZi5sZW5ndGgrZnIoby5leHRyYSkrKG8ubz9vLm8ubGVuZ3RoOjApLHQrPW8uYjt9bG4oZixyLHRoaXMudS5sZW5ndGgsZSx0KSx0aGlzLm9uZGF0YShudWxsLGYsITApLHRoaXMuZD0yO30sbi5wcm90b3R5cGUudGVybWluYXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciByPTAsdD10aGlzLnU7cjx0Lmxlbmd0aDtyKyspe3ZhciBlPXRbcl07ZS50KCk7fXRoaXMuZD0yO30sbn0oKTtmdW5jdGlvbiBsdChuLHIsdCl7aWYodHx8KHQ9cixyPXt9KSx0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjt2YXIgZT17fTtzbihuLFwiXCIsZSxyKTt2YXIgaT1PYmplY3Qua2V5cyhlKSxhPWkubGVuZ3RoLG89MCxmPTAsaD1hLHM9bmV3IEFycmF5KGEpLHU9W10sbD1mdW5jdGlvbigpe2Zvcih2YXIgZz0wO2c8dS5sZW5ndGg7KytnKXVbZ10oKTt9LHA9ZnVuY3Rpb24oKXt2YXIgZz1uZXcgQShmKzIyKSx3PW8sTT1mLW87Zj0wO2Zvcih2YXIgej0wO3o8aDsrK3ope3ZhciBtPXNbel07dHJ5e3ZhciBEPW0uYy5sZW5ndGg7QXIoZyxmLG0sbS5mLG0udSxEKTt2YXIgQz0zMCttLmYubGVuZ3RoK2ZyKG0uZXh0cmEpLFU9ZitDO2cuc2V0KG0uYyxVKSxBcihnLG8sbSxtLmYsbS51LEQsZixtLm0pLG8rPTE2K0MrKG0ubT9tLm0ubGVuZ3RoOjApLGY9VStEO31jYXRjaCh4KXtyZXR1cm4gdCh4LG51bGwpfX1sbihnLG8scy5sZW5ndGgsTSx3KSx0KG51bGwsZyk7fTthfHxwKCk7Zm9yKHZhciB5PWZ1bmN0aW9uKGcpe3ZhciB3PWlbZ10sTT1lW3ddLHo9TVswXSxtPU1bMV0sRD1ncigpLEM9ei5sZW5ndGg7RC5wKHopO3ZhciBVPW9yKHcpLHg9VS5sZW5ndGgsdj1tLmNvbW1lbnQsRT12JiZvcih2KSxTPUUmJkUubGVuZ3RoLEs9ZnIobS5leHRyYSksST1tLmxldmVsPT0wPzA6OCxaPWZ1bmN0aW9uKEIsRyl7aWYoQilsKCksdChCLG51bGwpO2Vsc2Uge3ZhciBrPUcubGVuZ3RoO3NbZ109WnIobSx7c2l6ZTpDLGNyYzpELmQoKSxjOkcsZjpVLG06RSx1OnghPXcubGVuZ3RofHxFJiZ2Lmxlbmd0aCE9Uyxjb21wcmVzc2lvbjpJfSksbys9MzAreCtLK2ssZis9NzYrMiooeCtLKSsoU3x8MCkraywtLWF8fHAoKTt9fTtpZih4PjY1NTM1JiZaKFwiZmlsZW5hbWUgdG9vIGxvbmdcIixudWxsKSwhSSlaKG51bGwseik7ZWxzZSBpZihDPDE2ZTQpdHJ5e1oobnVsbCxrcih6LG0pKTt9Y2F0Y2goQil7WihCLG51bGwpO31lbHNlIHUucHVzaChQbih6LG0sWikpO30sYz0wO2M8aDsrK2MpeShjKTtyZXR1cm4gbH1mdW5jdGlvbiB2dChuLHIpe3J8fChyPXt9KTt2YXIgdD17fSxlPVtdO3NuKG4sXCJcIix0LHIpO3ZhciBpPTAsYT0wO2Zvcih2YXIgbyBpbiB0KXt2YXIgZj10W29dLGg9ZlswXSxzPWZbMV0sdT1zLmxldmVsPT0wPzA6OCxsPW9yKG8pLHA9bC5sZW5ndGgseT1zLmNvbW1lbnQsYz15JiZvcih5KSxnPWMmJmMubGVuZ3RoLHc9ZnIocy5leHRyYSk7aWYocD42NTUzNSl0aHJvdyBcImZpbGVuYW1lIHRvbyBsb25nXCI7dmFyIE09dT9rcihoLHMpOmgsej1NLmxlbmd0aCxtPWdyKCk7bS5wKGgpLGUucHVzaChacihzLHtzaXplOmgubGVuZ3RoLGNyYzptLmQoKSxjOk0sZjpsLG06Yyx1OnAhPW8ubGVuZ3RofHxjJiZ5Lmxlbmd0aCE9ZyxvOmksY29tcHJlc3Npb246dX0pKSxpKz0zMCtwK3creixhKz03NisyKihwK3cpKyhnfHwwKSt6O31mb3IodmFyIEQ9bmV3IEEoYSsyMiksQz1pLFU9YS1pLHg9MDt4PGUubGVuZ3RoOysreCl7dmFyIGw9ZVt4XTtBcihELGwubyxsLGwuZixsLnUsbC5jLmxlbmd0aCk7dmFyIHY9MzArbC5mLmxlbmd0aCtmcihsLmV4dHJhKTtELnNldChsLmMsbC5vK3YpLEFyKEQsaSxsLGwuZixsLnUsbC5jLmxlbmd0aCxsLm8sbC5tKSxpKz0xNit2KyhsLm0/bC5tLmxlbmd0aDowKTt9cmV0dXJuIGxuKEQsaSxlLmxlbmd0aCxVLEMpLER9dmFyIGRuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3RoaXMub25kYXRhKG51bGwscix0KTt9LG4uY29tcHJlc3Npb249MCxufSgpLGN0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3ZhciByPXRoaXM7dGhpcy5pPW5ldyBKKGZ1bmN0aW9uKHQsZSl7ci5vbmRhdGEobnVsbCx0LGUpO30pO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3RyeXt0aGlzLmkucHVzaChyLHQpO31jYXRjaChlKXt0aGlzLm9uZGF0YShlLHIsdCk7fX0sbi5jb21wcmVzc2lvbj04LG59KCkscHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIsdCl7dmFyIGU9dGhpczt0PDMyZTQ/dGhpcy5pPW5ldyBKKGZ1bmN0aW9uKGksYSl7ZS5vbmRhdGEobnVsbCxpLGEpO30pOih0aGlzLmk9bmV3IGVuKGZ1bmN0aW9uKGksYSxvKXtlLm9uZGF0YShpLGEsbyk7fSksdGhpcy50ZXJtaW5hdGU9dGhpcy5pLnRlcm1pbmF0ZSk7fXJldHVybiBuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHIsdCl7dGhpcy5pLnRlcm1pbmF0ZSYmKHI9JChyLDApKSx0aGlzLmkucHVzaChyLHQpO30sbi5jb21wcmVzc2lvbj04LG59KCksZ3Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHIpe3RoaXMub25maWxlPXIsdGhpcy5rPVtdLHRoaXMubz17MDpkbn0sdGhpcy5wPWVyO31yZXR1cm4gbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihyLHQpe3ZhciBlPXRoaXM7aWYoIXRoaXMub25maWxlKXRocm93IFwibm8gY2FsbGJhY2tcIjtpZih0aGlzLmM+MCl7dmFyIGk9TWF0aC5taW4odGhpcy5jLHIubGVuZ3RoKSxhPXIuc3ViYXJyYXkoMCxpKTtpZih0aGlzLmMtPWksdGhpcy5kP3RoaXMuZC5wdXNoKGEsIXRoaXMuYyk6dGhpcy5rWzBdLnB1c2goYSkscj1yLnN1YmFycmF5KGkpLHIubGVuZ3RoKXJldHVybiB0aGlzLnB1c2gocix0KX1lbHNlIHt2YXIgbz0wLGY9MCxoPXZvaWQgMCxzPXZvaWQgMDt0aGlzLnAubGVuZ3RoP3IubGVuZ3RoPyhzPW5ldyBBKHRoaXMucC5sZW5ndGgrci5sZW5ndGgpLHMuc2V0KHRoaXMucCkscy5zZXQocix0aGlzLnAubGVuZ3RoKSk6cz10aGlzLnA6cz1yO2Zvcih2YXIgdT1zLmxlbmd0aCxsPXRoaXMuYyxwPWwmJnRoaXMuZCx5PWZ1bmN0aW9uKCl7dmFyIE0sej1QKHMsZik7aWYoej09NjczMjQ3NTIpe289MSxoPWYsYy5kPW51bGwsYy5jPTA7dmFyIG09WShzLGYrNiksRD1ZKHMsZis4KSxDPW0mMjA0OCxVPW0mOCx4PVkocyxmKzI2KSx2PVkocyxmKzI4KTtpZih1PmYrMzAreCt2KXt2YXIgRT1bXTtjLmsudW5zaGlmdChFKSxvPTI7dmFyIFM9UChzLGYrMTgpLEs9UChzLGYrMjIpLEk9dW4ocy5zdWJhcnJheShmKzMwLGYrPTMwK3gpLCFDKTtTPT00Mjk0OTY3Mjk1PyhNPVU/Wy0yXTpMbihzLGYpLFM9TVswXSxLPU1bMV0pOlUmJihTPS0xKSxmKz12LGMuYz1TO3ZhciBaPXtuYW1lOkksY29tcHJlc3Npb246RCxzdGFydDpmdW5jdGlvbigpe2lmKCFaLm9uZGF0YSl0aHJvdyBcIm5vIGNhbGxiYWNrXCI7aWYoIVMpWi5vbmRhdGEobnVsbCxlciwhMCk7ZWxzZSB7dmFyIEI9ZS5vW0RdO2lmKCFCKXRocm93IFwidW5rbm93biBjb21wcmVzc2lvbiB0eXBlIFwiK0Q7dmFyIEc9UzwwP25ldyBCKEkpOm5ldyBCKEksUyxLKTtHLm9uZGF0YT1mdW5jdGlvbihOLFEsVyl7Wi5vbmRhdGEoTixRLFcpO307Zm9yKHZhciBrPTAsTz1FO2s8Ty5sZW5ndGg7aysrKXt2YXIgSD1PW2tdO0cucHVzaChILCExKTt9ZS5rWzBdPT1FP2UuZD1HOkcucHVzaChlciwhMCk7fX0sdGVybWluYXRlOmZ1bmN0aW9uKCl7ZS5rWzBdPT1FJiZlLmQudGVybWluYXRlJiZlLmQudGVybWluYXRlKCk7fX07Uz49MCYmKFouc2l6ZT1TLFoub3JpZ2luYWxTaXplPUspLGMub25maWxlKFopO31yZXR1cm4gXCJicmVha1wifWVsc2UgaWYobCl7aWYoej09MTM0Njk1NzYwKXJldHVybiBoPWYrPTEyKyhsPT0tMiYmOCksbz0yLGMuYz0wLFwiYnJlYWtcIjtpZih6PT0zMzYzOTI0OClyZXR1cm4gaD1mLT00LG89MixjLmM9MCxcImJyZWFrXCJ9fSxjPXRoaXM7Zjx1LTQ7KytmKXt2YXIgZz15KCk7aWYoZz09PVwiYnJlYWtcIilicmVha31pZih0aGlzLnA9ZXIsbDwwKXt2YXIgdz1vP3Muc3ViYXJyYXkoMCxoLTEyLShsPT0tMiYmOCktKFAocyxoLTE2KT09MTM0Njk1NzYwJiY0KSk6cy5zdWJhcnJheSgwLGYpO3A/cC5wdXNoKHcsISFvKTp0aGlzLmtbKyhvPT0yKV0ucHVzaCh3KTt9aWYobyYyKXJldHVybiB0aGlzLnB1c2gocy5zdWJhcnJheShmKSx0KTt0aGlzLnA9cy5zdWJhcnJheShmKTt9aWYodCYmdGhpcy5jKXRocm93IFwiaW52YWxpZCB6aXAgZmlsZVwifSxuLnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihyKXt0aGlzLm9bci5jb21wcmVzc2lvbl09cjt9LG59KCk7ZnVuY3Rpb24gd3QobixyKXtpZih0eXBlb2YgciE9XCJmdW5jdGlvblwiKXRocm93IFwibm8gY2FsbGJhY2tcIjtmb3IodmFyIHQ9W10sZT1mdW5jdGlvbigpe2Zvcih2YXIgcD0wO3A8dC5sZW5ndGg7KytwKXRbcF0oKTt9LGk9e30sYT1uLmxlbmd0aC0yMjtQKG4sYSkhPTEwMTAxMDI1NjstLWEpaWYoIWF8fG4ubGVuZ3RoLWE+NjU1NTgpe3IoXCJpbnZhbGlkIHppcCBmaWxlXCIsbnVsbCk7cmV0dXJufXZhciBvPVkobixhKzgpO298fHIobnVsbCx7fSk7dmFyIGY9byxoPVAobixhKzE2KSxzPWg9PTQyOTQ5NjcyOTU7aWYocyl7aWYoYT1QKG4sYS0xMiksUChuLGEpIT0xMDEwNzU3OTIpe3IoXCJpbnZhbGlkIHppcCBmaWxlXCIsbnVsbCk7cmV0dXJufWY9bz1QKG4sYSszMiksaD1QKG4sYSs0OCk7fWZvcih2YXIgdT1mdW5jdGlvbihwKXt2YXIgeT0kbihuLGgscyksYz15WzBdLGc9eVsxXSx3PXlbMl0sTT15WzNdLHo9eVs0XSxtPXlbNV0sRD1YbihuLG0pO2g9ejt2YXIgQz1mdW5jdGlvbih4LHYpe3g/KGUoKSxyKHgsbnVsbCkpOihpW01dPXYsLS1vfHxyKG51bGwsaSkpO307aWYoIWMpQyhudWxsLCQobixELEQrZykpO2Vsc2UgaWYoYz09OCl7dmFyIFU9bi5zdWJhcnJheShELEQrZyk7aWYoZzwzMmU0KXRyeXtDKG51bGwseHIoVSxuZXcgQSh3KSkpO31jYXRjaCh4KXtDKHgsbnVsbCk7fWVsc2UgdC5wdXNoKGFuKFUse3NpemU6d30sQykpO31lbHNlIEMoXCJ1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgXCIrYyxudWxsKTt9LGw9MDtsPGY7KytsKXUoKTtyZXR1cm4gZX1mdW5jdGlvbiB5dChuKXtmb3IodmFyIHI9e30sdD1uLmxlbmd0aC0yMjtQKG4sdCkhPTEwMTAxMDI1NjstLXQpaWYoIXR8fG4ubGVuZ3RoLXQ+NjU1NTgpdGhyb3cgXCJpbnZhbGlkIHppcCBmaWxlXCI7dmFyIGU9WShuLHQrOCk7aWYoIWUpcmV0dXJuIHt9O3ZhciBpPVAobix0KzE2KSxhPWk9PTQyOTQ5NjcyOTU7aWYoYSl7aWYodD1QKG4sdC0xMiksUChuLHQpIT0xMDEwNzU3OTIpdGhyb3cgXCJpbnZhbGlkIHppcCBmaWxlXCI7ZT1QKG4sdCszMiksaT1QKG4sdCs0OCk7fWZvcih2YXIgbz0wO288ZTsrK28pe3ZhciBmPSRuKG4saSxhKSxoPWZbMF0scz1mWzFdLHU9ZlsyXSxsPWZbM10scD1mWzRdLHk9Zls1XSxjPVhuKG4seSk7aWYoaT1wLCFoKXJbbF09JChuLGMsYytzKTtlbHNlIGlmKGg9PTgpcltsXT14cihuLnN1YmFycmF5KGMsYytzKSxuZXcgQSh1KSk7ZWxzZSB0aHJvdyBcInVua25vd24gY29tcHJlc3Npb24gdHlwZSBcIitofXJldHVybiByfXZhciBmZmxhdGVfbW9kdWxlX21pbiA9IG51bGw7XG5cbnZhciBmZmxhdGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QXN5bmNDb21wcmVzczogUm4sXG5cdEFzeW5jRGVjb21wcmVzczogZXQsXG5cdEFzeW5jRGVmbGF0ZTogRW4sXG5cdEFzeW5jR3VuemlwOiBIbixcblx0QXN5bmNHemlwOiBSbixcblx0QXN5bmNJbmZsYXRlOiBlbixcblx0QXN5bmNVbnppcEluZmxhdGU6IHB0LFxuXHRBc3luY1VuemxpYjogWW4sXG5cdEFzeW5jWmlwRGVmbGF0ZTogaHQsXG5cdEFzeW5jWmxpYjogbnQsXG5cdENvbXByZXNzOiBxcixcblx0RGVjb2RlVVRGODogb3QsXG5cdERlY29tcHJlc3M6IEpuLFxuXHREZWZsYXRlOiBycixcblx0RW5jb2RlVVRGODogZnQsXG5cdEd1bnppcDogV3IsXG5cdEd6aXA6IHFyLFxuXHRJbmZsYXRlOiBKLFxuXHRVbnppcDogZ3QsXG5cdFVuemlwSW5mbGF0ZTogY3QsXG5cdFVuemlwUGFzc1Rocm91Z2g6IGRuLFxuXHRVbnpsaWI6IGpyLFxuXHRaaXA6IHV0LFxuXHRaaXBEZWZsYXRlOiBzdCxcblx0WmlwUGFzc1Rocm91Z2g6IEJyLFxuXHRabGliOiBvbixcblx0Y29tcHJlc3M6IHFuLFxuXHRjb21wcmVzc1N5bmM6IEhyLFxuXHRkZWNvbXByZXNzOiBpdCxcblx0ZGVjb21wcmVzc1N5bmM6IGF0LFxuXHRkZWZsYXRlOiBQbixcblx0ZGVmbGF0ZVN5bmM6IGtyLFxuXHRndW56aXA6IFduLFxuXHRndW56aXBTeW5jOiBZcixcblx0Z3ppcDogcW4sXG5cdGd6aXBTeW5jOiBIcixcblx0aW5mbGF0ZTogYW4sXG5cdGluZmxhdGVTeW5jOiB4cixcblx0c3RyRnJvbVU4OiB1bixcblx0c3RyVG9VODogb3IsXG5cdHVuemlwOiB3dCxcblx0dW56aXBTeW5jOiB5dCxcblx0dW56bGliOiBqbixcblx0dW56bGliU3luYzogSnIsXG5cdHppcDogbHQsXG5cdHppcFN5bmM6IHZ0LFxuXHR6bGliOiB0dCxcblx0emxpYlN5bmM6IGZuLFxuXHQnZGVmYXVsdCc6IGZmbGF0ZV9tb2R1bGVfbWluXG59KTtcblxuLyoqXG4gKiBOVVJCUyB1dGlsc1xuICpcbiAqIFNlZSBOVVJCU0N1cnZlIGFuZCBOVVJCU1N1cmZhY2UuXG4gKiovXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0TlVSQlMgVXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIE5VUkJTVXRpbHMgPSB7XG5cblx0Lypcblx0RmluZHMga25vdCB2ZWN0b3Igc3Bhbi5cblxuXHRwIDogZGVncmVlXG5cdHUgOiBwYXJhbWV0cmljIHZhbHVlXG5cdFUgOiBrbm90IHZlY3RvclxuXG5cdHJldHVybnMgdGhlIHNwYW5cblx0Ki9cblx0ZmluZFNwYW46IGZ1bmN0aW9uICggcCwgdSwgVSApIHtcblxuXHRcdHZhciBuID0gVS5sZW5ndGggLSBwIC0gMTtcblxuXHRcdGlmICggdSA+PSBVWyBuIF0gKSB7XG5cblx0XHRcdHJldHVybiBuIC0gMTtcblxuXHRcdH1cblxuXHRcdGlmICggdSA8PSBVWyBwIF0gKSB7XG5cblx0XHRcdHJldHVybiBwO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGxvdyA9IHA7XG5cdFx0dmFyIGhpZ2ggPSBuO1xuXHRcdHZhciBtaWQgPSBNYXRoLmZsb29yKCAoIGxvdyArIGhpZ2ggKSAvIDIgKTtcblxuXHRcdHdoaWxlICggdSA8IFVbIG1pZCBdIHx8IHUgPj0gVVsgbWlkICsgMSBdICkge1xuXG5cdFx0XHRpZiAoIHUgPCBVWyBtaWQgXSApIHtcblxuXHRcdFx0XHRoaWdoID0gbWlkO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxvdyA9IG1pZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRtaWQgPSBNYXRoLmZsb29yKCAoIGxvdyArIGhpZ2ggKSAvIDIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtaWQ7XG5cblx0fSxcblxuXG5cdC8qXG5cdENhbGN1bGF0ZSBiYXNpcyBmdW5jdGlvbnMuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSA3MCwgYWxnb3JpdGhtIEEyLjJcblxuXHRzcGFuIDogc3BhbiBpbiB3aGljaCB1IGxpZXNcblx0dSAgICA6IHBhcmFtZXRyaWMgcG9pbnRcblx0cCAgICA6IGRlZ3JlZVxuXHRVICAgIDoga25vdCB2ZWN0b3JcblxuXHRyZXR1cm5zIGFycmF5W3ArMV0gd2l0aCBiYXNpcyBmdW5jdGlvbnMgdmFsdWVzLlxuXHQqL1xuXHRjYWxjQmFzaXNGdW5jdGlvbnM6IGZ1bmN0aW9uICggc3BhbiwgdSwgcCwgVSApIHtcblxuXHRcdHZhciBOID0gW107XG5cdFx0dmFyIGxlZnQgPSBbXTtcblx0XHR2YXIgcmlnaHQgPSBbXTtcblx0XHROWyAwIF0gPSAxLjA7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0bGVmdFsgaiBdID0gdSAtIFVbIHNwYW4gKyAxIC0gaiBdO1xuXHRcdFx0cmlnaHRbIGogXSA9IFVbIHNwYW4gKyBqIF0gLSB1O1xuXG5cdFx0XHR2YXIgc2F2ZWQgPSAwLjA7XG5cblx0XHRcdGZvciAoIHZhciByID0gMDsgciA8IGo7ICsrIHIgKSB7XG5cblx0XHRcdFx0dmFyIHJ2ID0gcmlnaHRbIHIgKyAxIF07XG5cdFx0XHRcdHZhciBsdiA9IGxlZnRbIGogLSByIF07XG5cdFx0XHRcdHZhciB0ZW1wID0gTlsgciBdIC8gKCBydiArIGx2ICk7XG5cdFx0XHRcdE5bIHIgXSA9IHNhdmVkICsgcnYgKiB0ZW1wO1xuXHRcdFx0XHRzYXZlZCA9IGx2ICogdGVtcDtcblxuXHRcdFx0IH1cblxuXHRcdFx0IE5bIGogXSA9IHNhdmVkO1xuXG5cdFx0IH1cblxuXHRcdCByZXR1cm4gTjtcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIEItU3BsaW5lIGN1cnZlIHBvaW50cy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDgyLCBhbGdvcml0aG0gQTMuMS5cblxuXHRwIDogZGVncmVlIG9mIEItU3BsaW5lXG5cdFUgOiBrbm90IHZlY3RvclxuXHRQIDogY29udHJvbCBwb2ludHMgKHgsIHksIHosIHcpXG5cdHUgOiBwYXJhbWV0cmljIHBvaW50XG5cblx0cmV0dXJucyBwb2ludCBmb3IgZ2l2ZW4gdVxuXHQqL1xuXHRjYWxjQlNwbGluZVBvaW50OiBmdW5jdGlvbiAoIHAsIFUsIFAsIHUgKSB7XG5cblx0XHR2YXIgc3BhbiA9IHRoaXMuZmluZFNwYW4oIHAsIHUsIFUgKTtcblx0XHR2YXIgTiA9IHRoaXMuY2FsY0Jhc2lzRnVuY3Rpb25zKCBzcGFuLCB1LCBwLCBVICk7XG5cdFx0dmFyIEMgPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdHZhciBwb2ludCA9IFBbIHNwYW4gLSBwICsgaiBdO1xuXHRcdFx0dmFyIE5qID0gTlsgaiBdO1xuXHRcdFx0dmFyIHdOaiA9IHBvaW50LncgKiBOajtcblx0XHRcdEMueCArPSBwb2ludC54ICogd05qO1xuXHRcdFx0Qy55ICs9IHBvaW50LnkgKiB3Tmo7XG5cdFx0XHRDLnogKz0gcG9pbnQueiAqIHdOajtcblx0XHRcdEMudyArPSBwb2ludC53ICogTmo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gQztcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIGJhc2lzIGZ1bmN0aW9ucyBkZXJpdmF0aXZlcy4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDcyLCBhbGdvcml0aG0gQTIuMy5cblxuXHRzcGFuIDogc3BhbiBpbiB3aGljaCB1IGxpZXNcblx0dSAgICA6IHBhcmFtZXRyaWMgcG9pbnRcblx0cCAgICA6IGRlZ3JlZVxuXHRuICAgIDogbnVtYmVyIG9mIGRlcml2YXRpdmVzIHRvIGNhbGN1bGF0ZVxuXHRVICAgIDoga25vdCB2ZWN0b3JcblxuXHRyZXR1cm5zIGFycmF5W24rMV1bcCsxXSB3aXRoIGJhc2lzIGZ1bmN0aW9ucyBkZXJpdmF0aXZlc1xuXHQqL1xuXHRjYWxjQmFzaXNGdW5jdGlvbkRlcml2YXRpdmVzOiBmdW5jdGlvbiAoIHNwYW4sIHUsIHAsIG4sIFUgKSB7XG5cblx0XHR2YXIgemVyb0FyciA9IFtdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBwOyArKyBpIClcblx0XHRcdHplcm9BcnJbIGkgXSA9IDAuMDtcblxuXHRcdHZhciBkZXJzID0gW107XG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IG47ICsrIGkgKVxuXHRcdFx0ZGVyc1sgaSBdID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0dmFyIG5kdSA9IFtdO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBwOyArKyBpIClcblx0XHRcdG5kdVsgaSBdID0gemVyb0Fyci5zbGljZSggMCApO1xuXG5cdFx0bmR1WyAwIF1bIDAgXSA9IDEuMDtcblxuXHRcdHZhciBsZWZ0ID0gemVyb0Fyci5zbGljZSggMCApO1xuXHRcdHZhciByaWdodCA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblxuXHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBwOyArKyBqICkge1xuXG5cdFx0XHRsZWZ0WyBqIF0gPSB1IC0gVVsgc3BhbiArIDEgLSBqIF07XG5cdFx0XHRyaWdodFsgaiBdID0gVVsgc3BhbiArIGogXSAtIHU7XG5cblx0XHRcdHZhciBzYXZlZCA9IDAuMDtcblxuXHRcdFx0Zm9yICggdmFyIHIgPSAwOyByIDwgajsgKysgciApIHtcblxuXHRcdFx0XHR2YXIgcnYgPSByaWdodFsgciArIDEgXTtcblx0XHRcdFx0dmFyIGx2ID0gbGVmdFsgaiAtIHIgXTtcblx0XHRcdFx0bmR1WyBqIF1bIHIgXSA9IHJ2ICsgbHY7XG5cblx0XHRcdFx0dmFyIHRlbXAgPSBuZHVbIHIgXVsgaiAtIDEgXSAvIG5kdVsgaiBdWyByIF07XG5cdFx0XHRcdG5kdVsgciBdWyBqIF0gPSBzYXZlZCArIHJ2ICogdGVtcDtcblx0XHRcdFx0c2F2ZWQgPSBsdiAqIHRlbXA7XG5cblx0XHRcdH1cblxuXHRcdFx0bmR1WyBqIF1bIGogXSA9IHNhdmVkO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdGRlcnNbIDAgXVsgaiBdID0gbmR1WyBqIF1bIHAgXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciByID0gMDsgciA8PSBwOyArKyByICkge1xuXG5cdFx0XHR2YXIgczEgPSAwO1xuXHRcdFx0dmFyIHMyID0gMTtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBwOyArKyBpICkge1xuXG5cdFx0XHRcdGFbIGkgXSA9IHplcm9BcnIuc2xpY2UoIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhWyAwIF1bIDAgXSA9IDEuMDtcblxuXHRcdFx0Zm9yICggdmFyIGsgPSAxOyBrIDw9IG47ICsrIGsgKSB7XG5cblx0XHRcdFx0dmFyIGQgPSAwLjA7XG5cdFx0XHRcdHZhciByayA9IHIgLSBrO1xuXHRcdFx0XHR2YXIgcGsgPSBwIC0gaztcblxuXHRcdFx0XHRpZiAoIHIgPj0gayApIHtcblxuXHRcdFx0XHRcdGFbIHMyIF1bIDAgXSA9IGFbIHMxIF1bIDAgXSAvIG5kdVsgcGsgKyAxIF1bIHJrIF07XG5cdFx0XHRcdFx0ZCA9IGFbIHMyIF1bIDAgXSAqIG5kdVsgcmsgXVsgcGsgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGoxID0gKCByayA+PSAtIDEgKSA/IDEgOiAtIHJrO1xuXHRcdFx0XHR2YXIgajIgPSAoIHIgLSAxIDw9IHBrICkgPyBrIC0gMSA6IHAgLSByO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gajE7IGogPD0gajI7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRhWyBzMiBdWyBqIF0gPSAoIGFbIHMxIF1bIGogXSAtIGFbIHMxIF1bIGogLSAxIF0gKSAvIG5kdVsgcGsgKyAxIF1bIHJrICsgaiBdO1xuXHRcdFx0XHRcdGQgKz0gYVsgczIgXVsgaiBdICogbmR1WyByayArIGogXVsgcGsgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCByIDw9IHBrICkge1xuXG5cdFx0XHRcdFx0YVsgczIgXVsgayBdID0gLSBhWyBzMSBdWyBrIC0gMSBdIC8gbmR1WyBwayArIDEgXVsgciBdO1xuXHRcdFx0XHRcdGQgKz0gYVsgczIgXVsgayBdICogbmR1WyByIF1bIHBrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlcnNbIGsgXVsgciBdID0gZDtcblxuXHRcdFx0XHR2YXIgaiA9IHMxO1xuXHRcdFx0XHRzMSA9IHMyO1xuXHRcdFx0XHRzMiA9IGo7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciByID0gcDtcblxuXHRcdGZvciAoIHZhciBrID0gMTsgayA8PSBuOyArKyBrICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcDsgKysgaiApIHtcblxuXHRcdFx0XHRkZXJzWyBrIF1bIGogXSAqPSByO1xuXG5cdFx0XHR9XG5cblx0XHRcdHIgKj0gcCAtIGs7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGVycztcblxuXHR9LFxuXG5cblx0Lypcblx0XHRDYWxjdWxhdGUgZGVyaXZhdGl2ZXMgb2YgYSBCLVNwbGluZS4gU2VlIFRoZSBOVVJCUyBCb29rLCBwYWdlIDkzLCBhbGdvcml0aG0gQTMuMi5cblxuXHRcdHAgIDogZGVncmVlXG5cdFx0VSAgOiBrbm90IHZlY3RvclxuXHRcdFAgIDogY29udHJvbCBwb2ludHNcblx0XHR1ICA6IFBhcmFtZXRyaWMgcG9pbnRzXG5cdFx0bmQgOiBudW1iZXIgb2YgZGVyaXZhdGl2ZXNcblxuXHRcdHJldHVybnMgYXJyYXlbZCsxXSB3aXRoIGRlcml2YXRpdmVzXG5cdFx0Ki9cblx0Y2FsY0JTcGxpbmVEZXJpdmF0aXZlczogZnVuY3Rpb24gKCBwLCBVLCBQLCB1LCBuZCApIHtcblxuXHRcdHZhciBkdSA9IG5kIDwgcCA/IG5kIDogcDtcblx0XHR2YXIgQ0sgPSBbXTtcblx0XHR2YXIgc3BhbiA9IHRoaXMuZmluZFNwYW4oIHAsIHUsIFUgKTtcblx0XHR2YXIgbmRlcnMgPSB0aGlzLmNhbGNCYXNpc0Z1bmN0aW9uRGVyaXZhdGl2ZXMoIHNwYW4sIHUsIHAsIGR1LCBVICk7XG5cdFx0dmFyIFB3ID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBQLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0dmFyIHBvaW50ID0gUFsgaSBdLmNsb25lKCk7XG5cdFx0XHR2YXIgdyA9IHBvaW50Lnc7XG5cblx0XHRcdHBvaW50LnggKj0gdztcblx0XHRcdHBvaW50LnkgKj0gdztcblx0XHRcdHBvaW50LnogKj0gdztcblxuXHRcdFx0UHdbIGkgXSA9IHBvaW50O1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGsgPSAwOyBrIDw9IGR1OyArKyBrICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBQd1sgc3BhbiAtIHAgXS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBuZGVyc1sgayBdWyAwIF0gKTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHA7ICsrIGogKSB7XG5cblx0XHRcdFx0cG9pbnQuYWRkKCBQd1sgc3BhbiAtIHAgKyBqIF0uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggbmRlcnNbIGsgXVsgaiBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRDS1sgayBdID0gcG9pbnQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgayA9IGR1ICsgMTsgayA8PSBuZCArIDE7ICsrIGsgKSB7XG5cblx0XHRcdENLWyBrIF0gPSBuZXcgVmVjdG9yNCggMCwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIENLO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgXCJLIG92ZXIgSVwiXG5cblx0cmV0dXJucyBrIS8oaSEoay1pKSEpXG5cdCovXG5cdGNhbGNLb3Zlckk6IGZ1bmN0aW9uICggaywgaSApIHtcblxuXHRcdHZhciBub20gPSAxO1xuXG5cdFx0Zm9yICggdmFyIGogPSAyOyBqIDw9IGs7ICsrIGogKSB7XG5cblx0XHRcdG5vbSAqPSBqO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRlbm9tID0gMTtcblxuXHRcdGZvciAoIHZhciBqID0gMjsgaiA8PSBpOyArKyBqICkge1xuXG5cdFx0XHRkZW5vbSAqPSBqO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGogPSAyOyBqIDw9IGsgLSBpOyArKyBqICkge1xuXG5cdFx0XHRkZW5vbSAqPSBqO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5vbSAvIGRlbm9tO1xuXG5cdH0sXG5cblxuXHQvKlxuXHRDYWxjdWxhdGUgZGVyaXZhdGl2ZXMgKDAtbmQpIG9mIHJhdGlvbmFsIGN1cnZlLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgMTI3LCBhbGdvcml0aG0gQTQuMi5cblxuXHRQZGVycyA6IHJlc3VsdCBvZiBmdW5jdGlvbiBjYWxjQlNwbGluZURlcml2YXRpdmVzXG5cblx0cmV0dXJucyBhcnJheSB3aXRoIGRlcml2YXRpdmVzIGZvciByYXRpb25hbCBjdXJ2ZS5cblx0Ki9cblx0Y2FsY1JhdGlvbmFsQ3VydmVEZXJpdmF0aXZlczogZnVuY3Rpb24gKCBQZGVycyApIHtcblxuXHRcdHZhciBuZCA9IFBkZXJzLmxlbmd0aDtcblx0XHR2YXIgQWRlcnMgPSBbXTtcblx0XHR2YXIgd2RlcnMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5kOyArKyBpICkge1xuXG5cdFx0XHR2YXIgcG9pbnQgPSBQZGVyc1sgaSBdO1xuXHRcdFx0QWRlcnNbIGkgXSA9IG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56ICk7XG5cdFx0XHR3ZGVyc1sgaSBdID0gcG9pbnQudztcblxuXHRcdH1cblxuXHRcdHZhciBDSyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgbmQ7ICsrIGsgKSB7XG5cblx0XHRcdHZhciB2ID0gQWRlcnNbIGsgXS5jbG9uZSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gazsgKysgaSApIHtcblxuXHRcdFx0XHR2LnN1YiggQ0tbIGsgLSBpIF0uY2xvbmUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5jYWxjS292ZXJJKCBrLCBpICkgKiB3ZGVyc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRDS1sgayBdID0gdi5kaXZpZGVTY2FsYXIoIHdkZXJzWyAwIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBDSztcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIE5VUkJTIGN1cnZlIGRlcml2YXRpdmVzLiBTZWUgVGhlIE5VUkJTIEJvb2ssIHBhZ2UgMTI3LCBhbGdvcml0aG0gQTQuMi5cblxuXHRwICA6IGRlZ3JlZVxuXHRVICA6IGtub3QgdmVjdG9yXG5cdFAgIDogY29udHJvbCBwb2ludHMgaW4gaG9tb2dlbmVvdXMgc3BhY2Vcblx0dSAgOiBwYXJhbWV0cmljIHBvaW50c1xuXHRuZCA6IG51bWJlciBvZiBkZXJpdmF0aXZlc1xuXG5cdHJldHVybnMgYXJyYXkgd2l0aCBkZXJpdmF0aXZlcy5cblx0Ki9cblx0Y2FsY05VUkJTRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICggcCwgVSwgUCwgdSwgbmQgKSB7XG5cblx0XHR2YXIgUGRlcnMgPSB0aGlzLmNhbGNCU3BsaW5lRGVyaXZhdGl2ZXMoIHAsIFUsIFAsIHUsIG5kICk7XG5cdFx0cmV0dXJuIHRoaXMuY2FsY1JhdGlvbmFsQ3VydmVEZXJpdmF0aXZlcyggUGRlcnMgKTtcblxuXHR9LFxuXG5cblx0Lypcblx0Q2FsY3VsYXRlIHJhdGlvbmFsIEItU3BsaW5lIHN1cmZhY2UgcG9pbnQuIFNlZSBUaGUgTlVSQlMgQm9vaywgcGFnZSAxMzQsIGFsZ29yaXRobSBBNC4zLlxuXG5cdHAxLCBwMiA6IGRlZ3JlZXMgb2YgQi1TcGxpbmUgc3VyZmFjZVxuXHRVMSwgVTIgOiBrbm90IHZlY3RvcnNcblx0UCAgICAgIDogY29udHJvbCBwb2ludHMgKHgsIHksIHosIHcpXG5cdHUsIHYgICA6IHBhcmFtZXRyaWMgdmFsdWVzXG5cblx0cmV0dXJucyBwb2ludCBmb3IgZ2l2ZW4gKHUsIHYpXG5cdCovXG5cdGNhbGNTdXJmYWNlUG9pbnQ6IGZ1bmN0aW9uICggcCwgcSwgVSwgViwgUCwgdSwgdiwgdGFyZ2V0ICkge1xuXG5cdFx0dmFyIHVzcGFuID0gdGhpcy5maW5kU3BhbiggcCwgdSwgVSApO1xuXHRcdHZhciB2c3BhbiA9IHRoaXMuZmluZFNwYW4oIHEsIHYsIFYgKTtcblx0XHR2YXIgTnUgPSB0aGlzLmNhbGNCYXNpc0Z1bmN0aW9ucyggdXNwYW4sIHUsIHAsIFUgKTtcblx0XHR2YXIgTnYgPSB0aGlzLmNhbGNCYXNpc0Z1bmN0aW9ucyggdnNwYW4sIHYsIHEsIFYgKTtcblx0XHR2YXIgdGVtcCA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGwgPSAwOyBsIDw9IHE7ICsrIGwgKSB7XG5cblx0XHRcdHRlbXBbIGwgXSA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XG5cdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPD0gcDsgKysgayApIHtcblxuXHRcdFx0XHR2YXIgcG9pbnQgPSBQWyB1c3BhbiAtIHAgKyBrIF1bIHZzcGFuIC0gcSArIGwgXS5jbG9uZSgpO1xuXHRcdFx0XHR2YXIgdyA9IHBvaW50Lnc7XG5cdFx0XHRcdHBvaW50LnggKj0gdztcblx0XHRcdFx0cG9pbnQueSAqPSB3O1xuXHRcdFx0XHRwb2ludC56ICo9IHc7XG5cdFx0XHRcdHRlbXBbIGwgXS5hZGQoIHBvaW50Lm11bHRpcGx5U2NhbGFyKCBOdVsgayBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIFN3ID0gbmV3IFZlY3RvcjQoIDAsIDAsIDAsIDAgKTtcblx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPD0gcTsgKysgbCApIHtcblxuXHRcdFx0U3cuYWRkKCB0ZW1wWyBsIF0ubXVsdGlwbHlTY2FsYXIoIE52WyBsIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0U3cuZGl2aWRlU2NhbGFyKCBTdy53ICk7XG5cdFx0dGFyZ2V0LnNldCggU3cueCwgU3cueSwgU3cueiApO1xuXG5cdH1cblxufTtcblxuLyoqXG4gKiBOVVJCUyBjdXJ2ZSBvYmplY3RcbiAqXG4gKiBEZXJpdmVzIGZyb20gQ3VydmUsIG92ZXJyaWRpbmcgZ2V0UG9pbnQgYW5kIGdldFRhbmdlbnQuXG4gKlxuICogSW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gKHgsIHkgWywgej0wIFssIHc9MV1dKSBjb250cm9sIHBvaW50cyB3aXRoIHc9d2VpZ2h0LlxuICpcbiAqKi9cblxudmFyIE5VUkJTQ3VydmUgPSBmdW5jdGlvbiAoIGRlZ3JlZSwga25vdHMgLyogYXJyYXkgb2YgcmVhbHMgKi8sIGNvbnRyb2xQb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yKDJ8M3w0KSAqLywgc3RhcnRLbm90IC8qIGluZGV4IGluIGtub3RzICovLCBlbmRLbm90IC8qIGluZGV4IGluIGtub3RzICovICkge1xuXG5cdEN1cnZlLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLmRlZ3JlZSA9IGRlZ3JlZTtcblx0dGhpcy5rbm90cyA9IGtub3RzO1xuXHR0aGlzLmNvbnRyb2xQb2ludHMgPSBbXTtcblx0Ly8gVXNlZCBieSBwZXJpb2RpYyBOVVJCUyB0byByZW1vdmUgaGlkZGVuIHNwYW5zXG5cdHRoaXMuc3RhcnRLbm90ID0gc3RhcnRLbm90IHx8IDA7XG5cdHRoaXMuZW5kS25vdCA9IGVuZEtub3QgfHwgKCB0aGlzLmtub3RzLmxlbmd0aCAtIDEgKTtcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29udHJvbFBvaW50cy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHQvLyBlbnN1cmUgVmVjdG9yNCBmb3IgY29udHJvbCBwb2ludHNcblx0XHR2YXIgcG9pbnQgPSBjb250cm9sUG9pbnRzWyBpIF07XG5cdFx0dGhpcy5jb250cm9sUG9pbnRzWyBpIF0gPSBuZXcgVmVjdG9yNCggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiwgcG9pbnQudyApO1xuXG5cdH1cblxufTtcblxuXG5OVVJCU0N1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuTlVSQlNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOVVJCU0N1cnZlO1xuXG5cbk5VUkJTQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdHZhciB1ID0gdGhpcy5rbm90c1sgdGhpcy5zdGFydEtub3QgXSArIHQgKiAoIHRoaXMua25vdHNbIHRoaXMuZW5kS25vdCBdIC0gdGhpcy5rbm90c1sgdGhpcy5zdGFydEtub3QgXSApOyAvLyBsaW5lYXIgbWFwcGluZyB0LT51XG5cblx0Ly8gZm9sbG93aW5nIHJlc3VsdHMgaW4gKHd4LCB3eSwgd3osIHcpIGhvbW9nZW5lb3VzIHBvaW50XG5cdHZhciBocG9pbnQgPSBOVVJCU1V0aWxzLmNhbGNCU3BsaW5lUG9pbnQoIHRoaXMuZGVncmVlLCB0aGlzLmtub3RzLCB0aGlzLmNvbnRyb2xQb2ludHMsIHUgKTtcblxuXHRpZiAoIGhwb2ludC53ICE9IDEuMCApIHtcblxuXHRcdC8vIHByb2plY3QgdG8gM0Qgc3BhY2U6ICh3eCwgd3ksIHd6LCB3KSAtPiAoeCwgeSwgeiwgMSlcblx0XHRocG9pbnQuZGl2aWRlU2NhbGFyKCBocG9pbnQudyApO1xuXG5cdH1cblxuXHRyZXR1cm4gcG9pbnQuc2V0KCBocG9pbnQueCwgaHBvaW50LnksIGhwb2ludC56ICk7XG5cbn07XG5cblxuTlVSQlNDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0dmFyIHRhbmdlbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG5cdHZhciB1ID0gdGhpcy5rbm90c1sgMCBdICsgdCAqICggdGhpcy5rbm90c1sgdGhpcy5rbm90cy5sZW5ndGggLSAxIF0gLSB0aGlzLmtub3RzWyAwIF0gKTtcblx0dmFyIGRlcnMgPSBOVVJCU1V0aWxzLmNhbGNOVVJCU0Rlcml2YXRpdmVzKCB0aGlzLmRlZ3JlZSwgdGhpcy5rbm90cywgdGhpcy5jb250cm9sUG9pbnRzLCB1LCAxICk7XG5cdHRhbmdlbnQuY29weSggZGVyc1sgMSBdICkubm9ybWFsaXplKCk7XG5cblx0cmV0dXJuIHRhbmdlbnQ7XG5cbn07XG5cbi8qKlxuICogTG9hZGVyIGxvYWRzIEZCWCBmaWxlIGFuZCBnZW5lcmF0ZXMgR3JvdXAgcmVwcmVzZW50aW5nIEZCWCBzY2VuZS5cbiAqIFJlcXVpcmVzIEZCWCBmaWxlIHRvIGJlID49IDcuMCBhbmQgaW4gQVNDSUkgb3IgPj0gNjQwMCBpbiBCaW5hcnkgZm9ybWF0XG4gKiBWZXJzaW9ucyBsb3dlciB0aGFuIHRoaXMgbWF5IGxvYWQgYnV0IHdpbGwgcHJvYmFibHkgaGF2ZSBlcnJvcnNcbiAqXG4gKiBOZWVkcyBTdXBwb3J0OlxuICogIE1vcnBoIG5vcm1hbHMgLyBibGVuZCBzaGFwZSBub3JtYWxzXG4gKlxuICogRkJYIGZvcm1hdCByZWZlcmVuY2VzOlxuICogXHRodHRwczovL3dpa2kuYmxlbmRlci5vcmcvaW5kZXgucGhwL1VzZXI6TW9udDI5L0ZvdW5kYXRpb24vRkJYX0ZpbGVfU3RydWN0dXJlXG4gKiBcdGh0dHA6Ly9oZWxwLmF1dG9kZXNrLmNvbS92aWV3L0ZCWC8yMDE3L0VOVS8/Z3VpZD1fX2NwcF9yZWZfaW5kZXhfaHRtbCAoQysrIFNESyByZWZlcmVuY2UpXG4gKlxuICogXHRCaW5hcnkgZm9ybWF0IHNwZWNpZmljYXRpb246XG4gKlx0XHRodHRwczovL2NvZGUuYmxlbmRlci5vcmcvMjAxMy8wOC9mYngtYmluYXJ5LWZpbGUtZm9ybWF0LXNwZWNpZmljYXRpb24vXG4gKi9cblxuXG52YXIgRkJYTG9hZGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGZieFRyZWU7XG5cdHZhciBjb25uZWN0aW9ucztcblx0dmFyIHNjZW5lR3JhcGg7XG5cblx0ZnVuY3Rpb24gRkJYTG9hZGVyKCBtYW5hZ2VyICkge1xuXG5cdFx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdH1cblxuXHRGQlhMb2FkZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTG9hZGVyJDEucHJvdG90eXBlICksIHtcblxuXHRcdGNvbnN0cnVjdG9yOiBGQlhMb2FkZXIsXG5cblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcGF0aCA9ICggc2NvcGUucGF0aCA9PT0gJycgKSA/IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKSA6IHNjb3BlLnBhdGg7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggc2NvcGUucGF0aCApO1xuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXHRcdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHNjb3BlLndpdGhDcmVkZW50aWFscyApO1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggYnVmZmVyLCBwYXRoICkgKTtcblxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdFx0b25FcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIEZCWEJ1ZmZlciwgcGF0aCApIHtcblxuXHRcdFx0aWYgKCBpc0ZieEZvcm1hdEJpbmFyeSggRkJYQnVmZmVyICkgKSB7XG5cblx0XHRcdFx0ZmJ4VHJlZSA9IG5ldyBCaW5hcnlQYXJzZXIoKS5wYXJzZSggRkJYQnVmZmVyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIEZCWFRleHQgPSBjb252ZXJ0QXJyYXlCdWZmZXJUb1N0cmluZyggRkJYQnVmZmVyICk7XG5cblx0XHRcdFx0aWYgKCAhIGlzRmJ4Rm9ybWF0QVNDSUkoIEZCWFRleHQgKSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBmb3JtYXQuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdldEZieFZlcnNpb24oIEZCWFRleHQgKSA8IDcwMDAgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IEZCWCB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWQsIEZpbGVWZXJzaW9uOiAnICsgZ2V0RmJ4VmVyc2lvbiggRkJYVGV4dCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZieFRyZWUgPSBuZXcgVGV4dFBhcnNlcigpLnBhcnNlKCBGQlhUZXh0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc29sZS5sb2coIGZieFRyZWUgKTtcblxuXHRcdFx0dmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlciggdGhpcy5tYW5hZ2VyICkuc2V0UGF0aCggdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aCApLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cblx0XHRcdHJldHVybiBuZXcgRkJYVHJlZVBhcnNlciggdGV4dHVyZUxvYWRlciwgdGhpcy5tYW5hZ2VyICkucGFyc2UoIGZieFRyZWUgKTtcblxuXHRcdH1cblxuXHR9ICk7XG5cblx0Ly8gUGFyc2UgdGhlIEZCWFRyZWUgb2JqZWN0IHJldHVybmVkIGJ5IHRoZSBCaW5hcnlQYXJzZXIgb3IgVGV4dFBhcnNlciBhbmQgcmV0dXJuIGEgR3JvdXBcblx0ZnVuY3Rpb24gRkJYVHJlZVBhcnNlciggdGV4dHVyZUxvYWRlciwgbWFuYWdlciApIHtcblxuXHRcdHRoaXMudGV4dHVyZUxvYWRlciA9IHRleHR1cmVMb2FkZXI7XG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuXHR9XG5cblx0RkJYVHJlZVBhcnNlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogRkJYVHJlZVBhcnNlcixcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGNvbm5lY3Rpb25zID0gdGhpcy5wYXJzZUNvbm5lY3Rpb25zKCk7XG5cblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCk7XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGltYWdlcyApO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIHRleHR1cmVzICk7XG5cdFx0XHR2YXIgZGVmb3JtZXJzID0gdGhpcy5wYXJzZURlZm9ybWVycygpO1xuXHRcdFx0dmFyIGdlb21ldHJ5TWFwID0gbmV3IEdlb21ldHJ5UGFyc2VyKCkucGFyc2UoIGRlZm9ybWVycyApO1xuXG5cdFx0XHR0aGlzLnBhcnNlU2NlbmUoIGRlZm9ybWVycywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFscyApO1xuXG5cdFx0XHRyZXR1cm4gc2NlbmVHcmFwaDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZXMgRkJYVHJlZS5Db25uZWN0aW9ucyB3aGljaCBob2xkcyBwYXJlbnQtY2hpbGQgY29ubmVjdGlvbnMgYmV0d2VlbiBvYmplY3RzIChlLmcuIG1hdGVyaWFsIC0+IHRleHR1cmUsIG1vZGVsLT5nZW9tZXRyeSApXG5cdFx0Ly8gYW5kIGRldGFpbHMgdGhlIGNvbm5lY3Rpb24gdHlwZVxuXHRcdHBhcnNlQ29ubmVjdGlvbnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGNvbm5lY3Rpb25NYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGlmICggJ0Nvbm5lY3Rpb25zJyBpbiBmYnhUcmVlICkge1xuXG5cdFx0XHRcdHZhciByYXdDb25uZWN0aW9ucyA9IGZieFRyZWUuQ29ubmVjdGlvbnMuY29ubmVjdGlvbnM7XG5cblx0XHRcdFx0cmF3Q29ubmVjdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdDb25uZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0dmFyIGZyb21JRCA9IHJhd0Nvbm5lY3Rpb25bIDAgXTtcblx0XHRcdFx0XHR2YXIgdG9JRCA9IHJhd0Nvbm5lY3Rpb25bIDEgXTtcblx0XHRcdFx0XHR2YXIgcmVsYXRpb25zaGlwID0gcmF3Q29ubmVjdGlvblsgMiBdO1xuXG5cdFx0XHRcdFx0aWYgKCAhIGNvbm5lY3Rpb25NYXAuaGFzKCBmcm9tSUQgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29ubmVjdGlvbk1hcC5zZXQoIGZyb21JRCwge1xuXHRcdFx0XHRcdFx0XHRwYXJlbnRzOiBbXSxcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcGFyZW50UmVsYXRpb25zaGlwID0geyBJRDogdG9JRCwgcmVsYXRpb25zaGlwOiByZWxhdGlvbnNoaXAgfTtcblx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLmdldCggZnJvbUlEICkucGFyZW50cy5wdXNoKCBwYXJlbnRSZWxhdGlvbnNoaXAgKTtcblxuXHRcdFx0XHRcdGlmICggISBjb25uZWN0aW9uTWFwLmhhcyggdG9JRCApICkge1xuXG5cdFx0XHRcdFx0XHRjb25uZWN0aW9uTWFwLnNldCggdG9JRCwge1xuXHRcdFx0XHRcdFx0XHRwYXJlbnRzOiBbXSxcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY2hpbGRSZWxhdGlvbnNoaXAgPSB7IElEOiBmcm9tSUQsIHJlbGF0aW9uc2hpcDogcmVsYXRpb25zaGlwIH07XG5cdFx0XHRcdFx0Y29ubmVjdGlvbk1hcC5nZXQoIHRvSUQgKS5jaGlsZHJlbi5wdXNoKCBjaGlsZFJlbGF0aW9uc2hpcCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29ubmVjdGlvbk1hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBGQlhUcmVlLk9iamVjdHMuVmlkZW8gZm9yIGVtYmVkZGVkIGltYWdlIGRhdGFcblx0XHQvLyBUaGVzZSBpbWFnZXMgYXJlIGNvbm5lY3RlZCB0byB0ZXh0dXJlcyBpbiBGQlhUcmVlLk9iamVjdHMuVGV4dHVyZXNcblx0XHQvLyB2aWEgRkJYVHJlZS5Db25uZWN0aW9ucy5cblx0XHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgaW1hZ2VzID0ge307XG5cdFx0XHR2YXIgYmxvYnMgPSB7fTtcblxuXHRcdFx0aWYgKCAnVmlkZW8nIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgdmlkZW9Ob2RlcyA9IGZieFRyZWUuT2JqZWN0cy5WaWRlbztcblxuXHRcdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHZpZGVvTm9kZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgdmlkZW9Ob2RlID0gdmlkZW9Ob2Rlc1sgbm9kZUlEIF07XG5cblx0XHRcdFx0XHR2YXIgaWQgPSBwYXJzZUludCggbm9kZUlEICk7XG5cblx0XHRcdFx0XHRpbWFnZXNbIGlkIF0gPSB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWU7XG5cblx0XHRcdFx0XHQvLyByYXcgaW1hZ2UgZGF0YSBpcyBpbiB2aWRlb05vZGUuQ29udGVudFxuXHRcdFx0XHRcdGlmICggJ0NvbnRlbnQnIGluIHZpZGVvTm9kZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGFycmF5QnVmZmVyQ29udGVudCA9ICggdmlkZW9Ob2RlLkNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApICYmICggdmlkZW9Ob2RlLkNvbnRlbnQuYnl0ZUxlbmd0aCA+IDAgKTtcblx0XHRcdFx0XHRcdHZhciBiYXNlNjRDb250ZW50ID0gKCB0eXBlb2YgdmlkZW9Ob2RlLkNvbnRlbnQgPT09ICdzdHJpbmcnICkgJiYgKCB2aWRlb05vZGUuQ29udGVudCAhPT0gJycgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBhcnJheUJ1ZmZlckNvbnRlbnQgfHwgYmFzZTY0Q29udGVudCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLnBhcnNlSW1hZ2UoIHZpZGVvTm9kZXNbIG5vZGVJRCBdICk7XG5cblx0XHRcdFx0XHRcdFx0YmxvYnNbIHZpZGVvTm9kZS5SZWxhdGl2ZUZpbGVuYW1lIHx8IHZpZGVvTm9kZS5GaWxlbmFtZSBdID0gaW1hZ2U7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGlkIGluIGltYWdlcyApIHtcblxuXHRcdFx0XHR2YXIgZmlsZW5hbWUgPSBpbWFnZXNbIGlkIF07XG5cblx0XHRcdFx0aWYgKCBibG9ic1sgZmlsZW5hbWUgXSAhPT0gdW5kZWZpbmVkICkgaW1hZ2VzWyBpZCBdID0gYmxvYnNbIGZpbGVuYW1lIF07XG5cdFx0XHRcdGVsc2UgaW1hZ2VzWyBpZCBdID0gaW1hZ2VzWyBpZCBdLnNwbGl0KCAnXFxcXCcgKS5wb3AoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIGVtYmVkZGVkIGltYWdlIGRhdGEgaW4gRkJYVHJlZS5WaWRlby5Db250ZW50XG5cdFx0cGFyc2VJbWFnZTogZnVuY3Rpb24gKCB2aWRlb05vZGUgKSB7XG5cblx0XHRcdHZhciBjb250ZW50ID0gdmlkZW9Ob2RlLkNvbnRlbnQ7XG5cdFx0XHR2YXIgZmlsZU5hbWUgPSB2aWRlb05vZGUuUmVsYXRpdmVGaWxlbmFtZSB8fCB2aWRlb05vZGUuRmlsZW5hbWU7XG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZmlsZU5hbWUuc2xpY2UoIGZpbGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKSArIDEgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHR2YXIgdHlwZTtcblxuXHRcdFx0c3dpdGNoICggZXh0ZW5zaW9uICkge1xuXG5cdFx0XHRcdGNhc2UgJ2JtcCc6XG5cblx0XHRcdFx0XHR0eXBlID0gJ2ltYWdlL2JtcCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnanBnJzpcblx0XHRcdFx0Y2FzZSAnanBlZyc6XG5cblx0XHRcdFx0XHR0eXBlID0gJ2ltYWdlL2pwZWcnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BuZyc6XG5cblx0XHRcdFx0XHR0eXBlID0gJ2ltYWdlL3BuZyc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGlmJzpcblxuXHRcdFx0XHRcdHR5cGUgPSAnaW1hZ2UvdGlmZic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGdhJzpcblxuXHRcdFx0XHRcdGlmICggdGhpcy5tYW5hZ2VyLmdldEhhbmRsZXIoICcudGdhJyApID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdGQlhMb2FkZXI6IFRHQSBsb2FkZXIgbm90IGZvdW5kLCBza2lwcGluZyAnLCBmaWxlTmFtZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHlwZSA9ICdpbWFnZS90Z2EnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdGQlhMb2FkZXI6IEltYWdlIHR5cGUgXCInICsgZXh0ZW5zaW9uICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyApIHsgLy8gQVNDSUkgZm9ybWF0XG5cblx0XHRcdFx0cmV0dXJuICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArIGNvbnRlbnQ7XG5cblx0XHRcdH0gZWxzZSB7IC8vIEJpbmFyeSBGb3JtYXRcblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheSggY29udGVudCApO1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIG5ldyBCbG9iKCBbIGFycmF5IF0sIHsgdHlwZTogdHlwZSB9ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5UZXh0dXJlXG5cdFx0Ly8gVGhlc2UgY29udGFpbiBkZXRhaWxzIHN1Y2ggYXMgVVYgc2NhbGluZywgY3JvcHBpbmcsIHJvdGF0aW9uIGV0YyBhbmQgYXJlIGNvbm5lY3RlZFxuXHRcdC8vIHRvIGltYWdlcyBpbiBGQlhUcmVlLk9iamVjdHMuVmlkZW9cblx0XHRwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGltYWdlcyApIHtcblxuXHRcdFx0dmFyIHRleHR1cmVNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGlmICggJ1RleHR1cmUnIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgdGV4dHVyZU5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLlRleHR1cmU7XG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gdGV4dHVyZU5vZGVzICkge1xuXG5cdFx0XHRcdFx0dmFyIHRleHR1cmUgPSB0aGlzLnBhcnNlVGV4dHVyZSggdGV4dHVyZU5vZGVzWyBub2RlSUQgXSwgaW1hZ2VzICk7XG5cdFx0XHRcdFx0dGV4dHVyZU1hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZU1hcDtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBpbmRpdmlkdWFsIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLlRleHR1cmVcblx0XHRwYXJzZVRleHR1cmU6IGZ1bmN0aW9uICggdGV4dHVyZU5vZGUsIGltYWdlcyApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSB0aGlzLmxvYWRUZXh0dXJlKCB0ZXh0dXJlTm9kZSwgaW1hZ2VzICk7XG5cblx0XHRcdHRleHR1cmUuSUQgPSB0ZXh0dXJlTm9kZS5pZDtcblxuXHRcdFx0dGV4dHVyZS5uYW1lID0gdGV4dHVyZU5vZGUuYXR0ck5hbWU7XG5cblx0XHRcdHZhciB3cmFwTW9kZVUgPSB0ZXh0dXJlTm9kZS5XcmFwTW9kZVU7XG5cdFx0XHR2YXIgd3JhcE1vZGVWID0gdGV4dHVyZU5vZGUuV3JhcE1vZGVWO1xuXG5cdFx0XHR2YXIgdmFsdWVVID0gd3JhcE1vZGVVICE9PSB1bmRlZmluZWQgPyB3cmFwTW9kZVUudmFsdWUgOiAwO1xuXHRcdFx0dmFyIHZhbHVlViA9IHdyYXBNb2RlViAhPT0gdW5kZWZpbmVkID8gd3JhcE1vZGVWLnZhbHVlIDogMDtcblxuXHRcdFx0Ly8gaHR0cDovL2Rvd25sb2FkLmF1dG9kZXNrLmNvbS91cy9mYngvU0RLZG9jcy9GQlhfU0RLX0hlbHAvZmlsZXMvZmJ4c2RrcmVmL2NsYXNzX2tfZmJ4X3RleHR1cmUuaHRtbCM4ODk2NDBlNjNlMmU2ODEyNTllYTgxMDYxYjg1MTQzYVxuXHRcdFx0Ly8gMDogcmVwZWF0KGRlZmF1bHQpLCAxOiBjbGFtcFxuXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdmFsdWVVID09PSAwID8gUmVwZWF0V3JhcHBpbmcgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXHRcdFx0dGV4dHVyZS53cmFwVCA9IHZhbHVlViA9PT0gMCA/IFJlcGVhdFdyYXBwaW5nIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuXHRcdFx0aWYgKCAnU2NhbGluZycgaW4gdGV4dHVyZU5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRleHR1cmVOb2RlLlNjYWxpbmcudmFsdWU7XG5cblx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueCA9IHZhbHVlc1sgMCBdO1xuXHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC55ID0gdmFsdWVzWyAxIF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0XHR9LFxuXG5cdFx0Ly8gbG9hZCBhIHRleHR1cmUgc3BlY2lmaWVkIGFzIGEgYmxvYiBvciBkYXRhIFVSSSwgb3IgdmlhIGFuIGV4dGVybmFsIFVSTCB1c2luZyBUZXh0dXJlTG9hZGVyXG5cdFx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdGV4dHVyZU5vZGUsIGltYWdlcyApIHtcblxuXHRcdFx0dmFyIGZpbGVOYW1lO1xuXG5cdFx0XHR2YXIgY3VycmVudFBhdGggPSB0aGlzLnRleHR1cmVMb2FkZXIucGF0aDtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gY29ubmVjdGlvbnMuZ2V0KCB0ZXh0dXJlTm9kZS5pZCApLmNoaWxkcmVuO1xuXG5cdFx0XHRpZiAoIGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBpbWFnZXNbIGNoaWxkcmVuWyAwIF0uSUQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGZpbGVOYW1lID0gaW1hZ2VzWyBjaGlsZHJlblsgMCBdLklEIF07XG5cblx0XHRcdFx0aWYgKCBmaWxlTmFtZS5pbmRleE9mKCAnYmxvYjonICkgPT09IDAgfHwgZmlsZU5hbWUuaW5kZXhPZiggJ2RhdGE6JyApID09PSAwICkge1xuXG5cdFx0XHRcdFx0dGhpcy50ZXh0dXJlTG9hZGVyLnNldFBhdGgoIHVuZGVmaW5lZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGV4dHVyZTtcblxuXHRcdFx0dmFyIGV4dGVuc2lvbiA9IHRleHR1cmVOb2RlLkZpbGVOYW1lLnNsaWNlKCAtIDMgKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gJ3RnYScgKSB7XG5cblx0XHRcdFx0dmFyIGxvYWRlciA9IHRoaXMubWFuYWdlci5nZXRIYW5kbGVyKCAnLnRnYScgKTtcblxuXHRcdFx0XHRpZiAoIGxvYWRlciA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0ZCWExvYWRlcjogVEdBIGxvYWRlciBub3QgZm91bmQsIGNyZWF0aW5nIHBsYWNlaG9sZGVyIHRleHR1cmUgZm9yJywgdGV4dHVyZU5vZGUuUmVsYXRpdmVGaWxlbmFtZSApO1xuXHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZpbGVOYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBleHRlbnNpb24gPT09ICdwc2QnICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ0ZCWExvYWRlcjogUFNEIHRleHR1cmVzIGFyZSBub3Qgc3VwcG9ydGVkLCBjcmVhdGluZyBwbGFjZWhvbGRlciB0ZXh0dXJlIGZvcicsIHRleHR1cmVOb2RlLlJlbGF0aXZlRmlsZW5hbWUgKTtcblx0XHRcdFx0dGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGV4dHVyZSA9IHRoaXMudGV4dHVyZUxvYWRlci5sb2FkKCBmaWxlTmFtZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGV4dHVyZUxvYWRlci5zZXRQYXRoKCBjdXJyZW50UGF0aCApO1xuXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuTWF0ZXJpYWxcblx0XHRwYXJzZU1hdGVyaWFsczogZnVuY3Rpb24gKCB0ZXh0dXJlTWFwICkge1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWxNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGlmICggJ01hdGVyaWFsJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuTWF0ZXJpYWw7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiBtYXRlcmlhbE5vZGVzICkge1xuXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5wYXJzZU1hdGVyaWFsKCBtYXRlcmlhbE5vZGVzWyBub2RlSUQgXSwgdGV4dHVyZU1hcCApO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCAhPT0gbnVsbCApIG1hdGVyaWFsTWFwLnNldCggcGFyc2VJbnQoIG5vZGVJRCApLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxNYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLk1hdGVyaWFsXG5cdFx0Ly8gTWF0ZXJpYWxzIGFyZSBjb25uZWN0ZWQgdG8gdGV4dHVyZSBtYXBzIGluIEZCWFRyZWUuT2JqZWN0cy5UZXh0dXJlc1xuXHRcdC8vIEZCWCBmb3JtYXQgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgTGFtYmVydCBhbmQgUGhvbmcgc2hhZGluZyBtb2RlbHNcblx0XHRwYXJzZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG1hdGVyaWFsTm9kZSwgdGV4dHVyZU1hcCApIHtcblxuXHRcdFx0dmFyIElEID0gbWF0ZXJpYWxOb2RlLmlkO1xuXHRcdFx0dmFyIG5hbWUgPSBtYXRlcmlhbE5vZGUuYXR0ck5hbWU7XG5cdFx0XHR2YXIgdHlwZSA9IG1hdGVyaWFsTm9kZS5TaGFkaW5nTW9kZWw7XG5cblx0XHRcdC8vIENhc2Ugd2hlcmUgRkJYIHdyYXBzIHNoYWRpbmcgbW9kZWwgaW4gcHJvcGVydHkgb2JqZWN0LlxuXHRcdFx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0dHlwZSA9IHR5cGUudmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWdub3JlIHVudXNlZCBtYXRlcmlhbHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbnkgY29ubmVjdGlvbnMuXG5cdFx0XHRpZiAoICEgY29ubmVjdGlvbnMuaGFzKCBJRCApICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJzZVBhcmFtZXRlcnMoIG1hdGVyaWFsTm9kZSwgdGV4dHVyZU1hcCwgSUQgKTtcblxuXHRcdFx0dmFyIG1hdGVyaWFsO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlLnRvTG93ZXJDYXNlKCkgKSB7XG5cblx0XHRcdFx0Y2FzZSAncGhvbmcnOlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IHVua25vd24gbWF0ZXJpYWwgdHlwZSBcIiVzXCIuIERlZmF1bHRpbmcgdG8gTWVzaFBob25nTWF0ZXJpYWwuJywgdHlwZSApO1xuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gbmFtZTtcblxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIEZCWCBtYXRlcmlhbCBhbmQgcmV0dXJuIHBhcmFtZXRlcnMgc3VpdGFibGUgZm9yIGEgdGhyZWUuanMgbWF0ZXJpYWxcblx0XHQvLyBBbHNvIHBhcnNlIHRoZSB0ZXh0dXJlIG1hcCBhbmQgcmV0dXJuIGFueSB0ZXh0dXJlcyBhc3NvY2lhdGVkIHdpdGggdGhlIG1hdGVyaWFsXG5cdFx0cGFyc2VQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoIG1hdGVyaWFsTm9kZSwgdGV4dHVyZU1hcCwgSUQgKSB7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0ge307XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLkJ1bXBGYWN0b3IgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5idW1wU2NhbGUgPSBtYXRlcmlhbE5vZGUuQnVtcEZhY3Rvci52YWx1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5EaWZmdXNlICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuY29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5EaWZmdXNlLnZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsTm9kZS5EaWZmdXNlQ29sb3IgJiYgKCBtYXRlcmlhbE5vZGUuRGlmZnVzZUNvbG9yLnR5cGUgPT09ICdDb2xvcicgfHwgbWF0ZXJpYWxOb2RlLkRpZmZ1c2VDb2xvci50eXBlID09PSAnQ29sb3JSR0InICkgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIGJsZW5kZXIgZXhwb3J0ZXIgZXhwb3J0cyBkaWZmdXNlIGhlcmUgaW5zdGVhZCBvZiBpbiBtYXRlcmlhbE5vZGUuRGlmZnVzZVxuXHRcdFx0XHRwYXJhbWV0ZXJzLmNvbG9yID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuRGlmZnVzZUNvbG9yLnZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuRGlzcGxhY2VtZW50RmFjdG9yICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50U2NhbGUgPSBtYXRlcmlhbE5vZGUuRGlzcGxhY2VtZW50RmFjdG9yLnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZS52YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVDb2xvciAmJiAoIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZUNvbG9yLnR5cGUgPT09ICdDb2xvcicgfHwgbWF0ZXJpYWxOb2RlLkVtaXNzaXZlQ29sb3IudHlwZSA9PT0gJ0NvbG9yUkdCJyApICkge1xuXG5cdFx0XHRcdC8vIFRoZSBibGVuZGVyIGV4cG9ydGVyIGV4cG9ydHMgZW1pc3NpdmUgY29sb3IgaGVyZSBpbnN0ZWFkIG9mIGluIG1hdGVyaWFsTm9kZS5FbWlzc2l2ZVxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlID0gbmV3IENvbG9yKCkuZnJvbUFycmF5KCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVDb2xvci52YWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLkVtaXNzaXZlRmFjdG9yICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVJbnRlbnNpdHkgPSBwYXJzZUZsb2F0KCBtYXRlcmlhbE5vZGUuRW1pc3NpdmVGYWN0b3IudmFsdWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsTm9kZS5PcGFjaXR5ICkge1xuXG5cdFx0XHRcdHBhcmFtZXRlcnMub3BhY2l0eSA9IHBhcnNlRmxvYXQoIG1hdGVyaWFsTm9kZS5PcGFjaXR5LnZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzLm9wYWNpdHkgPCAxLjAgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuUmVmbGVjdGlvbkZhY3RvciApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eSA9IG1hdGVyaWFsTm9kZS5SZWZsZWN0aW9uRmFjdG9yLnZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWxOb2RlLlNoaW5pbmVzcyApIHtcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoaW5pbmVzcyA9IG1hdGVyaWFsTm9kZS5TaGluaW5lc3MudmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBtYXRlcmlhbE5vZGUuU3BlY3VsYXIgKSB7XG5cblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhciA9IG5ldyBDb2xvcigpLmZyb21BcnJheSggbWF0ZXJpYWxOb2RlLlNwZWN1bGFyLnZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsTm9kZS5TcGVjdWxhckNvbG9yICYmIG1hdGVyaWFsTm9kZS5TcGVjdWxhckNvbG9yLnR5cGUgPT09ICdDb2xvcicgKSB7XG5cblx0XHRcdFx0Ly8gVGhlIGJsZW5kZXIgZXhwb3J0ZXIgZXhwb3J0cyBzcGVjdWxhciBjb2xvciBoZXJlIGluc3RlYWQgb2YgaW4gbWF0ZXJpYWxOb2RlLlNwZWN1bGFyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIG1hdGVyaWFsTm9kZS5TcGVjdWxhckNvbG9yLnZhbHVlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdGNvbm5lY3Rpb25zLmdldCggSUQgKS5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdHZhciB0eXBlID0gY2hpbGQucmVsYXRpb25zaGlwO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdCdW1wJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ01heWF8VEVYX2FvX21hcCc6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRGlmZnVzZUNvbG9yJzpcblx0XHRcdFx0XHRjYXNlICdNYXlhfFRFWF9jb2xvcl9tYXAnOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5tYXAgPSBzY29wZS5nZXRUZXh0dXJlKCB0ZXh0dXJlTWFwLCBjaGlsZC5JRCApO1xuXHRcdFx0XHRcdFx0cGFyYW1ldGVycy5tYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0Rpc3BsYWNlbWVudENvbG9yJzpcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRW1pc3NpdmVDb2xvcic6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ05vcm1hbE1hcCc6XG5cdFx0XHRcdFx0Y2FzZSAnTWF5YXxURVhfbm9ybWFsX21hcCc6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1JlZmxlY3Rpb25Db2xvcic6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA9IHNjb3BlLmdldFRleHR1cmUoIHRleHR1cmVNYXAsIGNoaWxkLklEICk7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcC5tYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcC5lbmNvZGluZyA9IHNSR0JFbmNvZGluZztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnU3BlY3VsYXJDb2xvcic6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAuZW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RyYW5zcGFyZW50Q29sb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1RyYW5zcGFyZW5jeUZhY3Rvcic6XG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID0gc2NvcGUuZ2V0VGV4dHVyZSggdGV4dHVyZU1hcCwgY2hpbGQuSUQgKTtcblx0XHRcdFx0XHRcdHBhcmFtZXRlcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdBbWJpZW50Q29sb3InOlxuXHRcdFx0XHRcdGNhc2UgJ1NoaW5pbmVzc0V4cG9uZW50JzogLy8gQUtBIGdsb3NzaW5lc3MgbWFwXG5cdFx0XHRcdFx0Y2FzZSAnU3BlY3VsYXJGYWN0b3InOiAvLyBBS0Egc3BlY3VsYXJMZXZlbFxuXHRcdFx0XHRcdGNhc2UgJ1ZlY3RvckRpc3BsYWNlbWVudENvbG9yJzogLy8gTk9URTogU2VlbXMgdG8gYmUgYSBjb3B5IG9mIERpc3BsYWNlbWVudENvbG9yXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogJXMgbWFwIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhyZWUuanMsIHNraXBwaW5nIHRleHR1cmUuJywgdHlwZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG5cdFx0fSxcblxuXHRcdC8vIGdldCBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZU1hcCBmb3IgdXNlIGJ5IGEgbWF0ZXJpYWwuXG5cdFx0Z2V0VGV4dHVyZTogZnVuY3Rpb24gKCB0ZXh0dXJlTWFwLCBpZCApIHtcblxuXHRcdFx0Ly8gaWYgdGhlIHRleHR1cmUgaXMgYSBsYXllcmVkIHRleHR1cmUsIGp1c3QgdXNlIHRoZSBmaXJzdCBsYXllciBhbmQgaXNzdWUgYSB3YXJuaW5nXG5cdFx0XHRpZiAoICdMYXllcmVkVGV4dHVyZScgaW4gZmJ4VHJlZS5PYmplY3RzICYmIGlkIGluIGZieFRyZWUuT2JqZWN0cy5MYXllcmVkVGV4dHVyZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhyZWUuanMuIERpc2NhcmRpbmcgYWxsIGJ1dCBmaXJzdCBsYXllci4nICk7XG5cdFx0XHRcdGlkID0gY29ubmVjdGlvbnMuZ2V0KCBpZCApLmNoaWxkcmVuWyAwIF0uSUQ7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRleHR1cmVNYXAuZ2V0KCBpZCApO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5EZWZvcm1lclxuXHRcdC8vIERlZm9ybWVyIG5vZGUgY2FuIGNvbnRhaW4gc2tpbm5pbmcgb3IgVmVydGV4IENhY2hlIGFuaW1hdGlvbiBkYXRhLCBob3dldmVyIG9ubHkgc2tpbm5pbmcgaXMgc3VwcG9ydGVkIGhlcmVcblx0XHQvLyBHZW5lcmF0ZXMgbWFwIG9mIFNrZWxldG9uLWxpa2Ugb2JqZWN0cyBmb3IgdXNlIGxhdGVyIHdoZW4gZ2VuZXJhdGluZyBhbmQgYmluZGluZyBza2VsZXRvbnMuXG5cdFx0cGFyc2VEZWZvcm1lcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHNrZWxldG9ucyA9IHt9O1xuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0XHRpZiAoICdEZWZvcm1lcicgaW4gZmJ4VHJlZS5PYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciBEZWZvcm1lck5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLkRlZm9ybWVyO1xuXG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gRGVmb3JtZXJOb2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciBkZWZvcm1lck5vZGUgPSBEZWZvcm1lck5vZGVzWyBub2RlSUQgXTtcblxuXHRcdFx0XHRcdHZhciByZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKTtcblxuXHRcdFx0XHRcdGlmICggZGVmb3JtZXJOb2RlLmF0dHJUeXBlID09PSAnU2tpbicgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBza2VsZXRvbiA9IHRoaXMucGFyc2VTa2VsZXRvbiggcmVsYXRpb25zaGlwcywgRGVmb3JtZXJOb2RlcyApO1xuXHRcdFx0XHRcdFx0c2tlbGV0b24uSUQgPSBub2RlSUQ7XG5cblx0XHRcdFx0XHRcdGlmICggcmVsYXRpb25zaGlwcy5wYXJlbnRzLmxlbmd0aCA+IDEgKSBjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IHNrZWxldG9uIGF0dGFjaGVkIHRvIG1vcmUgdGhhbiBvbmUgZ2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZC4nICk7XG5cdFx0XHRcdFx0XHRza2VsZXRvbi5nZW9tZXRyeUlEID0gcmVsYXRpb25zaGlwcy5wYXJlbnRzWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdHNrZWxldG9uc1sgbm9kZUlEIF0gPSBza2VsZXRvbjtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRlZm9ybWVyTm9kZS5hdHRyVHlwZSA9PT0gJ0JsZW5kU2hhcGUnICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSB7XG5cdFx0XHRcdFx0XHRcdGlkOiBub2RlSUQsXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldC5yYXdUYXJnZXRzID0gdGhpcy5wYXJzZU1vcnBoVGFyZ2V0cyggcmVsYXRpb25zaGlwcywgRGVmb3JtZXJOb2RlcyApO1xuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXQuaWQgPSBub2RlSUQ7XG5cblx0XHRcdFx0XHRcdGlmICggcmVsYXRpb25zaGlwcy5wYXJlbnRzLmxlbmd0aCA+IDEgKSBjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IG1vcnBoIHRhcmdldCBhdHRhY2hlZCB0byBtb3JlIHRoYW4gb25lIGdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldHNbIG5vZGVJRCBdID0gbW9ycGhUYXJnZXQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cblx0XHRcdFx0c2tlbGV0b25zOiBza2VsZXRvbnMsXG5cdFx0XHRcdG1vcnBoVGFyZ2V0czogbW9ycGhUYXJnZXRzLFxuXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIHNpbmdsZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuRGVmb3JtZXJcblx0XHQvLyBUaGUgdG9wIGxldmVsIHNrZWxldG9uIG5vZGUgaGFzIHR5cGUgJ1NraW4nIGFuZCBzdWIgbm9kZXMgaGF2ZSB0eXBlICdDbHVzdGVyJ1xuXHRcdC8vIEVhY2ggc2tpbiBub2RlIHJlcHJlc2VudHMgYSBza2VsZXRvbiBhbmQgZWFjaCBjbHVzdGVyIG5vZGUgcmVwcmVzZW50cyBhIGJvbmVcblx0XHRwYXJzZVNrZWxldG9uOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGRlZm9ybWVyTm9kZXMgKSB7XG5cblx0XHRcdHZhciByYXdCb25lcyA9IFtdO1xuXG5cdFx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0dmFyIGJvbmVOb2RlID0gZGVmb3JtZXJOb2Rlc1sgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHRpZiAoIGJvbmVOb2RlLmF0dHJUeXBlICE9PSAnQ2x1c3RlcicgKSByZXR1cm47XG5cblx0XHRcdFx0dmFyIHJhd0JvbmUgPSB7XG5cblx0XHRcdFx0XHRJRDogY2hpbGQuSUQsXG5cdFx0XHRcdFx0aW5kaWNlczogW10sXG5cdFx0XHRcdFx0d2VpZ2h0czogW10sXG5cdFx0XHRcdFx0dHJhbnNmb3JtTGluazogbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGJvbmVOb2RlLlRyYW5zZm9ybUxpbmsuYSApLFxuXHRcdFx0XHRcdC8vIHRyYW5zZm9ybTogbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIGJvbmVOb2RlLlRyYW5zZm9ybS5hICksXG5cdFx0XHRcdFx0Ly8gbGlua01vZGU6IGJvbmVOb2RlLk1vZGUsXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAoICdJbmRleGVzJyBpbiBib25lTm9kZSApIHtcblxuXHRcdFx0XHRcdHJhd0JvbmUuaW5kaWNlcyA9IGJvbmVOb2RlLkluZGV4ZXMuYTtcblx0XHRcdFx0XHRyYXdCb25lLndlaWdodHMgPSBib25lTm9kZS5XZWlnaHRzLmE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJhd0JvbmVzLnB1c2goIHJhd0JvbmUgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4ge1xuXG5cdFx0XHRcdHJhd0JvbmVzOiByYXdCb25lcyxcblx0XHRcdFx0Ym9uZXM6IFtdXG5cblx0XHRcdH07XG5cblx0XHR9LFxuXG5cdFx0Ly8gVGhlIHRvcCBsZXZlbCBtb3JwaCBkZWZvcm1lciBub2RlIGhhcyB0eXBlIFwiQmxlbmRTaGFwZVwiIGFuZCBzdWIgbm9kZXMgaGF2ZSB0eXBlIFwiQmxlbmRTaGFwZUNoYW5uZWxcIlxuXHRcdHBhcnNlTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGRlZm9ybWVyTm9kZXMgKSB7XG5cblx0XHRcdHZhciByYXdNb3JwaFRhcmdldHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmVsYXRpb25zaGlwcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gcmVsYXRpb25zaGlwcy5jaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldE5vZGUgPSBkZWZvcm1lck5vZGVzWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdHZhciByYXdNb3JwaFRhcmdldCA9IHtcblxuXHRcdFx0XHRcdG5hbWU6IG1vcnBoVGFyZ2V0Tm9kZS5hdHRyTmFtZSxcblx0XHRcdFx0XHRpbml0aWFsV2VpZ2h0OiBtb3JwaFRhcmdldE5vZGUuRGVmb3JtUGVyY2VudCxcblx0XHRcdFx0XHRpZDogbW9ycGhUYXJnZXROb2RlLmlkLFxuXHRcdFx0XHRcdGZ1bGxXZWlnaHRzOiBtb3JwaFRhcmdldE5vZGUuRnVsbFdlaWdodHMuYVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldE5vZGUuYXR0clR5cGUgIT09ICdCbGVuZFNoYXBlQ2hhbm5lbCcgKSByZXR1cm47XG5cblx0XHRcdFx0cmF3TW9ycGhUYXJnZXQuZ2VvSUQgPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBjaGlsZC5JRCApICkuY2hpbGRyZW4uZmlsdGVyKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNoaWxkLnJlbGF0aW9uc2hpcCA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdH0gKVsgMCBdLklEO1xuXG5cdFx0XHRcdHJhd01vcnBoVGFyZ2V0cy5wdXNoKCByYXdNb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByYXdNb3JwaFRhcmdldHM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gY3JlYXRlIHRoZSBtYWluIEdyb3VwKCkgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIGxvYWRlclxuXHRcdHBhcnNlU2NlbmU6IGZ1bmN0aW9uICggZGVmb3JtZXJzLCBnZW9tZXRyeU1hcCwgbWF0ZXJpYWxNYXAgKSB7XG5cblx0XHRcdHNjZW5lR3JhcGggPSBuZXcgR3JvdXAoKTtcblxuXHRcdFx0dmFyIG1vZGVsTWFwID0gdGhpcy5wYXJzZU1vZGVscyggZGVmb3JtZXJzLnNrZWxldG9ucywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICk7XG5cblx0XHRcdHZhciBtb2RlbE5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsO1xuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0bW9kZWxNYXAuZm9yRWFjaCggZnVuY3Rpb24gKCBtb2RlbCApIHtcblxuXHRcdFx0XHR2YXIgbW9kZWxOb2RlID0gbW9kZWxOb2Rlc1sgbW9kZWwuSUQgXTtcblx0XHRcdFx0c2NvcGUuc2V0TG9va0F0UHJvcGVydGllcyggbW9kZWwsIG1vZGVsTm9kZSApO1xuXG5cdFx0XHRcdHZhciBwYXJlbnRDb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zLmdldCggbW9kZWwuSUQgKS5wYXJlbnRzO1xuXG5cdFx0XHRcdHBhcmVudENvbm5lY3Rpb25zLmZvckVhY2goIGZ1bmN0aW9uICggY29ubmVjdGlvbiApIHtcblxuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBtb2RlbE1hcC5nZXQoIGNvbm5lY3Rpb24uSUQgKTtcblx0XHRcdFx0XHRpZiAoIHBhcmVudCAhPT0gdW5kZWZpbmVkICkgcGFyZW50LmFkZCggbW9kZWwgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBtb2RlbC5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRzY2VuZUdyYXBoLmFkZCggbW9kZWwgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fSApO1xuXG5cdFx0XHR0aGlzLmJpbmRTa2VsZXRvbiggZGVmb3JtZXJzLnNrZWxldG9ucywgZ2VvbWV0cnlNYXAsIG1vZGVsTWFwICk7XG5cblx0XHRcdHRoaXMuY3JlYXRlQW1iaWVudExpZ2h0KCk7XG5cblx0XHRcdHRoaXMuc2V0dXBNb3JwaE1hdGVyaWFscygpO1xuXG5cdFx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGUucGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRub2RlLnVzZXJEYXRhLnRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4ID0gbm9kZS5wYXJlbnQubWF0cml4O1xuXHRcdFx0XHRcdFx0bm9kZS51c2VyRGF0YS50cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeFdvcmxkID0gbm9kZS5wYXJlbnQubWF0cml4V29ybGQ7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gZ2VuZXJhdGVUcmFuc2Zvcm0oIG5vZGUudXNlckRhdGEudHJhbnNmb3JtRGF0YSApO1xuXG5cdFx0XHRcdFx0bm9kZS5hcHBseU1hdHJpeDQoIHRyYW5zZm9ybSApO1xuXHRcdFx0XHRcdG5vZGUudXBkYXRlV29ybGRNYXRyaXgoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9uUGFyc2VyKCkucGFyc2UoKTtcblxuXHRcdFx0Ly8gaWYgYWxsIHRoZSBtb2RlbHMgd2hlcmUgYWxyZWFkeSBjb21iaW5lZCBpbiBhIHNpbmdsZSBncm91cCwganVzdCByZXR1cm4gdGhhdFxuXHRcdFx0aWYgKCBzY2VuZUdyYXBoLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzY2VuZUdyYXBoLmNoaWxkcmVuWyAwIF0uaXNHcm91cCApIHtcblxuXHRcdFx0XHRzY2VuZUdyYXBoLmNoaWxkcmVuWyAwIF0uYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5cdFx0XHRcdHNjZW5lR3JhcGggPSBzY2VuZUdyYXBoLmNoaWxkcmVuWyAwIF07XG5cblx0XHRcdH1cblxuXHRcdFx0c2NlbmVHcmFwaC5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuTW9kZWxcblx0XHRwYXJzZU1vZGVsczogZnVuY3Rpb24gKCBza2VsZXRvbnMsIGdlb21ldHJ5TWFwLCBtYXRlcmlhbE1hcCApIHtcblxuXHRcdFx0dmFyIG1vZGVsTWFwID0gbmV3IE1hcCgpO1xuXHRcdFx0dmFyIG1vZGVsTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuTW9kZWw7XG5cblx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gbW9kZWxOb2RlcyApIHtcblxuXHRcdFx0XHR2YXIgaWQgPSBwYXJzZUludCggbm9kZUlEICk7XG5cdFx0XHRcdHZhciBub2RlID0gbW9kZWxOb2Rlc1sgbm9kZUlEIF07XG5cdFx0XHRcdHZhciByZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBpZCApO1xuXG5cdFx0XHRcdHZhciBtb2RlbCA9IHRoaXMuYnVpbGRTa2VsZXRvbiggcmVsYXRpb25zaGlwcywgc2tlbGV0b25zLCBpZCwgbm9kZS5hdHRyTmFtZSApO1xuXG5cdFx0XHRcdGlmICggISBtb2RlbCApIHtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG5vZGUuYXR0clR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0NhbWVyYSc6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVDYW1lcmEoIHJlbGF0aW9uc2hpcHMgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdMaWdodCc6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVMaWdodCggcmVsYXRpb25zaGlwcyApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ01lc2gnOlxuXHRcdFx0XHRcdFx0XHRtb2RlbCA9IHRoaXMuY3JlYXRlTWVzaCggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnTnVyYnNDdXJ2ZSc6XG5cdFx0XHRcdFx0XHRcdG1vZGVsID0gdGhpcy5jcmVhdGVDdXJ2ZSggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdMaW1iTm9kZSc6XG5cdFx0XHRcdFx0XHRjYXNlICdSb290Jzpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgQm9uZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ051bGwnOlxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgR3JvdXAoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtb2RlbC5uYW1lID0gbm9kZS5hdHRyTmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBub2RlLmF0dHJOYW1lICkgOiAnJztcblxuXHRcdFx0XHRcdG1vZGVsLklEID0gaWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZ2V0VHJhbnNmb3JtRGF0YSggbW9kZWwsIG5vZGUgKTtcblx0XHRcdFx0bW9kZWxNYXAuc2V0KCBpZCwgbW9kZWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbW9kZWxNYXA7XG5cblx0XHR9LFxuXG5cdFx0YnVpbGRTa2VsZXRvbjogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBza2VsZXRvbnMsIGlkLCBuYW1lICkge1xuXG5cdFx0XHR2YXIgYm9uZSA9IG51bGw7XG5cblx0XHRcdHJlbGF0aW9uc2hpcHMucGFyZW50cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgSUQgaW4gc2tlbGV0b25zICkge1xuXG5cdFx0XHRcdFx0dmFyIHNrZWxldG9uID0gc2tlbGV0b25zWyBJRCBdO1xuXG5cdFx0XHRcdFx0c2tlbGV0b24ucmF3Qm9uZXMuZm9yRWFjaCggZnVuY3Rpb24gKCByYXdCb25lLCBpICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJhd0JvbmUuSUQgPT09IHBhcmVudC5JRCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3ViQm9uZSA9IGJvbmU7XG5cdFx0XHRcdFx0XHRcdGJvbmUgPSBuZXcgQm9uZSgpO1xuXG5cdFx0XHRcdFx0XHRcdGJvbmUubWF0cml4V29ybGQuY29weSggcmF3Qm9uZS50cmFuc2Zvcm1MaW5rICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2V0IG5hbWUgYW5kIGlkIGhlcmUgLSBvdGhlcndpc2UgaW4gY2FzZXMgd2hlcmUgXCJzdWJCb25lXCIgaXMgY3JlYXRlZCBpdCB3aWxsIG5vdCBoYXZlIGEgbmFtZSAvIGlkXG5cblx0XHRcdFx0XHRcdFx0Ym9uZS5uYW1lID0gbmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCBuYW1lICkgOiAnJztcblx0XHRcdFx0XHRcdFx0Ym9uZS5JRCA9IGlkO1xuXG5cdFx0XHRcdFx0XHRcdHNrZWxldG9uLmJvbmVzWyBpIF0gPSBib25lO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEluIGNhc2VzIHdoZXJlIGEgYm9uZSBpcyBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBtZXNoZXNcblx0XHRcdFx0XHRcdFx0Ly8gZHVwbGljYXRlIHRoZSBib25lIGhlcmUgYW5kIGFuZCBpdCBhcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBib25lXG5cdFx0XHRcdFx0XHRcdGlmICggc3ViQm9uZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGJvbmUuYWRkKCBzdWJCb25lICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBib25lO1xuXG5cdFx0fSxcblxuXHRcdC8vIGNyZWF0ZSBhIFBlcnNwZWN0aXZlQ2FtZXJhIG9yIE9ydGhvZ3JhcGhpY0NhbWVyYVxuXHRcdGNyZWF0ZUNhbWVyYTogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzICkge1xuXG5cdFx0XHR2YXIgbW9kZWw7XG5cdFx0XHR2YXIgY2FtZXJhQXR0cmlidXRlO1xuXG5cdFx0XHRyZWxhdGlvbnNoaXBzLmNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0dmFyIGF0dHIgPSBmYnhUcmVlLk9iamVjdHMuTm9kZUF0dHJpYnV0ZVsgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHRpZiAoIGF0dHIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNhbWVyYUF0dHJpYnV0ZSA9IGF0dHI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bW9kZWwgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgdHlwZSA9IDA7XG5cdFx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLkNhbWVyYVByb2plY3Rpb25UeXBlICE9PSB1bmRlZmluZWQgJiYgY2FtZXJhQXR0cmlidXRlLkNhbWVyYVByb2plY3Rpb25UeXBlLnZhbHVlID09PSAxICkge1xuXG5cdFx0XHRcdFx0dHlwZSA9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBuZWFyQ2xpcHBpbmdQbGFuZSA9IDE7XG5cdFx0XHRcdGlmICggY2FtZXJhQXR0cmlidXRlLk5lYXJQbGFuZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bmVhckNsaXBwaW5nUGxhbmUgPSBjYW1lcmFBdHRyaWJ1dGUuTmVhclBsYW5lLnZhbHVlIC8gMTAwMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZhckNsaXBwaW5nUGxhbmUgPSAxMDAwO1xuXHRcdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5GYXJQbGFuZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0ZmFyQ2xpcHBpbmdQbGFuZSA9IGNhbWVyYUF0dHJpYnV0ZS5GYXJQbGFuZS52YWx1ZSAvIDEwMDA7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0dmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0XHRcdHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cblx0XHRcdFx0aWYgKCBjYW1lcmFBdHRyaWJ1dGUuQXNwZWN0V2lkdGggIT09IHVuZGVmaW5lZCAmJiBjYW1lcmFBdHRyaWJ1dGUuQXNwZWN0SGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR3aWR0aCA9IGNhbWVyYUF0dHJpYnV0ZS5Bc3BlY3RXaWR0aC52YWx1ZTtcblx0XHRcdFx0XHRoZWlnaHQgPSBjYW1lcmFBdHRyaWJ1dGUuQXNwZWN0SGVpZ2h0LnZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG5cblx0XHRcdFx0dmFyIGZvdiA9IDQ1O1xuXHRcdFx0XHRpZiAoIGNhbWVyYUF0dHJpYnV0ZS5GaWVsZE9mVmlldyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Zm92ID0gY2FtZXJhQXR0cmlidXRlLkZpZWxkT2ZWaWV3LnZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgZm9jYWxMZW5ndGggPSBjYW1lcmFBdHRyaWJ1dGUuRm9jYWxMZW5ndGggPyBjYW1lcmFBdHRyaWJ1dGUuRm9jYWxMZW5ndGgudmFsdWUgOiBudWxsO1xuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlIDA6IC8vIFBlcnNwZWN0aXZlXG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXJDbGlwcGluZ1BsYW5lLCBmYXJDbGlwcGluZ1BsYW5lICk7XG5cdFx0XHRcdFx0XHRpZiAoIGZvY2FsTGVuZ3RoICE9PSBudWxsICkgbW9kZWwuc2V0Rm9jYWxMZW5ndGgoIGZvY2FsTGVuZ3RoICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTogLy8gT3J0aG9ncmFwaGljXG5cdFx0XHRcdFx0XHRtb2RlbCA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gd2lkdGggLyAyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIC0gaGVpZ2h0IC8gMiwgbmVhckNsaXBwaW5nUGxhbmUsIGZhckNsaXBwaW5nUGxhbmUgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBjYW1lcmEgdHlwZSAnICsgdHlwZSArICcuJyApO1xuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgT2JqZWN0M0QoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbW9kZWw7XG5cblx0XHR9LFxuXG5cdFx0Ly8gQ3JlYXRlIGEgRGlyZWN0aW9uYWxMaWdodCwgUG9pbnRMaWdodCBvciBTcG90TGlnaHRcblx0XHRjcmVhdGVMaWdodDogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzICkge1xuXG5cdFx0XHR2YXIgbW9kZWw7XG5cdFx0XHR2YXIgbGlnaHRBdHRyaWJ1dGU7XG5cblx0XHRcdHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4uZm9yRWFjaCggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHR2YXIgYXR0ciA9IGZieFRyZWUuT2JqZWN0cy5Ob2RlQXR0cmlidXRlWyBjaGlsZC5JRCBdO1xuXG5cdFx0XHRcdGlmICggYXR0ciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bGlnaHRBdHRyaWJ1dGUgPSBhdHRyO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bW9kZWwgPSBuZXcgT2JqZWN0M0QoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgdHlwZTtcblxuXHRcdFx0XHQvLyBMaWdodFR5cGUgY2FuIGJlIHVuZGVmaW5lZCBmb3IgUG9pbnQgbGlnaHRzXG5cdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuTGlnaHRUeXBlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0eXBlID0gMDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dHlwZSA9IGxpZ2h0QXR0cmlidXRlLkxpZ2h0VHlwZS52YWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvbG9yID0gMHhmZmZmZmY7XG5cblx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5Db2xvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgQ29sb3IoKS5mcm9tQXJyYXkoIGxpZ2h0QXR0cmlidXRlLkNvbG9yLnZhbHVlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpbnRlbnNpdHkgPSAoIGxpZ2h0QXR0cmlidXRlLkludGVuc2l0eSA9PT0gdW5kZWZpbmVkICkgPyAxIDogbGlnaHRBdHRyaWJ1dGUuSW50ZW5zaXR5LnZhbHVlIC8gMTAwO1xuXG5cdFx0XHRcdC8vIGxpZ2h0IGRpc2FibGVkXG5cdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuQ2FzdExpZ2h0T25PYmplY3QgIT09IHVuZGVmaW5lZCAmJiBsaWdodEF0dHJpYnV0ZS5DYXN0TGlnaHRPbk9iamVjdC52YWx1ZSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGludGVuc2l0eSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IDA7XG5cdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuRmFyQXR0ZW51YXRpb25FbmQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggbGlnaHRBdHRyaWJ1dGUuRW5hYmxlRmFyQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCAmJiBsaWdodEF0dHJpYnV0ZS5FbmFibGVGYXJBdHRlbnVhdGlvbi52YWx1ZSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0ZGlzdGFuY2UgPSAwO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlzdGFuY2UgPSBsaWdodEF0dHJpYnV0ZS5GYXJBdHRlbnVhdGlvbkVuZC52YWx1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVE9ETzogY291bGQgdGhpcyBiZSBjYWxjdWxhdGVkIGxpbmVhcmx5IGZyb20gRmFyQXR0ZW51YXRpb25TdGFydCB0byBGYXJBdHRlbnVhdGlvbkVuZD9cblx0XHRcdFx0dmFyIGRlY2F5ID0gMTtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAwOiAvLyBQb2ludFxuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgMTogLy8gRGlyZWN0aW9uYWxcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAyOiAvLyBTcG90XG5cdFx0XHRcdFx0XHR2YXIgYW5nbGUgPSBNYXRoLlBJIC8gMztcblxuXHRcdFx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5Jbm5lckFuZ2xlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoVXRpbHMuZGVnVG9SYWQoIGxpZ2h0QXR0cmlidXRlLklubmVyQW5nbGUudmFsdWUgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgcGVudW1icmEgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKCBsaWdodEF0dHJpYnV0ZS5PdXRlckFuZ2xlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogdGhpcyBpcyBub3QgY29ycmVjdCAtIEZCWCBjYWxjdWxhdGVzIG91dGVyIGFuZCBpbm5lciBhbmdsZSBpbiBkZWdyZWVzXG5cdFx0XHRcdFx0XHRcdC8vIHdpdGggT3V0ZXJBbmdsZSA+IElubmVyQW5nbGUgJiYgT3V0ZXJBbmdsZSA8PSBNYXRoLlBJXG5cdFx0XHRcdFx0XHRcdC8vIHdoaWxlIHRocmVlLmpzIHVzZXMgYSBwZW51bWJyYSBiZXR3ZWVuICgwLCAxKSB0byBhdHRlbnVhdGUgdGhlIGlubmVyIGFuZ2xlXG5cdFx0XHRcdFx0XHRcdHBlbnVtYnJhID0gTWF0aFV0aWxzLmRlZ1RvUmFkKCBsaWdodEF0dHJpYnV0ZS5PdXRlckFuZ2xlLnZhbHVlICk7XG5cdFx0XHRcdFx0XHRcdHBlbnVtYnJhID0gTWF0aC5tYXgoIHBlbnVtYnJhLCAxICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bW9kZWwgPSBuZXcgU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRkJYTG9hZGVyOiBVbmtub3duIGxpZ2h0IHR5cGUgJyArIGxpZ2h0QXR0cmlidXRlLkxpZ2h0VHlwZS52YWx1ZSArICcsIGRlZmF1bHRpbmcgdG8gYSBQb2ludExpZ2h0LicgKTtcblx0XHRcdFx0XHRcdG1vZGVsID0gbmV3IFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGxpZ2h0QXR0cmlidXRlLkNhc3RTaGFkb3dzICE9PSB1bmRlZmluZWQgJiYgbGlnaHRBdHRyaWJ1dGUuQ2FzdFNoYWRvd3MudmFsdWUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRtb2RlbC5jYXN0U2hhZG93ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1vZGVsO1xuXG5cdFx0fSxcblxuXHRcdGNyZWF0ZU1lc2g6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAsIG1hdGVyaWFsTWFwICkge1xuXG5cdFx0XHR2YXIgbW9kZWw7XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBudWxsO1xuXHRcdFx0dmFyIG1hdGVyaWFsID0gbnVsbDtcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBbXTtcblxuXHRcdFx0Ly8gZ2V0IGdlb21ldHJ5IGFuZCBtYXRlcmlhbHMocykgZnJvbSBjb25uZWN0aW9uc1xuXHRcdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlNYXAuaGFzKCBjaGlsZC5JRCApICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeU1hcC5nZXQoIGNoaWxkLklEICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxNYXAuaGFzKCBjaGlsZC5JRCApICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWxzLnB1c2goIG1hdGVyaWFsTWFwLmdldCggY2hpbGQuSUQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gbWF0ZXJpYWxzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG1hdGVyaWFsc1sgMCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG1hdGVyaWFsID0gbmV3IE1lc2hQaG9uZ01hdGVyaWFsKCB7IGNvbG9yOiAweGNjY2NjYyB9ICk7XG5cdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggJ2NvbG9yJyBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdG1hdGVyaWFscy5mb3JFYWNoKCBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5GQlhfRGVmb3JtZXIgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxzLmZvckVhY2goIGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5za2lubmluZyA9IHRydWU7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdG1vZGVsID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHRcdFx0bW9kZWwubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtb2RlbCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbW9kZWw7XG5cblx0XHR9LFxuXG5cdFx0Y3JlYXRlQ3VydmU6IGZ1bmN0aW9uICggcmVsYXRpb25zaGlwcywgZ2VvbWV0cnlNYXAgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeSA9IHJlbGF0aW9uc2hpcHMuY2hpbGRyZW4ucmVkdWNlKCBmdW5jdGlvbiAoIGdlbywgY2hpbGQgKSB7XG5cblx0XHRcdFx0aWYgKCBnZW9tZXRyeU1hcC5oYXMoIGNoaWxkLklEICkgKSBnZW8gPSBnZW9tZXRyeU1hcC5nZXQoIGNoaWxkLklEICk7XG5cblx0XHRcdFx0cmV0dXJuIGdlbztcblxuXHRcdFx0fSwgbnVsbCApO1xuXG5cdFx0XHQvLyBGQlggZG9lcyBub3QgbGlzdCBtYXRlcmlhbHMgZm9yIE51cmJzIGxpbmVzLCBzbyB3ZSdsbCBqdXN0IHB1dCBvdXIgb3duIGluIGhlcmUuXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4MzMwMGZmLCBsaW5ld2lkdGg6IDEgfSApO1xuXHRcdFx0cmV0dXJuIG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSB0aGUgbW9kZWwgbm9kZSBmb3IgdHJhbnNmb3JtIGRhdGFcblx0XHRnZXRUcmFuc2Zvcm1EYXRhOiBmdW5jdGlvbiAoIG1vZGVsLCBtb2RlbE5vZGUgKSB7XG5cblx0XHRcdHZhciB0cmFuc2Zvcm1EYXRhID0ge307XG5cblx0XHRcdGlmICggJ0luaGVyaXRUeXBlJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlID0gcGFyc2VJbnQoIG1vZGVsTm9kZS5Jbmhlcml0VHlwZS52YWx1ZSApO1xuXG5cdFx0XHRpZiAoICdSb3RhdGlvbk9yZGVyJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgPSBnZXRFdWxlck9yZGVyKCBtb2RlbE5vZGUuUm90YXRpb25PcmRlci52YWx1ZSApO1xuXHRcdFx0ZWxzZSB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgPSAnWllYJztcblxuXHRcdFx0aWYgKCAnTGNsX1RyYW5zbGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uID0gbW9kZWxOb2RlLkxjbF9UcmFuc2xhdGlvbi52YWx1ZTtcblxuXHRcdFx0aWYgKCAnUHJlUm90YXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucHJlUm90YXRpb24gPSBtb2RlbE5vZGUuUHJlUm90YXRpb24udmFsdWU7XG5cdFx0XHRpZiAoICdMY2xfUm90YXRpb24nIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb24gPSBtb2RlbE5vZGUuTGNsX1JvdGF0aW9uLnZhbHVlO1xuXHRcdFx0aWYgKCAnUG9zdFJvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnBvc3RSb3RhdGlvbiA9IG1vZGVsTm9kZS5Qb3N0Um90YXRpb24udmFsdWU7XG5cblx0XHRcdGlmICggJ0xjbF9TY2FsaW5nJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnNjYWxlID0gbW9kZWxOb2RlLkxjbF9TY2FsaW5nLnZhbHVlO1xuXG5cdFx0XHRpZiAoICdTY2FsaW5nT2Zmc2V0JyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdPZmZzZXQgPSBtb2RlbE5vZGUuU2NhbGluZ09mZnNldC52YWx1ZTtcblx0XHRcdGlmICggJ1NjYWxpbmdQaXZvdCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsaW5nUGl2b3QgPSBtb2RlbE5vZGUuU2NhbGluZ1Bpdm90LnZhbHVlO1xuXG5cdFx0XHRpZiAoICdSb3RhdGlvbk9mZnNldCcgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5yb3RhdGlvbk9mZnNldCA9IG1vZGVsTm9kZS5Sb3RhdGlvbk9mZnNldC52YWx1ZTtcblx0XHRcdGlmICggJ1JvdGF0aW9uUGl2b3QnIGluIG1vZGVsTm9kZSApIHRyYW5zZm9ybURhdGEucm90YXRpb25QaXZvdCA9IG1vZGVsTm9kZS5Sb3RhdGlvblBpdm90LnZhbHVlO1xuXG5cdFx0XHRtb2RlbC51c2VyRGF0YS50cmFuc2Zvcm1EYXRhID0gdHJhbnNmb3JtRGF0YTtcblxuXHRcdH0sXG5cblx0XHRzZXRMb29rQXRQcm9wZXJ0aWVzOiBmdW5jdGlvbiAoIG1vZGVsLCBtb2RlbE5vZGUgKSB7XG5cblx0XHRcdGlmICggJ0xvb2tBdFByb3BlcnR5JyBpbiBtb2RlbE5vZGUgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gY29ubmVjdGlvbnMuZ2V0KCBtb2RlbC5JRCApLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGNoaWxkcmVuLmZvckVhY2goIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNoaWxkLnJlbGF0aW9uc2hpcCA9PT0gJ0xvb2tBdFByb3BlcnR5JyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGxvb2tBdFRhcmdldCA9IGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCAnTGNsX1RyYW5zbGF0aW9uJyBpbiBsb29rQXRUYXJnZXQgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBvcyA9IGxvb2tBdFRhcmdldC5MY2xfVHJhbnNsYXRpb24udmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRGlyZWN0aW9uYWxMaWdodCwgU3BvdExpZ2h0XG5cdFx0XHRcdFx0XHRcdGlmICggbW9kZWwudGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtb2RlbC50YXJnZXQucG9zaXRpb24uZnJvbUFycmF5KCBwb3MgKTtcblx0XHRcdFx0XHRcdFx0XHRzY2VuZUdyYXBoLmFkZCggbW9kZWwudGFyZ2V0ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gQ2FtZXJhcyBhbmQgb3RoZXIgT2JqZWN0M0RzXG5cblx0XHRcdFx0XHRcdFx0XHRtb2RlbC5sb29rQXQoIG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KCBwb3MgKSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGJpbmRTa2VsZXRvbjogZnVuY3Rpb24gKCBza2VsZXRvbnMsIGdlb21ldHJ5TWFwLCBtb2RlbE1hcCApIHtcblxuXHRcdFx0dmFyIGJpbmRNYXRyaWNlcyA9IHRoaXMucGFyc2VQb3NlTm9kZXMoKTtcblxuXHRcdFx0Zm9yICggdmFyIElEIGluIHNrZWxldG9ucyApIHtcblxuXHRcdFx0XHR2YXIgc2tlbGV0b24gPSBza2VsZXRvbnNbIElEIF07XG5cblx0XHRcdFx0dmFyIHBhcmVudHMgPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBza2VsZXRvbi5JRCApICkucGFyZW50cztcblxuXHRcdFx0XHRwYXJlbnRzLmZvckVhY2goIGZ1bmN0aW9uICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeU1hcC5oYXMoIHBhcmVudC5JRCApICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZ2VvSUQgPSBwYXJlbnQuSUQ7XG5cdFx0XHRcdFx0XHR2YXIgZ2VvUmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggZ2VvSUQgKTtcblxuXHRcdFx0XHRcdFx0Z2VvUmVsYXRpb25zaGlwcy5wYXJlbnRzLmZvckVhY2goIGZ1bmN0aW9uICggZ2VvQ29ublBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1vZGVsTWFwLmhhcyggZ2VvQ29ublBhcmVudC5JRCApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1vZGVsID0gbW9kZWxNYXAuZ2V0KCBnZW9Db25uUGFyZW50LklEICk7XG5cblx0XHRcdFx0XHRcdFx0XHRtb2RlbC5iaW5kKCBuZXcgU2tlbGV0b24oIHNrZWxldG9uLmJvbmVzICksIGJpbmRNYXRyaWNlc1sgZ2VvQ29ublBhcmVudC5JRCBdICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VQb3NlTm9kZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGJpbmRNYXRyaWNlcyA9IHt9O1xuXG5cdFx0XHRpZiAoICdQb3NlJyBpbiBmYnhUcmVlLk9iamVjdHMgKSB7XG5cblx0XHRcdFx0dmFyIEJpbmRQb3NlTm9kZSA9IGZieFRyZWUuT2JqZWN0cy5Qb3NlO1xuXG5cdFx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gQmluZFBvc2VOb2RlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBCaW5kUG9zZU5vZGVbIG5vZGVJRCBdLmF0dHJUeXBlID09PSAnQmluZFBvc2UnICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgcG9zZU5vZGVzID0gQmluZFBvc2VOb2RlWyBub2RlSUQgXS5Qb3NlTm9kZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBwb3NlTm9kZXMgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRwb3NlTm9kZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBwb3NlTm9kZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGJpbmRNYXRyaWNlc1sgcG9zZU5vZGUuTm9kZSBdID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHBvc2VOb2RlLk1hdHJpeC5hICk7XG5cblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdGJpbmRNYXRyaWNlc1sgcG9zZU5vZGVzLk5vZGUgXSA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCBwb3NlTm9kZXMuTWF0cml4LmEgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYmluZE1hdHJpY2VzO1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIGFtYmllbnQgY29sb3IgaW4gRkJYVHJlZS5HbG9iYWxTZXR0aW5ncyAtIGlmIGl0J3Mgbm90IHNldCB0byBibGFjayAoZGVmYXVsdCksIGNyZWF0ZSBhbiBhbWJpZW50IGxpZ2h0XG5cdFx0Y3JlYXRlQW1iaWVudExpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdGlmICggJ0dsb2JhbFNldHRpbmdzJyBpbiBmYnhUcmVlICYmICdBbWJpZW50Q29sb3InIGluIGZieFRyZWUuR2xvYmFsU2V0dGluZ3MgKSB7XG5cblx0XHRcdFx0dmFyIGFtYmllbnRDb2xvciA9IGZieFRyZWUuR2xvYmFsU2V0dGluZ3MuQW1iaWVudENvbG9yLnZhbHVlO1xuXHRcdFx0XHR2YXIgciA9IGFtYmllbnRDb2xvclsgMCBdO1xuXHRcdFx0XHR2YXIgZyA9IGFtYmllbnRDb2xvclsgMSBdO1xuXHRcdFx0XHR2YXIgYiA9IGFtYmllbnRDb2xvclsgMiBdO1xuXG5cdFx0XHRcdGlmICggciAhPT0gMCB8fCBnICE9PSAwIHx8IGIgIT09IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoIHIsIGcsIGIgKTtcblx0XHRcdFx0XHRzY2VuZUdyYXBoLmFkZCggbmV3IEFtYmllbnRMaWdodCggY29sb3IsIDEgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHNldHVwTW9ycGhNYXRlcmlhbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcblx0XHRcdHNjZW5lR3JhcGgudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNoaWxkLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAmJiBjaGlsZC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGNoaWxkLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2hpbGQubWF0ZXJpYWwuZm9yRWFjaCggZnVuY3Rpb24gKCBtYXRlcmlhbCwgaSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHNjb3BlLnNldHVwTW9ycGhNYXRlcmlhbCggY2hpbGQsIG1hdGVyaWFsLCBpICk7XG5cblx0XHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHNjb3BlLnNldHVwTW9ycGhNYXRlcmlhbCggY2hpbGQsIGNoaWxkLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdH0sXG5cblx0XHRzZXR1cE1vcnBoTWF0ZXJpYWw6IGZ1bmN0aW9uICggY2hpbGQsIG1hdGVyaWFsLCBpbmRleCApIHtcblxuXHRcdFx0dmFyIHV1aWQgPSBjaGlsZC51dWlkO1xuXHRcdFx0dmFyIG1hdFV1aWQgPSBtYXRlcmlhbC51dWlkO1xuXG5cdFx0XHQvLyBpZiBhIGdlb21ldHJ5IGhhcyBtb3JwaCB0YXJnZXRzLCBpdCBjYW5ub3Qgc2hhcmUgdGhlIG1hdGVyaWFsIHdpdGggb3RoZXIgZ2VvbWV0cmllc1xuXHRcdFx0dmFyIHNoYXJlZE1hdCA9IGZhbHNlO1xuXG5cdFx0XHRzY2VuZUdyYXBoLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLmlzTWVzaCApIHtcblxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9kZS5tYXRlcmlhbCApICkge1xuXG5cdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFsLmZvckVhY2goIGZ1bmN0aW9uICggbWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0LnV1aWQgPT09IG1hdFV1aWQgJiYgbm9kZS51dWlkICE9PSB1dWlkICkgc2hhcmVkTWF0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5tYXRlcmlhbC51dWlkID09PSBtYXRVdWlkICYmIG5vZGUudXVpZCAhPT0gdXVpZCApIHNoYXJlZE1hdCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggc2hhcmVkTWF0ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciBjbG9uZWRNYXQgPSBtYXRlcmlhbC5jbG9uZSgpO1xuXHRcdFx0XHRjbG9uZWRNYXQubW9ycGhUYXJnZXRzID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSBjaGlsZC5tYXRlcmlhbCA9IGNsb25lZE1hdDtcblx0XHRcdFx0ZWxzZSBjaGlsZC5tYXRlcmlhbFsgaW5kZXggXSA9IGNsb25lZE1hdDtcblxuXHRcdFx0fSBlbHNlIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRydWU7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBwYXJzZSBHZW9tZXRyeSBkYXRhIGZyb20gRkJYVHJlZSBhbmQgcmV0dXJuIG1hcCBvZiBCdWZmZXJHZW9tZXRyaWVzXG5cdGZ1bmN0aW9uIEdlb21ldHJ5UGFyc2VyKCkge31cblxuXHRHZW9tZXRyeVBhcnNlci5wcm90b3R5cGUgPSB7XG5cblx0XHRjb25zdHJ1Y3RvcjogR2VvbWV0cnlQYXJzZXIsXG5cblx0XHQvLyBQYXJzZSBub2RlcyBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnlcblx0XHRwYXJzZTogZnVuY3Rpb24gKCBkZWZvcm1lcnMgKSB7XG5cblx0XHRcdHZhciBnZW9tZXRyeU1hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0aWYgKCAnR2VvbWV0cnknIGluIGZieFRyZWUuT2JqZWN0cyApIHtcblxuXHRcdFx0XHR2YXIgZ2VvTm9kZXMgPSBmYnhUcmVlLk9iamVjdHMuR2VvbWV0cnk7XG5cblx0XHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiBnZW9Ob2RlcyApIHtcblxuXHRcdFx0XHRcdHZhciByZWxhdGlvbnNoaXBzID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKTtcblx0XHRcdFx0XHR2YXIgZ2VvID0gdGhpcy5wYXJzZUdlb21ldHJ5KCByZWxhdGlvbnNoaXBzLCBnZW9Ob2Rlc1sgbm9kZUlEIF0sIGRlZm9ybWVycyApO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnlNYXAuc2V0KCBwYXJzZUludCggbm9kZUlEICksIGdlbyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnlNYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUGFyc2Ugc2luZ2xlIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdFx0cGFyc2VHZW9tZXRyeTogZnVuY3Rpb24gKCByZWxhdGlvbnNoaXBzLCBnZW9Ob2RlLCBkZWZvcm1lcnMgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGdlb05vZGUuYXR0clR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnTWVzaCc6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyc2VNZXNoR2VvbWV0cnkoIHJlbGF0aW9uc2hpcHMsIGdlb05vZGUsIGRlZm9ybWVycyApO1xuXG5cdFx0XHRcdGNhc2UgJ051cmJzQ3VydmUnOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlTnVyYnNHZW9tZXRyeSggZ2VvTm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cblx0XHQvLyBQYXJzZSBzaW5nbGUgbm9kZSBtZXNoIGdlb21ldHJ5IGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRcdHBhcnNlTWVzaEdlb21ldHJ5OiBmdW5jdGlvbiAoIHJlbGF0aW9uc2hpcHMsIGdlb05vZGUsIGRlZm9ybWVycyApIHtcblxuXHRcdFx0dmFyIHNrZWxldG9ucyA9IGRlZm9ybWVycy5za2VsZXRvbnM7XG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRcdHZhciBtb2RlbE5vZGVzID0gcmVsYXRpb25zaGlwcy5wYXJlbnRzLm1hcCggZnVuY3Rpb24gKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZieFRyZWUuT2JqZWN0cy5Nb2RlbFsgcGFyZW50LklEIF07XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gZG9uJ3QgY3JlYXRlIGdlb21ldHJ5IGlmIGl0IGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IG1vZGVsc1xuXHRcdFx0aWYgKCBtb2RlbE5vZGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuXHRcdFx0dmFyIHNrZWxldG9uID0gcmVsYXRpb25zaGlwcy5jaGlsZHJlbi5yZWR1Y2UoIGZ1bmN0aW9uICggc2tlbGV0b24sIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggc2tlbGV0b25zWyBjaGlsZC5JRCBdICE9PSB1bmRlZmluZWQgKSBza2VsZXRvbiA9IHNrZWxldG9uc1sgY2hpbGQuSUQgXTtcblxuXHRcdFx0XHRyZXR1cm4gc2tlbGV0b247XG5cblx0XHRcdH0sIG51bGwgKTtcblxuXHRcdFx0cmVsYXRpb25zaGlwcy5jaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkICkge1xuXG5cdFx0XHRcdGlmICggZGVmb3JtZXJzLm1vcnBoVGFyZ2V0c1sgY2hpbGQuSUQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzLnB1c2goIGRlZm9ybWVycy5tb3JwaFRhcmdldHNbIGNoaWxkLklEIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gQXNzdW1lIG9uZSBtb2RlbCBhbmQgZ2V0IHRoZSBwcmVSb3RhdGlvbiBmcm9tIHRoYXRcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZW9tZXRyeSB0aGlzIG1heSBjYXVzZSBwcm9ibGVtc1xuXHRcdFx0dmFyIG1vZGVsTm9kZSA9IG1vZGVsTm9kZXNbIDAgXTtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybURhdGEgPSB7fTtcblxuXHRcdFx0aWYgKCAnUm90YXRpb25PcmRlcicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyID0gZ2V0RXVsZXJPcmRlciggbW9kZWxOb2RlLlJvdGF0aW9uT3JkZXIudmFsdWUgKTtcblx0XHRcdGlmICggJ0luaGVyaXRUeXBlJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLmluaGVyaXRUeXBlID0gcGFyc2VJbnQoIG1vZGVsTm9kZS5Jbmhlcml0VHlwZS52YWx1ZSApO1xuXG5cdFx0XHRpZiAoICdHZW9tZXRyaWNUcmFuc2xhdGlvbicgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS50cmFuc2xhdGlvbiA9IG1vZGVsTm9kZS5HZW9tZXRyaWNUcmFuc2xhdGlvbi52YWx1ZTtcblx0XHRcdGlmICggJ0dlb21ldHJpY1JvdGF0aW9uJyBpbiBtb2RlbE5vZGUgKSB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uID0gbW9kZWxOb2RlLkdlb21ldHJpY1JvdGF0aW9uLnZhbHVlO1xuXHRcdFx0aWYgKCAnR2VvbWV0cmljU2NhbGluZycgaW4gbW9kZWxOb2RlICkgdHJhbnNmb3JtRGF0YS5zY2FsZSA9IG1vZGVsTm9kZS5HZW9tZXRyaWNTY2FsaW5nLnZhbHVlO1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gZ2VuZXJhdGVUcmFuc2Zvcm0oIHRyYW5zZm9ybURhdGEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2VuR2VvbWV0cnkoIGdlb05vZGUsIHNrZWxldG9uLCBtb3JwaFRhcmdldHMsIHRyYW5zZm9ybSApO1xuXG5cdFx0fSxcblxuXHRcdC8vIEdlbmVyYXRlIGEgQnVmZmVyR2VvbWV0cnkgZnJvbSBhIG5vZGUgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5XG5cdFx0Z2VuR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvTm9kZSwgc2tlbGV0b24sIG1vcnBoVGFyZ2V0cywgcHJlVHJhbnNmb3JtICkge1xuXG5cdFx0XHR2YXIgZ2VvID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRpZiAoIGdlb05vZGUuYXR0ck5hbWUgKSBnZW8ubmFtZSA9IGdlb05vZGUuYXR0ck5hbWU7XG5cblx0XHRcdHZhciBnZW9JbmZvID0gdGhpcy5wYXJzZUdlb05vZGUoIGdlb05vZGUsIHNrZWxldG9uICk7XG5cdFx0XHR2YXIgYnVmZmVycyA9IHRoaXMuZ2VuQnVmZmVycyggZ2VvSW5mbyApO1xuXG5cdFx0XHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy52ZXJ0ZXgsIDMgKTtcblxuXHRcdFx0cG9zaXRpb25BdHRyaWJ1dGUuYXBwbHlNYXRyaXg0KCBwcmVUcmFuc2Zvcm0gKTtcblxuXHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25BdHRyaWJ1dGUgKTtcblxuXHRcdFx0aWYgKCBidWZmZXJzLmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLmNvbG9ycywgMyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHRnZW8uc2V0QXR0cmlidXRlKCAnc2tpbkluZGV4JywgbmV3IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy53ZWlnaHRzSW5kaWNlcywgNCApICk7XG5cblx0XHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVycy52ZXJ0ZXhXZWlnaHRzLCA0ICkgKTtcblxuXHRcdFx0XHQvLyB1c2VkIGxhdGVyIHRvIGJpbmQgdGhlIHNrZWxldG9uIHRvIHRoZSBtb2RlbFxuXHRcdFx0XHRnZW8uRkJYX0RlZm9ybWVyID0gc2tlbGV0b247XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWZmZXJzLm5vcm1hbC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggcHJlVHJhbnNmb3JtICk7XG5cblx0XHRcdFx0dmFyIG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBidWZmZXJzLm5vcm1hbCwgMyApO1xuXHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuYXBwbHlOb3JtYWxNYXRyaXgoIG5vcm1hbE1hdHJpeCApO1xuXG5cdFx0XHRcdGdlby5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRidWZmZXJzLnV2cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHV2QnVmZmVyLCBpICkge1xuXG5cdFx0XHRcdC8vIHN1YnNlcXVlbnQgdXYgYnVmZmVycyBhcmUgY2FsbGVkICd1djEnLCAndXYyJywgLi4uXG5cdFx0XHRcdHZhciBuYW1lID0gJ3V2JyArICggaSArIDEgKS50b1N0cmluZygpO1xuXG5cdFx0XHRcdC8vIHRoZSBmaXJzdCB1diBidWZmZXIgaXMganVzdCBjYWxsZWQgJ3V2J1xuXHRcdFx0XHRpZiAoIGkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRuYW1lID0gJ3V2JztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvLnNldEF0dHJpYnV0ZSggbmFtZSwgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlcnMudXZzWyBpIF0sIDIgKSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggZ2VvSW5mby5tYXRlcmlhbCAmJiBnZW9JbmZvLm1hdGVyaWFsLm1hcHBpbmdUeXBlICE9PSAnQWxsU2FtZScgKSB7XG5cblx0XHRcdFx0Ly8gQ29udmVydCB0aGUgbWF0ZXJpYWwgaW5kaWNlcyBvZiBlYWNoIHZlcnRleCBpbnRvIHJlbmRlcmluZyBncm91cHMgb24gdGhlIGdlb21ldHJ5LlxuXHRcdFx0XHR2YXIgcHJldk1hdGVyaWFsSW5kZXggPSBidWZmZXJzLm1hdGVyaWFsSW5kZXhbIDAgXTtcblx0XHRcdFx0dmFyIHN0YXJ0SW5kZXggPSAwO1xuXG5cdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5mb3JFYWNoKCBmdW5jdGlvbiAoIGN1cnJlbnRJbmRleCwgaSApIHtcblxuXHRcdFx0XHRcdGlmICggY3VycmVudEluZGV4ICE9PSBwcmV2TWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0XHRcdFx0Z2VvLmFkZEdyb3VwKCBzdGFydEluZGV4LCBpIC0gc3RhcnRJbmRleCwgcHJldk1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRcdFx0cHJldk1hdGVyaWFsSW5kZXggPSBjdXJyZW50SW5kZXg7XG5cdFx0XHRcdFx0XHRzdGFydEluZGV4ID0gaTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gdGhlIGxvb3AgYWJvdmUgZG9lc24ndCBhZGQgdGhlIGxhc3QgZ3JvdXAsIGRvIHRoYXQgaGVyZS5cblx0XHRcdFx0aWYgKCBnZW8uZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgbGFzdEdyb3VwID0gZ2VvLmdyb3Vwc1sgZ2VvLmdyb3Vwcy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdFx0dmFyIGxhc3RJbmRleCA9IGxhc3RHcm91cC5zdGFydCArIGxhc3RHcm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGlmICggbGFzdEluZGV4ICE9PSBidWZmZXJzLm1hdGVyaWFsSW5kZXgubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHRnZW8uYWRkR3JvdXAoIGxhc3RJbmRleCwgYnVmZmVycy5tYXRlcmlhbEluZGV4Lmxlbmd0aCAtIGxhc3RJbmRleCwgcHJldk1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2FzZSB3aGVyZSB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0ZXJpYWxzIGJ1dCB0aGUgd2hvbGUgZ2VvbWV0cnkgaXMgb25seVxuXHRcdFx0XHQvLyB1c2luZyBvbmUgb2YgdGhlbVxuXHRcdFx0XHRpZiAoIGdlby5ncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Z2VvLmFkZEdyb3VwKCAwLCBidWZmZXJzLm1hdGVyaWFsSW5kZXgubGVuZ3RoLCBidWZmZXJzLm1hdGVyaWFsSW5kZXhbIDAgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmFkZE1vcnBoVGFyZ2V0cyggZ2VvLCBnZW9Ob2RlLCBtb3JwaFRhcmdldHMsIHByZVRyYW5zZm9ybSApO1xuXG5cdFx0XHRyZXR1cm4gZ2VvO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlR2VvTm9kZTogZnVuY3Rpb24gKCBnZW9Ob2RlLCBza2VsZXRvbiApIHtcblxuXHRcdFx0dmFyIGdlb0luZm8gPSB7fTtcblxuXHRcdFx0Z2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnMgPSAoIGdlb05vZGUuVmVydGljZXMgIT09IHVuZGVmaW5lZCApID8gZ2VvTm9kZS5WZXJ0aWNlcy5hIDogW107XG5cdFx0XHRnZW9JbmZvLnZlcnRleEluZGljZXMgPSAoIGdlb05vZGUuUG9seWdvblZlcnRleEluZGV4ICE9PSB1bmRlZmluZWQgKSA/IGdlb05vZGUuUG9seWdvblZlcnRleEluZGV4LmEgOiBbXTtcblxuXHRcdFx0aWYgKCBnZW9Ob2RlLkxheWVyRWxlbWVudENvbG9yICkge1xuXG5cdFx0XHRcdGdlb0luZm8uY29sb3IgPSB0aGlzLnBhcnNlVmVydGV4Q29sb3JzKCBnZW9Ob2RlLkxheWVyRWxlbWVudENvbG9yWyAwIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb05vZGUuTGF5ZXJFbGVtZW50TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby5tYXRlcmlhbCA9IHRoaXMucGFyc2VNYXRlcmlhbEluZGljZXMoIGdlb05vZGUuTGF5ZXJFbGVtZW50TWF0ZXJpYWxbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnROb3JtYWwgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby5ub3JtYWwgPSB0aGlzLnBhcnNlTm9ybWFscyggZ2VvTm9kZS5MYXllckVsZW1lbnROb3JtYWxbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRVViApIHtcblxuXHRcdFx0XHRnZW9JbmZvLnV2ID0gW107XG5cblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHR3aGlsZSAoIGdlb05vZGUuTGF5ZXJFbGVtZW50VVZbIGkgXSApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvTm9kZS5MYXllckVsZW1lbnRVVlsgaSBdLlVWICkge1xuXG5cdFx0XHRcdFx0XHRnZW9JbmZvLnV2LnB1c2goIHRoaXMucGFyc2VVVnMoIGdlb05vZGUuTGF5ZXJFbGVtZW50VVZbIGkgXSApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9JbmZvLndlaWdodFRhYmxlID0ge307XG5cblx0XHRcdGlmICggc2tlbGV0b24gIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Z2VvSW5mby5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG5cdFx0XHRcdHNrZWxldG9uLnJhd0JvbmVzLmZvckVhY2goIGZ1bmN0aW9uICggcmF3Qm9uZSwgaSApIHtcblxuXHRcdFx0XHRcdC8vIGxvb3Agb3ZlciB0aGUgYm9uZSdzIHZlcnRleCBpbmRpY2VzIGFuZCB3ZWlnaHRzXG5cdFx0XHRcdFx0cmF3Qm9uZS5pbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uICggaW5kZXgsIGogKSB7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXSA9PT0gdW5kZWZpbmVkICkgZ2VvSW5mby53ZWlnaHRUYWJsZVsgaW5kZXggXSA9IFtdO1xuXG5cdFx0XHRcdFx0XHRnZW9JbmZvLndlaWdodFRhYmxlWyBpbmRleCBdLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0XHRpZDogaSxcblx0XHRcdFx0XHRcdFx0d2VpZ2h0OiByYXdCb25lLndlaWdodHNbIGogXSxcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZ2VvSW5mbztcblxuXHRcdH0sXG5cblx0XHRnZW5CdWZmZXJzOiBmdW5jdGlvbiAoIGdlb0luZm8gKSB7XG5cblx0XHRcdHZhciBidWZmZXJzID0ge1xuXHRcdFx0XHR2ZXJ0ZXg6IFtdLFxuXHRcdFx0XHRub3JtYWw6IFtdLFxuXHRcdFx0XHRjb2xvcnM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdLFxuXHRcdFx0XHRtYXRlcmlhbEluZGV4OiBbXSxcblx0XHRcdFx0dmVydGV4V2VpZ2h0czogW10sXG5cdFx0XHRcdHdlaWdodHNJbmRpY2VzOiBbXSxcblx0XHRcdH07XG5cblx0XHRcdHZhciBwb2x5Z29uSW5kZXggPSAwO1xuXHRcdFx0dmFyIGZhY2VMZW5ndGggPSAwO1xuXHRcdFx0dmFyIGRpc3BsYXllZFdlaWdodHNXYXJuaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIHRoZXNlIHdpbGwgaG9sZCBkYXRhIGZvciBhIHNpbmdsZSBmYWNlXG5cdFx0XHR2YXIgZmFjZVBvc2l0aW9uSW5kZXhlcyA9IFtdO1xuXHRcdFx0dmFyIGZhY2VOb3JtYWxzID0gW107XG5cdFx0XHR2YXIgZmFjZUNvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGZhY2VVVnMgPSBbXTtcblx0XHRcdHZhciBmYWNlV2VpZ2h0cyA9IFtdO1xuXHRcdFx0dmFyIGZhY2VXZWlnaHRJbmRpY2VzID0gW107XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRnZW9JbmZvLnZlcnRleEluZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gKCB2ZXJ0ZXhJbmRleCwgcG9seWdvblZlcnRleEluZGV4ICkge1xuXG5cdFx0XHRcdHZhciBlbmRPZkZhY2UgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBGYWNlIGluZGV4IGFuZCB2ZXJ0ZXggaW5kZXggYXJyYXlzIGFyZSBjb21iaW5lZCBpbiBhIHNpbmdsZSBhcnJheVxuXHRcdFx0XHQvLyBBIGN1YmUgd2l0aCBxdWFkIGZhY2VzIGxvb2tzIGxpa2UgdGhpczpcblx0XHRcdFx0Ly8gUG9seWdvblZlcnRleEluZGV4OiAqMjQge1xuXHRcdFx0XHQvLyAgYTogMCwgMSwgMywgLTMsIDIsIDMsIDUsIC01LCA0LCA1LCA3LCAtNywgNiwgNywgMSwgLTEsIDEsIDcsIDUsIC00LCA2LCAwLCAyLCAtNVxuXHRcdFx0XHQvLyAgfVxuXHRcdFx0XHQvLyBOZWdhdGl2ZSBudW1iZXJzIG1hcmsgdGhlIGVuZCBvZiBhIGZhY2UgLSBmaXJzdCBmYWNlIGhlcmUgaXMgMCwgMSwgMywgLTNcblx0XHRcdFx0Ly8gdG8gZmluZCBpbmRleCBvZiBsYXN0IHZlcnRleCBiaXQgc2hpZnQgdGhlIGluZGV4OiBeIC0gMVxuXHRcdFx0XHRpZiAoIHZlcnRleEluZGV4IDwgMCApIHtcblxuXHRcdFx0XHRcdHZlcnRleEluZGV4ID0gdmVydGV4SW5kZXggXiAtIDE7IC8vIGVxdWl2YWxlbnQgdG8gKCB4ICogLTEgKSAtIDFcblx0XHRcdFx0XHRlbmRPZkZhY2UgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgd2VpZ2h0SW5kaWNlcyA9IFtdO1xuXHRcdFx0XHR2YXIgd2VpZ2h0cyA9IFtdO1xuXG5cdFx0XHRcdGZhY2VQb3NpdGlvbkluZGV4ZXMucHVzaCggdmVydGV4SW5kZXggKiAzLCB2ZXJ0ZXhJbmRleCAqIDMgKyAxLCB2ZXJ0ZXhJbmRleCAqIDMgKyAyICk7XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLmNvbG9yICkge1xuXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBnZXREYXRhKCBwb2x5Z29uVmVydGV4SW5kZXgsIHBvbHlnb25JbmRleCwgdmVydGV4SW5kZXgsIGdlb0luZm8uY29sb3IgKTtcblxuXHRcdFx0XHRcdGZhY2VDb2xvcnMucHVzaCggZGF0YVsgMCBdLCBkYXRhWyAxIF0sIGRhdGFbIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGdlb0luZm8uc2tlbGV0b24gKSB7XG5cblx0XHRcdFx0XHRpZiAoIGdlb0luZm8ud2VpZ2h0VGFibGVbIHZlcnRleEluZGV4IF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0Z2VvSW5mby53ZWlnaHRUYWJsZVsgdmVydGV4SW5kZXggXS5mb3JFYWNoKCBmdW5jdGlvbiAoIHd0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHdlaWdodHMucHVzaCggd3Qud2VpZ2h0ICk7XG5cdFx0XHRcdFx0XHRcdHdlaWdodEluZGljZXMucHVzaCggd3QuaWQgKTtcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHdlaWdodHMubGVuZ3RoID4gNCApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIGRpc3BsYXllZFdlaWdodHNXYXJuaW5nICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogVmVydGV4IGhhcyBtb3JlIHRoYW4gNCBza2lubmluZyB3ZWlnaHRzIGFzc2lnbmVkIHRvIHZlcnRleC4gRGVsZXRpbmcgYWRkaXRpb25hbCB3ZWlnaHRzLicgKTtcblx0XHRcdFx0XHRcdFx0ZGlzcGxheWVkV2VpZ2h0c1dhcm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciB3SW5kZXggPSBbIDAsIDAsIDAsIDAgXTtcblx0XHRcdFx0XHRcdHZhciBXZWlnaHQgPSBbIDAsIDAsIDAsIDAgXTtcblxuXHRcdFx0XHRcdFx0d2VpZ2h0cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHdlaWdodCwgd2VpZ2h0SW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50SW5kZXggPSB3ZWlnaHRJbmRpY2VzWyB3ZWlnaHRJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFdlaWdodC5mb3JFYWNoKCBmdW5jdGlvbiAoIGNvbXBhcmVkV2VpZ2h0LCBjb21wYXJlZFdlaWdodEluZGV4LCBjb21wYXJlZFdlaWdodEFycmF5ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID4gY29tcGFyZWRXZWlnaHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBhcmVkV2VpZ2h0QXJyYXlbIGNvbXBhcmVkV2VpZ2h0SW5kZXggXSA9IGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50V2VpZ2h0ID0gY29tcGFyZWRXZWlnaHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0bXAgPSB3SW5kZXhbIGNvbXBhcmVkV2VpZ2h0SW5kZXggXTtcblx0XHRcdFx0XHRcdFx0XHRcdHdJbmRleFsgY29tcGFyZWRXZWlnaHRJbmRleCBdID0gY3VycmVudEluZGV4O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudEluZGV4ID0gdG1wO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHR3ZWlnaHRJbmRpY2VzID0gd0luZGV4O1xuXHRcdFx0XHRcdFx0d2VpZ2h0cyA9IFdlaWdodDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIHRoZSB3ZWlnaHQgYXJyYXkgaXMgc2hvcnRlciB0aGFuIDQgcGFkIHdpdGggMHNcblx0XHRcdFx0XHR3aGlsZSAoIHdlaWdodHMubGVuZ3RoIDwgNCApIHtcblxuXHRcdFx0XHRcdFx0d2VpZ2h0cy5wdXNoKCAwICk7XG5cdFx0XHRcdFx0XHR3ZWlnaHRJbmRpY2VzLnB1c2goIDAgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDQ7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRcdGZhY2VXZWlnaHRzLnB1c2goIHdlaWdodHNbIGkgXSApO1xuXHRcdFx0XHRcdFx0ZmFjZVdlaWdodEluZGljZXMucHVzaCggd2VpZ2h0SW5kaWNlc1sgaSBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5ub3JtYWwgKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgZ2VvSW5mby5ub3JtYWwgKTtcblxuXHRcdFx0XHRcdGZhY2VOb3JtYWxzLnB1c2goIGRhdGFbIDAgXSwgZGF0YVsgMSBdLCBkYXRhWyAyIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLm1hdGVyaWFsICYmIGdlb0luZm8ubWF0ZXJpYWwubWFwcGluZ1R5cGUgIT09ICdBbGxTYW1lJyApIHtcblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbEluZGV4ID0gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCBnZW9JbmZvLm1hdGVyaWFsIClbIDAgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLnV2ICkge1xuXG5cdFx0XHRcdFx0Z2VvSW5mby51di5mb3JFYWNoKCBmdW5jdGlvbiAoIHV2LCBpICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGdldERhdGEoIHBvbHlnb25WZXJ0ZXhJbmRleCwgcG9seWdvbkluZGV4LCB2ZXJ0ZXhJbmRleCwgdXYgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBmYWNlVVZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRmYWNlVVZzWyBpIF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRmYWNlVVZzWyBpIF0ucHVzaCggZGF0YVsgMCBdICk7XG5cdFx0XHRcdFx0XHRmYWNlVVZzWyBpIF0ucHVzaCggZGF0YVsgMSBdICk7XG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VMZW5ndGggKys7XG5cblx0XHRcdFx0aWYgKCBlbmRPZkZhY2UgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5nZW5GYWNlKCBidWZmZXJzLCBnZW9JbmZvLCBmYWNlUG9zaXRpb25JbmRleGVzLCBtYXRlcmlhbEluZGV4LCBmYWNlTm9ybWFscywgZmFjZUNvbG9ycywgZmFjZVVWcywgZmFjZVdlaWdodHMsIGZhY2VXZWlnaHRJbmRpY2VzLCBmYWNlTGVuZ3RoICk7XG5cblx0XHRcdFx0XHRwb2x5Z29uSW5kZXggKys7XG5cdFx0XHRcdFx0ZmFjZUxlbmd0aCA9IDA7XG5cblx0XHRcdFx0XHQvLyByZXNldCBhcnJheXMgZm9yIHRoZSBuZXh0IGZhY2Vcblx0XHRcdFx0XHRmYWNlUG9zaXRpb25JbmRleGVzID0gW107XG5cdFx0XHRcdFx0ZmFjZU5vcm1hbHMgPSBbXTtcblx0XHRcdFx0XHRmYWNlQ29sb3JzID0gW107XG5cdFx0XHRcdFx0ZmFjZVVWcyA9IFtdO1xuXHRcdFx0XHRcdGZhY2VXZWlnaHRzID0gW107XG5cdFx0XHRcdFx0ZmFjZVdlaWdodEluZGljZXMgPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIGJ1ZmZlcnM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gR2VuZXJhdGUgZGF0YSBmb3IgYSBzaW5nbGUgZmFjZSBpbiBhIGdlb21ldHJ5LiBJZiB0aGUgZmFjZSBpcyBhIHF1YWQgdGhlbiBzcGxpdCBpdCBpbnRvIDIgdHJpc1xuXHRcdGdlbkZhY2U6IGZ1bmN0aW9uICggYnVmZmVycywgZ2VvSW5mbywgZmFjZVBvc2l0aW9uSW5kZXhlcywgbWF0ZXJpYWxJbmRleCwgZmFjZU5vcm1hbHMsIGZhY2VDb2xvcnMsIGZhY2VVVnMsIGZhY2VXZWlnaHRzLCBmYWNlV2VpZ2h0SW5kaWNlcywgZmFjZUxlbmd0aCApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAyOyBpIDwgZmFjZUxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgMCBdIF0gKTtcblx0XHRcdFx0YnVmZmVycy52ZXJ0ZXgucHVzaCggZ2VvSW5mby52ZXJ0ZXhQb3NpdGlvbnNbIGZhY2VQb3NpdGlvbkluZGV4ZXNbIDEgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAyIF0gXSApO1xuXG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAoIGkgLSAxICkgKiAzIF0gXSApO1xuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgKCBpIC0gMSApICogMyArIDEgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyAoIGkgLSAxICkgKiAzICsgMiBdIF0gKTtcblxuXHRcdFx0XHRidWZmZXJzLnZlcnRleC5wdXNoKCBnZW9JbmZvLnZlcnRleFBvc2l0aW9uc1sgZmFjZVBvc2l0aW9uSW5kZXhlc1sgaSAqIDMgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyBpICogMyArIDEgXSBdICk7XG5cdFx0XHRcdGJ1ZmZlcnMudmVydGV4LnB1c2goIGdlb0luZm8udmVydGV4UG9zaXRpb25zWyBmYWNlUG9zaXRpb25JbmRleGVzWyBpICogMyArIDIgXSBdICk7XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAwIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAzIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgKCBpIC0gMSApICogNCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0ICsgMiBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyAoIGkgLSAxICkgKiA0ICsgMyBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0IF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLnZlcnRleFdlaWdodHMucHVzaCggZmFjZVdlaWdodHNbIGkgKiA0ICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy52ZXJ0ZXhXZWlnaHRzLnB1c2goIGZhY2VXZWlnaHRzWyBpICogNCArIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMudmVydGV4V2VpZ2h0cy5wdXNoKCBmYWNlV2VpZ2h0c1sgaSAqIDQgKyAzIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIDAgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIDMgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgKCBpIC0gMSApICogNCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgKCBpIC0gMSApICogNCArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbICggaSAtIDEgKSAqIDQgKyAyIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyAoIGkgLSAxICkgKiA0ICsgMyBdICk7XG5cblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyBpICogNCBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy53ZWlnaHRzSW5kaWNlcy5wdXNoKCBmYWNlV2VpZ2h0SW5kaWNlc1sgaSAqIDQgKyAxIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLndlaWdodHNJbmRpY2VzLnB1c2goIGZhY2VXZWlnaHRJbmRpY2VzWyBpICogNCArIDIgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMud2VpZ2h0c0luZGljZXMucHVzaCggZmFjZVdlaWdodEluZGljZXNbIGkgKiA0ICsgMyBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5jb2xvciApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIDAgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIDIgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgKCBpIC0gMSApICogMyBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5jb2xvcnMucHVzaCggZmFjZUNvbG9yc1sgKCBpIC0gMSApICogMyArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbICggaSAtIDEgKSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIGkgKiAzIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLmNvbG9ycy5wdXNoKCBmYWNlQ29sb3JzWyBpICogMyArIDEgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMuY29sb3JzLnB1c2goIGZhY2VDb2xvcnNbIGkgKiAzICsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby5tYXRlcmlhbCAmJiBnZW9JbmZvLm1hdGVyaWFsLm1hcHBpbmdUeXBlICE9PSAnQWxsU2FtZScgKSB7XG5cblx0XHRcdFx0XHRidWZmZXJzLm1hdGVyaWFsSW5kZXgucHVzaCggbWF0ZXJpYWxJbmRleCApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubWF0ZXJpYWxJbmRleC5wdXNoKCBtYXRlcmlhbEluZGV4ICk7XG5cdFx0XHRcdFx0YnVmZmVycy5tYXRlcmlhbEluZGV4LnB1c2goIG1hdGVyaWFsSW5kZXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBnZW9JbmZvLm5vcm1hbCApIHtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAwIF0gKTtcblx0XHRcdFx0XHRidWZmZXJzLm5vcm1hbC5wdXNoKCBmYWNlTm9ybWFsc1sgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbICggaSAtIDEgKSAqIDMgXSApO1xuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyAoIGkgLSAxICkgKiAzICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbICggaSAtIDEgKSAqIDMgKyAyIF0gKTtcblxuXHRcdFx0XHRcdGJ1ZmZlcnMubm9ybWFsLnB1c2goIGZhY2VOb3JtYWxzWyBpICogMyBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIGkgKiAzICsgMSBdICk7XG5cdFx0XHRcdFx0YnVmZmVycy5ub3JtYWwucHVzaCggZmFjZU5vcm1hbHNbIGkgKiAzICsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZ2VvSW5mby51diApIHtcblxuXHRcdFx0XHRcdGdlb0luZm8udXYuZm9yRWFjaCggZnVuY3Rpb24gKCB1diwgaiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBidWZmZXJzLnV2c1sgaiBdID09PSB1bmRlZmluZWQgKSBidWZmZXJzLnV2c1sgaiBdID0gW107XG5cblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAwIF0gKTtcblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bICggaSAtIDEgKSAqIDIgXSApO1xuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bICggaSAtIDEgKSAqIDIgKyAxIF0gKTtcblxuXHRcdFx0XHRcdFx0YnVmZmVycy51dnNbIGogXS5wdXNoKCBmYWNlVVZzWyBqIF1bIGkgKiAyIF0gKTtcblx0XHRcdFx0XHRcdGJ1ZmZlcnMudXZzWyBqIF0ucHVzaCggZmFjZVVWc1sgaiBdWyBpICogMiArIDEgXSApO1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdGFkZE1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCBwYXJlbnRHZW8sIHBhcmVudEdlb05vZGUsIG1vcnBoVGFyZ2V0cywgcHJlVHJhbnNmb3JtICkge1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0cy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHRcdHBhcmVudEdlby5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG5cblx0XHRcdHBhcmVudEdlby5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBbXTtcblx0XHRcdC8vIHBhcmVudEdlby5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gW107IC8vIG5vdCBpbXBsZW1lbnRlZFxuXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdFx0bW9ycGhUYXJnZXRzLmZvckVhY2goIGZ1bmN0aW9uICggbW9ycGhUYXJnZXQgKSB7XG5cblx0XHRcdFx0bW9ycGhUYXJnZXQucmF3VGFyZ2V0cy5mb3JFYWNoKCBmdW5jdGlvbiAoIHJhd1RhcmdldCApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaEdlb05vZGUgPSBmYnhUcmVlLk9iamVjdHMuR2VvbWV0cnlbIHJhd1RhcmdldC5nZW9JRCBdO1xuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaEdlb05vZGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0c2NvcGUuZ2VuTW9ycGhHZW9tZXRyeSggcGFyZW50R2VvLCBwYXJlbnRHZW9Ob2RlLCBtb3JwaEdlb05vZGUsIHByZVRyYW5zZm9ybSwgcmF3VGFyZ2V0Lm5hbWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdH0sXG5cblx0XHQvLyBhIG1vcnBoIGdlb21ldHJ5IG5vZGUgaXMgc2ltaWxhciB0byBhIHN0YW5kYXJkICBub2RlLCBhbmQgdGhlIG5vZGUgaXMgYWxzbyBjb250YWluZWRcblx0XHQvLyBpbiBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnksIGhvd2V2ZXIgaXQgY2FuIG9ubHkgaGF2ZSBhdHRyaWJ1dGVzIGZvciBwb3NpdGlvbiwgbm9ybWFsXG5cdFx0Ly8gYW5kIGEgc3BlY2lhbCBhdHRyaWJ1dGUgSW5kZXggZGVmaW5pbmcgd2hpY2ggdmVydGljZXMgb2YgdGhlIG9yaWdpbmFsIGdlb21ldHJ5IGFyZSBhZmZlY3RlZFxuXHRcdC8vIE5vcm1hbCBhbmQgcG9zaXRpb24gYXR0cmlidXRlcyBvbmx5IGhhdmUgZGF0YSBmb3IgdGhlIHZlcnRpY2VzIHRoYXQgYXJlIGFmZmVjdGVkIGJ5IHRoZSBtb3JwaFxuXHRcdGdlbk1vcnBoR2VvbWV0cnk6IGZ1bmN0aW9uICggcGFyZW50R2VvLCBwYXJlbnRHZW9Ob2RlLCBtb3JwaEdlb05vZGUsIHByZVRyYW5zZm9ybSwgbmFtZSApIHtcblxuXHRcdFx0dmFyIHZlcnRleEluZGljZXMgPSAoIHBhcmVudEdlb05vZGUuUG9seWdvblZlcnRleEluZGV4ICE9PSB1bmRlZmluZWQgKSA/IHBhcmVudEdlb05vZGUuUG9seWdvblZlcnRleEluZGV4LmEgOiBbXTtcblxuXHRcdFx0dmFyIG1vcnBoUG9zaXRpb25zU3BhcnNlID0gKCBtb3JwaEdlb05vZGUuVmVydGljZXMgIT09IHVuZGVmaW5lZCApID8gbW9ycGhHZW9Ob2RlLlZlcnRpY2VzLmEgOiBbXTtcblx0XHRcdHZhciBpbmRpY2VzID0gKCBtb3JwaEdlb05vZGUuSW5kZXhlcyAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEdlb05vZGUuSW5kZXhlcy5hIDogW107XG5cblx0XHRcdHZhciBsZW5ndGggPSBwYXJlbnRHZW8uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIDM7XG5cdFx0XHR2YXIgbW9ycGhQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBsZW5ndGggKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG1vcnBoSW5kZXggPSBpbmRpY2VzWyBpIF0gKiAzO1xuXG5cdFx0XHRcdG1vcnBoUG9zaXRpb25zWyBtb3JwaEluZGV4IF0gPSBtb3JwaFBvc2l0aW9uc1NwYXJzZVsgaSAqIDMgXTtcblx0XHRcdFx0bW9ycGhQb3NpdGlvbnNbIG1vcnBoSW5kZXggKyAxIF0gPSBtb3JwaFBvc2l0aW9uc1NwYXJzZVsgaSAqIDMgKyAxIF07XG5cdFx0XHRcdG1vcnBoUG9zaXRpb25zWyBtb3JwaEluZGV4ICsgMiBdID0gbW9ycGhQb3NpdGlvbnNTcGFyc2VbIGkgKiAzICsgMiBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IGFkZCBtb3JwaCBub3JtYWwgc3VwcG9ydFxuXHRcdFx0dmFyIG1vcnBoR2VvSW5mbyA9IHtcblx0XHRcdFx0dmVydGV4SW5kaWNlczogdmVydGV4SW5kaWNlcyxcblx0XHRcdFx0dmVydGV4UG9zaXRpb25zOiBtb3JwaFBvc2l0aW9ucyxcblxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIG1vcnBoQnVmZmVycyA9IHRoaXMuZ2VuQnVmZmVycyggbW9ycGhHZW9JbmZvICk7XG5cblx0XHRcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBtb3JwaEJ1ZmZlcnMudmVydGV4LCAzICk7XG5cdFx0XHRwb3NpdGlvbkF0dHJpYnV0ZS5uYW1lID0gbmFtZSB8fCBtb3JwaEdlb05vZGUuYXR0ck5hbWU7XG5cblx0XHRcdHBvc2l0aW9uQXR0cmlidXRlLmFwcGx5TWF0cml4NCggcHJlVHJhbnNmb3JtICk7XG5cblx0XHRcdHBhcmVudEdlby5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24ucHVzaCggcG9zaXRpb25BdHRyaWJ1dGUgKTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBub3JtYWwgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50Tm9ybWFsIGlmIGl0IGV4aXN0c1xuXHRcdHBhcnNlTm9ybWFsczogZnVuY3Rpb24gKCBOb3JtYWxOb2RlICkge1xuXG5cdFx0XHR2YXIgbWFwcGluZ1R5cGUgPSBOb3JtYWxOb2RlLk1hcHBpbmdJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgcmVmZXJlbmNlVHlwZSA9IE5vcm1hbE5vZGUuUmVmZXJlbmNlSW5mb3JtYXRpb25UeXBlO1xuXHRcdFx0dmFyIGJ1ZmZlciA9IE5vcm1hbE5vZGUuTm9ybWFscy5hO1xuXHRcdFx0dmFyIGluZGV4QnVmZmVyID0gW107XG5cdFx0XHRpZiAoIHJlZmVyZW5jZVR5cGUgPT09ICdJbmRleFRvRGlyZWN0JyApIHtcblxuXHRcdFx0XHRpZiAoICdOb3JtYWxJbmRleCcgaW4gTm9ybWFsTm9kZSApIHtcblxuXHRcdFx0XHRcdGluZGV4QnVmZmVyID0gTm9ybWFsTm9kZS5Ob3JtYWxJbmRleC5hO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoICdOb3JtYWxzSW5kZXgnIGluIE5vcm1hbE5vZGUgKSB7XG5cblx0XHRcdFx0XHRpbmRleEJ1ZmZlciA9IE5vcm1hbE5vZGUuTm9ybWFsc0luZGV4LmE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGFTaXplOiAzLFxuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdFx0aW5kaWNlczogaW5kZXhCdWZmZXIsXG5cdFx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBVVnMgZnJvbSBGQlhUcmVlLk9iamVjdHMuR2VvbWV0cnkuTGF5ZXJFbGVtZW50VVYgaWYgaXQgZXhpc3RzXG5cdFx0cGFyc2VVVnM6IGZ1bmN0aW9uICggVVZOb2RlICkge1xuXG5cdFx0XHR2YXIgbWFwcGluZ1R5cGUgPSBVVk5vZGUuTWFwcGluZ0luZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciByZWZlcmVuY2VUeXBlID0gVVZOb2RlLlJlZmVyZW5jZUluZm9ybWF0aW9uVHlwZTtcblx0XHRcdHZhciBidWZmZXIgPSBVVk5vZGUuVVYuYTtcblx0XHRcdHZhciBpbmRleEJ1ZmZlciA9IFtdO1xuXHRcdFx0aWYgKCByZWZlcmVuY2VUeXBlID09PSAnSW5kZXhUb0RpcmVjdCcgKSB7XG5cblx0XHRcdFx0aW5kZXhCdWZmZXIgPSBVVk5vZGUuVVZJbmRleC5hO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGFTaXplOiAyLFxuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcblx0XHRcdFx0aW5kaWNlczogaW5kZXhCdWZmZXIsXG5cdFx0XHRcdG1hcHBpbmdUeXBlOiBtYXBwaW5nVHlwZSxcblx0XHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdFx0fTtcblxuXHRcdH0sXG5cblx0XHQvLyBQYXJzZSBWZXJ0ZXggQ29sb3JzIGZyb20gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LkxheWVyRWxlbWVudENvbG9yIGlmIGl0IGV4aXN0c1xuXHRcdHBhcnNlVmVydGV4Q29sb3JzOiBmdW5jdGlvbiAoIENvbG9yTm9kZSApIHtcblxuXHRcdFx0dmFyIG1hcHBpbmdUeXBlID0gQ29sb3JOb2RlLk1hcHBpbmdJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgcmVmZXJlbmNlVHlwZSA9IENvbG9yTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgYnVmZmVyID0gQ29sb3JOb2RlLkNvbG9ycy5hO1xuXHRcdFx0dmFyIGluZGV4QnVmZmVyID0gW107XG5cdFx0XHRpZiAoIHJlZmVyZW5jZVR5cGUgPT09ICdJbmRleFRvRGlyZWN0JyApIHtcblxuXHRcdFx0XHRpbmRleEJ1ZmZlciA9IENvbG9yTm9kZS5Db2xvckluZGV4LmE7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YVNpemU6IDQsXG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxuXHRcdFx0XHRpbmRpY2VzOiBpbmRleEJ1ZmZlcixcblx0XHRcdFx0bWFwcGluZ1R5cGU6IG1hcHBpbmdUeXBlLFxuXHRcdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIFBhcnNlIG1hcHBpbmcgYW5kIG1hdGVyaWFsIGRhdGEgaW4gRkJYVHJlZS5PYmplY3RzLkdlb21ldHJ5LkxheWVyRWxlbWVudE1hdGVyaWFsIGlmIGl0IGV4aXN0c1xuXHRcdHBhcnNlTWF0ZXJpYWxJbmRpY2VzOiBmdW5jdGlvbiAoIE1hdGVyaWFsTm9kZSApIHtcblxuXHRcdFx0dmFyIG1hcHBpbmdUeXBlID0gTWF0ZXJpYWxOb2RlLk1hcHBpbmdJbmZvcm1hdGlvblR5cGU7XG5cdFx0XHR2YXIgcmVmZXJlbmNlVHlwZSA9IE1hdGVyaWFsTm9kZS5SZWZlcmVuY2VJbmZvcm1hdGlvblR5cGU7XG5cblx0XHRcdGlmICggbWFwcGluZ1R5cGUgPT09ICdOb01hcHBpbmdJbmZvcm1hdGlvbicgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRkYXRhU2l6ZTogMSxcblx0XHRcdFx0XHRidWZmZXI6IFsgMCBdLFxuXHRcdFx0XHRcdGluZGljZXM6IFsgMCBdLFxuXHRcdFx0XHRcdG1hcHBpbmdUeXBlOiAnQWxsU2FtZScsXG5cdFx0XHRcdFx0cmVmZXJlbmNlVHlwZTogcmVmZXJlbmNlVHlwZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRlcmlhbEluZGV4QnVmZmVyID0gTWF0ZXJpYWxOb2RlLk1hdGVyaWFscy5hO1xuXG5cdFx0XHQvLyBTaW5jZSBtYXRlcmlhbHMgYXJlIHN0b3JlZCBhcyBpbmRpY2VzLCB0aGVyZSdzIGEgYml0IG9mIGEgbWlzbWF0Y2ggYmV0d2VlbiBGQlggYW5kIHdoYXRcblx0XHRcdC8vIHdlIGV4cGVjdC5TbyB3ZSBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIGJ1ZmZlciB0aGF0IHBvaW50cyB0byB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlcixcblx0XHRcdC8vIGZvciBjb25mb3JtaW5nIHdpdGggdGhlIG90aGVyIGZ1bmN0aW9ucyB3ZSd2ZSB3cml0dGVuIGZvciBvdGhlciBkYXRhLlxuXHRcdFx0dmFyIG1hdGVyaWFsSW5kaWNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbEluZGV4QnVmZmVyLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbEluZGljZXMucHVzaCggaSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGFTaXplOiAxLFxuXHRcdFx0XHRidWZmZXI6IG1hdGVyaWFsSW5kZXhCdWZmZXIsXG5cdFx0XHRcdGluZGljZXM6IG1hdGVyaWFsSW5kaWNlcyxcblx0XHRcdFx0bWFwcGluZ1R5cGU6IG1hcHBpbmdUeXBlLFxuXHRcdFx0XHRyZWZlcmVuY2VUeXBlOiByZWZlcmVuY2VUeXBlXG5cdFx0XHR9O1xuXG5cdFx0fSxcblxuXHRcdC8vIEdlbmVyYXRlIGEgTnVyYkdlb21ldHJ5IGZyb20gYSBub2RlIGluIEZCWFRyZWUuT2JqZWN0cy5HZW9tZXRyeVxuXHRcdHBhcnNlTnVyYnNHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9Ob2RlICkge1xuXG5cdFx0XHRpZiAoIE5VUkJTQ3VydmUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBUaGUgbG9hZGVyIHJlbGllcyBvbiBOVVJCU0N1cnZlIGZvciBhbnkgbnVyYnMgcHJlc2VudCBpbiB0aGUgbW9kZWwuIE51cmJzIHdpbGwgc2hvdyB1cCBhcyBlbXB0eSBnZW9tZXRyeS4nICk7XG5cdFx0XHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb3JkZXIgPSBwYXJzZUludCggZ2VvTm9kZS5PcmRlciApO1xuXG5cdFx0XHRpZiAoIGlzTmFOKCBvcmRlciApICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IEludmFsaWQgT3JkZXIgJXMgZ2l2ZW4gZm9yIGdlb21ldHJ5IElEOiAlcycsIGdlb05vZGUuT3JkZXIsIGdlb05vZGUuaWQgKTtcblx0XHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZWdyZWUgPSBvcmRlciAtIDE7XG5cblx0XHRcdHZhciBrbm90cyA9IGdlb05vZGUuS25vdFZlY3Rvci5hO1xuXHRcdFx0dmFyIGNvbnRyb2xQb2ludHMgPSBbXTtcblx0XHRcdHZhciBwb2ludHNWYWx1ZXMgPSBnZW9Ob2RlLlBvaW50cy5hO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHNWYWx1ZXMubGVuZ3RoOyBpIDwgbDsgaSArPSA0ICkge1xuXG5cdFx0XHRcdGNvbnRyb2xQb2ludHMucHVzaCggbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoIHBvaW50c1ZhbHVlcywgaSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0YXJ0S25vdCwgZW5kS25vdDtcblxuXHRcdFx0aWYgKCBnZW9Ob2RlLkZvcm0gPT09ICdDbG9zZWQnICkge1xuXG5cdFx0XHRcdGNvbnRyb2xQb2ludHMucHVzaCggY29udHJvbFBvaW50c1sgMCBdICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb05vZGUuRm9ybSA9PT0gJ1BlcmlvZGljJyApIHtcblxuXHRcdFx0XHRzdGFydEtub3QgPSBkZWdyZWU7XG5cdFx0XHRcdGVuZEtub3QgPSBrbm90cy5sZW5ndGggLSAxIC0gc3RhcnRLbm90O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRlZ3JlZTsgKysgaSApIHtcblxuXHRcdFx0XHRcdGNvbnRyb2xQb2ludHMucHVzaCggY29udHJvbFBvaW50c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJ2ZSA9IG5ldyBOVVJCU0N1cnZlKCBkZWdyZWUsIGtub3RzLCBjb250cm9sUG9pbnRzLCBzdGFydEtub3QsIGVuZEtub3QgKTtcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGN1cnZlLmdldFBvaW50cyggY29udHJvbFBvaW50cy5sZW5ndGggKiA3ICk7XG5cblx0XHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG5cblx0XHRcdHZlcnRpY2VzLmZvckVhY2goIGZ1bmN0aW9uICggdmVydGV4LCBpICkge1xuXG5cdFx0XHRcdHZlcnRleC50b0FycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH0sXG5cblx0fTtcblxuXHQvLyBwYXJzZSBhbmltYXRpb24gZGF0YSBmcm9tIEZCWFRyZWVcblx0ZnVuY3Rpb24gQW5pbWF0aW9uUGFyc2VyKCkge31cblxuXHRBbmltYXRpb25QYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEFuaW1hdGlvblBhcnNlcixcblxuXHRcdC8vIHRha2UgcmF3IGFuaW1hdGlvbiBjbGlwcyBhbmQgdHVybiB0aGVtIGludG8gdGhyZWUuanMgYW5pbWF0aW9uIGNsaXBzXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbkNsaXBzID0gW107XG5cblx0XHRcdHZhciByYXdDbGlwcyA9IHRoaXMucGFyc2VDbGlwcygpO1xuXG5cdFx0XHRpZiAoIHJhd0NsaXBzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiByYXdDbGlwcyApIHtcblxuXHRcdFx0XHRcdHZhciByYXdDbGlwID0gcmF3Q2xpcHNbIGtleSBdO1xuXG5cdFx0XHRcdFx0dmFyIGNsaXAgPSB0aGlzLmFkZENsaXAoIHJhd0NsaXAgKTtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbkNsaXBzLnB1c2goIGNsaXAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbkNsaXBzO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlQ2xpcHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gc2luY2UgdGhlIGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiBkYXRhIGlzIHN0b3JlZCBpbiBGQlhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmUsXG5cdFx0XHQvLyBpZiB0aGlzIGlzIHVuZGVmaW5lZCB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGVyZSBhcmUgbm8gYW5pbWF0aW9uc1xuXHRcdFx0aWYgKCBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uQ3VydmUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdHZhciBjdXJ2ZU5vZGVzTWFwID0gdGhpcy5wYXJzZUFuaW1hdGlvbkN1cnZlTm9kZXMoKTtcblxuXHRcdFx0dGhpcy5wYXJzZUFuaW1hdGlvbkN1cnZlcyggY3VydmVOb2Rlc01hcCApO1xuXG5cdFx0XHR2YXIgbGF5ZXJzTWFwID0gdGhpcy5wYXJzZUFuaW1hdGlvbkxheWVycyggY3VydmVOb2Rlc01hcCApO1xuXHRcdFx0dmFyIHJhd0NsaXBzID0gdGhpcy5wYXJzZUFuaW1TdGFja3MoIGxheWVyc01hcCApO1xuXG5cdFx0XHRyZXR1cm4gcmF3Q2xpcHM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlTm9kZVxuXHRcdC8vIGVhY2ggQW5pbWF0aW9uQ3VydmVOb2RlIGhvbGRzIGRhdGEgZm9yIGFuIGFuaW1hdGlvbiB0cmFuc2Zvcm0gZm9yIGEgbW9kZWwgKGUuZy4gbGVmdCBhcm0gcm90YXRpb24gKVxuXHRcdC8vIGFuZCBpcyByZWZlcmVuY2VkIGJ5IGFuIEFuaW1hdGlvbkxheWVyXG5cdFx0cGFyc2VBbmltYXRpb25DdXJ2ZU5vZGVzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciByYXdDdXJ2ZU5vZGVzID0gZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlTm9kZTtcblxuXHRcdFx0dmFyIGN1cnZlTm9kZXNNYXAgPSBuZXcgTWFwKCk7XG5cblx0XHRcdGZvciAoIHZhciBub2RlSUQgaW4gcmF3Q3VydmVOb2RlcyApIHtcblxuXHRcdFx0XHR2YXIgcmF3Q3VydmVOb2RlID0gcmF3Q3VydmVOb2Rlc1sgbm9kZUlEIF07XG5cblx0XHRcdFx0aWYgKCByYXdDdXJ2ZU5vZGUuYXR0ck5hbWUubWF0Y2goIC9TfFJ8VHxEZWZvcm1QZXJjZW50LyApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdFx0dmFyIGN1cnZlTm9kZSA9IHtcblxuXHRcdFx0XHRcdFx0aWQ6IHJhd0N1cnZlTm9kZS5pZCxcblx0XHRcdFx0XHRcdGF0dHI6IHJhd0N1cnZlTm9kZS5hdHRyTmFtZSxcblx0XHRcdFx0XHRcdGN1cnZlczoge30sXG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5zZXQoIGN1cnZlTm9kZS5pZCwgY3VydmVOb2RlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjdXJ2ZU5vZGVzTWFwO1xuXG5cdFx0fSxcblxuXHRcdC8vIHBhcnNlIG5vZGVzIGluIEZCWFRyZWUuT2JqZWN0cy5BbmltYXRpb25DdXJ2ZSBhbmQgY29ubmVjdCB0aGVtIHVwIHRvXG5cdFx0Ly8gcHJldmlvdXNseSBwYXJzZWQgQW5pbWF0aW9uQ3VydmVOb2Rlcy4gRWFjaCBBbmltYXRpb25DdXJ2ZSBob2xkcyBkYXRhIGZvciBhIHNpbmdsZSBhbmltYXRlZFxuXHRcdC8vIGF4aXMgKCBlLmcuIHRpbWVzIGFuZCB2YWx1ZXMgb2YgeCByb3RhdGlvbilcblx0XHRwYXJzZUFuaW1hdGlvbkN1cnZlczogZnVuY3Rpb24gKCBjdXJ2ZU5vZGVzTWFwICkge1xuXG5cdFx0XHR2YXIgcmF3Q3VydmVzID0gZmJ4VHJlZS5PYmplY3RzLkFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHQvLyBUT0RPOiBNYW55IHZhbHVlcyBhcmUgaWRlbnRpY2FsIHVwIHRvIHJvdW5kb2ZmIGVycm9yLCBidXQgd29uJ3QgYmUgb3B0aW1pc2VkXG5cdFx0XHQvLyBlLmcuIHBvc2l0aW9uIHRpbWVzOiBbMCwgMC40LCAwLiA4XVxuXHRcdFx0Ly8gcG9zaXRpb24gdmFsdWVzOiBbNy4yMzUzODMzNTAyMzQ3N2UtNywgOTMuNjc1MTg2MTU3MjI2NTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDksIDcuMjM1MzgzMzUwMjM0NzdlLTcsIDkzLjY3NTE4NjE1NzIyNjU2LCAtMC45OTgyNjk1NTc5NTI4ODA5LCA3LjIzNTM4NDQ4NzEwMzE0N2UtNywgOTMuNjc1MjA5MDQ1NDEwMTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDldXG5cdFx0XHQvLyBjbGVhcmx5LCB0aGlzIHNob3VsZCBiZSBvcHRpbWlzZWQgdG9cblx0XHRcdC8vIHRpbWVzOiBbMF0sIHBvc2l0aW9ucyBbNy4yMzUzODMzNTAyMzQ3N2UtNywgOTMuNjc1MTg2MTU3MjI2NTYsIC0wLjk5ODI2OTU1Nzk1Mjg4MDldXG5cdFx0XHQvLyB0aGlzIHNob3dzIHVwIGluIG5lYXJseSBldmVyeSBGQlggZmlsZSwgYW5kIGdlbmVyYWxseSB0aW1lIGFycmF5IGlzIGxlbmd0aCA+IDEwMFxuXG5cdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHJhd0N1cnZlcyApIHtcblxuXHRcdFx0XHR2YXIgYW5pbWF0aW9uQ3VydmUgPSB7XG5cblx0XHRcdFx0XHRpZDogcmF3Q3VydmVzWyBub2RlSUQgXS5pZCxcblx0XHRcdFx0XHR0aW1lczogcmF3Q3VydmVzWyBub2RlSUQgXS5LZXlUaW1lLmEubWFwKCBjb252ZXJ0RkJYVGltZVRvU2Vjb25kcyApLFxuXHRcdFx0XHRcdHZhbHVlczogcmF3Q3VydmVzWyBub2RlSUQgXS5LZXlWYWx1ZUZsb2F0LmEsXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR2YXIgcmVsYXRpb25zaGlwcyA9IGNvbm5lY3Rpb25zLmdldCggYW5pbWF0aW9uQ3VydmUuaWQgKTtcblxuXHRcdFx0XHRpZiAoIHJlbGF0aW9uc2hpcHMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciBhbmltYXRpb25DdXJ2ZUlEID0gcmVsYXRpb25zaGlwcy5wYXJlbnRzWyAwIF0uSUQ7XG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbkN1cnZlUmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwcy5wYXJlbnRzWyAwIF0ucmVsYXRpb25zaGlwO1xuXG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL1gvICkgKSB7XG5cblx0XHRcdFx0XHRcdGN1cnZlTm9kZXNNYXAuZ2V0KCBhbmltYXRpb25DdXJ2ZUlEICkuY3VydmVzWyAneCcgXSA9IGFuaW1hdGlvbkN1cnZlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYW5pbWF0aW9uQ3VydmVSZWxhdGlvbnNoaXAubWF0Y2goIC9ZLyApICkge1xuXG5cdFx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ3knIF0gPSBhbmltYXRpb25DdXJ2ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFuaW1hdGlvbkN1cnZlUmVsYXRpb25zaGlwLm1hdGNoKCAvWi8gKSApIHtcblxuXHRcdFx0XHRcdFx0Y3VydmVOb2Rlc01hcC5nZXQoIGFuaW1hdGlvbkN1cnZlSUQgKS5jdXJ2ZXNbICd6JyBdID0gYW5pbWF0aW9uQ3VydmU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhbmltYXRpb25DdXJ2ZVJlbGF0aW9uc2hpcC5tYXRjaCggL2R8RGVmb3JtUGVyY2VudC8gKSAmJiBjdXJ2ZU5vZGVzTWFwLmhhcyggYW5pbWF0aW9uQ3VydmVJRCApICkge1xuXG5cdFx0XHRcdFx0XHRjdXJ2ZU5vZGVzTWFwLmdldCggYW5pbWF0aW9uQ3VydmVJRCApLmN1cnZlc1sgJ21vcnBoJyBdID0gYW5pbWF0aW9uQ3VydmU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvbkxheWVyLiBFYWNoIGxheWVycyBob2xkcyByZWZlcmVuY2VzXG5cdFx0Ly8gdG8gdmFyaW91cyBBbmltYXRpb25DdXJ2ZU5vZGVzIGFuZCBpcyByZWZlcmVuY2VkIGJ5IGFuIEFuaW1hdGlvblN0YWNrIG5vZGVcblx0XHQvLyBub3RlOiB0aGVvcmV0aWNhbGx5IGEgc3RhY2sgY2FuIGhhdmUgbXVsdGlwbGUgbGF5ZXJzLCBob3dldmVyIGluIHByYWN0aWNlIHRoZXJlIGFsd2F5cyBzZWVtcyB0byBiZSBvbmUgcGVyIHN0YWNrXG5cdFx0cGFyc2VBbmltYXRpb25MYXllcnM6IGZ1bmN0aW9uICggY3VydmVOb2Rlc01hcCApIHtcblxuXHRcdFx0dmFyIHJhd0xheWVycyA9IGZieFRyZWUuT2JqZWN0cy5BbmltYXRpb25MYXllcjtcblxuXHRcdFx0dmFyIGxheWVyc01hcCA9IG5ldyBNYXAoKTtcblxuXHRcdFx0Zm9yICggdmFyIG5vZGVJRCBpbiByYXdMYXllcnMgKSB7XG5cblx0XHRcdFx0dmFyIGxheWVyQ3VydmVOb2RlcyA9IFtdO1xuXG5cdFx0XHRcdHZhciBjb25uZWN0aW9uID0gY29ubmVjdGlvbnMuZ2V0KCBwYXJzZUludCggbm9kZUlEICkgKTtcblxuXHRcdFx0XHRpZiAoIGNvbm5lY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIGFsbCB0aGUgYW5pbWF0aW9uQ3VydmVOb2RlcyB1c2VkIGluIHRoZSBsYXllclxuXHRcdFx0XHRcdHZhciBjaGlsZHJlbiA9IGNvbm5lY3Rpb24uY2hpbGRyZW47XG5cblx0XHRcdFx0XHRjaGlsZHJlbi5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoaWxkLCBpICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnZlTm9kZXNNYXAuaGFzKCBjaGlsZC5JRCApICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJ2ZU5vZGUgPSBjdXJ2ZU5vZGVzTWFwLmdldCggY2hpbGQuSUQgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBjaGVjayB0aGF0IHRoZSBjdXJ2ZXMgYXJlIGRlZmluZWQgZm9yIGF0IGxlYXN0IG9uZSBheGlzLCBvdGhlcndpc2UgaWdub3JlIHRoZSBjdXJ2ZU5vZGVcblx0XHRcdFx0XHRcdFx0aWYgKCBjdXJ2ZU5vZGUuY3VydmVzLnggIT09IHVuZGVmaW5lZCB8fCBjdXJ2ZU5vZGUuY3VydmVzLnkgIT09IHVuZGVmaW5lZCB8fCBjdXJ2ZU5vZGUuY3VydmVzLnogIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1vZGVsSUQgPSBjb25uZWN0aW9ucy5nZXQoIGNoaWxkLklEICkucGFyZW50cy5maWx0ZXIoIGZ1bmN0aW9uICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYXJlbnQucmVsYXRpb25zaGlwICE9PSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gKVsgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG1vZGVsSUQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmF3TW9kZWwgPSBmYnhUcmVlLk9iamVjdHMuTW9kZWxbIG1vZGVsSUQudG9TdHJpbmcoKSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmF3TW9kZWwgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogRW5jb3VudGVyZWQgYSB1bnVzZWQgY3VydmUuJywgY2hpbGQgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBub2RlID0ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kZWxOYW1lOiByYXdNb2RlbC5hdHRyTmFtZSA/IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKCByYXdNb2RlbC5hdHRyTmFtZSApIDogJycsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0SUQ6IHJhd01vZGVsLmlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluaXRpYWxQb3NpdGlvbjogWyAwLCAwLCAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5pdGlhbFJvdGF0aW9uOiBbIDAsIDAsIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbml0aWFsU2NhbGU6IFsgMSwgMSwgMSBdLFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NlbmVHcmFwaC50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2hpbGQuSUQgPT09IHJhd01vZGVsLmlkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLnRyYW5zZm9ybSA9IGNoaWxkLm1hdHJpeDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjaGlsZC51c2VyRGF0YS50cmFuc2Zvcm1EYXRhICkgbm9kZS5ldWxlck9yZGVyID0gY2hpbGQudXNlckRhdGEudHJhbnNmb3JtRGF0YS5ldWxlck9yZGVyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoICEgbm9kZS50cmFuc2Zvcm0gKSBub2RlLnRyYW5zZm9ybSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGFuaW1hdGVkIG1vZGVsIGlzIHByZSByb3RhdGVkLCB3ZSdsbCBoYXZlIHRvIGFwcGx5IHRoZSBwcmUgcm90YXRpb25zIHRvIGV2ZXJ5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuaW1hdGlvbiB2YWx1ZSBhcyB3ZWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggJ1ByZVJvdGF0aW9uJyBpbiByYXdNb2RlbCApIG5vZGUucHJlUm90YXRpb24gPSByYXdNb2RlbC5QcmVSb3RhdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAnUG9zdFJvdGF0aW9uJyBpbiByYXdNb2RlbCApIG5vZGUucG9zdFJvdGF0aW9uID0gcmF3TW9kZWwuUG9zdFJvdGF0aW9uLnZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxheWVyQ3VydmVOb2Rlc1sgaSBdID0gbm9kZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBsYXllckN1cnZlTm9kZXNbIGkgXSApIGxheWVyQ3VydmVOb2Rlc1sgaSBdWyBjdXJ2ZU5vZGUuYXR0ciBdID0gY3VydmVOb2RlO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlTm9kZS5jdXJ2ZXMubW9ycGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggbGF5ZXJDdXJ2ZU5vZGVzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRlZm9ybWVySUQgPSBjb25uZWN0aW9ucy5nZXQoIGNoaWxkLklEICkucGFyZW50cy5maWx0ZXIoIGZ1bmN0aW9uICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYXJlbnQucmVsYXRpb25zaGlwICE9PSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gKVsgMCBdLklEO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbW9ycGhlcklEID0gY29ubmVjdGlvbnMuZ2V0KCBkZWZvcm1lcklEICkucGFyZW50c1sgMCBdLklEO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGdlb0lEID0gY29ubmVjdGlvbnMuZ2V0KCBtb3JwaGVySUQgKS5wYXJlbnRzWyAwIF0uSUQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFzc3VtaW5nIGdlb21ldHJ5IGlzIG5vdCB1c2VkIGluIG1vcmUgdGhhbiBvbmUgbW9kZWxcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtb2RlbElEID0gY29ubmVjdGlvbnMuZ2V0KCBnZW9JRCApLnBhcmVudHNbIDAgXS5JRDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJhd01vZGVsID0gZmJ4VHJlZS5PYmplY3RzLk1vZGVsWyBtb2RlbElEIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBub2RlID0ge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1vZGVsTmFtZTogcmF3TW9kZWwuYXR0ck5hbWUgPyBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZSggcmF3TW9kZWwuYXR0ck5hbWUgKSA6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtb3JwaE5hbWU6IGZieFRyZWUuT2JqZWN0cy5EZWZvcm1lclsgZGVmb3JtZXJJRCBdLmF0dHJOYW1lLFxuXG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXllckN1cnZlTm9kZXNbIGkgXSA9IG5vZGU7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRsYXllckN1cnZlTm9kZXNbIGkgXVsgY3VydmVOb2RlLmF0dHIgXSA9IGN1cnZlTm9kZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdGxheWVyc01hcC5zZXQoIHBhcnNlSW50KCBub2RlSUQgKSwgbGF5ZXJDdXJ2ZU5vZGVzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYXllcnNNYXA7XG5cblx0XHR9LFxuXG5cdFx0Ly8gcGFyc2Ugbm9kZXMgaW4gRkJYVHJlZS5PYmplY3RzLkFuaW1hdGlvblN0YWNrLiBUaGVzZSBhcmUgdGhlIHRvcCBsZXZlbCBub2RlIGluIHRoZSBhbmltYXRpb25cblx0XHQvLyBoaWVyYXJjaHkuIEVhY2ggU3RhY2sgbm9kZSB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgQW5pbWF0aW9uQ2xpcFxuXHRcdHBhcnNlQW5pbVN0YWNrczogZnVuY3Rpb24gKCBsYXllcnNNYXAgKSB7XG5cblx0XHRcdHZhciByYXdTdGFja3MgPSBmYnhUcmVlLk9iamVjdHMuQW5pbWF0aW9uU3RhY2s7XG5cblx0XHRcdC8vIGNvbm5lY3QgdGhlIHN0YWNrcyAoY2xpcHMpIHVwIHRvIHRoZSBsYXllcnNcblx0XHRcdHZhciByYXdDbGlwcyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB2YXIgbm9kZUlEIGluIHJhd1N0YWNrcyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBjb25uZWN0aW9ucy5nZXQoIHBhcnNlSW50KCBub2RlSUQgKSApLmNoaWxkcmVuO1xuXG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRcdC8vIGl0IHNlZW1zIGxpa2Ugc3RhY2tzIHdpbGwgYWx3YXlzIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSBsYXllci4gQnV0IGp1c3QgaW4gY2FzZSB0aGVyZSBhcmUgZmlsZXNcblx0XHRcdFx0XHQvLyB3aGVyZSB0aGVyZSBhcmUgbXVsdGlwbGUgbGF5ZXJzIHBlciBzdGFjaywgd2UnbGwgZGlzcGxheSBhIHdhcm5pbmdcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IEVuY291bnRlcmVkIGFuIGFuaW1hdGlvbiBzdGFjayB3aXRoIG11bHRpcGxlIGxheWVycywgdGhpcyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC4gSWdub3Jpbmcgc3Vic2VxdWVudCBsYXllcnMuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbGF5ZXIgPSBsYXllcnNNYXAuZ2V0KCBjaGlsZHJlblsgMCBdLklEICk7XG5cblx0XHRcdFx0cmF3Q2xpcHNbIG5vZGVJRCBdID0ge1xuXG5cdFx0XHRcdFx0bmFtZTogcmF3U3RhY2tzWyBub2RlSUQgXS5hdHRyTmFtZSxcblx0XHRcdFx0XHRsYXllcjogbGF5ZXIsXG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmF3Q2xpcHM7XG5cblx0XHR9LFxuXG5cdFx0YWRkQ2xpcDogZnVuY3Rpb24gKCByYXdDbGlwICkge1xuXG5cdFx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cdFx0XHRyYXdDbGlwLmxheWVyLmZvckVhY2goIGZ1bmN0aW9uICggcmF3VHJhY2tzICkge1xuXG5cdFx0XHRcdHRyYWNrcyA9IHRyYWNrcy5jb25jYXQoIHNjb3BlLmdlbmVyYXRlVHJhY2tzKCByYXdUcmFja3MgKSApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggcmF3Q2xpcC5uYW1lLCAtIDEsIHRyYWNrcyApO1xuXG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlVHJhY2tzOiBmdW5jdGlvbiAoIHJhd1RyYWNrcyApIHtcblxuXHRcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG5cdFx0XHR2YXIgaW5pdGlhbFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblx0XHRcdHZhciBpbml0aWFsUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXHRcdFx0dmFyIGluaXRpYWxTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGlmICggcmF3VHJhY2tzLnRyYW5zZm9ybSApIHJhd1RyYWNrcy50cmFuc2Zvcm0uZGVjb21wb3NlKCBpbml0aWFsUG9zaXRpb24sIGluaXRpYWxSb3RhdGlvbiwgaW5pdGlhbFNjYWxlICk7XG5cblx0XHRcdGluaXRpYWxQb3NpdGlvbiA9IGluaXRpYWxQb3NpdGlvbi50b0FycmF5KCk7XG5cdFx0XHRpbml0aWFsUm90YXRpb24gPSBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbiggaW5pdGlhbFJvdGF0aW9uLCByYXdUcmFja3MuZXVsZXJPcmRlciApLnRvQXJyYXkoKTtcblx0XHRcdGluaXRpYWxTY2FsZSA9IGluaXRpYWxTY2FsZS50b0FycmF5KCk7XG5cblx0XHRcdGlmICggcmF3VHJhY2tzLlQgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyggcmF3VHJhY2tzLlQuY3VydmVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgcG9zaXRpb25UcmFjayA9IHRoaXMuZ2VuZXJhdGVWZWN0b3JUcmFjayggcmF3VHJhY2tzLm1vZGVsTmFtZSwgcmF3VHJhY2tzLlQuY3VydmVzLCBpbml0aWFsUG9zaXRpb24sICdwb3NpdGlvbicgKTtcblx0XHRcdFx0aWYgKCBwb3NpdGlvblRyYWNrICE9PSB1bmRlZmluZWQgKSB0cmFja3MucHVzaCggcG9zaXRpb25UcmFjayApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcmF3VHJhY2tzLlIgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyggcmF3VHJhY2tzLlIuY3VydmVzICkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHR2YXIgcm90YXRpb25UcmFjayA9IHRoaXMuZ2VuZXJhdGVSb3RhdGlvblRyYWNrKCByYXdUcmFja3MubW9kZWxOYW1lLCByYXdUcmFja3MuUi5jdXJ2ZXMsIGluaXRpYWxSb3RhdGlvbiwgcmF3VHJhY2tzLnByZVJvdGF0aW9uLCByYXdUcmFja3MucG9zdFJvdGF0aW9uLCByYXdUcmFja3MuZXVsZXJPcmRlciApO1xuXHRcdFx0XHRpZiAoIHJvdGF0aW9uVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCByb3RhdGlvblRyYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByYXdUcmFja3MuUyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKCByYXdUcmFja3MuUy5jdXJ2ZXMgKS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHZhciBzY2FsZVRyYWNrID0gdGhpcy5nZW5lcmF0ZVZlY3RvclRyYWNrKCByYXdUcmFja3MubW9kZWxOYW1lLCByYXdUcmFja3MuUy5jdXJ2ZXMsIGluaXRpYWxTY2FsZSwgJ3NjYWxlJyApO1xuXHRcdFx0XHRpZiAoIHNjYWxlVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCBzY2FsZVRyYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByYXdUcmFja3MuRGVmb3JtUGVyY2VudCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBtb3JwaFRyYWNrID0gdGhpcy5nZW5lcmF0ZU1vcnBoVHJhY2soIHJhd1RyYWNrcyApO1xuXHRcdFx0XHRpZiAoIG1vcnBoVHJhY2sgIT09IHVuZGVmaW5lZCApIHRyYWNrcy5wdXNoKCBtb3JwaFRyYWNrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyYWNrcztcblxuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZVZlY3RvclRyYWNrOiBmdW5jdGlvbiAoIG1vZGVsTmFtZSwgY3VydmVzLCBpbml0aWFsVmFsdWUsIHR5cGUgKSB7XG5cblx0XHRcdHZhciB0aW1lcyA9IHRoaXMuZ2V0VGltZXNGb3JBbGxBeGVzKCBjdXJ2ZXMgKTtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldEtleWZyYW1lVHJhY2tWYWx1ZXMoIHRpbWVzLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gbmV3IFZlY3RvcktleWZyYW1lVHJhY2soIG1vZGVsTmFtZSArICcuJyArIHR5cGUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuXHRcdH0sXG5cblx0XHRnZW5lcmF0ZVJvdGF0aW9uVHJhY2s6IGZ1bmN0aW9uICggbW9kZWxOYW1lLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSwgcHJlUm90YXRpb24sIHBvc3RSb3RhdGlvbiwgZXVsZXJPcmRlciApIHtcblxuXHRcdFx0aWYgKCBjdXJ2ZXMueCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuaW50ZXJwb2xhdGVSb3RhdGlvbnMoIGN1cnZlcy54ICk7XG5cdFx0XHRcdGN1cnZlcy54LnZhbHVlcyA9IGN1cnZlcy54LnZhbHVlcy5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY3VydmVzLnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlUm90YXRpb25zKCBjdXJ2ZXMueSApO1xuXHRcdFx0XHRjdXJ2ZXMueS52YWx1ZXMgPSBjdXJ2ZXMueS52YWx1ZXMubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1cnZlcy56ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZVJvdGF0aW9ucyggY3VydmVzLnogKTtcblx0XHRcdFx0Y3VydmVzLnoudmFsdWVzID0gY3VydmVzLnoudmFsdWVzLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy5nZXRUaW1lc0ZvckFsbEF4ZXMoIGN1cnZlcyApO1xuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0S2V5ZnJhbWVUcmFja1ZhbHVlcyggdGltZXMsIGN1cnZlcywgaW5pdGlhbFZhbHVlICk7XG5cblx0XHRcdGlmICggcHJlUm90YXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRwcmVSb3RhdGlvbiA9IHByZVJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRcdHByZVJvdGF0aW9uLnB1c2goIGV1bGVyT3JkZXIgKTtcblxuXHRcdFx0XHRwcmVSb3RhdGlvbiA9IG5ldyBFdWxlcigpLmZyb21BcnJheSggcHJlUm90YXRpb24gKTtcblx0XHRcdFx0cHJlUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21FdWxlciggcHJlUm90YXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvc3RSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHBvc3RSb3RhdGlvbiA9IHBvc3RSb3RhdGlvbi5tYXAoIE1hdGhVdGlscy5kZWdUb1JhZCApO1xuXHRcdFx0XHRwb3N0Um90YXRpb24ucHVzaCggZXVsZXJPcmRlciApO1xuXG5cdFx0XHRcdHBvc3RSb3RhdGlvbiA9IG5ldyBFdWxlcigpLmZyb21BcnJheSggcG9zdFJvdGF0aW9uICk7XG5cdFx0XHRcdHBvc3RSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbUV1bGVyKCBwb3N0Um90YXRpb24gKS5pbnZlcnQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0XHR2YXIgZXVsZXIgPSBuZXcgRXVsZXIoKTtcblxuXHRcdFx0dmFyIHF1YXRlcm5pb25WYWx1ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGV1bGVyLnNldCggdmFsdWVzWyBpIF0sIHZhbHVlc1sgaSArIDEgXSwgdmFsdWVzWyBpICsgMiBdLCBldWxlck9yZGVyICk7XG5cblx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICk7XG5cblx0XHRcdFx0aWYgKCBwcmVSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbi5wcmVtdWx0aXBseSggcHJlUm90YXRpb24gKTtcblx0XHRcdFx0aWYgKCBwb3N0Um90YXRpb24gIT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24ubXVsdGlwbHkoIHBvc3RSb3RhdGlvbiApO1xuXG5cdFx0XHRcdHF1YXRlcm5pb24udG9BcnJheSggcXVhdGVybmlvblZhbHVlcywgKCBpIC8gMyApICogNCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG1vZGVsTmFtZSArICcucXVhdGVybmlvbicsIHRpbWVzLCBxdWF0ZXJuaW9uVmFsdWVzICk7XG5cblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVNb3JwaFRyYWNrOiBmdW5jdGlvbiAoIHJhd1RyYWNrcyApIHtcblxuXHRcdFx0dmFyIGN1cnZlcyA9IHJhd1RyYWNrcy5EZWZvcm1QZXJjZW50LmN1cnZlcy5tb3JwaDtcblx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXMudmFsdWVzLm1hcCggZnVuY3Rpb24gKCB2YWwgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHZhbCAvIDEwMDtcblxuXHRcdFx0fSApO1xuXG5cdFx0XHR2YXIgbW9ycGhOdW0gPSBzY2VuZUdyYXBoLmdldE9iamVjdEJ5TmFtZSggcmF3VHJhY2tzLm1vZGVsTmFtZSApLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgcmF3VHJhY2tzLm1vcnBoTmFtZSBdO1xuXG5cdFx0XHRyZXR1cm4gbmV3IE51bWJlcktleWZyYW1lVHJhY2soIHJhd1RyYWNrcy5tb2RlbE5hbWUgKyAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhOdW0gKyAnXScsIGN1cnZlcy50aW1lcywgdmFsdWVzICk7XG5cblx0XHR9LFxuXG5cdFx0Ly8gRm9yIGFsbCBhbmltYXRlZCBvYmplY3RzLCB0aW1lcyBhcmUgZGVmaW5lZCBzZXBhcmF0ZWx5IGZvciBlYWNoIGF4aXNcblx0XHQvLyBIZXJlIHdlJ2xsIGNvbWJpbmUgdGhlIHRpbWVzIGludG8gb25lIHNvcnRlZCBhcnJheSB3aXRob3V0IGR1cGxpY2F0ZXNcblx0XHRnZXRUaW1lc0ZvckFsbEF4ZXM6IGZ1bmN0aW9uICggY3VydmVzICkge1xuXG5cdFx0XHR2YXIgdGltZXMgPSBbXTtcblxuXHRcdFx0Ly8gZmlyc3Qgam9pbiB0b2dldGhlciB0aGUgdGltZXMgZm9yIGVhY2ggYXhpcywgaWYgZGVmaW5lZFxuXHRcdFx0aWYgKCBjdXJ2ZXMueCAhPT0gdW5kZWZpbmVkICkgdGltZXMgPSB0aW1lcy5jb25jYXQoIGN1cnZlcy54LnRpbWVzICk7XG5cdFx0XHRpZiAoIGN1cnZlcy55ICE9PSB1bmRlZmluZWQgKSB0aW1lcyA9IHRpbWVzLmNvbmNhdCggY3VydmVzLnkudGltZXMgKTtcblx0XHRcdGlmICggY3VydmVzLnogIT09IHVuZGVmaW5lZCApIHRpbWVzID0gdGltZXMuY29uY2F0KCBjdXJ2ZXMuei50aW1lcyApO1xuXG5cdFx0XHQvLyB0aGVuIHNvcnQgdGhlbVxuXHRcdFx0dGltZXMgPSB0aW1lcy5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGEgLSBiO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIGFuZCByZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCB0aW1lcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdHZhciB0YXJnZXRJbmRleCA9IDE7XG5cdFx0XHRcdHZhciBsYXN0VmFsdWUgPSB0aW1lc1sgMCBdO1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCB0aW1lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGltZXNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSAhPT0gbGFzdFZhbHVlICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lc1sgdGFyZ2V0SW5kZXggXSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0XHRcdGxhc3RWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0XHRcdHRhcmdldEluZGV4ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aW1lcyA9IHRpbWVzLnNsaWNlKCAwLCB0YXJnZXRJbmRleCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aW1lcztcblxuXHRcdH0sXG5cblx0XHRnZXRLZXlmcmFtZVRyYWNrVmFsdWVzOiBmdW5jdGlvbiAoIHRpbWVzLCBjdXJ2ZXMsIGluaXRpYWxWYWx1ZSApIHtcblxuXHRcdFx0dmFyIHByZXZWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHR2YXIgeEluZGV4ID0gLSAxO1xuXHRcdFx0dmFyIHlJbmRleCA9IC0gMTtcblx0XHRcdHZhciB6SW5kZXggPSAtIDE7XG5cblx0XHRcdHRpbWVzLmZvckVhY2goIGZ1bmN0aW9uICggdGltZSApIHtcblxuXHRcdFx0XHRpZiAoIGN1cnZlcy54ICkgeEluZGV4ID0gY3VydmVzLngudGltZXMuaW5kZXhPZiggdGltZSApO1xuXHRcdFx0XHRpZiAoIGN1cnZlcy55ICkgeUluZGV4ID0gY3VydmVzLnkudGltZXMuaW5kZXhPZiggdGltZSApO1xuXHRcdFx0XHRpZiAoIGN1cnZlcy56ICkgekluZGV4ID0gY3VydmVzLnoudGltZXMuaW5kZXhPZiggdGltZSApO1xuXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIHggdmFsdWUgZGVmaW5lZCBmb3IgdGhpcyBmcmFtZSwgdXNlIHRoYXRcblx0XHRcdFx0aWYgKCB4SW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdHZhciB4VmFsdWUgPSBjdXJ2ZXMueC52YWx1ZXNbIHhJbmRleCBdO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB4VmFsdWUgKTtcblx0XHRcdFx0XHRwcmV2VmFsdWVbIDAgXSA9IHhWYWx1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHVzZSB0aGUgeCB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBmcmFtZVxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCBwcmV2VmFsdWVbIDAgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHlJbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdFx0dmFyIHlWYWx1ZSA9IGN1cnZlcy55LnZhbHVlc1sgeUluZGV4IF07XG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHlWYWx1ZSApO1xuXHRcdFx0XHRcdHByZXZWYWx1ZVsgMSBdID0geVZhbHVlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggcHJldlZhbHVlWyAxIF0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB6SW5kZXggIT09IC0gMSApIHtcblxuXHRcdFx0XHRcdHZhciB6VmFsdWUgPSBjdXJ2ZXMuei52YWx1ZXNbIHpJbmRleCBdO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB6VmFsdWUgKTtcblx0XHRcdFx0XHRwcmV2VmFsdWVbIDIgXSA9IHpWYWx1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIHByZXZWYWx1ZVsgMiBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cblx0XHR9LFxuXG5cdFx0Ly8gUm90YXRpb25zIGFyZSBkZWZpbmVkIGFzIEV1bGVyIGFuZ2xlcyB3aGljaCBjYW4gaGF2ZSB2YWx1ZXMgIG9mIGFueSBzaXplXG5cdFx0Ly8gVGhlc2Ugd2lsbCBiZSBjb252ZXJ0ZWQgdG8gcXVhdGVybmlvbnMgd2hpY2ggZG9uJ3Qgc3VwcG9ydCB2YWx1ZXMgZ3JlYXRlciB0aGFuXG5cdFx0Ly8gUEksIHNvIHdlJ2xsIGludGVycG9sYXRlIGxhcmdlIHJvdGF0aW9uc1xuXHRcdGludGVycG9sYXRlUm90YXRpb25zOiBmdW5jdGlvbiAoIGN1cnZlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPCBjdXJ2ZS52YWx1ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbml0aWFsVmFsdWUgPSBjdXJ2ZS52YWx1ZXNbIGkgLSAxIF07XG5cdFx0XHRcdHZhciB2YWx1ZXNTcGFuID0gY3VydmUudmFsdWVzWyBpIF0gLSBpbml0aWFsVmFsdWU7XG5cblx0XHRcdFx0dmFyIGFic29sdXRlU3BhbiA9IE1hdGguYWJzKCB2YWx1ZXNTcGFuICk7XG5cblx0XHRcdFx0aWYgKCBhYnNvbHV0ZVNwYW4gPj0gMTgwICkge1xuXG5cdFx0XHRcdFx0dmFyIG51bVN1YkludGVydmFscyA9IGFic29sdXRlU3BhbiAvIDE4MDtcblxuXHRcdFx0XHRcdHZhciBzdGVwID0gdmFsdWVzU3BhbiAvIG51bVN1YkludGVydmFscztcblx0XHRcdFx0XHR2YXIgbmV4dFZhbHVlID0gaW5pdGlhbFZhbHVlICsgc3RlcDtcblxuXHRcdFx0XHRcdHZhciBpbml0aWFsVGltZSA9IGN1cnZlLnRpbWVzWyBpIC0gMSBdO1xuXHRcdFx0XHRcdHZhciB0aW1lU3BhbiA9IGN1cnZlLnRpbWVzWyBpIF0gLSBpbml0aWFsVGltZTtcblx0XHRcdFx0XHR2YXIgaW50ZXJ2YWwgPSB0aW1lU3BhbiAvIG51bVN1YkludGVydmFscztcblx0XHRcdFx0XHR2YXIgbmV4dFRpbWUgPSBpbml0aWFsVGltZSArIGludGVydmFsO1xuXG5cdFx0XHRcdFx0dmFyIGludGVycG9sYXRlZFRpbWVzID0gW107XG5cdFx0XHRcdFx0dmFyIGludGVycG9sYXRlZFZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCBuZXh0VGltZSA8IGN1cnZlLnRpbWVzWyBpIF0gKSB7XG5cblx0XHRcdFx0XHRcdGludGVycG9sYXRlZFRpbWVzLnB1c2goIG5leHRUaW1lICk7XG5cdFx0XHRcdFx0XHRuZXh0VGltZSArPSBpbnRlcnZhbDtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGVkVmFsdWVzLnB1c2goIG5leHRWYWx1ZSApO1xuXHRcdFx0XHRcdFx0bmV4dFZhbHVlICs9IHN0ZXA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJ2ZS50aW1lcyA9IGluamVjdCggY3VydmUudGltZXMsIGksIGludGVycG9sYXRlZFRpbWVzICk7XG5cdFx0XHRcdFx0Y3VydmUudmFsdWVzID0gaW5qZWN0KCBjdXJ2ZS52YWx1ZXMsIGksIGludGVycG9sYXRlZFZhbHVlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHR9O1xuXG5cdC8vIHBhcnNlIGFuIEZCWCBmaWxlIGluIEFTQ0lJIGZvcm1hdFxuXHRmdW5jdGlvbiBUZXh0UGFyc2VyKCkge31cblxuXHRUZXh0UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuXHRcdGNvbnN0cnVjdG9yOiBUZXh0UGFyc2VyLFxuXG5cdFx0Z2V0UHJldk5vZGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubm9kZVN0YWNrWyB0aGlzLmN1cnJlbnRJbmRlbnQgLSAyIF07XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q3VycmVudE5vZGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMubm9kZVN0YWNrWyB0aGlzLmN1cnJlbnRJbmRlbnQgLSAxIF07XG5cblx0XHR9LFxuXG5cdFx0Z2V0Q3VycmVudFByb3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudFByb3A7XG5cblx0XHR9LFxuXG5cdFx0cHVzaFN0YWNrOiBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cblx0XHRcdHRoaXMubm9kZVN0YWNrLnB1c2goIG5vZGUgKTtcblx0XHRcdHRoaXMuY3VycmVudEluZGVudCArPSAxO1xuXG5cdFx0fSxcblxuXHRcdHBvcFN0YWNrOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHRoaXMubm9kZVN0YWNrLnBvcCgpO1xuXHRcdFx0dGhpcy5jdXJyZW50SW5kZW50IC09IDE7XG5cblx0XHR9LFxuXG5cdFx0c2V0Q3VycmVudFByb3A6IGZ1bmN0aW9uICggdmFsLCBuYW1lICkge1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRQcm9wID0gdmFsO1xuXHRcdFx0dGhpcy5jdXJyZW50UHJvcE5hbWUgPSBuYW1lO1xuXG5cdFx0fSxcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRoaXMuY3VycmVudEluZGVudCA9IDA7XG5cblx0XHRcdHRoaXMuYWxsTm9kZXMgPSBuZXcgRkJYVHJlZSgpO1xuXHRcdFx0dGhpcy5ub2RlU3RhY2sgPSBbXTtcblx0XHRcdHRoaXMuY3VycmVudFByb3AgPSBbXTtcblx0XHRcdHRoaXMuY3VycmVudFByb3BOYW1lID0gJyc7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHZhciBzcGxpdCA9IHRleHQuc3BsaXQoIC9bXFxyXFxuXSsvICk7XG5cblx0XHRcdHNwbGl0LmZvckVhY2goIGZ1bmN0aW9uICggbGluZSwgaSApIHtcblxuXHRcdFx0XHR2YXIgbWF0Y2hDb21tZW50ID0gbGluZS5tYXRjaCggL15bXFxzXFx0XSo7LyApO1xuXHRcdFx0XHR2YXIgbWF0Y2hFbXB0eSA9IGxpbmUubWF0Y2goIC9eW1xcc1xcdF0qJC8gKTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoQ29tbWVudCB8fCBtYXRjaEVtcHR5ICkgcmV0dXJuO1xuXG5cdFx0XHRcdHZhciBtYXRjaEJlZ2lubmluZyA9IGxpbmUubWF0Y2goICdeXFxcXHR7JyArIHNjb3BlLmN1cnJlbnRJbmRlbnQgKyAnfShcXFxcdyspOiguKil7JywgJycgKTtcblx0XHRcdFx0dmFyIG1hdGNoUHJvcGVydHkgPSBsaW5lLm1hdGNoKCAnXlxcXFx0eycgKyAoIHNjb3BlLmN1cnJlbnRJbmRlbnQgKSArICd9KFxcXFx3Kyk6W1xcXFxzXFxcXHRcXFxcclxcXFxuXSguKiknICk7XG5cdFx0XHRcdHZhciBtYXRjaEVuZCA9IGxpbmUubWF0Y2goICdeXFxcXHR7JyArICggc2NvcGUuY3VycmVudEluZGVudCAtIDEgKSArICd9fScgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoQmVnaW5uaW5nICkge1xuXG5cdFx0XHRcdFx0c2NvcGUucGFyc2VOb2RlQmVnaW4oIGxpbmUsIG1hdGNoQmVnaW5uaW5nICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hQcm9wZXJ0eSApIHtcblxuXHRcdFx0XHRcdHNjb3BlLnBhcnNlTm9kZVByb3BlcnR5KCBsaW5lLCBtYXRjaFByb3BlcnR5LCBzcGxpdFsgKysgaSBdICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hFbmQgKSB7XG5cblx0XHRcdFx0XHRzY29wZS5wb3BTdGFjaygpO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpbmUubWF0Y2goIC9eW15cXHNcXHR9XS8gKSApIHtcblxuXHRcdFx0XHRcdC8vIGxhcmdlIGFycmF5cyBhcmUgc3BsaXQgb3ZlciBtdWx0aXBsZSBsaW5lcyB0ZXJtaW5hdGVkIHdpdGggYSAnLCcgY2hhcmFjdGVyXG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBlbmNvdW50ZXJlZCB0aGUgbGluZSBuZWVkcyB0byBiZSBqb2luZWQgdG8gdGhlIHByZXZpb3VzIGxpbmVcblx0XHRcdFx0XHRzY29wZS5wYXJzZU5vZGVQcm9wZXJ0eUNvbnRpbnVlZCggbGluZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hbGxOb2RlcztcblxuXHRcdH0sXG5cblx0XHRwYXJzZU5vZGVCZWdpbjogZnVuY3Rpb24gKCBsaW5lLCBwcm9wZXJ0eSApIHtcblxuXHRcdFx0dmFyIG5vZGVOYW1lID0gcHJvcGVydHlbIDEgXS50cmltKCkucmVwbGFjZSggL15cIi8sICcnICkucmVwbGFjZSggL1wiJC8sICcnICk7XG5cblx0XHRcdHZhciBub2RlQXR0cnMgPSBwcm9wZXJ0eVsgMiBdLnNwbGl0KCAnLCcgKS5tYXAoIGZ1bmN0aW9uICggYXR0ciApIHtcblxuXHRcdFx0XHRyZXR1cm4gYXR0ci50cmltKCkucmVwbGFjZSggL15cIi8sICcnICkucmVwbGFjZSggL1wiJC8sICcnICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dmFyIG5vZGUgPSB7IG5hbWU6IG5vZGVOYW1lIH07XG5cdFx0XHR2YXIgYXR0cnMgPSB0aGlzLnBhcnNlTm9kZUF0dHIoIG5vZGVBdHRycyApO1xuXG5cdFx0XHR2YXIgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG5cblx0XHRcdC8vIGEgdG9wIG5vZGVcblx0XHRcdGlmICggdGhpcy5jdXJyZW50SW5kZW50ID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuYWxsTm9kZXMuYWRkKCBub2RlTmFtZSwgbm9kZSApO1xuXG5cdFx0XHR9IGVsc2UgeyAvLyBhIHN1Ym5vZGVcblxuXHRcdFx0XHQvLyBpZiB0aGUgc3Vibm9kZSBhbHJlYWR5IGV4aXN0cywgYXBwZW5kIGl0XG5cdFx0XHRcdGlmICggbm9kZU5hbWUgaW4gY3VycmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgUG9zZSBuZWVkcyBQb3NlTm9kZXMgYXMgYW4gYXJyYXlcblx0XHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSAnUG9zZU5vZGUnICkge1xuXG5cdFx0XHRcdFx0XHRjdXJyZW50Tm9kZS5Qb3NlTm9kZS5wdXNoKCBub2RlICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXS5pZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXSA9IHt9O1xuXHRcdFx0XHRcdFx0Y3VycmVudE5vZGVbIG5vZGVOYW1lIF1bIGN1cnJlbnROb2RlWyBub2RlTmFtZSBdLmlkIF0gPSBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggYXR0cnMuaWQgIT09ICcnICkgY3VycmVudE5vZGVbIG5vZGVOYW1lIF1bIGF0dHJzLmlkIF0gPSBub2RlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBhdHRycy5pZCA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXSA9IHt9O1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdWyBhdHRycy5pZCBdID0gbm9kZTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSAhPT0gJ1Byb3BlcnRpZXM3MCcgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVOYW1lID09PSAnUG9zZU5vZGUnIClcdGN1cnJlbnROb2RlWyBub2RlTmFtZSBdID0gWyBub2RlIF07XG5cdFx0XHRcdFx0ZWxzZSBjdXJyZW50Tm9kZVsgbm9kZU5hbWUgXSA9IG5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZW9mIGF0dHJzLmlkID09PSAnbnVtYmVyJyApIG5vZGUuaWQgPSBhdHRycy5pZDtcblx0XHRcdGlmICggYXR0cnMubmFtZSAhPT0gJycgKSBub2RlLmF0dHJOYW1lID0gYXR0cnMubmFtZTtcblx0XHRcdGlmICggYXR0cnMudHlwZSAhPT0gJycgKSBub2RlLmF0dHJUeXBlID0gYXR0cnMudHlwZTtcblxuXHRcdFx0dGhpcy5wdXNoU3RhY2soIG5vZGUgKTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZU5vZGVBdHRyOiBmdW5jdGlvbiAoIGF0dHJzICkge1xuXG5cdFx0XHR2YXIgaWQgPSBhdHRyc1sgMCBdO1xuXG5cdFx0XHRpZiAoIGF0dHJzWyAwIF0gIT09ICcnICkge1xuXG5cdFx0XHRcdGlkID0gcGFyc2VJbnQoIGF0dHJzWyAwIF0gKTtcblxuXHRcdFx0XHRpZiAoIGlzTmFOKCBpZCApICkge1xuXG5cdFx0XHRcdFx0aWQgPSBhdHRyc1sgMCBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZSA9ICcnLCB0eXBlID0gJyc7XG5cblx0XHRcdGlmICggYXR0cnMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHRuYW1lID0gYXR0cnNbIDEgXS5yZXBsYWNlKCAvXihcXHcrKTo6LywgJycgKTtcblx0XHRcdFx0dHlwZSA9IGF0dHJzWyAyIF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgaWQ6IGlkLCBuYW1lOiBuYW1lLCB0eXBlOiB0eXBlIH07XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VOb2RlUHJvcGVydHk6IGZ1bmN0aW9uICggbGluZSwgcHJvcGVydHksIGNvbnRlbnRMaW5lICkge1xuXG5cdFx0XHR2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eVsgMSBdLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApLnRyaW0oKTtcblx0XHRcdHZhciBwcm9wVmFsdWUgPSBwcm9wZXJ0eVsgMiBdLnJlcGxhY2UoIC9eXCIvLCAnJyApLnJlcGxhY2UoIC9cIiQvLCAnJyApLnRyaW0oKTtcblxuXHRcdFx0Ly8gZm9yIHNwZWNpYWwgY2FzZTogYmFzZTY0IGltYWdlIGRhdGEgZm9sbG93cyBcIkNvbnRlbnQ6ICxcIiBsaW5lXG5cdFx0XHQvL1x0Q29udGVudDogLFxuXHRcdFx0Ly9cdCBcIi85ai80UkRhUlhocFpnQUFUVTBBLi4uXCJcblx0XHRcdGlmICggcHJvcE5hbWUgPT09ICdDb250ZW50JyAmJiBwcm9wVmFsdWUgPT09ICcsJyApIHtcblxuXHRcdFx0XHRwcm9wVmFsdWUgPSBjb250ZW50TGluZS5yZXBsYWNlKCAvXCIvZywgJycgKS5yZXBsYWNlKCAvLCQvLCAnJyApLnRyaW0oKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG5cdFx0XHR2YXIgcGFyZW50TmFtZSA9IGN1cnJlbnROb2RlLm5hbWU7XG5cblx0XHRcdGlmICggcGFyZW50TmFtZSA9PT0gJ1Byb3BlcnRpZXM3MCcgKSB7XG5cblx0XHRcdFx0dGhpcy5wYXJzZU5vZGVTcGVjaWFsUHJvcGVydHkoIGxpbmUsIHByb3BOYW1lLCBwcm9wVmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbm5lY3Rpb25zXG5cdFx0XHRpZiAoIHByb3BOYW1lID09PSAnQycgKSB7XG5cblx0XHRcdFx0dmFyIGNvbm5Qcm9wcyA9IHByb3BWYWx1ZS5zcGxpdCggJywnICkuc2xpY2UoIDEgKTtcblx0XHRcdFx0dmFyIGZyb20gPSBwYXJzZUludCggY29ublByb3BzWyAwIF0gKTtcblx0XHRcdFx0dmFyIHRvID0gcGFyc2VJbnQoIGNvbm5Qcm9wc1sgMSBdICk7XG5cblx0XHRcdFx0dmFyIHJlc3QgPSBwcm9wVmFsdWUuc3BsaXQoICcsJyApLnNsaWNlKCAzICk7XG5cblx0XHRcdFx0cmVzdCA9IHJlc3QubWFwKCBmdW5jdGlvbiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZWxlbS50cmltKCkucmVwbGFjZSggL15cIi8sICcnICk7XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHByb3BOYW1lID0gJ2Nvbm5lY3Rpb25zJztcblx0XHRcdFx0cHJvcFZhbHVlID0gWyBmcm9tLCB0byBdO1xuXHRcdFx0XHRhcHBlbmQoIHByb3BWYWx1ZSwgcmVzdCApO1xuXG5cdFx0XHRcdGlmICggY3VycmVudE5vZGVbIHByb3BOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vZGVcblx0XHRcdGlmICggcHJvcE5hbWUgPT09ICdOb2RlJyApIGN1cnJlbnROb2RlLmlkID0gcHJvcFZhbHVlO1xuXG5cdFx0XHQvLyBjb25uZWN0aW9uc1xuXHRcdFx0aWYgKCBwcm9wTmFtZSBpbiBjdXJyZW50Tm9kZSAmJiBBcnJheS5pc0FycmF5KCBjdXJyZW50Tm9kZVsgcHJvcE5hbWUgXSApICkge1xuXG5cdFx0XHRcdGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdLnB1c2goIHByb3BWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggcHJvcE5hbWUgIT09ICdhJyApIGN1cnJlbnROb2RlWyBwcm9wTmFtZSBdID0gcHJvcFZhbHVlO1xuXHRcdFx0XHRlbHNlIGN1cnJlbnROb2RlLmEgPSBwcm9wVmFsdWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRDdXJyZW50UHJvcCggY3VycmVudE5vZGUsIHByb3BOYW1lICk7XG5cblx0XHRcdC8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5LCB1bmxlc3MgaXQgZW5kcyBpbiAnLCcgaW4gd2hpY2ggY2FzZSBtb3JlIHdpbGwgYmUgYWRkZWQgdG8gaXRcblx0XHRcdGlmICggcHJvcE5hbWUgPT09ICdhJyAmJiBwcm9wVmFsdWUuc2xpY2UoIC0gMSApICE9PSAnLCcgKSB7XG5cblx0XHRcdFx0Y3VycmVudE5vZGUuYSA9IHBhcnNlTnVtYmVyQXJyYXkoIHByb3BWYWx1ZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0cGFyc2VOb2RlUHJvcGVydHlDb250aW51ZWQ6IGZ1bmN0aW9uICggbGluZSApIHtcblxuXHRcdFx0dmFyIGN1cnJlbnROb2RlID0gdGhpcy5nZXRDdXJyZW50Tm9kZSgpO1xuXG5cdFx0XHRjdXJyZW50Tm9kZS5hICs9IGxpbmU7XG5cblx0XHRcdC8vIGlmIHRoZSBsaW5lIGRvZXNuJ3QgZW5kIGluICcsJyB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcHJvcGVydHkgdmFsdWVcblx0XHRcdC8vIHNvIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhbiBhcnJheVxuXHRcdFx0aWYgKCBsaW5lLnNsaWNlKCAtIDEgKSAhPT0gJywnICkge1xuXG5cdFx0XHRcdGN1cnJlbnROb2RlLmEgPSBwYXJzZU51bWJlckFycmF5KCBjdXJyZW50Tm9kZS5hICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBwYXJzZSBcIlByb3BlcnR5NzBcIlxuXHRcdHBhcnNlTm9kZVNwZWNpYWxQcm9wZXJ0eTogZnVuY3Rpb24gKCBsaW5lLCBwcm9wTmFtZSwgcHJvcFZhbHVlICkge1xuXG5cdFx0XHQvLyBzcGxpdCB0aGlzXG5cdFx0XHQvLyBQOiBcIkxjbCBTY2FsaW5nXCIsIFwiTGNsIFNjYWxpbmdcIiwgXCJcIiwgXCJBXCIsMSwxLDFcblx0XHRcdC8vIGludG8gYXJyYXkgbGlrZSBiZWxvd1xuXHRcdFx0Ly8gW1wiTGNsIFNjYWxpbmdcIiwgXCJMY2wgU2NhbGluZ1wiLCBcIlwiLCBcIkFcIiwgXCIxLDEsMVwiIF1cblx0XHRcdHZhciBwcm9wcyA9IHByb3BWYWx1ZS5zcGxpdCggJ1wiLCcgKS5tYXAoIGZ1bmN0aW9uICggcHJvcCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJvcC50cmltKCkucmVwbGFjZSggL15cXFwiLywgJycgKS5yZXBsYWNlKCAvXFxzLywgJ18nICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dmFyIGlubmVyUHJvcE5hbWUgPSBwcm9wc1sgMCBdO1xuXHRcdFx0dmFyIGlubmVyUHJvcFR5cGUxID0gcHJvcHNbIDEgXTtcblx0XHRcdHZhciBpbm5lclByb3BUeXBlMiA9IHByb3BzWyAyIF07XG5cdFx0XHR2YXIgaW5uZXJQcm9wRmxhZyA9IHByb3BzWyAzIF07XG5cdFx0XHR2YXIgaW5uZXJQcm9wVmFsdWUgPSBwcm9wc1sgNCBdO1xuXG5cdFx0XHQvLyBjYXN0IHZhbHVlcyB3aGVyZSBuZWVkZWQsIG90aGVyd2lzZSBsZWF2ZSBhcyBzdHJpbmdzXG5cdFx0XHRzd2l0Y2ggKCBpbm5lclByb3BUeXBlMSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnQnOlxuXHRcdFx0XHRjYXNlICdlbnVtJzpcblx0XHRcdFx0Y2FzZSAnYm9vbCc6XG5cdFx0XHRcdGNhc2UgJ1VMb25nTG9uZyc6XG5cdFx0XHRcdGNhc2UgJ2RvdWJsZSc6XG5cdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdGNhc2UgJ0ZpZWxkT2ZWaWV3Jzpcblx0XHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IHBhcnNlRmxvYXQoIGlubmVyUHJvcFZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnQ29sb3InOlxuXHRcdFx0XHRjYXNlICdDb2xvclJHQic6XG5cdFx0XHRcdGNhc2UgJ1ZlY3RvcjNEJzpcblx0XHRcdFx0Y2FzZSAnTGNsX1RyYW5zbGF0aW9uJzpcblx0XHRcdFx0Y2FzZSAnTGNsX1JvdGF0aW9uJzpcblx0XHRcdFx0Y2FzZSAnTGNsX1NjYWxpbmcnOlxuXHRcdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gcGFyc2VOdW1iZXJBcnJheSggaW5uZXJQcm9wVmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDQVVUSU9OOiB0aGVzZSBwcm9wcyBtdXN0IGFwcGVuZCB0byBwYXJlbnQncyBwYXJlbnRcblx0XHRcdHRoaXMuZ2V0UHJldk5vZGUoKVsgaW5uZXJQcm9wTmFtZSBdID0ge1xuXG5cdFx0XHRcdCd0eXBlJzogaW5uZXJQcm9wVHlwZTEsXG5cdFx0XHRcdCd0eXBlMic6IGlubmVyUHJvcFR5cGUyLFxuXHRcdFx0XHQnZmxhZyc6IGlubmVyUHJvcEZsYWcsXG5cdFx0XHRcdCd2YWx1ZSc6IGlubmVyUHJvcFZhbHVlXG5cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuc2V0Q3VycmVudFByb3AoIHRoaXMuZ2V0UHJldk5vZGUoKSwgaW5uZXJQcm9wTmFtZSApO1xuXG5cdFx0fSxcblxuXHR9O1xuXG5cdC8vIFBhcnNlIGFuIEZCWCBmaWxlIGluIEJpbmFyeSBmb3JtYXRcblx0ZnVuY3Rpb24gQmluYXJ5UGFyc2VyKCkge31cblxuXHRCaW5hcnlQYXJzZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEJpbmFyeVBhcnNlcixcblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0dmFyIHJlYWRlciA9IG5ldyBCaW5hcnlSZWFkZXIoIGJ1ZmZlciApO1xuXHRcdFx0cmVhZGVyLnNraXAoIDIzICk7IC8vIHNraXAgbWFnaWMgMjMgYnl0ZXNcblxuXHRcdFx0dmFyIHZlcnNpb24gPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cblx0XHRcdGlmICggdmVyc2lvbiA8IDY0MDAgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuRkJYTG9hZGVyOiBGQlggdmVyc2lvbiBub3Qgc3VwcG9ydGVkLCBGaWxlVmVyc2lvbjogJyArIHZlcnNpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYWxsTm9kZXMgPSBuZXcgRkJYVHJlZSgpO1xuXG5cdFx0XHR3aGlsZSAoICEgdGhpcy5lbmRPZkNvbnRlbnQoIHJlYWRlciApICkge1xuXG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5wYXJzZU5vZGUoIHJlYWRlciwgdmVyc2lvbiApO1xuXHRcdFx0XHRpZiAoIG5vZGUgIT09IG51bGwgKSBhbGxOb2Rlcy5hZGQoIG5vZGUubmFtZSwgbm9kZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhbGxOb2RlcztcblxuXHRcdH0sXG5cblx0XHQvLyBDaGVjayBpZiByZWFkZXIgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiBjb250ZW50LlxuXHRcdGVuZE9mQ29udGVudDogZnVuY3Rpb24gKCByZWFkZXIgKSB7XG5cblx0XHRcdC8vIGZvb3RlciBzaXplOiAxNjBieXRlcyArIDE2LWJ5dGUgYWxpZ25tZW50IHBhZGRpbmdcblx0XHRcdC8vIC0gMTZieXRlczogbWFnaWNcblx0XHRcdC8vIC0gcGFkZGluZyB0aWwgMTYtYnl0ZSBhbGlnbm1lbnQgKGF0IGxlYXN0IDFieXRlPylcblx0XHRcdC8vXHQoc2VlbXMgbGlrZSBzb21lIGV4cG9ydGVycyBlbWJlZCBmaXhlZCAxNSBvciAxNmJ5dGVzPylcblx0XHRcdC8vIC0gNGJ5dGVzOiBtYWdpY1xuXHRcdFx0Ly8gLSA0Ynl0ZXM6IHZlcnNpb25cblx0XHRcdC8vIC0gMTIwYnl0ZXM6IHplcm9cblx0XHRcdC8vIC0gMTZieXRlczogbWFnaWNcblx0XHRcdGlmICggcmVhZGVyLnNpemUoKSAlIDE2ID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiAoICggcmVhZGVyLmdldE9mZnNldCgpICsgMTYwICsgMTYgKSAmIH4gMHhmICkgPj0gcmVhZGVyLnNpemUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldE9mZnNldCgpICsgMTYwICsgMTYgPj0gcmVhZGVyLnNpemUoKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdC8vIHJlY3Vyc2l2ZWx5IHBhcnNlIG5vZGVzIHVudGlsIHRoZSBlbmQgb2YgdGhlIGZpbGUgaXMgcmVhY2hlZFxuXHRcdHBhcnNlTm9kZTogZnVuY3Rpb24gKCByZWFkZXIsIHZlcnNpb24gKSB7XG5cblx0XHRcdHZhciBub2RlID0ge307XG5cblx0XHRcdC8vIFRoZSBmaXJzdCB0aHJlZSBkYXRhIHNpemVzIGRlcGVuZHMgb24gdmVyc2lvbi5cblx0XHRcdHZhciBlbmRPZmZzZXQgPSAoIHZlcnNpb24gPj0gNzUwMCApID8gcmVhZGVyLmdldFVpbnQ2NCgpIDogcmVhZGVyLmdldFVpbnQzMigpO1xuXHRcdFx0dmFyIG51bVByb3BlcnRpZXMgPSAoIHZlcnNpb24gPj0gNzUwMCApID8gcmVhZGVyLmdldFVpbnQ2NCgpIDogcmVhZGVyLmdldFVpbnQzMigpO1xuXG5cdFx0XHQoIHZlcnNpb24gPj0gNzUwMCApID8gcmVhZGVyLmdldFVpbnQ2NCgpIDogcmVhZGVyLmdldFVpbnQzMigpOyAvLyB0aGUgcmV0dXJuZWQgcHJvcGVydHlMaXN0TGVuIGlzIG5vdCB1c2VkXG5cblx0XHRcdHZhciBuYW1lTGVuID0gcmVhZGVyLmdldFVpbnQ4KCk7XG5cdFx0XHR2YXIgbmFtZSA9IHJlYWRlci5nZXRTdHJpbmcoIG5hbWVMZW4gKTtcblxuXHRcdFx0Ly8gUmVnYXJkcyB0aGlzIG5vZGUgYXMgTlVMTC1yZWNvcmQgaWYgZW5kT2Zmc2V0IGlzIHplcm9cblx0XHRcdGlmICggZW5kT2Zmc2V0ID09PSAwICkgcmV0dXJuIG51bGw7XG5cblx0XHRcdHZhciBwcm9wZXJ0eUxpc3QgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtUHJvcGVydGllczsgaSArKyApIHtcblxuXHRcdFx0XHRwcm9wZXJ0eUxpc3QucHVzaCggdGhpcy5wYXJzZVByb3BlcnR5KCByZWFkZXIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZ2FyZHMgdGhlIGZpcnN0IHRocmVlIGVsZW1lbnRzIGluIHByb3BlcnR5TGlzdCBhcyBpZCwgYXR0ck5hbWUsIGFuZCBhdHRyVHlwZVxuXHRcdFx0dmFyIGlkID0gcHJvcGVydHlMaXN0Lmxlbmd0aCA+IDAgPyBwcm9wZXJ0eUxpc3RbIDAgXSA6ICcnO1xuXHRcdFx0dmFyIGF0dHJOYW1lID0gcHJvcGVydHlMaXN0Lmxlbmd0aCA+IDEgPyBwcm9wZXJ0eUxpc3RbIDEgXSA6ICcnO1xuXHRcdFx0dmFyIGF0dHJUeXBlID0gcHJvcGVydHlMaXN0Lmxlbmd0aCA+IDIgPyBwcm9wZXJ0eUxpc3RbIDIgXSA6ICcnO1xuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGlzIG5vZGUgcmVwcmVzZW50cyBqdXN0IGEgc2luZ2xlIHByb3BlcnR5XG5cdFx0XHQvLyBsaWtlIChuYW1lLCAwKSBzZXQgb3IgKG5hbWUyLCBbMCwgMSwgMl0pIHNldCBvZiB7bmFtZTogMCwgbmFtZTI6IFswLCAxLCAyXX1cblx0XHRcdG5vZGUuc2luZ2xlUHJvcGVydHkgPSAoIG51bVByb3BlcnRpZXMgPT09IDEgJiYgcmVhZGVyLmdldE9mZnNldCgpID09PSBlbmRPZmZzZXQgKSA/IHRydWUgOiBmYWxzZTtcblxuXHRcdFx0d2hpbGUgKCBlbmRPZmZzZXQgPiByZWFkZXIuZ2V0T2Zmc2V0KCkgKSB7XG5cblx0XHRcdFx0dmFyIHN1Yk5vZGUgPSB0aGlzLnBhcnNlTm9kZSggcmVhZGVyLCB2ZXJzaW9uICk7XG5cblx0XHRcdFx0aWYgKCBzdWJOb2RlICE9PSBudWxsICkgdGhpcy5wYXJzZVN1Yk5vZGUoIG5hbWUsIG5vZGUsIHN1Yk5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRub2RlLnByb3BlcnR5TGlzdCA9IHByb3BlcnR5TGlzdDsgLy8gcmF3IHByb3BlcnR5IGxpc3QgdXNlZCBieSBwYXJlbnRcblxuXHRcdFx0aWYgKCB0eXBlb2YgaWQgPT09ICdudW1iZXInICkgbm9kZS5pZCA9IGlkO1xuXHRcdFx0aWYgKCBhdHRyTmFtZSAhPT0gJycgKSBub2RlLmF0dHJOYW1lID0gYXR0ck5hbWU7XG5cdFx0XHRpZiAoIGF0dHJUeXBlICE9PSAnJyApIG5vZGUuYXR0clR5cGUgPSBhdHRyVHlwZTtcblx0XHRcdGlmICggbmFtZSAhPT0gJycgKSBub2RlLm5hbWUgPSBuYW1lO1xuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH0sXG5cblx0XHRwYXJzZVN1Yk5vZGU6IGZ1bmN0aW9uICggbmFtZSwgbm9kZSwgc3ViTm9kZSApIHtcblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBjaGlsZCBub2RlIGlzIHNpbmdsZSBwcm9wZXJ0eVxuXHRcdFx0aWYgKCBzdWJOb2RlLnNpbmdsZVByb3BlcnR5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAwIF07XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0gPSBzdWJOb2RlO1xuXG5cdFx0XHRcdFx0c3ViTm9kZS5hID0gdmFsdWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnQ29ubmVjdGlvbnMnICYmIHN1Yk5vZGUubmFtZSA9PT0gJ0MnICkge1xuXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xuXG5cdFx0XHRcdHN1Yk5vZGUucHJvcGVydHlMaXN0LmZvckVhY2goIGZ1bmN0aW9uICggcHJvcGVydHksIGkgKSB7XG5cblx0XHRcdFx0XHQvLyBmaXJzdCBDb25uZWN0aW9uIGlzIEZCWCB0eXBlIChPTywgT1AsIGV0Yy4pLiBXZSdsbCBkaXNjYXJkIHRoZXNlXG5cdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgYXJyYXkucHVzaCggcHJvcGVydHkgKTtcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBub2RlLmNvbm5lY3Rpb25zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRub2RlLmNvbm5lY3Rpb25zID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5vZGUuY29ubmVjdGlvbnMucHVzaCggYXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggc3ViTm9kZS5uYW1lID09PSAnUHJvcGVydGllczcwJyApIHtcblxuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBzdWJOb2RlICk7XG5cblx0XHRcdFx0a2V5cy5mb3JFYWNoKCBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdFx0XHRcdG5vZGVbIGtleSBdID0gc3ViTm9kZVsga2V5IF07XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnUHJvcGVydGllczcwJyAmJiBzdWJOb2RlLm5hbWUgPT09ICdQJyApIHtcblxuXHRcdFx0XHR2YXIgaW5uZXJQcm9wTmFtZSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAwIF07XG5cdFx0XHRcdHZhciBpbm5lclByb3BUeXBlMSA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAxIF07XG5cdFx0XHRcdHZhciBpbm5lclByb3BUeXBlMiA9IHN1Yk5vZGUucHJvcGVydHlMaXN0WyAyIF07XG5cdFx0XHRcdHZhciBpbm5lclByb3BGbGFnID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDMgXTtcblx0XHRcdFx0dmFyIGlubmVyUHJvcFZhbHVlO1xuXG5cdFx0XHRcdGlmICggaW5uZXJQcm9wTmFtZS5pbmRleE9mKCAnTGNsICcgKSA9PT0gMCApIGlubmVyUHJvcE5hbWUgPSBpbm5lclByb3BOYW1lLnJlcGxhY2UoICdMY2wgJywgJ0xjbF8nICk7XG5cdFx0XHRcdGlmICggaW5uZXJQcm9wVHlwZTEuaW5kZXhPZiggJ0xjbCAnICkgPT09IDAgKSBpbm5lclByb3BUeXBlMSA9IGlubmVyUHJvcFR5cGUxLnJlcGxhY2UoICdMY2wgJywgJ0xjbF8nICk7XG5cblx0XHRcdFx0aWYgKCBpbm5lclByb3BUeXBlMSA9PT0gJ0NvbG9yJyB8fCBpbm5lclByb3BUeXBlMSA9PT0gJ0NvbG9yUkdCJyB8fCBpbm5lclByb3BUeXBlMSA9PT0gJ1ZlY3RvcicgfHwgaW5uZXJQcm9wVHlwZTEgPT09ICdWZWN0b3IzRCcgfHwgaW5uZXJQcm9wVHlwZTEuaW5kZXhPZiggJ0xjbF8nICkgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRpbm5lclByb3BWYWx1ZSA9IFtcblx0XHRcdFx0XHRcdHN1Yk5vZGUucHJvcGVydHlMaXN0WyA0IF0sXG5cdFx0XHRcdFx0XHRzdWJOb2RlLnByb3BlcnR5TGlzdFsgNSBdLFxuXHRcdFx0XHRcdFx0c3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDYgXVxuXHRcdFx0XHRcdF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlubmVyUHJvcFZhbHVlID0gc3ViTm9kZS5wcm9wZXJ0eUxpc3RbIDQgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhpcyB3aWxsIGJlIGNvcGllZCB0byBwYXJlbnQsIHNlZSBhYm92ZVxuXHRcdFx0XHRub2RlWyBpbm5lclByb3BOYW1lIF0gPSB7XG5cblx0XHRcdFx0XHQndHlwZSc6IGlubmVyUHJvcFR5cGUxLFxuXHRcdFx0XHRcdCd0eXBlMic6IGlubmVyUHJvcFR5cGUyLFxuXHRcdFx0XHRcdCdmbGFnJzogaW5uZXJQcm9wRmxhZyxcblx0XHRcdFx0XHQndmFsdWUnOiBpbm5lclByb3BWYWx1ZVxuXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSBpZiAoIG5vZGVbIHN1Yk5vZGUubmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCB0eXBlb2Ygc3ViTm9kZS5pZCA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IHt9O1xuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdWyBzdWJOb2RlLmlkIF0gPSBzdWJOb2RlO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRub2RlWyBzdWJOb2RlLm5hbWUgXSA9IHN1Yk5vZGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggc3ViTm9kZS5uYW1lID09PSAnUG9zZU5vZGUnICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIEFycmF5LmlzQXJyYXkoIG5vZGVbIHN1Yk5vZGUubmFtZSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdID0gWyBub2RlWyBzdWJOb2RlLm5hbWUgXSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bm9kZVsgc3ViTm9kZS5uYW1lIF0ucHVzaCggc3ViTm9kZSApO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGVbIHN1Yk5vZGUubmFtZSBdWyBzdWJOb2RlLmlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdG5vZGVbIHN1Yk5vZGUubmFtZSBdWyBzdWJOb2RlLmlkIF0gPSBzdWJOb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHBhcnNlUHJvcGVydHk6IGZ1bmN0aW9uICggcmVhZGVyICkge1xuXG5cdFx0XHR2YXIgdHlwZSA9IHJlYWRlci5nZXRTdHJpbmcoIDEgKTtcblxuXHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRjYXNlICdDJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEJvb2xlYW4oKTtcblxuXHRcdFx0XHRjYXNlICdEJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0NjQoKTtcblxuXHRcdFx0XHRjYXNlICdGJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEZsb2F0MzIoKTtcblxuXHRcdFx0XHRjYXNlICdJJzpcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldEludDMyKCk7XG5cblx0XHRcdFx0Y2FzZSAnTCc6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQ2NCgpO1xuXG5cdFx0XHRcdGNhc2UgJ1InOlxuXHRcdFx0XHRcdHZhciBsZW5ndGggPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRBcnJheUJ1ZmZlciggbGVuZ3RoICk7XG5cblx0XHRcdFx0Y2FzZSAnUyc6XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHJlYWRlci5nZXRVaW50MzIoKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyLmdldFN0cmluZyggbGVuZ3RoICk7XG5cblx0XHRcdFx0Y2FzZSAnWSc6XG5cdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQxNigpO1xuXG5cdFx0XHRcdGNhc2UgJ2InOlxuXHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0Y2FzZSAnbCc6XG5cblx0XHRcdFx0XHR2YXIgYXJyYXlMZW5ndGggPSByZWFkZXIuZ2V0VWludDMyKCk7XG5cdFx0XHRcdFx0dmFyIGVuY29kaW5nID0gcmVhZGVyLmdldFVpbnQzMigpOyAvLyAwOiBub24tY29tcHJlc3NlZCwgMTogY29tcHJlc3NlZFxuXHRcdFx0XHRcdHZhciBjb21wcmVzc2VkTGVuZ3RoID0gcmVhZGVyLmdldFVpbnQzMigpO1xuXG5cdFx0XHRcdFx0aWYgKCBlbmNvZGluZyA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRCb29sZWFuQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnZCc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRGbG9hdDY0QXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRGbG9hdDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnaSc6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlci5nZXRJbnQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWFkZXIuZ2V0SW50NjRBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgZmZsYXRlID09PSAndW5kZWZpbmVkJyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkZCWExvYWRlcjogRXh0ZXJuYWwgbGlicmFyeSBmZmxhdGUubWluLmpzIHJlcXVpcmVkLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBkYXRhID0gSnIoIG5ldyBVaW50OEFycmF5KCByZWFkZXIuZ2V0QXJyYXlCdWZmZXIoIGNvbXByZXNzZWRMZW5ndGggKSApICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblx0XHRcdFx0XHR2YXIgcmVhZGVyMiA9IG5ldyBCaW5hcnlSZWFkZXIoIGRhdGEuYnVmZmVyICk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdiJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRCb29sZWFuQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2QnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRGbG9hdDY0QXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRGbG9hdDMyQXJyYXkoIGFycmF5TGVuZ3RoICk7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVhZGVyMi5nZXRJbnQzMkFycmF5KCBhcnJheUxlbmd0aCApO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRlcjIuZ2V0SW50NjRBcnJheSggYXJyYXlMZW5ndGggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkZCWExvYWRlcjogVW5rbm93biBwcm9wZXJ0eSB0eXBlICcgKyB0eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEJpbmFyeVJlYWRlciggYnVmZmVyLCBsaXR0bGVFbmRpYW4gKSB7XG5cblx0XHR0aGlzLmR2ID0gbmV3IERhdGFWaWV3KCBidWZmZXIgKTtcblx0XHR0aGlzLm9mZnNldCA9IDA7XG5cdFx0dGhpcy5saXR0bGVFbmRpYW4gPSAoIGxpdHRsZUVuZGlhbiAhPT0gdW5kZWZpbmVkICkgPyBsaXR0bGVFbmRpYW4gOiB0cnVlO1xuXG5cdH1cblxuXHRCaW5hcnlSZWFkZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEJpbmFyeVJlYWRlcixcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5vZmZzZXQ7XG5cblx0XHR9LFxuXG5cdFx0c2l6ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kdi5idWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdH0sXG5cblx0XHRza2lwOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXG5cdFx0fSxcblxuXHRcdC8vIHNlZW1zIGxpa2UgdHJ1ZS9mYWxzZSByZXByZXNlbnRhdGlvbiBkZXBlbmRzIG9uIGV4cG9ydGVyLlxuXHRcdC8vIHRydWU6IDEgb3IgJ1knKD0weDU5KSwgZmFsc2U6IDAgb3IgJ1QnKD0weDU0KVxuXHRcdC8vIHRoZW4gc2VlcyBMU0IuXG5cdFx0Z2V0Qm9vbGVhbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldFVpbnQ4KCkgJiAxICkgPT09IDE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0Qm9vbGVhbkFycmF5OiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdHZhciBhID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNpemU7IGkgKysgKSB7XG5cblx0XHRcdFx0YS5wdXNoKCB0aGlzLmdldEJvb2xlYW4oKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXG5cdFx0fSxcblxuXHRcdGdldFVpbnQ4OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0VWludDgoIHRoaXMub2Zmc2V0ICk7XG5cdFx0XHR0aGlzLm9mZnNldCArPSAxO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0fSxcblxuXHRcdGdldEludDE2OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0SW50MTYoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRJbnQzMjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldEludDMyKCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0SW50MzJBcnJheTogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGEucHVzaCggdGhpcy5nZXRJbnQzMigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0VWludDMyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZHYuZ2V0VWludDMyKCB0aGlzLm9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4gKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IDQ7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Ly8gSmF2YVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgNjQtYml0IGludGVnZXIgc28gY2FsY3VsYXRlIHRoaXMgaGVyZVxuXHRcdC8vIDEgPDwgMzIgd2lsbCByZXR1cm4gMSBzbyB1c2luZyBtdWx0aXBseSBvcGVyYXRpb24gaW5zdGVhZCBoZXJlLlxuXHRcdC8vIFRoZXJlJ3MgYSBwb3NzaWJpbGl0eSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgd3JvbmcgdmFsdWUgaWYgdGhlIHZhbHVlXG5cdFx0Ly8gaXMgb3V0IG9mIHRoZSByYW5nZSBiZXR3ZWVuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIGFuZCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUi5cblx0XHQvLyBUT0RPOiBzYWZlbHkgaGFuZGxlIDY0LWJpdCBpbnRlZ2VyXG5cdFx0Z2V0SW50NjQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0dmFyIGxvdywgaGlnaDtcblxuXHRcdFx0aWYgKCB0aGlzLmxpdHRsZUVuZGlhbiApIHtcblxuXHRcdFx0XHRsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuXHRcdFx0XHRoaWdoID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRoaWdoID0gdGhpcy5nZXRVaW50MzIoKTtcblx0XHRcdFx0bG93ID0gdGhpcy5nZXRVaW50MzIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmVnYXRpdmUgdmFsdWVcblx0XHRcdGlmICggaGlnaCAmIDB4ODAwMDAwMDAgKSB7XG5cblx0XHRcdFx0aGlnaCA9IH4gaGlnaCAmIDB4RkZGRkZGRkY7XG5cdFx0XHRcdGxvdyA9IH4gbG93ICYgMHhGRkZGRkZGRjtcblxuXHRcdFx0XHRpZiAoIGxvdyA9PT0gMHhGRkZGRkZGRiApIGhpZ2ggPSAoIGhpZ2ggKyAxICkgJiAweEZGRkZGRkZGO1xuXG5cdFx0XHRcdGxvdyA9ICggbG93ICsgMSApICYgMHhGRkZGRkZGRjtcblxuXHRcdFx0XHRyZXR1cm4gLSAoIGhpZ2ggKiAweDEwMDAwMDAwMCArIGxvdyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG5cblx0XHR9LFxuXG5cdFx0Z2V0SW50NjRBcnJheTogZnVuY3Rpb24gKCBzaXplICkge1xuXG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG5cdFx0XHRcdGEucHVzaCggdGhpcy5nZXRJbnQ2NCgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cblx0XHR9LFxuXG5cdFx0Ly8gTm90ZTogc2VlIGdldEludDY0KCkgY29tbWVudFxuXHRcdGdldFVpbnQ2NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgbG93LCBoaWdoO1xuXG5cdFx0XHRpZiAoIHRoaXMubGl0dGxlRW5kaWFuICkge1xuXG5cdFx0XHRcdGxvdyA9IHRoaXMuZ2V0VWludDMyKCk7XG5cdFx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSB0aGlzLmdldFVpbnQzMigpO1xuXHRcdFx0XHRsb3cgPSB0aGlzLmdldFVpbnQzMigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoaWdoICogMHgxMDAwMDAwMDAgKyBsb3c7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RmxvYXQzMjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldEZsb2F0MzIoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gNDtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRGbG9hdDMyQXJyYXk6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhLnB1c2goIHRoaXMuZ2V0RmxvYXQzMigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0RmxvYXQ2NDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmR2LmdldEZsb2F0NjQoIHRoaXMub2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiApO1xuXHRcdFx0dGhpcy5vZmZzZXQgKz0gODtcblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdH0sXG5cblx0XHRnZXRGbG9hdDY0QXJyYXk6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhLnB1c2goIHRoaXMuZ2V0RmxvYXQ2NCgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGE7XG5cblx0XHR9LFxuXG5cdFx0Z2V0QXJyYXlCdWZmZXI6IGZ1bmN0aW9uICggc2l6ZSApIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5kdi5idWZmZXIuc2xpY2UoIHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIHNpemUgKTtcblx0XHRcdHRoaXMub2Zmc2V0ICs9IHNpemU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9LFxuXG5cdFx0Z2V0U3RyaW5nOiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0XHRcdC8vIG5vdGU6IHNhZmFyaSA5IGRvZXNuJ3Qgc3VwcG9ydCBVaW50OEFycmF5LmluZGV4T2Y7IGNyZWF0ZSBpbnRlcm1lZGlhdGUgYXJyYXkgaW5zdGVhZFxuXHRcdFx0dmFyIGEgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcblxuXHRcdFx0XHRhWyBpIF0gPSB0aGlzLmdldFVpbnQ4KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG51bGxCeXRlID0gYS5pbmRleE9mKCAwICk7XG5cdFx0XHRpZiAoIG51bGxCeXRlID49IDAgKSBhID0gYS5zbGljZSggMCwgbnVsbEJ5dGUgKTtcblxuXHRcdFx0cmV0dXJuIExvYWRlclV0aWxzLmRlY29kZVRleHQoIG5ldyBVaW50OEFycmF5KCBhICkgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vIEZCWFRyZWUgaG9sZHMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgRkJYIGRhdGEsIHJldHVybmVkIGJ5IHRoZSBUZXh0UGFyc2VyICggRkJYIEFTQ0lJIGZvcm1hdClcblx0Ly8gYW5kIEJpbmFyeVBhcnNlciggRkJYIEJpbmFyeSBmb3JtYXQpXG5cdGZ1bmN0aW9uIEZCWFRyZWUoKSB7fVxuXG5cdEZCWFRyZWUucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IEZCWFRyZWUsXG5cblx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCB2YWwgKSB7XG5cblx0XHRcdHRoaXNbIGtleSBdID0gdmFsO1xuXG5cdFx0fSxcblxuXHR9O1xuXG5cdC8vICoqKioqKioqKioqKioqIFVUSUxJVFkgRlVOQ1RJT05TICoqKioqKioqKioqKioqXG5cblx0ZnVuY3Rpb24gaXNGYnhGb3JtYXRCaW5hcnkoIGJ1ZmZlciApIHtcblxuXHRcdHZhciBDT1JSRUNUID0gJ0theWRhcmEgRkJYIEJpbmFyeSAgXFwwJztcblxuXHRcdHJldHVybiBidWZmZXIuYnl0ZUxlbmd0aCA+PSBDT1JSRUNULmxlbmd0aCAmJiBDT1JSRUNUID09PSBjb252ZXJ0QXJyYXlCdWZmZXJUb1N0cmluZyggYnVmZmVyLCAwLCBDT1JSRUNULmxlbmd0aCApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpc0ZieEZvcm1hdEFTQ0lJKCB0ZXh0ICkge1xuXG5cdFx0dmFyIENPUlJFQ1QgPSBbICdLJywgJ2EnLCAneScsICdkJywgJ2EnLCAncicsICdhJywgJ1xcXFwnLCAnRicsICdCJywgJ1gnLCAnXFxcXCcsICdCJywgJ2knLCAnbicsICdhJywgJ3InLCAneScsICdcXFxcJywgJ1xcXFwnIF07XG5cblx0XHR2YXIgY3Vyc29yID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlYWQoIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IHRleHRbIG9mZnNldCAtIDEgXTtcblx0XHRcdHRleHQgPSB0ZXh0LnNsaWNlKCBjdXJzb3IgKyBvZmZzZXQgKTtcblx0XHRcdGN1cnNvciArKztcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBDT1JSRUNULmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0dmFyIG51bSA9IHJlYWQoIDEgKTtcblx0XHRcdGlmICggbnVtID09PSBDT1JSRUNUWyBpIF0gKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RmJ4VmVyc2lvbiggdGV4dCApIHtcblxuXHRcdHZhciB2ZXJzaW9uUmVnRXhwID0gL0ZCWFZlcnNpb246IChcXGQrKS87XG5cdFx0dmFyIG1hdGNoID0gdGV4dC5tYXRjaCggdmVyc2lvblJlZ0V4cCApO1xuXG5cdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0dmFyIHZlcnNpb24gPSBwYXJzZUludCggbWF0Y2hbIDEgXSApO1xuXHRcdFx0cmV0dXJuIHZlcnNpb247XG5cblx0XHR9XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5GQlhMb2FkZXI6IENhbm5vdCBmaW5kIHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhlIGZpbGUgZ2l2ZW4uJyApO1xuXG5cdH1cblxuXHQvLyBDb252ZXJ0cyBGQlggdGlja3MgaW50byByZWFsIHRpbWUgc2Vjb25kcy5cblx0ZnVuY3Rpb24gY29udmVydEZCWFRpbWVUb1NlY29uZHMoIHRpbWUgKSB7XG5cblx0XHRyZXR1cm4gdGltZSAvIDQ2MTg2MTU4MDAwO1xuXG5cdH1cblxuXHR2YXIgZGF0YUFycmF5ID0gW107XG5cblx0Ly8gZXh0cmFjdHMgdGhlIGRhdGEgZnJvbSB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgRkJYIGFycmF5IGJhc2VkIG9uIGluZGV4aW5nIHR5cGVcblx0ZnVuY3Rpb24gZ2V0RGF0YSggcG9seWdvblZlcnRleEluZGV4LCBwb2x5Z29uSW5kZXgsIHZlcnRleEluZGV4LCBpbmZvT2JqZWN0ICkge1xuXG5cdFx0dmFyIGluZGV4O1xuXG5cdFx0c3dpdGNoICggaW5mb09iamVjdC5tYXBwaW5nVHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnQnlQb2x5Z29uVmVydGV4JyA6XG5cdFx0XHRcdGluZGV4ID0gcG9seWdvblZlcnRleEluZGV4O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0J5UG9seWdvbicgOlxuXHRcdFx0XHRpbmRleCA9IHBvbHlnb25JbmRleDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCeVZlcnRpY2UnIDpcblx0XHRcdFx0aW5kZXggPSB2ZXJ0ZXhJbmRleDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdBbGxTYW1lJyA6XG5cdFx0XHRcdGluZGV4ID0gaW5mb09iamVjdC5pbmRpY2VzWyAwIF07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdCA6XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZCWExvYWRlcjogdW5rbm93biBhdHRyaWJ1dGUgbWFwcGluZyB0eXBlICcgKyBpbmZvT2JqZWN0Lm1hcHBpbmdUeXBlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGluZm9PYmplY3QucmVmZXJlbmNlVHlwZSA9PT0gJ0luZGV4VG9EaXJlY3QnICkgaW5kZXggPSBpbmZvT2JqZWN0LmluZGljZXNbIGluZGV4IF07XG5cblx0XHR2YXIgZnJvbSA9IGluZGV4ICogaW5mb09iamVjdC5kYXRhU2l6ZTtcblx0XHR2YXIgdG8gPSBmcm9tICsgaW5mb09iamVjdC5kYXRhU2l6ZTtcblxuXHRcdHJldHVybiBzbGljZSggZGF0YUFycmF5LCBpbmZvT2JqZWN0LmJ1ZmZlciwgZnJvbSwgdG8gKTtcblxuXHR9XG5cblx0dmFyIHRlbXBFdWxlciA9IG5ldyBFdWxlcigpO1xuXHR2YXIgdGVtcFZlYyA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Ly8gZ2VuZXJhdGUgdHJhbnNmb3JtYXRpb24gZnJvbSBGQlggdHJhbnNmb3JtIGRhdGFcblx0Ly8gcmVmOiBodHRwczovL2hlbHAuYXV0b2Rlc2suY29tL3ZpZXcvRkJYLzIwMTcvRU5VLz9ndWlkPV9fZmlsZXNfR1VJRF8xMENERDYzQ183OUMxXzRGMkRfQkIyOF9BRDJCRTY1QTAyRURfaHRtXG5cdC8vIHJlZjogaHR0cDovL2RvY3MuYXV0b2Rlc2suY29tL0ZCWC8yMDE0L0VOVS9GQlgtU0RLLURvY3VtZW50YXRpb24vaW5kZXguaHRtbD91cmw9Y3BwX3JlZi9fdHJhbnNmb3JtYXRpb25zXzJtYWluXzhjeHgtZXhhbXBsZS5odG1sLHRvcGljTnVtYmVyPWNwcF9yZWZfX3RyYW5zZm9ybWF0aW9uc18ybWFpbl84Y3h4X2V4YW1wbGVfaHRtbGZjMTBhMWUxLWIxOGQtNGU3Mi05ZGMwLTcwZDBmMTk1OWY1ZVxuXHRmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zZm9ybSggdHJhbnNmb3JtRGF0YSApIHtcblxuXHRcdHZhciBsVHJhbnNsYXRpb25NID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFByZVJvdGF0aW9uTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dmFyIGxSb3RhdGlvbk0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUG9zdFJvdGF0aW9uTSA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHR2YXIgbFNjYWxpbmdNID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFNjYWxpbmdQaXZvdE0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsU2NhbGluZ09mZnNldE0gPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUm90YXRpb25PZmZzZXRNID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFJvdGF0aW9uUGl2b3RNID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHZhciBsUGFyZW50R1ggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsUGFyZW50TFggPSBuZXcgTWF0cml4NCgpO1xuXHRcdHZhciBsR2xvYmFsVCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHR2YXIgaW5oZXJpdFR5cGUgPSAoIHRyYW5zZm9ybURhdGEuaW5oZXJpdFR5cGUgKSA/IHRyYW5zZm9ybURhdGEuaW5oZXJpdFR5cGUgOiAwO1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnRyYW5zbGF0aW9uICkgbFRyYW5zbGF0aW9uTS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEudHJhbnNsYXRpb24gKSApO1xuXG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnByZVJvdGF0aW9uICkge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSB0cmFuc2Zvcm1EYXRhLnByZVJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRhcnJheS5wdXNoKCB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgKTtcblx0XHRcdGxQcmVSb3RhdGlvbk0ubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCB0ZW1wRXVsZXIuZnJvbUFycmF5KCBhcnJheSApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucm90YXRpb24gKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IHRyYW5zZm9ybURhdGEucm90YXRpb24ubWFwKCBNYXRoVXRpbHMuZGVnVG9SYWQgKTtcblx0XHRcdGFycmF5LnB1c2goIHRyYW5zZm9ybURhdGEuZXVsZXJPcmRlciApO1xuXHRcdFx0bFJvdGF0aW9uTS5tYWtlUm90YXRpb25Gcm9tRXVsZXIoIHRlbXBFdWxlci5mcm9tQXJyYXkoIGFycmF5ICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5wb3N0Um90YXRpb24gKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IHRyYW5zZm9ybURhdGEucG9zdFJvdGF0aW9uLm1hcCggTWF0aFV0aWxzLmRlZ1RvUmFkICk7XG5cdFx0XHRhcnJheS5wdXNoKCB0cmFuc2Zvcm1EYXRhLmV1bGVyT3JkZXIgKTtcblx0XHRcdGxQb3N0Um90YXRpb25NLm1ha2VSb3RhdGlvbkZyb21FdWxlciggdGVtcEV1bGVyLmZyb21BcnJheSggYXJyYXkgKSApO1xuXHRcdFx0bFBvc3RSb3RhdGlvbk0uaW52ZXJ0KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEuc2NhbGUgKSBsU2NhbGluZ00uc2NhbGUoIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnNjYWxlICkgKTtcblxuXHRcdC8vIFBpdm90cyBhbmQgb2Zmc2V0c1xuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5zY2FsaW5nT2Zmc2V0ICkgbFNjYWxpbmdPZmZzZXRNLnNldFBvc2l0aW9uKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS5zY2FsaW5nT2Zmc2V0ICkgKTtcblx0XHRpZiAoIHRyYW5zZm9ybURhdGEuc2NhbGluZ1Bpdm90ICkgbFNjYWxpbmdQaXZvdE0uc2V0UG9zaXRpb24oIHRlbXBWZWMuZnJvbUFycmF5KCB0cmFuc2Zvcm1EYXRhLnNjYWxpbmdQaXZvdCApICk7XG5cdFx0aWYgKCB0cmFuc2Zvcm1EYXRhLnJvdGF0aW9uT2Zmc2V0ICkgbFJvdGF0aW9uT2Zmc2V0TS5zZXRQb3NpdGlvbiggdGVtcFZlYy5mcm9tQXJyYXkoIHRyYW5zZm9ybURhdGEucm90YXRpb25PZmZzZXQgKSApO1xuXHRcdGlmICggdHJhbnNmb3JtRGF0YS5yb3RhdGlvblBpdm90ICkgbFJvdGF0aW9uUGl2b3RNLnNldFBvc2l0aW9uKCB0ZW1wVmVjLmZyb21BcnJheSggdHJhbnNmb3JtRGF0YS5yb3RhdGlvblBpdm90ICkgKTtcblxuXHRcdC8vIHBhcmVudCB0cmFuc2Zvcm1cblx0XHRpZiAoIHRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4V29ybGQgKSB7XG5cblx0XHRcdGxQYXJlbnRMWC5jb3B5KCB0cmFuc2Zvcm1EYXRhLnBhcmVudE1hdHJpeCApO1xuXHRcdFx0bFBhcmVudEdYLmNvcHkoIHRyYW5zZm9ybURhdGEucGFyZW50TWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdHZhciBsTFJNID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBsUHJlUm90YXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvbk0gKS5tdWx0aXBseSggbFBvc3RSb3RhdGlvbk0gKTtcblx0XHQvLyBHbG9iYWwgUm90YXRpb25cblx0XHR2YXIgbFBhcmVudEdSTSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0bFBhcmVudEdSTS5leHRyYWN0Um90YXRpb24oIGxQYXJlbnRHWCApO1xuXG5cdFx0Ly8gR2xvYmFsIFNoZWFyKlNjYWxpbmdcblx0XHR2YXIgbFBhcmVudFRNID0gbmV3IE1hdHJpeDQoKTtcblx0XHRsUGFyZW50VE0uY29weVBvc2l0aW9uKCBsUGFyZW50R1ggKTtcblxuXHRcdHZhciBsUGFyZW50R1NNID0gbmV3IE1hdHJpeDQoKTtcblx0XHR2YXIgbFBhcmVudEdSU00gPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxQYXJlbnRUTSApLmludmVydCgpLm11bHRpcGx5KCBsUGFyZW50R1ggKTtcblx0XHRsUGFyZW50R1NNLmNvcHkoIGxQYXJlbnRHUk0gKS5pbnZlcnQoKS5tdWx0aXBseSggbFBhcmVudEdSU00gKTtcblx0XHR2YXIgbExTTSA9IGxTY2FsaW5nTTtcblxuXHRcdHZhciBsR2xvYmFsUlMgPSBuZXcgTWF0cml4NCgpO1xuXG5cdFx0aWYgKCBpbmhlcml0VHlwZSA9PT0gMCApIHtcblxuXHRcdFx0bEdsb2JhbFJTLmNvcHkoIGxQYXJlbnRHUk0gKS5tdWx0aXBseSggbExSTSApLm11bHRpcGx5KCBsUGFyZW50R1NNICkubXVsdGlwbHkoIGxMU00gKTtcblxuXHRcdH0gZWxzZSBpZiAoIGluaGVyaXRUeXBlID09PSAxICkge1xuXG5cdFx0XHRsR2xvYmFsUlMuY29weSggbFBhcmVudEdSTSApLm11bHRpcGx5KCBsUGFyZW50R1NNICkubXVsdGlwbHkoIGxMUk0gKS5tdWx0aXBseSggbExTTSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dmFyIGxQYXJlbnRMU00gPSBuZXcgTWF0cml4NCgpLnNjYWxlKCBuZXcgVmVjdG9yMygpLnNldEZyb21NYXRyaXhTY2FsZSggbFBhcmVudExYICkgKTtcblx0XHRcdHZhciBsUGFyZW50TFNNX2ludiA9IG5ldyBNYXRyaXg0KCkuY29weSggbFBhcmVudExTTSApLmludmVydCgpO1xuXHRcdFx0dmFyIGxQYXJlbnRHU01fbm9Mb2NhbCA9IG5ldyBNYXRyaXg0KCkuY29weSggbFBhcmVudEdTTSApLm11bHRpcGx5KCBsUGFyZW50TFNNX2ludiApO1xuXG5cdFx0XHRsR2xvYmFsUlMuY29weSggbFBhcmVudEdSTSApLm11bHRpcGx5KCBsTFJNICkubXVsdGlwbHkoIGxQYXJlbnRHU01fbm9Mb2NhbCApLm11bHRpcGx5KCBsTFNNICk7XG5cblx0XHR9XG5cblx0XHR2YXIgbFJvdGF0aW9uUGl2b3RNX2ludiA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0bFJvdGF0aW9uUGl2b3RNX2ludi5jb3B5KCBsUm90YXRpb25QaXZvdE0gKS5pbnZlcnQoKTtcblx0XHR2YXIgbFNjYWxpbmdQaXZvdE1faW52ID0gbmV3IE1hdHJpeDQoKTtcblx0XHRsU2NhbGluZ1Bpdm90TV9pbnYuY29weSggbFNjYWxpbmdQaXZvdE0gKS5pbnZlcnQoKTtcblx0XHQvLyBDYWxjdWxhdGUgdGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXhcblx0XHR2YXIgbFRyYW5zZm9ybSA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0bFRyYW5zZm9ybS5jb3B5KCBsVHJhbnNsYXRpb25NICkubXVsdGlwbHkoIGxSb3RhdGlvbk9mZnNldE0gKS5tdWx0aXBseSggbFJvdGF0aW9uUGl2b3RNICkubXVsdGlwbHkoIGxQcmVSb3RhdGlvbk0gKS5tdWx0aXBseSggbFJvdGF0aW9uTSApLm11bHRpcGx5KCBsUG9zdFJvdGF0aW9uTSApLm11bHRpcGx5KCBsUm90YXRpb25QaXZvdE1faW52ICkubXVsdGlwbHkoIGxTY2FsaW5nT2Zmc2V0TSApLm11bHRpcGx5KCBsU2NhbGluZ1Bpdm90TSApLm11bHRpcGx5KCBsU2NhbGluZ00gKS5tdWx0aXBseSggbFNjYWxpbmdQaXZvdE1faW52ICk7XG5cblx0XHR2YXIgbExvY2FsVFdpdGhBbGxQaXZvdEFuZE9mZnNldEluZm8gPSBuZXcgTWF0cml4NCgpLmNvcHlQb3NpdGlvbiggbFRyYW5zZm9ybSApO1xuXG5cdFx0dmFyIGxHbG9iYWxUcmFuc2xhdGlvbiA9IG5ldyBNYXRyaXg0KCkuY29weSggbFBhcmVudEdYICkubXVsdGlwbHkoIGxMb2NhbFRXaXRoQWxsUGl2b3RBbmRPZmZzZXRJbmZvICk7XG5cdFx0bEdsb2JhbFQuY29weVBvc2l0aW9uKCBsR2xvYmFsVHJhbnNsYXRpb24gKTtcblxuXHRcdGxUcmFuc2Zvcm0gPSBuZXcgTWF0cml4NCgpLmNvcHkoIGxHbG9iYWxUICkubXVsdGlwbHkoIGxHbG9iYWxSUyApO1xuXG5cdFx0Ly8gZnJvbSBnbG9iYWwgdG8gbG9jYWxcblx0XHRsVHJhbnNmb3JtLnByZW11bHRpcGx5KCBsUGFyZW50R1guaW52ZXJ0KCkgKTtcblxuXHRcdHJldHVybiBsVHJhbnNmb3JtO1xuXG5cdH1cblxuXHQvLyBSZXR1cm5zIHRoZSB0aHJlZS5qcyBpbnRyaW5zaWMgRXVsZXIgb3JkZXIgY29ycmVzcG9uZGluZyB0byBGQlggZXh0cmluc2ljIEV1bGVyIG9yZGVyXG5cdC8vIHJlZjogaHR0cDovL2hlbHAuYXV0b2Rlc2suY29tL3ZpZXcvRkJYLzIwMTcvRU5VLz9ndWlkPV9fY3BwX3JlZl9jbGFzc19mYnhfZXVsZXJfaHRtbFxuXHRmdW5jdGlvbiBnZXRFdWxlck9yZGVyKCBvcmRlciApIHtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgMDtcblxuXHRcdHZhciBlbnVtcyA9IFtcblx0XHRcdCdaWVgnLCAvLyAtPiBYWVogZXh0cmluc2ljXG5cdFx0XHQnWVpYJywgLy8gLT4gWFpZIGV4dHJpbnNpY1xuXHRcdFx0J1haWScsIC8vIC0+IFlaWCBleHRyaW5zaWNcblx0XHRcdCdaWFknLCAvLyAtPiBZWFogZXh0cmluc2ljXG5cdFx0XHQnWVhaJywgLy8gLT4gWlhZIGV4dHJpbnNpY1xuXHRcdFx0J1hZWicsIC8vIC0+IFpZWCBleHRyaW5zaWNcblx0XHRcdC8vJ1NwaGVyaWNYWVonLCAvLyBub3QgcG9zc2libGUgdG8gc3VwcG9ydFxuXHRcdF07XG5cblx0XHRpZiAoIG9yZGVyID09PSA2ICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GQlhMb2FkZXI6IHVuc3VwcG9ydGVkIEV1bGVyIE9yZGVyOiBTcGhlcmljYWwgWFlaLiBBbmltYXRpb25zIGFuZCByb3RhdGlvbnMgbWF5IGJlIGluY29ycmVjdC4nICk7XG5cdFx0XHRyZXR1cm4gZW51bXNbIDAgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBlbnVtc1sgb3JkZXIgXTtcblxuXHR9XG5cblx0Ly8gUGFyc2VzIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIG51bWJlcnMgYW5kIHJldHVybnMgdGhlbSBhbiBhcnJheS5cblx0Ly8gVXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBUZXh0UGFyc2VyXG5cdGZ1bmN0aW9uIHBhcnNlTnVtYmVyQXJyYXkoIHZhbHVlICkge1xuXG5cdFx0dmFyIGFycmF5ID0gdmFsdWUuc3BsaXQoICcsJyApLm1hcCggZnVuY3Rpb24gKCB2YWwgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCB2YWwgKTtcblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydEFycmF5QnVmZmVyVG9TdHJpbmcoIGJ1ZmZlciwgZnJvbSwgdG8gKSB7XG5cblx0XHRpZiAoIGZyb20gPT09IHVuZGVmaW5lZCApIGZyb20gPSAwO1xuXHRcdGlmICggdG8gPT09IHVuZGVmaW5lZCApIHRvID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0XHRyZXR1cm4gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dCggbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciwgZnJvbSwgdG8gKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBhcHBlbmQoIGEsIGIgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBhLmxlbmd0aCwgbCA9IGIubGVuZ3RoOyBpIDwgbDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0YVsgaiBdID0gYlsgaSBdO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBzbGljZSggYSwgYiwgZnJvbSwgdG8gKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IGZyb20sIGogPSAwOyBpIDwgdG87IGkgKyssIGogKysgKSB7XG5cblx0XHRcdGFbIGogXSA9IGJbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhO1xuXG5cdH1cblxuXHQvLyBpbmplY3QgYXJyYXkgYTIgaW50byBhcnJheSBhMSBhdCBpbmRleFxuXHRmdW5jdGlvbiBpbmplY3QoIGExLCBpbmRleCwgYTIgKSB7XG5cblx0XHRyZXR1cm4gYTEuc2xpY2UoIDAsIGluZGV4ICkuY29uY2F0KCBhMiApLmNvbmNhdCggYTEuc2xpY2UoIGluZGV4ICkgKTtcblxuXHR9XG5cblx0cmV0dXJuIEZCWExvYWRlcjtcblxufSApKCk7XG5cbnZhciBTVkdMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0TG9hZGVyJDEuY2FsbCggdGhpcywgbWFuYWdlciApO1xuXG5cdC8vIERlZmF1bHQgZG90cyBwZXIgaW5jaFxuXHR0aGlzLmRlZmF1bHREUEkgPSA5MDtcblxuXHQvLyBBY2NlcHRlZCB1bml0czogJ21tJywgJ2NtJywgJ2luJywgJ3B0JywgJ3BjJywgJ3B4J1xuXHR0aGlzLmRlZmF1bHRVbml0ID0gJ3B4JztcblxufTtcblxuU1ZHTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExvYWRlciQxLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFNWR0xvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCBzY29wZS5wYXRoICk7XG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHNjb3BlLnJlcXVlc3RIZWFkZXIgKTtcblx0XHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCBzY29wZS53aXRoQ3JlZGVudGlhbHMgKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggdGV4dCApICk7XG5cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdGlmICggb25FcnJvciApIHtcblxuXHRcdFx0XHRcdG9uRXJyb3IoIGUgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb2RlKCBub2RlLCBzdHlsZSApIHtcblxuXHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gZ2V0Tm9kZVRyYW5zZm9ybSggbm9kZSApO1xuXG5cdFx0XHR2YXIgdHJhdmVyc2VDaGlsZE5vZGVzID0gdHJ1ZTtcblxuXHRcdFx0dmFyIHBhdGggPSBudWxsO1xuXG5cdFx0XHRzd2l0Y2ggKCBub2RlLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3N2Zyc6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3R5bGUnOlxuXHRcdFx0XHRcdHBhcnNlQ1NTU3R5bGVzaGVldCggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2cnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwYXRoJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ2QnICkgKSBwYXRoID0gcGFyc2VQYXRoTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VSZWN0Tm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BvbHlnb24nOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VQb2x5Z29uTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3BvbHlsaW5lJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlUG9seWxpbmVOb2RlKCBub2RlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnY2lyY2xlJzpcblx0XHRcdFx0XHRzdHlsZSA9IHBhcnNlU3R5bGUoIG5vZGUsIHN0eWxlICk7XG5cdFx0XHRcdFx0cGF0aCA9IHBhcnNlQ2lyY2xlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2VsbGlwc2UnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VFbGxpcHNlTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0XHRcdHN0eWxlID0gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKTtcblx0XHRcdFx0XHRwYXRoID0gcGFyc2VMaW5lTm9kZSggbm9kZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2RlZnMnOlxuXHRcdFx0XHRcdHRyYXZlcnNlQ2hpbGROb2RlcyA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3VzZSc6XG5cdFx0XHRcdFx0c3R5bGUgPSBwYXJzZVN0eWxlKCBub2RlLCBzdHlsZSApO1xuXHRcdFx0XHRcdHZhciB1c2VkTm9kZUlkID0gbm9kZS5ocmVmLmJhc2VWYWwuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0dmFyIHVzZWROb2RlID0gbm9kZS52aWV3cG9ydEVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQoIHVzZWROb2RlSWQgKTtcblx0XHRcdFx0XHRpZiAoIHVzZWROb2RlICkge1xuXG5cdFx0XHRcdFx0XHRwYXJzZU5vZGUoIHVzZWROb2RlLCBzdHlsZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiBcXCd1c2Ugbm9kZVxcJyByZWZlcmVuY2VzIG5vbi1leGlzdGVudCBub2RlIGlkOiAnICsgdXNlZE5vZGVJZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIG5vZGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhdGggKSB7XG5cblx0XHRcdFx0aWYgKCBzdHlsZS5maWxsICE9PSB1bmRlZmluZWQgJiYgc3R5bGUuZmlsbCAhPT0gJ25vbmUnICkge1xuXG5cdFx0XHRcdFx0cGF0aC5jb2xvci5zZXRTdHlsZSggc3R5bGUuZmlsbCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cmFuc2Zvcm1QYXRoKCBwYXRoLCBjdXJyZW50VHJhbnNmb3JtICk7XG5cblx0XHRcdFx0cGF0aHMucHVzaCggcGF0aCApO1xuXG5cdFx0XHRcdHBhdGgudXNlckRhdGEgPSB7IG5vZGU6IG5vZGUsIHN0eWxlOiBzdHlsZSB9O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHJhdmVyc2VDaGlsZE5vZGVzICkge1xuXG5cdFx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2RlcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRwYXJzZU5vZGUoIG5vZGVzWyBpIF0sIHN0eWxlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHJhbnNmb3JtICkge1xuXG5cdFx0XHRcdHRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuXG5cdFx0XHRcdGlmICggdHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uY29weSggdHJhbnNmb3JtU3RhY2tbIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBhdGhOb2RlKCBub2RlICkge1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0dmFyIHBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdHZhciBjb250cm9sID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdFx0dmFyIGZpcnN0UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0dmFyIGlzRmlyc3RQb2ludCA9IHRydWU7XG5cdFx0XHR2YXIgZG9TZXRGaXJzdFBvaW50ID0gZmFsc2U7XG5cblx0XHRcdHZhciBkID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdkJyApO1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggZCApO1xuXG5cdFx0XHR2YXIgY29tbWFuZHMgPSBkLm1hdGNoKCAvW2EtZGYtel1bXmEtZGYtel0qL2lnICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbW1hbmRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNvbW1hbmQgPSBjb21tYW5kc1sgaSBdO1xuXG5cdFx0XHRcdHZhciB0eXBlID0gY29tbWFuZC5jaGFyQXQoIDAgKTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb21tYW5kLnN1YnN0ciggMSApLnRyaW0oKTtcblxuXHRcdFx0XHRpZiAoIGlzRmlyc3RQb2ludCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGRvU2V0Rmlyc3RQb2ludCA9IHRydWU7XG5cdFx0XHRcdFx0aXNGaXJzdFBvaW50ID0gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVic6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0wnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblx0XHRcdFx0XHRcdFx0cGF0aC5saW5lVG8oIHBvaW50LngsIHBvaW50LnkgKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDYgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAzIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDQgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgNSBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IG51bWJlcnNbIGogKyAzIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgNCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDUgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnUyc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApLFxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAzIF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCA9IG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgPSBudW1iZXJzWyBqICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdRJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDMgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyAzIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1QnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciByeCA9IGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApO1xuXHRcdFx0XHRcdFx0XHR2YXIgcnkgPSBnZXRSZWZsZWN0aW9uKCBwb2ludC55LCBjb250cm9sLnkgKTtcblx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdHJ4LFxuXHRcdFx0XHRcdFx0XHRcdHJ5LFxuXHRcdFx0XHRcdFx0XHRcdG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0bnVtYmVyc1sgaiArIDEgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSByeDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcnk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ID0gbnVtYmVyc1sgaiArIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQSc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDcgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBjb21tYW5kIGlmIHN0YXJ0IHBvaW50ID09IGVuZCBwb2ludFxuXHRcdFx0XHRcdFx0XHRpZiAoIG51bWJlcnNbIGogKyA1IF0gPT0gcG9pbnQueCAmJiBudW1iZXJzWyBqICsgNiBdID09IHBvaW50LnkgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ID0gbnVtYmVyc1sgaiArIDUgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IG51bWJlcnNbIGogKyA2IF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhcnNlQXJjQ29tbWFuZChcblx0XHRcdFx0XHRcdFx0XHRwYXRoLCBudW1iZXJzWyBqIF0sIG51bWJlcnNbIGogKyAxIF0sIG51bWJlcnNbIGogKyAyIF0sIG51bWJlcnNbIGogKyAzIF0sIG51bWJlcnNbIGogKyA0IF0sIHN0YXJ0LCBwb2ludFxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyAwIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXRoLm1vdmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnaCc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50Lng7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50Lnk7XG5cdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCBwb2ludC54LCBwb2ludC55ICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgMSBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXRoLmxpbmVUbyggcG9pbnQueCwgcG9pbnQueSApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAwIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAxIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyAyIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyAzIF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueCArIG51bWJlcnNbIGogKyA0IF0sXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQueSArIG51bWJlcnNbIGogKyA1IF1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC54ID0gcG9pbnQueCArIG51bWJlcnNbIGogKyAyIF07XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC54ICs9IG51bWJlcnNbIGogKyA0IF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnkgKz0gbnVtYmVyc1sgaiArIDUgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdFx0XHR2YXIgbnVtYmVycyA9IHBhcnNlRmxvYXRzKCBkYXRhICk7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBudW1iZXJzLmxlbmd0aDsgaiA8IGpsOyBqICs9IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LngsIGNvbnRyb2wueCApLFxuXHRcdFx0XHRcdFx0XHRcdGdldFJlZmxlY3Rpb24oIHBvaW50LnksIGNvbnRyb2wueSApLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnggKyBudW1iZXJzWyBqICsgMiBdLFxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnkgKyBudW1iZXJzWyBqICsgMyBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wueCA9IHBvaW50LnggKyBudW1iZXJzWyBqICsgMCBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueCArPSBudW1iZXJzWyBqICsgMiBdO1xuXHRcdFx0XHRcdFx0XHRwb2ludC55ICs9IG51bWJlcnNbIGogKyAzIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBqID09PSAwICYmIGRvU2V0Rmlyc3RQb2ludCA9PT0gdHJ1ZSApIGZpcnN0UG9pbnQuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3EnOlxuXHRcdFx0XHRcdFx0dmFyIG51bWJlcnMgPSBwYXJzZUZsb2F0cyggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbnVtYmVycy5sZW5ndGg7IGogPCBqbDsgaiArPSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDIgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDMgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcG9pbnQueSArIG51bWJlcnNbIGogKyAxIF07XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDIgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcnggPSBnZXRSZWZsZWN0aW9uKCBwb2ludC54LCBjb250cm9sLnggKTtcblx0XHRcdFx0XHRcdFx0dmFyIHJ5ID0gZ2V0UmVmbGVjdGlvbiggcG9pbnQueSwgY29udHJvbC55ICk7XG5cdFx0XHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0XHRyeCxcblx0XHRcdFx0XHRcdFx0XHRyeSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXSxcblx0XHRcdFx0XHRcdFx0XHRwb2ludC55ICsgbnVtYmVyc1sgaiArIDEgXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSByeDtcblx0XHRcdFx0XHRcdFx0Y29udHJvbC55ID0gcnk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggPSBwb2ludC54ICsgbnVtYmVyc1sgaiArIDAgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSA9IHBvaW50LnkgKyBudW1iZXJzWyBqICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBkb1NldEZpcnN0UG9pbnQgPT09IHRydWUgKSBmaXJzdFBvaW50LmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRcdHZhciBudW1iZXJzID0gcGFyc2VGbG9hdHMoIGRhdGEgKTtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG51bWJlcnMubGVuZ3RoOyBqIDwgamw7IGogKz0gNyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBza2lwIGNvbW1hbmQgaWYgbm8gZGlzcGxhY2VtZW50XG5cdFx0XHRcdFx0XHRcdGlmICggbnVtYmVyc1sgaiArIDUgXSA9PSAwICYmIG51bWJlcnNbIGogKyA2IF0gPT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHBvaW50LnggKz0gbnVtYmVyc1sgaiArIDUgXTtcblx0XHRcdFx0XHRcdFx0cG9pbnQueSArPSBudW1iZXJzWyBqICsgNiBdO1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnggPSBwb2ludC54O1xuXHRcdFx0XHRcdFx0XHRjb250cm9sLnkgPSBwb2ludC55O1xuXHRcdFx0XHRcdFx0XHRwYXJzZUFyY0NvbW1hbmQoXG5cdFx0XHRcdFx0XHRcdFx0cGF0aCwgbnVtYmVyc1sgaiBdLCBudW1iZXJzWyBqICsgMSBdLCBudW1iZXJzWyBqICsgMiBdLCBudW1iZXJzWyBqICsgMyBdLCBudW1iZXJzWyBqICsgNCBdLCBzdGFydCwgcG9pbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgZG9TZXRGaXJzdFBvaW50ID09PSB0cnVlICkgZmlyc3RQb2ludC5jb3B5KCBwb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdFx0XHRwYXRoLmN1cnJlbnRQYXRoLmF1dG9DbG9zZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggcGF0aC5jdXJyZW50UGF0aC5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXNldCBwb2ludCB0byBiZWdpbm5pbmcgb2YgUGF0aFxuXHRcdFx0XHRcdFx0XHRwb2ludC5jb3B5KCBmaXJzdFBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdHBhdGguY3VycmVudFBhdGguY3VycmVudFBvaW50LmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdGlzRmlyc3RQb2ludCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBjb21tYW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBwYXJzZUZsb2F0cyggZGF0YSApLCBwYXJzZUZsb2F0cyggZGF0YSApLmxlbmd0aCAgKVxuXG5cdFx0XHRcdGRvU2V0Rmlyc3RQb2ludCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwYXRoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VDU1NTdHlsZXNoZWV0KCBub2RlICkge1xuXG5cdFx0XHRpZiAoICEgbm9kZS5zaGVldCB8fCAhIG5vZGUuc2hlZXQuY3NzUnVsZXMgfHwgISBub2RlLnNoZWV0LmNzc1J1bGVzLmxlbmd0aCApIHJldHVybjtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZS5zaGVldC5jc3NSdWxlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHN0eWxlc2hlZXQgPSBub2RlLnNoZWV0LmNzc1J1bGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBzdHlsZXNoZWV0LnR5cGUgIT09IDEgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2YXIgc2VsZWN0b3JMaXN0ID0gc3R5bGVzaGVldC5zZWxlY3RvclRleHRcblx0XHRcdFx0XHQuc3BsaXQoIC8sL2dtIClcblx0XHRcdFx0XHQuZmlsdGVyKCBCb29sZWFuIClcblx0XHRcdFx0XHQubWFwKCBpID0+IGkudHJpbSgpICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgc2VsZWN0b3JMaXN0Lmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHN0eWxlc2hlZXRzWyBzZWxlY3Rvckxpc3RbIGogXSBdID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdFx0XHRcdHN0eWxlc2hlZXRzWyBzZWxlY3Rvckxpc3RbIGogXSBdIHx8IHt9LFxuXHRcdFx0XHRcdFx0c3R5bGVzaGVldC5zdHlsZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuXHRcdCAqIGh0dHBzOi8vbW9ydG9yYXkuY29tLzIwMTcvMDIvMTYvcmVuZGVyaW5nLWFuLXN2Zy1lbGxpcHRpY2FsLWFyYy1hcy1iZXppZXItY3VydmVzLyBBcHBlbmRpeDogRW5kcG9pbnQgdG8gY2VudGVyIGFyYyBjb252ZXJzaW9uXG5cdFx0ICogRnJvbVxuXHRcdCAqIHJ4IHJ5IHgtYXhpcy1yb3RhdGlvbiBsYXJnZS1hcmMtZmxhZyBzd2VlcC1mbGFnIHggeVxuXHRcdCAqIFRvXG5cdFx0ICogYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb25cblx0XHQgKi9cblxuXHRcdGZ1bmN0aW9uIHBhcnNlQXJjQ29tbWFuZCggcGF0aCwgcngsIHJ5LCB4X2F4aXNfcm90YXRpb24sIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCBzdGFydCwgZW5kICkge1xuXG5cdFx0XHRpZiAoIHJ4ID09IDAgfHwgcnkgPT0gMCApIHtcblxuXHRcdFx0XHQvLyBkcmF3IGEgbGluZSBpZiBlaXRoZXIgb2YgdGhlIHJhZGlpID09IDBcblx0XHRcdFx0cGF0aC5saW5lVG8oIGVuZC54LCBlbmQueSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0eF9heGlzX3JvdGF0aW9uID0geF9heGlzX3JvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcblxuXHRcdFx0Ly8gRW5zdXJlIHJhZGlpIGFyZSBwb3NpdGl2ZVxuXHRcdFx0cnggPSBNYXRoLmFicyggcnggKTtcblx0XHRcdHJ5ID0gTWF0aC5hYnMoIHJ5ICk7XG5cblx0XHRcdC8vIENvbXB1dGUgKHgxJywgeTEnKVxuXHRcdFx0dmFyIGR4MiA9ICggc3RhcnQueCAtIGVuZC54ICkgLyAyLjA7XG5cdFx0XHR2YXIgZHkyID0gKCBzdGFydC55IC0gZW5kLnkgKSAvIDIuMDtcblx0XHRcdHZhciB4MXAgPSBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBkeDIgKyBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBkeTI7XG5cdFx0XHR2YXIgeTFwID0gLSBNYXRoLnNpbiggeF9heGlzX3JvdGF0aW9uICkgKiBkeDIgKyBNYXRoLmNvcyggeF9heGlzX3JvdGF0aW9uICkgKiBkeTI7XG5cblx0XHRcdC8vIENvbXB1dGUgKGN4JywgY3knKVxuXHRcdFx0dmFyIHJ4cyA9IHJ4ICogcng7XG5cdFx0XHR2YXIgcnlzID0gcnkgKiByeTtcblx0XHRcdHZhciB4MXBzID0geDFwICogeDFwO1xuXHRcdFx0dmFyIHkxcHMgPSB5MXAgKiB5MXA7XG5cblx0XHRcdC8vIEVuc3VyZSByYWRpaSBhcmUgbGFyZ2UgZW5vdWdoXG5cdFx0XHR2YXIgY3IgPSB4MXBzIC8gcnhzICsgeTFwcyAvIHJ5cztcblxuXHRcdFx0aWYgKCBjciA+IDEgKSB7XG5cblx0XHRcdFx0Ly8gc2NhbGUgdXAgcngscnkgZXF1YWxseSBzbyBjciA9PSAxXG5cdFx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KCBjciApO1xuXHRcdFx0XHRyeCA9IHMgKiByeDtcblx0XHRcdFx0cnkgPSBzICogcnk7XG5cdFx0XHRcdHJ4cyA9IHJ4ICogcng7XG5cdFx0XHRcdHJ5cyA9IHJ5ICogcnk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRxID0gKCByeHMgKiB5MXBzICsgcnlzICogeDFwcyApO1xuXHRcdFx0dmFyIHBxID0gKCByeHMgKiByeXMgLSBkcSApIC8gZHE7XG5cdFx0XHR2YXIgcSA9IE1hdGguc3FydCggTWF0aC5tYXgoIDAsIHBxICkgKTtcblx0XHRcdGlmICggbGFyZ2VfYXJjX2ZsYWcgPT09IHN3ZWVwX2ZsYWcgKSBxID0gLSBxO1xuXHRcdFx0dmFyIGN4cCA9IHEgKiByeCAqIHkxcCAvIHJ5O1xuXHRcdFx0dmFyIGN5cCA9IC0gcSAqIHJ5ICogeDFwIC8gcng7XG5cblx0XHRcdC8vIFN0ZXAgMzogQ29tcHV0ZSAoY3gsIGN5KSBmcm9tIChjeCcsIGN5Jylcblx0XHRcdHZhciBjeCA9IE1hdGguY29zKCB4X2F4aXNfcm90YXRpb24gKSAqIGN4cCAtIE1hdGguc2luKCB4X2F4aXNfcm90YXRpb24gKSAqIGN5cCArICggc3RhcnQueCArIGVuZC54ICkgLyAyO1xuXHRcdFx0dmFyIGN5ID0gTWF0aC5zaW4oIHhfYXhpc19yb3RhdGlvbiApICogY3hwICsgTWF0aC5jb3MoIHhfYXhpc19yb3RhdGlvbiApICogY3lwICsgKCBzdGFydC55ICsgZW5kLnkgKSAvIDI7XG5cblx0XHRcdC8vIFN0ZXAgNDogQ29tcHV0ZSDOuDEgYW5kIM6Uzrhcblx0XHRcdHZhciB0aGV0YSA9IHN2Z0FuZ2xlKCAxLCAwLCAoIHgxcCAtIGN4cCApIC8gcngsICggeTFwIC0gY3lwICkgLyByeSApO1xuXHRcdFx0dmFyIGRlbHRhID0gc3ZnQW5nbGUoICggeDFwIC0gY3hwICkgLyByeCwgKCB5MXAgLSBjeXAgKSAvIHJ5LCAoIC0geDFwIC0gY3hwICkgLyByeCwgKCAtIHkxcCAtIGN5cCApIC8gcnkgKSAlICggTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hYnNlbGxpcHNlKCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHRoZXRhICsgZGVsdGEsIHN3ZWVwX2ZsYWcgPT09IDAsIHhfYXhpc19yb3RhdGlvbiApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3ZnQW5nbGUoIHV4LCB1eSwgdngsIHZ5ICkge1xuXG5cdFx0XHR2YXIgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG5cdFx0XHR2YXIgbGVuID0gTWF0aC5zcXJ0KCB1eCAqIHV4ICsgdXkgKiB1eSApICogTWF0aC5zcXJ0KCB2eCAqIHZ4ICsgdnkgKiB2eSApO1xuXHRcdFx0dmFyIGFuZyA9IE1hdGguYWNvcyggTWF0aC5tYXgoIC0gMSwgTWF0aC5taW4oIDEsIGRvdCAvIGxlbiApICkgKTsgLy8gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLCBzbGlnaHRseSBvdmVyIHZhbHVlcyBhcHBlYXJcblx0XHRcdGlmICggKCB1eCAqIHZ5IC0gdXkgKiB2eCApIDwgMCApIGFuZyA9IC0gYW5nO1xuXHRcdFx0cmV0dXJuIGFuZztcblxuXHRcdH1cblxuXHRcdC8qXG5cdFx0KiBBY2NvcmRpbmcgdG8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNSZWN0RWxlbWVudFJYQXR0cmlidXRlXG5cdFx0KiByb3VuZGVkIGNvcm5lciBzaG91bGQgYmUgcmVuZGVyZWQgdG8gZWxsaXB0aWNhbCBhcmMsIGJ1dCBiZXppZXIgY3VydmUgZG9lcyB0aGUgam9iIHdlbGwgZW5vdWdoXG5cdFx0Ki9cblx0XHRmdW5jdGlvbiBwYXJzZVJlY3ROb2RlKCBub2RlICkge1xuXG5cdFx0XHR2YXIgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneCcgKSB8fCAwICk7XG5cdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneScgKSB8fCAwICk7XG5cdFx0XHR2YXIgcnggPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3J4JyApIHx8IDAgKTtcblx0XHRcdHZhciByeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncnknICkgfHwgMCApO1xuXHRcdFx0dmFyIHcgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3dpZHRoJyApICk7XG5cdFx0XHR2YXIgaCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnaGVpZ2h0JyApICk7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oIHggKyAyICogcngsIHkgKTtcblx0XHRcdHBhdGgubGluZVRvKCB4ICsgdyAtIDIgKiByeCwgeSApO1xuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHBhdGguYmV6aWVyQ3VydmVUbyggeCArIHcsIHksIHggKyB3LCB5LCB4ICsgdywgeSArIDIgKiByeSApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHggKyB3LCB5ICsgaCAtIDIgKiByeSApO1xuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHBhdGguYmV6aWVyQ3VydmVUbyggeCArIHcsIHkgKyBoLCB4ICsgdywgeSArIGgsIHggKyB3IC0gMiAqIHJ4LCB5ICsgaCApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHggKyAyICogcngsIHkgKyBoICk7XG5cblx0XHRcdGlmICggcnggIT09IDAgfHwgcnkgIT09IDAgKSB7XG5cblx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCB4LCB5ICsgaCwgeCwgeSArIGgsIHgsIHkgKyBoIC0gMiAqIHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKyAyICogcnkgKTtcblxuXHRcdFx0aWYgKCByeCAhPT0gMCB8fCByeSAhPT0gMCApIHtcblxuXHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIHgsIHksIHgsIHksIHggKyAyICogcngsIHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcGF0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlUG9seWdvbk5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdGZ1bmN0aW9uIGl0ZXJhdG9yKCBtYXRjaCwgYSwgYiApIHtcblxuXHRcdFx0XHR2YXIgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGEgKTtcblx0XHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBiICk7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWdleCA9IC8oLT9bXFxkXFwuP10rKVssfFxcc10oLT9bXFxkXFwuP10rKS9nO1xuXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcblxuXHRcdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdwb2ludHMnICkucmVwbGFjZSggcmVnZXgsIGl0ZXJhdG9yICk7XG5cblx0XHRcdHBhdGguY3VycmVudFBhdGguYXV0b0Nsb3NlID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVBvbHlsaW5lTm9kZSggbm9kZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gaXRlcmF0b3IoIG1hdGNoLCBhLCBiICkge1xuXG5cdFx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggYSApO1xuXHRcdFx0XHR2YXIgeSA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIGIgKTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAwICkge1xuXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cGF0aC5saW5lVG8oIHgsIHkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZ2V4ID0gLygtP1tcXGRcXC4/XSspWyx8XFxzXSgtP1tcXGRcXC4/XSspL2c7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXG5cdFx0XHRub2RlLmdldEF0dHJpYnV0ZSggJ3BvaW50cycgKS5yZXBsYWNlKCByZWdleCwgaXRlcmF0b3IgKTtcblxuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSBmYWxzZTtcblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNpcmNsZU5vZGUoIG5vZGUgKSB7XG5cblx0XHRcdHZhciB4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeCcgKSApO1xuXHRcdFx0dmFyIHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ2N5JyApICk7XG5cdFx0XHR2YXIgciA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAncicgKSApO1xuXG5cdFx0XHR2YXIgc3VicGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0XHRzdWJwYXRoLmFic2FyYyggeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cdFx0XHRwYXRoLnN1YlBhdGhzLnB1c2goIHN1YnBhdGggKTtcblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVsbGlwc2VOb2RlKCBub2RlICkge1xuXG5cdFx0XHR2YXIgeCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAnY3gnICkgKTtcblx0XHRcdHZhciB5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdjeScgKSApO1xuXHRcdFx0dmFyIHJ4ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeCcgKSApO1xuXHRcdFx0dmFyIHJ5ID0gcGFyc2VGbG9hdFdpdGhVbml0cyggbm9kZS5nZXRBdHRyaWJ1dGUoICdyeScgKSApO1xuXG5cdFx0XHR2YXIgc3VicGF0aCA9IG5ldyBQYXRoKCk7XG5cdFx0XHRzdWJwYXRoLmFic2VsbGlwc2UoIHgsIHksIHJ4LCByeSwgMCwgTWF0aC5QSSAqIDIgKTtcblxuXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cdFx0XHRwYXRoLnN1YlBhdGhzLnB1c2goIHN1YnBhdGggKTtcblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUxpbmVOb2RlKCBub2RlICkge1xuXG5cdFx0XHR2YXIgeDEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gxJyApICk7XG5cdFx0XHR2YXIgeTEgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3kxJyApICk7XG5cdFx0XHR2YXIgeDIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3gyJyApICk7XG5cdFx0XHR2YXIgeTIgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3kyJyApICk7XG5cblx0XHRcdHZhciBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oIHgxLCB5MSApO1xuXHRcdFx0cGF0aC5saW5lVG8oIHgyLCB5MiApO1xuXHRcdFx0cGF0aC5jdXJyZW50UGF0aC5hdXRvQ2xvc2UgPSBmYWxzZTtcblxuXHRcdFx0cmV0dXJuIHBhdGg7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VTdHlsZSggbm9kZSwgc3R5bGUgKSB7XG5cblx0XHRcdHN0eWxlID0gT2JqZWN0LmFzc2lnbigge30sIHN0eWxlICk7IC8vIGNsb25lIHN0eWxlXG5cblx0XHRcdHZhciBzdHlsZXNoZWV0U3R5bGVzID0ge307XG5cblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICdjbGFzcycgKSApIHtcblxuXHRcdFx0XHR2YXIgY2xhc3NTZWxlY3RvcnMgPSBub2RlLmdldEF0dHJpYnV0ZSggJ2NsYXNzJyApXG5cdFx0XHRcdFx0LnNwbGl0KCAvXFxzLyApXG5cdFx0XHRcdFx0LmZpbHRlciggQm9vbGVhbiApXG5cdFx0XHRcdFx0Lm1hcCggaSA9PiBpLnRyaW0oKSApO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNsYXNzU2VsZWN0b3JzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHN0eWxlc2hlZXRTdHlsZXMgPSBPYmplY3QuYXNzaWduKCBzdHlsZXNoZWV0U3R5bGVzLCBzdHlsZXNoZWV0c1sgJy4nICsgY2xhc3NTZWxlY3RvcnNbIGkgXSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9kZS5oYXNBdHRyaWJ1dGUoICdpZCcgKSApIHtcblxuXHRcdFx0XHRzdHlsZXNoZWV0U3R5bGVzID0gT2JqZWN0LmFzc2lnbiggc3R5bGVzaGVldFN0eWxlcywgc3R5bGVzaGVldHNbICcjJyArIG5vZGUuZ2V0QXR0cmlidXRlKCAnaWQnICkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZFN0eWxlKCBzdmdOYW1lLCBqc05hbWUsIGFkanVzdEZ1bmN0aW9uICkge1xuXG5cdFx0XHRcdGlmICggYWRqdXN0RnVuY3Rpb24gPT09IHVuZGVmaW5lZCApIGFkanVzdEZ1bmN0aW9uID0gZnVuY3Rpb24gY29weSggdiApIHtcblxuXHRcdFx0XHRcdGlmICggdi5zdGFydHNXaXRoKCAndXJsJyApICkgY29uc29sZS53YXJuKCAnU1ZHTG9hZGVyOiB1cmwgYWNjZXNzIGluIGF0dHJpYnV0ZXMgaXMgbm90IGltcGxlbWVudGVkLicgKTtcblxuXHRcdFx0XHRcdHJldHVybiB2O1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBub2RlLmhhc0F0dHJpYnV0ZSggc3ZnTmFtZSApICkgc3R5bGVbIGpzTmFtZSBdID0gYWRqdXN0RnVuY3Rpb24oIG5vZGUuZ2V0QXR0cmlidXRlKCBzdmdOYW1lICkgKTtcblx0XHRcdFx0aWYgKCBzdHlsZXNoZWV0U3R5bGVzWyBzdmdOYW1lIF0gKSBzdHlsZVsganNOYW1lIF0gPSBhZGp1c3RGdW5jdGlvbiggc3R5bGVzaGVldFN0eWxlc1sgc3ZnTmFtZSBdICk7XG5cdFx0XHRcdGlmICggbm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlWyBzdmdOYW1lIF0gIT09ICcnICkgc3R5bGVbIGpzTmFtZSBdID0gYWRqdXN0RnVuY3Rpb24oIG5vZGUuc3R5bGVbIHN2Z05hbWUgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNsYW1wKCB2ICkge1xuXG5cdFx0XHRcdHJldHVybiBNYXRoLm1heCggMCwgTWF0aC5taW4oIDEsIHBhcnNlRmxvYXRXaXRoVW5pdHMoIHYgKSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcG9zaXRpdmUoIHYgKSB7XG5cblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KCAwLCBwYXJzZUZsb2F0V2l0aFVuaXRzKCB2ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhZGRTdHlsZSggJ2ZpbGwnLCAnZmlsbCcgKTtcblx0XHRcdGFkZFN0eWxlKCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGxPcGFjaXR5JywgY2xhbXAgKTtcblx0XHRcdGFkZFN0eWxlKCAnb3BhY2l0eScsICdvcGFjaXR5JywgY2xhbXAgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlJywgJ3N0cm9rZScgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsIGNsYW1wICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS13aWR0aCcsICdzdHJva2VXaWR0aCcsIHBvc2l0aXZlICk7XG5cdFx0XHRhZGRTdHlsZSggJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2VMaW5lSm9pbicgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlTGluZUNhcCcgKTtcblx0XHRcdGFkZFN0eWxlKCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlTWl0ZXJMaW1pdCcsIHBvc2l0aXZlICk7XG5cdFx0XHRhZGRTdHlsZSggJ3Zpc2liaWxpdHknLCAndmlzaWJpbGl0eScgKTtcblxuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNQYXRoRWxlbWVudEltcGxlbWVudGF0aW9uTm90ZXNcblxuXHRcdGZ1bmN0aW9uIGdldFJlZmxlY3Rpb24oIGEsIGIgKSB7XG5cblx0XHRcdHJldHVybiBhIC0gKCBiIC0gYSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcHB2Zy9zdmctbnVtYmVycyAoTUlUIExpY2Vuc2UpXG5cblx0XHRmdW5jdGlvbiBwYXJzZUZsb2F0cyggaW5wdXQgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnSW52YWxpZCBpbnB1dDogJyArIHR5cGVvZiBpbnB1dCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIENoYXJhY3RlciBncm91cHNcblx0XHRcdHZhciBSRSA9IHtcblx0XHRcdFx0U0VQQVJBVE9SOiAvWyBcXHRcXHJcXG5cXCwuXFwtK10vLFxuXHRcdFx0XHRXSElURVNQQUNFOiAvWyBcXHRcXHJcXG5dLyxcblx0XHRcdFx0RElHSVQ6IC9bXFxkXS8sXG5cdFx0XHRcdFNJR046IC9bLStdLyxcblx0XHRcdFx0UE9JTlQ6IC9cXC4vLFxuXHRcdFx0XHRDT01NQTogLywvLFxuXHRcdFx0XHRFWFA6IC9lL2lcblx0XHRcdH07XG5cblx0XHRcdC8vIFN0YXRlc1xuXHRcdFx0dmFyIFNFUCA9IDA7XG5cdFx0XHR2YXIgSU5UID0gMTtcblx0XHRcdHZhciBGTE9BVCA9IDI7XG5cdFx0XHR2YXIgRVhQID0gMztcblxuXHRcdFx0dmFyIHN0YXRlID0gU0VQO1xuXHRcdFx0dmFyIHNlZW5Db21tYSA9IHRydWU7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sIG51bWJlciA9ICcnLCBleHBvbmVudCA9ICcnO1xuXG5cdFx0XHRmdW5jdGlvbiB0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCBwYXJ0aWFsICkge1xuXG5cdFx0XHRcdHZhciBlcnJvciA9IG5ldyBTeW50YXhFcnJvciggJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJyArIGN1cnJlbnQgKyAnXCIgYXQgaW5kZXggJyArIGkgKyAnLicgKTtcblx0XHRcdFx0ZXJyb3IucGFydGlhbCA9IHBhcnRpYWw7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG5ld051bWJlcigpIHtcblxuXHRcdFx0XHRpZiAoIG51bWJlciAhPT0gJycgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGV4cG9uZW50ID09PSAnJyApIHJlc3VsdC5wdXNoKCBOdW1iZXIoIG51bWJlciApICk7XG5cdFx0XHRcdFx0ZWxzZSByZXN1bHQucHVzaCggTnVtYmVyKCBudW1iZXIgKSAqIE1hdGgucG93KCAxMCwgTnVtYmVyKCBleHBvbmVudCApICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bnVtYmVyID0gJyc7XG5cdFx0XHRcdGV4cG9uZW50ID0gJyc7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnQsIGkgPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gaW5wdXRbIGkgXTtcblxuXHRcdFx0XHQvLyBwYXJzZSB1bnRpbCBuZXh0IG51bWJlclxuXHRcdFx0XHRpZiAoIHN0YXRlID09PSBTRVAgKSB7XG5cblx0XHRcdFx0XHQvLyBlYXQgd2hpdGVzcGFjZVxuXHRcdFx0XHRcdGlmICggUkUuV0hJVEVTUEFDRS50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gc3RhcnQgbmV3IG51bWJlclxuXHRcdFx0XHRcdGlmICggUkUuRElHSVQudGVzdCggY3VycmVudCApIHx8IFJFLlNJR04udGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IElOVDtcblx0XHRcdFx0XHRcdG51bWJlciA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuUE9JTlQudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IEZMT0FUO1xuXHRcdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhyb3cgb24gZG91YmxlIGNvbW1hcyAoZS5nLiBcIjEsICwgMlwiKVxuXHRcdFx0XHRcdGlmICggUkUuQ09NTUEudGVzdCggY3VycmVudCApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNlZW5Db21tYSApIHtcblxuXHRcdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzZWVuQ29tbWEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwYXJzZSBpbnRlZ2VyIHBhcnRcblx0XHRcdFx0aWYgKCBzdGF0ZSA9PT0gSU5UICkge1xuXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdG51bWJlciArPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0bnVtYmVyICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IEZMT0FUO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIFJFLkVYUC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gRVhQO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgc2lnbnMgKFwiLSsxXCIpLCBidXQgbm90IG9uIHNpZ24gYXMgc2VwYXJhdG9yIChcIi0xLTJcIilcblx0XHRcdFx0XHRpZiAoIFJFLlNJR04udGVzdCggY3VycmVudCApXG5cdFx0XHRcdFx0XHRcdCYmIG51bWJlci5sZW5ndGggPT09IDFcblx0XHRcdFx0XHRcdFx0JiYgUkUuU0lHTi50ZXN0KCBudW1iZXJbIDAgXSApICkge1xuXG5cdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcGFyc2UgZGVjaW1hbCBwYXJ0XG5cdFx0XHRcdGlmICggc3RhdGUgPT09IEZMT0FUICkge1xuXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdG51bWJlciArPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIFJFLkVYUC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdHN0YXRlID0gRVhQO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyB0aHJvdyBvbiBkb3VibGUgZGVjaW1hbCBwb2ludHMgKGUuZy4gXCIxLi4yXCIpXG5cdFx0XHRcdFx0aWYgKCBSRS5QT0lOVC50ZXN0KCBjdXJyZW50ICkgJiYgbnVtYmVyWyBudW1iZXIubGVuZ3RoIC0gMSBdID09PSAnLicgKSB7XG5cblx0XHRcdFx0XHRcdHRocm93U3ludGF4RXJyb3IoIGN1cnJlbnQsIGksIHJlc3VsdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwYXJzZSBleHBvbmVudCBwYXJ0XG5cdFx0XHRcdGlmICggc3RhdGUgPT0gRVhQICkge1xuXG5cdFx0XHRcdFx0aWYgKCBSRS5ESUdJVC50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGV4cG9uZW50ICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggZXhwb25lbnQgPT09ICcnICkge1xuXG5cdFx0XHRcdFx0XHRcdGV4cG9uZW50ICs9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICggZXhwb25lbnQubGVuZ3RoID09PSAxICYmIFJFLlNJR04udGVzdCggZXhwb25lbnQgKSApIHtcblxuXHRcdFx0XHRcdFx0XHR0aHJvd1N5bnRheEVycm9yKCBjdXJyZW50LCBpLCByZXN1bHQgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdC8vIGVuZCBvZiBudW1iZXJcblx0XHRcdFx0aWYgKCBSRS5XSElURVNQQUNFLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xuXHRcdFx0XHRcdHNlZW5Db21tYSA9IGZhbHNlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLkNPTU1BLnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gU0VQO1xuXHRcdFx0XHRcdHNlZW5Db21tYSA9IHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggUkUuU0lHTi50ZXN0KCBjdXJyZW50ICkgKSB7XG5cblx0XHRcdFx0XHRuZXdOdW1iZXIoKTtcblx0XHRcdFx0XHRzdGF0ZSA9IElOVDtcblx0XHRcdFx0XHRudW1iZXIgPSBjdXJyZW50O1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIFJFLlBPSU5ULnRlc3QoIGN1cnJlbnQgKSApIHtcblxuXHRcdFx0XHRcdG5ld051bWJlcigpO1xuXHRcdFx0XHRcdHN0YXRlID0gRkxPQVQ7XG5cdFx0XHRcdFx0bnVtYmVyID0gY3VycmVudDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhyb3dTeW50YXhFcnJvciggY3VycmVudCwgaSwgcmVzdWx0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCB0aGUgbGFzdCBudW1iZXIgZm91bmQgKGlmIGFueSlcblx0XHRcdG5ld051bWJlcigpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0Ly8gVW5pdHNcblxuXHRcdHZhciB1bml0cyA9IFsgJ21tJywgJ2NtJywgJ2luJywgJ3B0JywgJ3BjJywgJ3B4JyBdO1xuXG5cdFx0Ly8gQ29udmVyc2lvbjogWyBmcm9tVW5pdCBdWyB0b1VuaXQgXSAoLTEgbWVhbnMgZHBpIGRlcGVuZGVudClcblx0XHR2YXIgdW5pdENvbnZlcnNpb24gPSB7XG5cblx0XHRcdCdtbSc6IHtcblx0XHRcdFx0J21tJzogMSxcblx0XHRcdFx0J2NtJzogMC4xLFxuXHRcdFx0XHQnaW4nOiAxIC8gMjUuNCxcblx0XHRcdFx0J3B0JzogNzIgLyAyNS40LFxuXHRcdFx0XHQncGMnOiA2IC8gMjUuNCxcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J2NtJzoge1xuXHRcdFx0XHQnbW0nOiAxMCxcblx0XHRcdFx0J2NtJzogMSxcblx0XHRcdFx0J2luJzogMSAvIDIuNTQsXG5cdFx0XHRcdCdwdCc6IDcyIC8gMi41NCxcblx0XHRcdFx0J3BjJzogNiAvIDIuNTQsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdpbic6IHtcblx0XHRcdFx0J21tJzogMjUuNCxcblx0XHRcdFx0J2NtJzogMi41NCxcblx0XHRcdFx0J2luJzogMSxcblx0XHRcdFx0J3B0JzogNzIsXG5cdFx0XHRcdCdwYyc6IDYsXG5cdFx0XHRcdCdweCc6IC0gMVxuXHRcdFx0fSxcblx0XHRcdCdwdCc6IHtcblx0XHRcdFx0J21tJzogMjUuNCAvIDcyLFxuXHRcdFx0XHQnY20nOiAyLjU0IC8gNzIsXG5cdFx0XHRcdCdpbic6IDEgLyA3Mixcblx0XHRcdFx0J3B0JzogMSxcblx0XHRcdFx0J3BjJzogNiAvIDcyLFxuXHRcdFx0XHQncHgnOiAtIDFcblx0XHRcdH0sXG5cdFx0XHQncGMnOiB7XG5cdFx0XHRcdCdtbSc6IDI1LjQgLyA2LFxuXHRcdFx0XHQnY20nOiAyLjU0IC8gNixcblx0XHRcdFx0J2luJzogMSAvIDYsXG5cdFx0XHRcdCdwdCc6IDcyIC8gNixcblx0XHRcdFx0J3BjJzogMSxcblx0XHRcdFx0J3B4JzogLSAxXG5cdFx0XHR9LFxuXHRcdFx0J3B4Jzoge1xuXHRcdFx0XHQncHgnOiAxXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcGFyc2VGbG9hdFdpdGhVbml0cyggc3RyaW5nICkge1xuXG5cdFx0XHR2YXIgdGhlVW5pdCA9ICdweCc7XG5cblx0XHRcdGlmICggdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgfHwgc3RyaW5nIGluc3RhbmNlb2YgU3RyaW5nICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHVuaXRzLmxlbmd0aDsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgdSA9IHVuaXRzWyBpIF07XG5cblx0XHRcdFx0XHRpZiAoIHN0cmluZy5lbmRzV2l0aCggdSApICkge1xuXG5cdFx0XHRcdFx0XHR0aGVVbml0ID0gdTtcblx0XHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoIDAsIHN0cmluZy5sZW5ndGggLSB1Lmxlbmd0aCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzY2FsZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCB0aGVVbml0ID09PSAncHgnICYmIHNjb3BlLmRlZmF1bHRVbml0ICE9PSAncHgnICkge1xuXG5cdFx0XHRcdC8vIENvbnZlcnNpb24gc2NhbGUgZnJvbSAgcGl4ZWxzIHRvIGluY2hlcywgdGhlbiB0byBkZWZhdWx0IHVuaXRzXG5cblx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgJ2luJyBdWyBzY29wZS5kZWZhdWx0VW5pdCBdIC8gc2NvcGUuZGVmYXVsdERQSTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzY2FsZSA9IHVuaXRDb252ZXJzaW9uWyB0aGVVbml0IF1bIHNjb3BlLmRlZmF1bHRVbml0IF07XG5cblx0XHRcdFx0aWYgKCBzY2FsZSA8IDAgKSB7XG5cblx0XHRcdFx0XHQvLyBDb252ZXJzaW9uIHNjYWxlIHRvIHBpeGVsc1xuXG5cdFx0XHRcdFx0c2NhbGUgPSB1bml0Q29udmVyc2lvblsgdGhlVW5pdCBdWyAnaW4nIF0gKiBzY29wZS5kZWZhdWx0RFBJO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2NhbGUgKiBwYXJzZUZsb2F0KCBzdHJpbmcgKTtcblxuXHRcdH1cblxuXHRcdC8vIFRyYW5zZm9ybXNcblxuXHRcdGZ1bmN0aW9uIGdldE5vZGVUcmFuc2Zvcm0oIG5vZGUgKSB7XG5cblx0XHRcdGlmICggISAoIG5vZGUuaGFzQXR0cmlidXRlKCAndHJhbnNmb3JtJyApIHx8ICggbm9kZS5ub2RlTmFtZSA9PT0gJ3VzZScgJiYgKCBub2RlLmhhc0F0dHJpYnV0ZSggJ3gnICkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoICd5JyApICkgKSApICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0cmFuc2Zvcm0gPSBwYXJzZU5vZGVUcmFuc2Zvcm0oIG5vZGUgKTtcblxuXHRcdFx0aWYgKCB0cmFuc2Zvcm1TdGFjay5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHRyYW5zZm9ybS5wcmVtdWx0aXBseSggdHJhbnNmb3JtU3RhY2tbIHRyYW5zZm9ybVN0YWNrLmxlbmd0aCAtIDEgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRUcmFuc2Zvcm0uY29weSggdHJhbnNmb3JtICk7XG5cdFx0XHR0cmFuc2Zvcm1TdGFjay5wdXNoKCB0cmFuc2Zvcm0gKTtcblxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlTm9kZVRyYW5zZm9ybSggbm9kZSApIHtcblxuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0XHR2YXIgY3VycmVudFRyYW5zZm9ybSA9IHRlbXBUcmFuc2Zvcm0wO1xuXG5cdFx0XHRpZiAoIG5vZGUubm9kZU5hbWUgPT09ICd1c2UnICYmICggbm9kZS5oYXNBdHRyaWJ1dGUoICd4JyApIHx8IG5vZGUuaGFzQXR0cmlidXRlKCAneScgKSApICkge1xuXG5cdFx0XHRcdHZhciB0eCA9IHBhcnNlRmxvYXRXaXRoVW5pdHMoIG5vZGUuZ2V0QXR0cmlidXRlKCAneCcgKSApO1xuXHRcdFx0XHR2YXIgdHkgPSBwYXJzZUZsb2F0V2l0aFVuaXRzKCBub2RlLmdldEF0dHJpYnV0ZSggJ3knICkgKTtcblxuXHRcdFx0XHR0cmFuc2Zvcm0udHJhbnNsYXRlKCB0eCwgdHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGUuaGFzQXR0cmlidXRlKCAndHJhbnNmb3JtJyApICkge1xuXG5cdFx0XHRcdHZhciB0cmFuc2Zvcm1zVGV4dHMgPSBub2RlLmdldEF0dHJpYnV0ZSggJ3RyYW5zZm9ybScgKS5zcGxpdCggJyknICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIHRJbmRleCA9IHRyYW5zZm9ybXNUZXh0cy5sZW5ndGggLSAxOyB0SW5kZXggPj0gMDsgdEluZGV4IC0tICkge1xuXG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybVRleHQgPSB0cmFuc2Zvcm1zVGV4dHNbIHRJbmRleCBdLnRyaW0oKTtcblxuXHRcdFx0XHRcdGlmICggdHJhbnNmb3JtVGV4dCA9PT0gJycgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdHZhciBvcGVuUGFyUG9zID0gdHJhbnNmb3JtVGV4dC5pbmRleE9mKCAnKCcgKTtcblx0XHRcdFx0XHR2YXIgY2xvc2VQYXJQb3MgPSB0cmFuc2Zvcm1UZXh0Lmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggb3BlblBhclBvcyA+IDAgJiYgb3BlblBhclBvcyA8IGNsb3NlUGFyUG9zICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtVHlwZSA9IHRyYW5zZm9ybVRleHQuc3Vic3RyKCAwLCBvcGVuUGFyUG9zICk7XG5cblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IHBhcnNlRmxvYXRzKCB0cmFuc2Zvcm1UZXh0LnN1YnN0ciggb3BlblBhclBvcyArIDEsIGNsb3NlUGFyUG9zIC0gb3BlblBhclBvcyAtIDEgKSApO1xuXG5cdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLmlkZW50aXR5KCk7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIHRyYW5zZm9ybVR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0eCA9IGFycmF5WyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdHkgPSB0eDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eSA9IGFycmF5WyAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS50cmFuc2xhdGUoIHR4LCB0eSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID49IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBhbmdsZSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgY3ggPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGN5ID0gMDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQW5nbGVcblx0XHRcdFx0XHRcdFx0XHRcdGFuZ2xlID0gLSBhcnJheVsgMCBdICogTWF0aC5QSSAvIDE4MDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDZW50ZXIgeCwgeVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjeCA9IGFycmF5WyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN5ID0gYXJyYXlbIDIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSb3RhdGUgYXJvdW5kIGNlbnRlciAoY3gsIGN5KVxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTEuaWRlbnRpdHkoKS50cmFuc2xhdGUoIC0gY3gsIC0gY3kgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUcmFuc2Zvcm0yLmlkZW50aXR5KCkucm90YXRlKCBhbmdsZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRyYW5zZm9ybTMubXVsdGlwbHlNYXRyaWNlcyggdGVtcFRyYW5zZm9ybTIsIHRlbXBUcmFuc2Zvcm0xICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVHJhbnNmb3JtMS5pZGVudGl0eSgpLnRyYW5zbGF0ZSggY3gsIGN5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLm11bHRpcGx5TWF0cmljZXMoIHRlbXBUcmFuc2Zvcm0xLCB0ZW1wVHJhbnNmb3JtMyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBhcnJheS5sZW5ndGggPj0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHNjYWxlWCA9IGFycmF5WyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc2NhbGVZID0gc2NhbGVYO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA+PSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNjYWxlWSA9IGFycmF5WyAxIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zY2FsZSggc2NhbGVYLCBzY2FsZVkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3NrZXdYJzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNldChcblx0XHRcdFx0XHRcdFx0XHRcdFx0MSwgTWF0aC50YW4oIGFycmF5WyAwIF0gKiBNYXRoLlBJIC8gMTgwICksIDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDEsIDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDAsIDAsIDFcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdza2V3WSc6XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRyYW5zZm9ybS5zZXQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDEsIDAsIDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgudGFuKCBhcnJheVsgMCBdICogTWF0aC5QSSAvIDE4MCApLCAxLCAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQwLCAwLCAxXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnbWF0cml4JzpcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VHJhbnNmb3JtLnNldChcblx0XHRcdFx0XHRcdFx0XHRcdFx0YXJyYXlbIDAgXSwgYXJyYXlbIDIgXSwgYXJyYXlbIDQgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YXJyYXlbIDEgXSwgYXJyYXlbIDMgXSwgYXJyYXlbIDUgXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0MCwgMCwgMVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cmFuc2Zvcm0ucHJlbXVsdGlwbHkoIGN1cnJlbnRUcmFuc2Zvcm0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgoIHBhdGgsIG0gKSB7XG5cblx0XHRcdGZ1bmN0aW9uIHRyYW5zZlZlYzIoIHYyICkge1xuXG5cdFx0XHRcdHRlbXBWMy5zZXQoIHYyLngsIHYyLnksIDEgKS5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR2Mi5zZXQoIHRlbXBWMy54LCB0ZW1wVjMueSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpc1JvdGF0ZWQgPSBpc1RyYW5zZm9ybVJvdGF0ZWQoIG0gKTtcblxuXHRcdFx0dmFyIHN1YlBhdGhzID0gcGF0aC5zdWJQYXRocztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgc3ViUGF0aCA9IHN1YlBhdGhzWyBpIF07XG5cdFx0XHRcdHZhciBjdXJ2ZXMgPSBzdWJQYXRoLmN1cnZlcztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBjdXJ2ZXMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoIGN1cnZlLmlzTGluZUN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzQ3ViaWNCZXppZXJDdXJ2ZSApIHtcblxuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjAgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYxICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MiApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgKSB7XG5cblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIGN1cnZlLnYwICk7XG5cdFx0XHRcdFx0XHR0cmFuc2ZWZWMyKCBjdXJ2ZS52MSApO1xuXHRcdFx0XHRcdFx0dHJhbnNmVmVjMiggY3VydmUudjIgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGlzUm90YXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdTVkdMb2FkZXI6IEVsbGlwdGljIGFyYyBvciBlbGxpcHNlIHJvdGF0aW9uIG9yIHNrZXdpbmcgaXMgbm90IGltcGxlbWVudGVkLicgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0ZW1wVjIuc2V0KCBjdXJ2ZS5hWCwgY3VydmUuYVkgKTtcblx0XHRcdFx0XHRcdHRyYW5zZlZlYzIoIHRlbXBWMiApO1xuXHRcdFx0XHRcdFx0Y3VydmUuYVggPSB0ZW1wVjIueDtcblx0XHRcdFx0XHRcdGN1cnZlLmFZID0gdGVtcFYyLnk7XG5cblx0XHRcdFx0XHRcdGN1cnZlLnhSYWRpdXMgKj0gZ2V0VHJhbnNmb3JtU2NhbGVYKCBtICk7XG5cdFx0XHRcdFx0XHRjdXJ2ZS55UmFkaXVzICo9IGdldFRyYW5zZm9ybVNjYWxlWSggbSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNUcmFuc2Zvcm1Sb3RhdGVkKCBtICkge1xuXG5cdFx0XHRyZXR1cm4gbS5lbGVtZW50c1sgMSBdICE9PSAwIHx8IG0uZWxlbWVudHNbIDMgXSAhPT0gMDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRyYW5zZm9ybVNjYWxlWCggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cztcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRyYW5zZm9ybVNjYWxlWSggbSApIHtcblxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cztcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIHRlWyAzIF0gKiB0ZVsgMyBdICsgdGVbIDQgXSAqIHRlWyA0IF0gKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHR2YXIgcGF0aHMgPSBbXTtcblx0XHR2YXIgc3R5bGVzaGVldHMgPSB7fTtcblxuXHRcdHZhciB0cmFuc2Zvcm1TdGFjayA9IFtdO1xuXG5cdFx0dmFyIHRlbXBUcmFuc2Zvcm0wID0gbmV3IE1hdHJpeDMoKTtcblx0XHR2YXIgdGVtcFRyYW5zZm9ybTEgPSBuZXcgTWF0cml4MygpO1xuXHRcdHZhciB0ZW1wVHJhbnNmb3JtMiA9IG5ldyBNYXRyaXgzKCk7XG5cdFx0dmFyIHRlbXBUcmFuc2Zvcm0zID0gbmV3IE1hdHJpeDMoKTtcblx0XHR2YXIgdGVtcFYyID0gbmV3IFZlY3RvcjIoKTtcblx0XHR2YXIgdGVtcFYzID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdHZhciBjdXJyZW50VHJhbnNmb3JtID0gbmV3IE1hdHJpeDMoKTtcblxuXHRcdHZhciB4bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCB0ZXh0LCAnaW1hZ2Uvc3ZnK3htbCcgKTsgLy8gYXBwbGljYXRpb24veG1sXG5cblx0XHRwYXJzZU5vZGUoIHhtbC5kb2N1bWVudEVsZW1lbnQsIHtcblx0XHRcdGZpbGw6ICcjMDAwJyxcblx0XHRcdGZpbGxPcGFjaXR5OiAxLFxuXHRcdFx0c3Ryb2tlT3BhY2l0eTogMSxcblx0XHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdFx0c3Ryb2tlTGluZUpvaW46ICdtaXRlcicsXG5cdFx0XHRzdHJva2VMaW5lQ2FwOiAnYnV0dCcsXG5cdFx0XHRzdHJva2VNaXRlckxpbWl0OiA0XG5cdFx0fSApO1xuXG5cdFx0dmFyIGRhdGEgPSB7IHBhdGhzOiBwYXRocywgeG1sOiB4bWwuZG9jdW1lbnRFbGVtZW50IH07XG5cblx0XHQvLyBjb25zb2xlLmxvZyggcGF0aHMgKTtcblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cbn0gKTtcblxuU1ZHTG9hZGVyLmdldFN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKCB3aWR0aCwgY29sb3IsIGxpbmVKb2luLCBsaW5lQ2FwLCBtaXRlckxpbWl0ICkge1xuXG5cdC8vIFBhcmFtIHdpZHRoOiBTdHJva2Ugd2lkdGhcblx0Ly8gUGFyYW0gY29sb3I6IEFzIHJldHVybmVkIGJ5IFRIUkVFLkNvbG9yLmdldFN0eWxlKClcblx0Ly8gUGFyYW0gbGluZUpvaW46IE9uZSBvZiBcInJvdW5kXCIsIFwiYmV2ZWxcIiwgXCJtaXRlclwiIG9yIFwibWl0ZXItbGltaXRcIlxuXHQvLyBQYXJhbSBsaW5lQ2FwOiBPbmUgb2YgXCJyb3VuZFwiLCBcInNxdWFyZVwiIG9yIFwiYnV0dFwiXG5cdC8vIFBhcmFtIG1pdGVyTGltaXQ6IE1heGltdW0gam9pbiBsZW5ndGgsIGluIG11bHRpcGxlcyBvZiB0aGUgXCJ3aWR0aFwiIHBhcmFtZXRlciAoam9pbiBpcyB0cnVuY2F0ZWQgaWYgaXQgZXhjZWVkcyB0aGF0IGRpc3RhbmNlKVxuXHQvLyBSZXR1cm5zIHN0eWxlIG9iamVjdFxuXG5cdHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogMTtcblx0Y29sb3IgPSBjb2xvciAhPT0gdW5kZWZpbmVkID8gY29sb3IgOiAnIzAwMCc7XG5cdGxpbmVKb2luID0gbGluZUpvaW4gIT09IHVuZGVmaW5lZCA/IGxpbmVKb2luIDogJ21pdGVyJztcblx0bGluZUNhcCA9IGxpbmVDYXAgIT09IHVuZGVmaW5lZCA/IGxpbmVDYXAgOiAnYnV0dCc7XG5cdG1pdGVyTGltaXQgPSBtaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgPyBtaXRlckxpbWl0IDogNDtcblxuXHRyZXR1cm4ge1xuXHRcdHN0cm9rZUNvbG9yOiBjb2xvcixcblx0XHRzdHJva2VXaWR0aDogd2lkdGgsXG5cdFx0c3Ryb2tlTGluZUpvaW46IGxpbmVKb2luLFxuXHRcdHN0cm9rZUxpbmVDYXA6IGxpbmVDYXAsXG5cdFx0c3Ryb2tlTWl0ZXJMaW1pdDogbWl0ZXJMaW1pdFxuXHR9O1xuXG59O1xuXG5TVkdMb2FkZXIucG9pbnRzVG9TdHJva2UgPSBmdW5jdGlvbiAoIHBvaW50cywgc3R5bGUsIGFyY0RpdmlzaW9ucywgbWluRGlzdGFuY2UgKSB7XG5cblx0Ly8gR2VuZXJhdGVzIGEgc3Ryb2tlIHdpdGggc29tZSB3aXRkaCBhcm91bmQgdGhlIGdpdmVuIHBhdGguXG5cdC8vIFRoZSBwYXRoIGNhbiBiZSBvcGVuIG9yIGNsb3NlZCAobGFzdCBwb2ludCBlcXVhbHMgdG8gZmlyc3QgcG9pbnQpXG5cdC8vIFBhcmFtIHBvaW50czogQXJyYXkgb2YgVmVjdG9yMkQgKHRoZSBwYXRoKS4gTWluaW11bSAyIHBvaW50cy5cblx0Ly8gUGFyYW0gc3R5bGU6IE9iamVjdCB3aXRoIFNWRyBwcm9wZXJ0aWVzIGFzIHJldHVybmVkIGJ5IFNWR0xvYWRlci5nZXRTdHJva2VTdHlsZSgpLCBvciBTVkdMb2FkZXIucGFyc2UoKSBpbiB0aGUgcGF0aC51c2VyRGF0YS5zdHlsZSBvYmplY3Rcblx0Ly8gUGFyYW1zIGFyY0RpdmlzaW9uczogQXJjIGRpdmlzaW9ucyBmb3Igcm91bmQgam9pbnMgYW5kIGVuZGNhcHMuIChPcHRpb25hbClcblx0Ly8gUGFyYW0gbWluRGlzdGFuY2U6IFBvaW50cyBjbG9zZXIgdG8gdGhpcyBkaXN0YW5jZSB3aWxsIGJlIG1lcmdlZC4gKE9wdGlvbmFsKVxuXHQvLyBSZXR1cm5zIEJ1ZmZlckdlb21ldHJ5IHdpdGggc3Ryb2tlIHRyaWFuZ2xlcyAoSW4gcGxhbmUgeiA9IDApLiBVViBjb29yZGluYXRlcyBhcmUgZ2VuZXJhdGVkICgndScgYWxvbmcgcGF0aC4gJ3YnIGFjcm9zcyBpdCwgZnJvbSBsZWZ0IHRvIHJpZ2h0KVxuXG5cdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHR2YXIgbm9ybWFscyA9IFtdO1xuXHR2YXIgdXZzID0gW107XG5cblx0aWYgKCBTVkdMb2FkZXIucG9pbnRzVG9TdHJva2VXaXRoQnVmZmVycyggcG9pbnRzLCBzdHlsZSwgYXJjRGl2aXNpb25zLCBtaW5EaXN0YW5jZSwgdmVydGljZXMsIG5vcm1hbHMsIHV2cyApID09PSAwICkge1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdGdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHRyZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblNWR0xvYWRlci5wb2ludHNUb1N0cm9rZVdpdGhCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB0ZW1wVjJfMSA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfMiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfMyA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfNCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfNSA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfNiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciB0ZW1wVjJfNyA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBsYXN0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGxhc3RQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgcG9pbnQwTCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBwb2ludDBSID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIGN1cnJlbnRQb2ludEwgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgY3VycmVudFBvaW50UiA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBuZXh0UG9pbnRMID0gbmV3IFZlY3RvcjIoKTtcblx0dmFyIG5leHRQb2ludFIgPSBuZXcgVmVjdG9yMigpO1xuXHR2YXIgaW5uZXJQb2ludCA9IG5ldyBWZWN0b3IyKCk7XG5cdHZhciBvdXRlclBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludHMsIHN0eWxlLCBhcmNEaXZpc2lvbnMsIG1pbkRpc3RhbmNlLCB2ZXJ0aWNlcywgbm9ybWFscywgdXZzLCB2ZXJ0ZXhPZmZzZXQgKSB7XG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gdXBkYXRlIGV4aXN0aW5nIGFycmF5cyBvciBidWZmZXJzLlxuXHRcdC8vIEFjY2VwdHMgc2FtZSBwYXJhbWV0ZXJzIGFzIHBvaW50c1RvU3Ryb2tlLCBwbHVzIHRoZSBidWZmZXJzIGFuZCBvcHRpb25hbCBvZmZzZXQuXG5cdFx0Ly8gUGFyYW0gdmVydGV4T2Zmc2V0OiBPZmZzZXQgdmVydGljZXMgdG8gc3RhcnQgd3JpdGluZyBpbiB0aGUgYnVmZmVycyAoMyBlbGVtZW50cy92ZXJ0ZXggZm9yIHZlcnRpY2VzIGFuZCBub3JtYWxzLCBhbmQgMiBlbGVtZW50cy92ZXJ0ZXggZm9yIHV2cylcblx0XHQvLyBSZXR1cm5zIG51bWJlciBvZiB3cml0dGVuIHZlcnRpY2VzIC8gbm9ybWFscyAvIHV2cyBwYWlyc1xuXHRcdC8vIGlmICd2ZXJ0aWNlcycgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBubyB0cmlhbmdsZXMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGUgcmV0dXJuZWQgdmVydGljZXMgY291bnQgd2lsbCBzdGlsbCBiZSB2YWxpZCAodXNlZnVsIHRvIHByZWFsbG9jYXRlIHRoZSBidWZmZXJzKVxuXHRcdC8vICdub3JtYWxzJyBhbmQgJ3V2cycgYnVmZmVycyBhcmUgb3B0aW9uYWxcblxuXHRcdGFyY0RpdmlzaW9ucyA9IGFyY0RpdmlzaW9ucyAhPT0gdW5kZWZpbmVkID8gYXJjRGl2aXNpb25zIDogMTI7XG5cdFx0bWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZSAhPT0gdW5kZWZpbmVkID8gbWluRGlzdGFuY2UgOiAwLjAwMTtcblx0XHR2ZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhPZmZzZXQgIT09IHVuZGVmaW5lZCA/IHZlcnRleE9mZnNldCA6IDA7XG5cblx0XHQvLyBGaXJzdCBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZWQgcG9pbnRzXG5cdFx0cG9pbnRzID0gcmVtb3ZlRHVwbGljYXRlZFBvaW50cyggcG9pbnRzICk7XG5cblx0XHR2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGlmICggbnVtUG9pbnRzIDwgMiApIHJldHVybiAwO1xuXG5cdFx0dmFyIGlzQ2xvc2VkID0gcG9pbnRzWyAwIF0uZXF1YWxzKCBwb2ludHNbIG51bVBvaW50cyAtIDEgXSApO1xuXG5cdFx0dmFyIGN1cnJlbnRQb2ludDtcblx0XHR2YXIgcHJldmlvdXNQb2ludCA9IHBvaW50c1sgMCBdO1xuXHRcdHZhciBuZXh0UG9pbnQ7XG5cblx0XHR2YXIgc3Ryb2tlV2lkdGgyID0gc3R5bGUuc3Ryb2tlV2lkdGggLyAyO1xuXG5cdFx0dmFyIGRlbHRhVSA9IDEgLyAoIG51bVBvaW50cyAtIDEgKTtcblx0XHR2YXIgdTAgPSAwO1xuXG5cdFx0dmFyIGlubmVyU2lkZU1vZGlmaWVkO1xuXHRcdHZhciBqb2luSXNPbkxlZnRTaWRlO1xuXHRcdHZhciBpc01pdGVyO1xuXHRcdHZhciBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSA9IGZhbHNlO1xuXG5cdFx0dmFyIG51bVZlcnRpY2VzID0gMDtcblx0XHR2YXIgY3VycmVudENvb3JkaW5hdGUgPSB2ZXJ0ZXhPZmZzZXQgKiAzO1xuXHRcdHZhciBjdXJyZW50Q29vcmRpbmF0ZVVWID0gdmVydGV4T2Zmc2V0ICogMjtcblxuXHRcdC8vIEdldCBpbml0aWFsIGxlZnQgYW5kIHJpZ2h0IHN0cm9rZSBwb2ludHNcblx0XHRnZXROb3JtYWwoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSwgdGVtcFYyXzEgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XG5cdFx0bGFzdFBvaW50TC5jb3B5KCBwb2ludHNbIDAgXSApLnN1YiggdGVtcFYyXzEgKTtcblx0XHRsYXN0UG9pbnRSLmNvcHkoIHBvaW50c1sgMCBdICkuYWRkKCB0ZW1wVjJfMSApO1xuXHRcdHBvaW50MEwuY29weSggbGFzdFBvaW50TCApO1xuXHRcdHBvaW50MFIuY29weSggbGFzdFBvaW50UiApO1xuXG5cdFx0Zm9yICggdmFyIGlQb2ludCA9IDE7IGlQb2ludCA8IG51bVBvaW50czsgaVBvaW50ICsrICkge1xuXG5cdFx0XHRjdXJyZW50UG9pbnQgPSBwb2ludHNbIGlQb2ludCBdO1xuXG5cdFx0XHQvLyBHZXQgbmV4dCBwb2ludFxuXHRcdFx0aWYgKCBpUG9pbnQgPT09IG51bVBvaW50cyAtIDEgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0Nsb3NlZCApIHtcblxuXHRcdFx0XHRcdC8vIFNraXAgZHVwbGljYXRlZCBpbml0aWFsIHBvaW50XG5cdFx0XHRcdFx0bmV4dFBvaW50ID0gcG9pbnRzWyAxIF07XG5cblx0XHRcdFx0fSBlbHNlIG5leHRQb2ludCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRuZXh0UG9pbnQgPSBwb2ludHNbIGlQb2ludCArIDEgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWwgb2YgcHJldmlvdXMgc2VnbWVudCBpbiB0ZW1wVjJfMVxuXHRcdFx0dmFyIG5vcm1hbDEgPSB0ZW1wVjJfMTtcblx0XHRcdGdldE5vcm1hbCggcHJldmlvdXNQb2ludCwgY3VycmVudFBvaW50LCBub3JtYWwxICk7XG5cblx0XHRcdHRlbXBWMl8zLmNvcHkoIG5vcm1hbDEgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XG5cdFx0XHRjdXJyZW50UG9pbnRMLmNvcHkoIGN1cnJlbnRQb2ludCApLnN1YiggdGVtcFYyXzMgKTtcblx0XHRcdGN1cnJlbnRQb2ludFIuY29weSggY3VycmVudFBvaW50ICkuYWRkKCB0ZW1wVjJfMyApO1xuXG5cdFx0XHR2YXIgdTEgPSB1MCArIGRlbHRhVTtcblxuXHRcdFx0aW5uZXJTaWRlTW9kaWZpZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBuZXh0UG9pbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBOb3JtYWwgb2YgbmV4dCBzZWdtZW50IGluIHRlbXBWMl8yXG5cdFx0XHRcdGdldE5vcm1hbCggY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHRlbXBWMl8yICk7XG5cblx0XHRcdFx0dGVtcFYyXzMuY29weSggdGVtcFYyXzIgKS5tdWx0aXBseVNjYWxhciggc3Ryb2tlV2lkdGgyICk7XG5cdFx0XHRcdG5leHRQb2ludEwuY29weSggY3VycmVudFBvaW50ICkuc3ViKCB0ZW1wVjJfMyApO1xuXHRcdFx0XHRuZXh0UG9pbnRSLmNvcHkoIGN1cnJlbnRQb2ludCApLmFkZCggdGVtcFYyXzMgKTtcblxuXHRcdFx0XHRqb2luSXNPbkxlZnRTaWRlID0gdHJ1ZTtcblx0XHRcdFx0dGVtcFYyXzMuc3ViVmVjdG9ycyggbmV4dFBvaW50LCBwcmV2aW91c1BvaW50ICk7XG5cdFx0XHRcdGlmICggbm9ybWFsMS5kb3QoIHRlbXBWMl8zICkgPCAwICkge1xuXG5cdFx0XHRcdFx0am9pbklzT25MZWZ0U2lkZSA9IGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGlQb2ludCA9PT0gMSApIGluaXRpYWxKb2luSXNPbkxlZnRTaWRlID0gam9pbklzT25MZWZ0U2lkZTtcblxuXHRcdFx0XHR0ZW1wVjJfMy5zdWJWZWN0b3JzKCBuZXh0UG9pbnQsIGN1cnJlbnRQb2ludCApO1xuXHRcdFx0XHR0ZW1wVjJfMy5ub3JtYWxpemUoKTtcblx0XHRcdFx0dmFyIGRvdCA9IE1hdGguYWJzKCBub3JtYWwxLmRvdCggdGVtcFYyXzMgKSApO1xuXG5cdFx0XHRcdC8vIElmIHBhdGggaXMgc3RyYWlnaHQsIGRvbid0IGNyZWF0ZSBqb2luXG5cdFx0XHRcdGlmICggZG90ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gQ29tcHV0ZSBpbm5lciBhbmQgb3V0ZXIgc2VnbWVudCBpbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0dmFyIG1pdGVyU2lkZSA9IHN0cm9rZVdpZHRoMiAvIGRvdDtcblx0XHRcdFx0XHR0ZW1wVjJfMy5tdWx0aXBseVNjYWxhciggLSBtaXRlclNpZGUgKTtcblx0XHRcdFx0XHR0ZW1wVjJfNC5zdWJWZWN0b3JzKCBjdXJyZW50UG9pbnQsIHByZXZpb3VzUG9pbnQgKTtcblx0XHRcdFx0XHR0ZW1wVjJfNS5jb3B5KCB0ZW1wVjJfNCApLnNldExlbmd0aCggbWl0ZXJTaWRlICkuYWRkKCB0ZW1wVjJfMyApO1xuXHRcdFx0XHRcdGlubmVyUG9pbnQuY29weSggdGVtcFYyXzUgKS5uZWdhdGUoKTtcblx0XHRcdFx0XHR2YXIgbWl0ZXJMZW5ndGgyID0gdGVtcFYyXzUubGVuZ3RoKCk7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGhQcmV2ID0gdGVtcFYyXzQubGVuZ3RoKCk7XG5cdFx0XHRcdFx0dGVtcFYyXzQuZGl2aWRlU2NhbGFyKCBzZWdtZW50TGVuZ3RoUHJldiApO1xuXHRcdFx0XHRcdHRlbXBWMl82LnN1YlZlY3RvcnMoIG5leHRQb2ludCwgY3VycmVudFBvaW50ICk7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGhOZXh0ID0gdGVtcFYyXzYubGVuZ3RoKCk7XG5cdFx0XHRcdFx0dGVtcFYyXzYuZGl2aWRlU2NhbGFyKCBzZWdtZW50TGVuZ3RoTmV4dCApO1xuXHRcdFx0XHRcdC8vIENoZWNrIHRoYXQgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudHMgZG9lc24ndCBvdmVybGFwIHdpdGggdGhlIGlubmVyUG9pbnQgb2YgaW50ZXJzZWN0aW9uXG5cdFx0XHRcdFx0aWYgKCB0ZW1wVjJfNC5kb3QoIGlubmVyUG9pbnQgKSA8IHNlZ21lbnRMZW5ndGhQcmV2ICYmIHRlbXBWMl82LmRvdCggaW5uZXJQb2ludCApIDwgc2VnbWVudExlbmd0aE5leHQgKSB7XG5cblx0XHRcdFx0XHRcdGlubmVyU2lkZU1vZGlmaWVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dGVyUG9pbnQuY29weSggdGVtcFYyXzUgKS5hZGQoIGN1cnJlbnRQb2ludCApO1xuXHRcdFx0XHRcdGlubmVyUG9pbnQuYWRkKCBjdXJyZW50UG9pbnQgKTtcblxuXHRcdFx0XHRcdGlzTWl0ZXIgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRuZXh0UG9pbnRSLmNvcHkoIGlubmVyUG9pbnQgKTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFBvaW50Ui5jb3B5KCBpbm5lclBvaW50ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0bmV4dFBvaW50TC5jb3B5KCBpbm5lclBvaW50ICk7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRQb2ludEwuY29weSggaW5uZXJQb2ludCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBUaGUgc2VnbWVudCB0cmlhbmdsZXMgYXJlIGdlbmVyYXRlZCBoZXJlIGlmIHRoZXJlIHdhcyBvdmVybGFwcGluZ1xuXG5cdFx0XHRcdFx0XHRtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c3dpdGNoICggc3R5bGUuc3Ryb2tlTGluZUpvaW4gKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ2JldmVsJzpcblxuXHRcdFx0XHRcdFx0XHRtYWtlU2VnbWVudFdpdGhCZXZlbEpvaW4oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkLCB1MSApO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdyb3VuZCc6XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VnbWVudCB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRjcmVhdGVTZWdtZW50VHJpYW5nbGVzV2l0aE1pZGRsZVNlY3Rpb24oIGpvaW5Jc09uTGVmdFNpZGUsIGlubmVyU2lkZU1vZGlmaWVkICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSm9pbiB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGN1cnJlbnRQb2ludCwgY3VycmVudFBvaW50TCwgbmV4dFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0bWFrZUNpcmN1bGFyU2VjdG9yKCBjdXJyZW50UG9pbnQsIG5leHRQb2ludFIsIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlICdtaXRlcic6XG5cdFx0XHRcdFx0XHRjYXNlICdtaXRlci1jbGlwJzpcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1pdGVyRnJhY3Rpb24gPSAoIHN0cm9rZVdpZHRoMiAqIHN0eWxlLnN0cm9rZU1pdGVyTGltaXQgKSAvIG1pdGVyTGVuZ3RoMjtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1pdGVyRnJhY3Rpb24gPCAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGpvaW4gbWl0ZXIgbGVuZ3RoIGV4Y2VlZHMgdGhlIG1pdGVyIGxpbWl0XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0eWxlLnN0cm9rZUxpbmVKb2luICE9PSAnbWl0ZXItY2xpcCcgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFNlZ21lbnQgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gTWl0ZXItY2xpcCBqb2luIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFYyXzYuc3ViVmVjdG9ycyggb3V0ZXJQb2ludCwgY3VycmVudFBvaW50TCApLm11bHRpcGx5U2NhbGFyKCBtaXRlckZyYWN0aW9uICkuYWRkKCBjdXJyZW50UG9pbnRMICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBWMl83LnN1YlZlY3RvcnMoIG91dGVyUG9pbnQsIG5leHRQb2ludEwgKS5tdWx0aXBseVNjYWxhciggbWl0ZXJGcmFjdGlvbiApLmFkZCggbmV4dFBvaW50TCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNiwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl83LCB1MSwgMCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVjJfNi5zdWJWZWN0b3JzKCBvdXRlclBvaW50LCBjdXJyZW50UG9pbnRSICkubXVsdGlwbHlTY2FsYXIoIG1pdGVyRnJhY3Rpb24gKS5hZGQoIGN1cnJlbnRQb2ludFIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFYyXzcuc3ViVmVjdG9ycyggb3V0ZXJQb2ludCwgbmV4dFBvaW50UiApLm11bHRpcGx5U2NhbGFyKCBtaXRlckZyYWN0aW9uICkuYWRkKCBuZXh0UG9pbnRSICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl82LCB1MSwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzYsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzcsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfNywgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE1pdGVyIGpvaW4gc2VnbWVudCB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIE9wdGltaXplZCBzZWdtZW50ICsgam9pbiB0cmlhbmdsZXNcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBvdXRlclBvaW50LCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBvaW50TC5jb3B5KCBvdXRlclBvaW50ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBvaW50Ui5jb3B5KCBvdXRlclBvaW50ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQWRkIGV4dHJhIG1pdGVyIGpvaW4gdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDAgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdTEsIDAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggb3V0ZXJQb2ludCwgdTEsIDEgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG91dGVyUG9pbnQsIHUxLCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aXNNaXRlciA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBUaGUgc2VnbWVudCB0cmlhbmdsZXMgYXJlIGdlbmVyYXRlZCBoZXJlIHdoZW4gdHdvIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgY29sbGluZWFyXG5cblx0XHRcdFx0XHRtYWtlU2VnbWVudFRyaWFuZ2xlcygpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBUaGUgc2VnbWVudCB0cmlhbmdsZXMgYXJlIGdlbmVyYXRlZCBoZXJlIGlmIGl0IGlzIHRoZSBlbmRpbmcgc2VnbWVudFxuXG5cdFx0XHRcdG1ha2VTZWdtZW50VHJpYW5nbGVzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIGlzQ2xvc2VkICYmIGlQb2ludCA9PT0gbnVtUG9pbnRzIC0gMSApIHtcblxuXHRcdFx0XHQvLyBTdGFydCBsaW5lIGVuZGNhcFxuXHRcdFx0XHRhZGRDYXBHZW9tZXRyeSggcG9pbnRzWyAwIF0sIHBvaW50MEwsIHBvaW50MFIsIGpvaW5Jc09uTGVmdFNpZGUsIHRydWUsIHUwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVtZW50IGxvb3AgdmFyaWFibGVzXG5cblx0XHRcdHUwID0gdTE7XG5cblx0XHRcdHByZXZpb3VzUG9pbnQgPSBjdXJyZW50UG9pbnQ7XG5cblx0XHRcdGxhc3RQb2ludEwuY29weSggbmV4dFBvaW50TCApO1xuXHRcdFx0bGFzdFBvaW50Ui5jb3B5KCBuZXh0UG9pbnRSICk7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgaXNDbG9zZWQgKSB7XG5cblx0XHRcdC8vIEVuZGluZyBsaW5lIGVuZGNhcFxuXHRcdFx0YWRkQ2FwR2VvbWV0cnkoIGN1cnJlbnRQb2ludCwgY3VycmVudFBvaW50TCwgY3VycmVudFBvaW50Uiwgam9pbklzT25MZWZ0U2lkZSwgZmFsc2UsIHUxICk7XG5cblx0XHR9IGVsc2UgaWYgKCBpbm5lclNpZGVNb2RpZmllZCAmJiB2ZXJ0aWNlcyApIHtcblxuXHRcdFx0Ly8gTW9kaWZ5IHBhdGggZmlyc3Qgc2VnbWVudCB2ZXJ0aWNlcyB0byBhZGp1c3QgdG8gdGhlIHNlZ21lbnRzIGlubmVyIGFuZCBvdXRlciBpbnRlcnNlY3Rpb25zXG5cblx0XHRcdHZhciBsYXN0T3V0ZXIgPSBvdXRlclBvaW50O1xuXHRcdFx0dmFyIGxhc3RJbm5lciA9IGlubmVyUG9pbnQ7XG5cblx0XHRcdGlmICggaW5pdGlhbEpvaW5Jc09uTGVmdFNpZGUgIT09IGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0bGFzdE91dGVyID0gaW5uZXJQb2ludDtcblx0XHRcdFx0bGFzdElubmVyID0gb3V0ZXJQb2ludDtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBpc01pdGVyIHx8IGluaXRpYWxKb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0bGFzdElubmVyLnRvQXJyYXkoIHZlcnRpY2VzLCAwICogMyApO1xuXHRcdFx0XHRcdGxhc3RJbm5lci50b0FycmF5KCB2ZXJ0aWNlcywgMyAqIDMgKTtcblxuXHRcdFx0XHRcdGlmICggaXNNaXRlciApIHtcblxuXHRcdFx0XHRcdFx0bGFzdE91dGVyLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGlzTWl0ZXIgfHwgISBpbml0aWFsSm9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdGxhc3RJbm5lci50b0FycmF5KCB2ZXJ0aWNlcywgMSAqIDMgKTtcblx0XHRcdFx0XHRsYXN0SW5uZXIudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cblx0XHRcdFx0XHRpZiAoIGlzTWl0ZXIgKSB7XG5cblx0XHRcdFx0XHRcdGxhc3RPdXRlci50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudW1WZXJ0aWNlcztcblxuXHRcdC8vIC0tIEVuZCBvZiBhbGdvcml0aG1cblxuXHRcdC8vIC0tIEZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Tm9ybWFsKCBwMSwgcDIsIHJlc3VsdCApIHtcblxuXHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHAyLCBwMSApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gcmVzdWx0LnksIHJlc3VsdC54ICkubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIHBvc2l0aW9uLCB1LCB2ICkge1xuXG5cdFx0XHRpZiAoIHZlcnRpY2VzICkge1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBjdXJyZW50Q29vcmRpbmF0ZSBdID0gcG9zaXRpb24ueDtcblx0XHRcdFx0dmVydGljZXNbIGN1cnJlbnRDb29yZGluYXRlICsgMSBdID0gcG9zaXRpb24ueTtcblx0XHRcdFx0dmVydGljZXNbIGN1cnJlbnRDb29yZGluYXRlICsgMiBdID0gMDtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbHMgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBjdXJyZW50Q29vcmRpbmF0ZSBdID0gMDtcblx0XHRcdFx0XHRub3JtYWxzWyBjdXJyZW50Q29vcmRpbmF0ZSArIDEgXSA9IDA7XG5cdFx0XHRcdFx0bm9ybWFsc1sgY3VycmVudENvb3JkaW5hdGUgKyAyIF0gPSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdXJyZW50Q29vcmRpbmF0ZSArPSAzO1xuXG5cdFx0XHRcdGlmICggdXZzICkge1xuXG5cdFx0XHRcdFx0dXZzWyBjdXJyZW50Q29vcmRpbmF0ZVVWIF0gPSB1O1xuXHRcdFx0XHRcdHV2c1sgY3VycmVudENvb3JkaW5hdGVVViArIDEgXSA9IHY7XG5cblx0XHRcdFx0XHRjdXJyZW50Q29vcmRpbmF0ZVVWICs9IDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdG51bVZlcnRpY2VzICs9IDM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYWtlQ2lyY3VsYXJTZWN0b3IoIGNlbnRlciwgcDEsIHAyLCB1LCB2ICkge1xuXG5cdFx0XHQvLyBwYXJhbSBwMSwgcDI6IFBvaW50cyBpbiB0aGUgY2lyY2xlIGFyYy5cblx0XHRcdC8vIHAxIGFuZCBwMiBhcmUgaW4gY2xvY2t3aXNlIGRpcmVjdGlvbi5cblxuXHRcdFx0dGVtcFYyXzEuY29weSggcDEgKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGVtcFYyXzIuY29weSggcDIgKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR2YXIgYW5nbGUgPSBNYXRoLlBJO1xuXHRcdFx0dmFyIGRvdCA9IHRlbXBWMl8xLmRvdCggdGVtcFYyXzIgKTtcblx0XHRcdGlmICggTWF0aC5hYnMoIGRvdCApIDwgMSApIGFuZ2xlID0gTWF0aC5hYnMoIE1hdGguYWNvcyggZG90ICkgKTtcblxuXHRcdFx0YW5nbGUgLz0gYXJjRGl2aXNpb25zO1xuXG5cdFx0XHR0ZW1wVjJfMy5jb3B5KCBwMSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJjRGl2aXNpb25zIC0gMTsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHRlbXBWMl80LmNvcHkoIHRlbXBWMl8zICkucm90YXRlQXJvdW5kKCBjZW50ZXIsIGFuZ2xlICk7XG5cblx0XHRcdFx0YWRkVmVydGV4KCB0ZW1wVjJfMywgdSwgdiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIHRlbXBWMl80LCB1LCB2ICk7XG5cdFx0XHRcdGFkZFZlcnRleCggY2VudGVyLCB1LCAwLjUgKTtcblxuXHRcdFx0XHR0ZW1wVjJfMy5jb3B5KCB0ZW1wVjJfNCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFkZFZlcnRleCggdGVtcFYyXzQsIHUsIHYgKTtcblx0XHRcdGFkZFZlcnRleCggcDIsIHUsIHYgKTtcblx0XHRcdGFkZFZlcnRleCggY2VudGVyLCB1LCAwLjUgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VTZWdtZW50VHJpYW5nbGVzKCkge1xuXG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTEsIDEgKTtcblx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1ha2VTZWdtZW50V2l0aEJldmVsSm9pbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQsIHUgKSB7XG5cblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW1pemVkIHNlZ21lbnQgKyBiZXZlbCB0cmlhbmdsZXNcblxuXHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBQYXRoIHNlZ21lbnRzIHRyaWFuZ2xlc1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdC8vIEJldmVsIGpvaW4gdHJpYW5nbGVcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50TCwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFBhdGggc2VnbWVudHMgdHJpYW5nbGVzXG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1MSwgMSApO1xuXG5cdFx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZVxuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRSLCB1LCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRSLCB1LCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQmV2ZWwgam9pbiB0cmlhbmdsZS4gVGhlIHNlZ21lbnQgdHJpYW5nbGVzIGFyZSBkb25lIGluIHRoZSBtYWluIGxvb3BcblxuXHRcdFx0XHRpZiAoIGpvaW5Jc09uTGVmdFNpZGUgKSB7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIG5leHRQb2ludEwsIHUsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdSwgMC41ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdSwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1LCAwLjUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVNlZ21lbnRUcmlhbmdsZXNXaXRoTWlkZGxlU2VjdGlvbiggam9pbklzT25MZWZ0U2lkZSwgaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdGlmICggaW5uZXJTaWRlTW9kaWZpZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludEwsIHUxLCAwICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludFIsIHUwLCAxICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnRMLCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludCwgdTEsIDAuNSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBuZXh0UG9pbnRMLCB1MCwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggaW5uZXJQb2ludCwgdTEsIDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YWRkVmVydGV4KCBsYXN0UG9pbnRSLCB1MCwgMSApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbGFzdFBvaW50TCwgdTAsIDAgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGN1cnJlbnRQb2ludFIsIHUxLCAxICk7XG5cblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGxhc3RQb2ludEwsIHUwLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTEsIDEgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50UiwgdTAsIDEgKTtcblx0XHRcdFx0XHRhZGRWZXJ0ZXgoIGlubmVyUG9pbnQsIHUxLCAwICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBjdXJyZW50UG9pbnQsIHUxLCAwLjUgKTtcblxuXHRcdFx0XHRcdGFkZFZlcnRleCggY3VycmVudFBvaW50LCB1MSwgMC41ICk7XG5cdFx0XHRcdFx0YWRkVmVydGV4KCBpbm5lclBvaW50LCB1MSwgMCApO1xuXHRcdFx0XHRcdGFkZFZlcnRleCggbmV4dFBvaW50UiwgdTAsIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcEdlb21ldHJ5KCBjZW50ZXIsIHAxLCBwMiwgam9pbklzT25MZWZ0U2lkZSwgc3RhcnQsIHUgKSB7XG5cblx0XHRcdC8vIHBhcmFtIGNlbnRlcjogRW5kIHBvaW50IG9mIHRoZSBwYXRoXG5cdFx0XHQvLyBwYXJhbSBwMSwgcDI6IExlZnQgYW5kIHJpZ2h0IGNhcCBwb2ludHNcblxuXHRcdFx0c3dpdGNoICggc3R5bGUuc3Ryb2tlTGluZUNhcCApIHtcblxuXHRcdFx0XHRjYXNlICdyb3VuZCc6XG5cblx0XHRcdFx0XHRpZiAoIHN0YXJ0ICkge1xuXG5cdFx0XHRcdFx0XHRtYWtlQ2lyY3VsYXJTZWN0b3IoIGNlbnRlciwgcDIsIHAxLCB1LCAwLjUgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG1ha2VDaXJjdWxhclNlY3RvciggY2VudGVyLCBwMSwgcDIsIHUsIDAuNSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc3F1YXJlJzpcblxuXHRcdFx0XHRcdGlmICggc3RhcnQgKSB7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8xLnN1YlZlY3RvcnMoIHAxLCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl8yLnNldCggdGVtcFYyXzEueSwgLSB0ZW1wVjJfMS54ICk7XG5cblx0XHRcdFx0XHRcdHRlbXBWMl8zLmFkZFZlY3RvcnMoIHRlbXBWMl8xLCB0ZW1wVjJfMiApLmFkZCggY2VudGVyICk7XG5cdFx0XHRcdFx0XHR0ZW1wVjJfNC5zdWJWZWN0b3JzKCB0ZW1wVjJfMiwgdGVtcFYyXzEgKS5hZGQoIGNlbnRlciApO1xuXG5cdFx0XHRcdFx0XHQvLyBNb2RpZnkgYWxyZWFkeSBleGlzdGluZyB2ZXJ0aWNlc1xuXHRcdFx0XHRcdFx0aWYgKCBqb2luSXNPbkxlZnRTaWRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAxICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblx0XHRcdFx0XHRcdFx0dGVtcFYyXzQudG9BcnJheSggdmVydGljZXMsIDMgKiAzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dGVtcFYyXzMudG9BcnJheSggdmVydGljZXMsIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCAzICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgMCAqIDMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzEuc3ViVmVjdG9ycyggcDIsIGNlbnRlciApO1xuXHRcdFx0XHRcdFx0dGVtcFYyXzIuc2V0KCB0ZW1wVjJfMS55LCAtIHRlbXBWMl8xLnggKTtcblxuXHRcdFx0XHRcdFx0dGVtcFYyXzMuYWRkVmVjdG9ycyggdGVtcFYyXzEsIHRlbXBWMl8yICkuYWRkKCBjZW50ZXIgKTtcblx0XHRcdFx0XHRcdHRlbXBWMl80LnN1YlZlY3RvcnMoIHRlbXBWMl8yLCB0ZW1wVjJfMSApLmFkZCggY2VudGVyICk7XG5cblx0XHRcdFx0XHRcdHZhciB2bCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0Ly8gTW9kaWZ5IGFscmVhZHkgZXhpc3RpbmcgdmVydGljZXNcblx0XHRcdFx0XHRcdGlmICggam9pbklzT25MZWZ0U2lkZSApIHtcblxuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfMy50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAxICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSAyICogMyApO1xuXHRcdFx0XHRcdFx0XHR0ZW1wVjJfNC50b0FycmF5KCB2ZXJ0aWNlcywgdmwgLSA0ICogMyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHRlbXBWMl8zLnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDIgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDEgKiAzICk7XG5cdFx0XHRcdFx0XHRcdHRlbXBWMl80LnRvQXJyYXkoIHZlcnRpY2VzLCB2bCAtIDQgKiAzICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVkUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHRcdC8vIENyZWF0ZXMgYSBuZXcgYXJyYXkgaWYgbmVjZXNzYXJ5IHdpdGggZHVwbGljYXRlZCBwb2ludHMgcmVtb3ZlZC5cblx0XHRcdC8vIFRoaXMgZG9lcyBub3QgcmVtb3ZlIGR1cGxpY2F0ZWQgaW5pdGlhbCBhbmQgZW5kaW5nIHBvaW50cyBvZiBhIGNsb3NlZCBwYXRoLlxuXG5cdFx0XHR2YXIgZHVwUG9pbnRzID0gZmFsc2U7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludHNbIGkgXS5kaXN0YW5jZVRvKCBwb2ludHNbIGkgKyAxIF0gKSA8IG1pbkRpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0ZHVwUG9pbnRzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIGR1cFBvaW50cyApIHJldHVybiBwb2ludHM7XG5cblx0XHRcdHZhciBuZXdQb2ludHMgPSBbXTtcblx0XHRcdG5ld1BvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA8IG47IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBwb2ludHNbIGkgXS5kaXN0YW5jZVRvKCBwb2ludHNbIGkgKyAxIF0gKSA+PSBtaW5EaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKCBwb2ludHNbIGkgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRuZXdQb2ludHMucHVzaCggcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdICk7XG5cblx0XHRcdHJldHVybiBuZXdQb2ludHM7XG5cblx0XHR9XG5cblx0fTtcblxufSgpO1xuXG5PYmplY3QzRC5EZWZhdWx0VXAuc2V0KDAsIDAsIDEpO1xudmFyIGRlZmF1bHRDb2xvciA9ICdob3RwaW5rJztcbnZhciB0cmF2ZXJzZUNoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkLCBvcGFjaXR5LCBzaGFkb3cpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhjaGlsZC51dWlkKVxuICAgIGlmIChjaGlsZC5pc01lc2gpIHtcbiAgICAgICAgY29uc29sZS5sb2coY2hpbGQubWF0ZXJpYWwpO1xuICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwudHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwuZm9yRWFjaChmdW5jdGlvbiAobWF0KSB7XG4gICAgICAgICAgICAgICAgbWF0ID0gbWF0LmNsb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsID0gY2hpbGQubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5tYXRlcmlhbCA9IGNoaWxkLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coY2hpbGQubWF0ZXJpYWwudXVpZClcbiAgICAgICAgaWYgKG9wYWNpdHkgIT09IDEuMCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGVyaWFsLmlzTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkLm1hdGVyaWFsKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLmZvckVhY2goZnVuY3Rpb24gKG1hdCkge1xuICAgICAgICAgICAgICAgICAgICBtYXQudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtYXQub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gJ1BvaW50TGlnaHQnKSB7XG4gICAgICAgIGNoaWxkLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCB8fCBjaGlsZC5pc0dyb3VwKSB7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkMikge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZDIsIG9wYWNpdHksIHNoYWRvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgU1RMQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbW9kZWwgPSB1c2VMb2FkZXIoU1RMTG9hZGVyLCBwcm9wcy51cmwpO1xuICAgIHZhciBzY2VuZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZWwuY2xvbmUoKTsgfSwgW21vZGVsXSk7XG4gICAgLy8gY29uc29sZS5sb2coJ0xvYWRpbmc6ICcpXG4gICAgLy8gY29uc29sZS5sb2cocHJvcHMpXG4gICAgLy8gdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyAgICAgLy8gc2NlbmUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAvLyAgICAgLy8gICAgIHRyYXZlcnNlQ2hpbGRyZW4oY2hpbGQsIHByb3BzLm9wYWNpdHksIHRydWUpXG4gICAgLy8gICAgIC8vIH0pXG4gICAgLy8gICAgIHNjZW5lLm5hbWUgPSAnbG9hZGVkJ1xuICAgIC8vIH0pXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7IHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSwgc2NhbGU6IFtwcm9wcy5zY2FsZVswXSwgcHJvcHMuc2NhbGVbMV0sIHByb3BzLnNjYWxlWzJdXSwgY2FzdFNoYWRvdzogdHJ1ZSwgcmVjZWl2ZVNoYWRvdzogdHJ1ZSwgbmFtZTogJ2xvYWRlZCcgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogc2NlbmUsIGF0dGFjaDogXCJnZW9tZXRyeVwiIH0pLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFN0YW5kYXJkTWF0ZXJpYWxcIiwgeyBjb2xvcjogcHJvcHMuY29sb3IgPyBwcm9wcy5jb2xvciA6IGRlZmF1bHRDb2xvciwgdHJhbnNwYXJlbnQ6IHByb3BzLm9wYWNpdHkgIT09IDEuMCA/IHRydWUgOiBmYWxzZSwgb3BhY2l0eTogcHJvcHMub3BhY2l0eSA/IHByb3BzLm9wYWNpdHkgOiAxLjAgfSkpKTtcbn07XG52YXIgR0xURkFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKEdMVEZMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kZWwuc2NlbmUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQ2hpbGRyZW4oY2hpbGQsIHByb3BzLm9wYWNpdHksIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsLnNjZW5lLCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5LCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0pKSk7XG59O1xudmFyIENvbGxhZGFBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihDb2xsYWRhTG9hZGVyLCBwcm9wcy51cmwpO1xuICAgIHZhciBzY2VuZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9kZWwuc2NlbmUuY2xvbmUodHJ1ZSk7IH0sIFttb2RlbC5zY2VuZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjZW5lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKGNoaWxkLCBwcm9wcy5vcGFjaXR5LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjZW5lLm5hbWUgPSAnbG9hZGVkJztcbiAgICB9LCBbc2NlbmVdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IHNjZW5lLCBwb3NpdGlvbjogcHJvcHMudCwgc2NhbGU6IHByb3BzLnNjYWxlLCBxdWF0ZXJuaW9uOiBwcm9wcy5xIH0pKTtcbn07XG52YXIgT0JKQXNzZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbXRsdXJsID0gcHJvcHMudXJsLnNsaWNlKDAsIHByb3BzLnVybC5sZW5ndGggLSAzKSArICdtdGwnO1xuICAgIHZhciBtYXRlcmlhbHMgPSB1c2VMb2FkZXIoTVRMTG9hZGVyLCBtdGx1cmwpO1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihPQkpMb2FkZXIsIHByb3BzLnVybCwgZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgICBtYXRlcmlhbHMucHJlbG9hZCgpO1xuICAgICAgICAvLyBsb2FkZXIuc2V0TWF0ZXJpYWxzKG1hdGVyaWFscylcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihjaGlsZCwgcHJvcHMub3BhY2l0eSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgeyBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0sIHNjYWxlOiBbcHJvcHMuc2NhbGVbMF0sIHByb3BzLnNjYWxlWzFdLCBwcm9wcy5zY2FsZVsyXV0sIGNhc3RTaGFkb3c6IHRydWUsIHJlY2VpdmVTaGFkb3c6IHRydWUgfSxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCB7IG9iamVjdDogbW9kZWwgfSkpKTtcbn07XG52YXIgVlJNTEFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKFZSTUxMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kZWwuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQ2hpbGRyZW4oY2hpbGQsIHByb3BzLm9wYWNpdHksIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsIH0pKSk7XG59O1xudmFyIFBDREFzc2V0ID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG1vZGVsID0gdXNlTG9hZGVyKFBDRExvYWRlciwgcHJvcHMudXJsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBtb2RlbC5tYXRlcmlhbC5jb2xvciA9IHByb3BzLmNvbG9yXG4gICAgICAgIC8vICAgICA/IG5ldyBUSFJFRS5Db2xvcihwcm9wcy5jb2xvcilcbiAgICAgICAgLy8gICAgIDogbmV3IFRIUkVFLkNvbG9yKGRlZmF1bHRDb2xvcilcbiAgICAgICAgLy8gbW9kZWwubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBwcm9wcy5vcGFjaXR5ICE9PSAxLjAgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgLy8gbW9kZWwubWF0ZXJpYWwub3BhY2l0eSA9IHByb3BzLm9wYWNpdHkgPyBwcm9wcy5vcGFjaXR5IDogMS4wXG4gICAgfSk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7IHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSwgc2NhbGU6IFtwcm9wcy5zY2FsZVswXSwgcHJvcHMuc2NhbGVbMV0sIHByb3BzLnNjYWxlWzJdXSwgY2FzdFNoYWRvdzogdHJ1ZSwgcmVjZWl2ZVNoYWRvdzogdHJ1ZSB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBtb2RlbCB9KSkpO1xufTtcbnZhciBQTFlBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihQTFlMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7IHBvc2l0aW9uOiBbcHJvcHMudFswXSwgcHJvcHMudFsxXSwgcHJvcHMudFsyXV0sIHF1YXRlcm5pb246IFtwcm9wcy5xWzBdLCBwcm9wcy5xWzFdLCBwcm9wcy5xWzJdLCBwcm9wcy5xWzNdXSwgc2NhbGU6IFtwcm9wcy5zY2FsZVswXSwgcHJvcHMuc2NhbGVbMV0sIHByb3BzLnNjYWxlWzJdXSwgY2FzdFNoYWRvdzogdHJ1ZSwgcmVjZWl2ZVNoYWRvdzogdHJ1ZSB9LFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIHsgb2JqZWN0OiBtb2RlbCwgYXR0YWNoOiBcImdlb21ldHJ5XCIgfSksXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoU3RhbmRhcmRNYXRlcmlhbFwiLCB7IGNvbG9yOiBwcm9wcy5jb2xvciA/IHByb3BzLmNvbG9yIDogZGVmYXVsdENvbG9yLCB0cmFuc3BhcmVudDogcHJvcHMub3BhY2l0eSAhPT0gMS4wID8gdHJ1ZSA6IGZhbHNlLCBvcGFjaXR5OiBwcm9wcy5vcGFjaXR5ID8gcHJvcHMub3BhY2l0eSA6IDEuMCB9KSkpO1xufTtcbnZhciBGQlhBc3NldCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBtb2RlbCA9IHVzZUxvYWRlcihGQlhMb2FkZXIsIHByb3BzLnVybCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbW9kZWwuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlQ2hpbGRyZW4oY2hpbGQsIHByb3BzLm9wYWNpdHksIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHsgcG9zaXRpb246IFtwcm9wcy50WzBdLCBwcm9wcy50WzFdLCBwcm9wcy50WzJdXSwgcXVhdGVybmlvbjogW3Byb3BzLnFbMF0sIHByb3BzLnFbMV0sIHByb3BzLnFbMl0sIHByb3BzLnFbM11dLCBzY2FsZTogW3Byb3BzLnNjYWxlWzBdLCBwcm9wcy5zY2FsZVsxXSwgcHJvcHMuc2NhbGVbMl1dLCBjYXN0U2hhZG93OiB0cnVlLCByZWNlaXZlU2hhZG93OiB0cnVlIH0sXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgeyBvYmplY3Q6IG1vZGVsIH0pKSk7XG59O1xudmFyIFNWR1NoYXBlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNoYXBlID0gX2Euc2hhcGUsIGNvbG9yID0gX2EuY29sb3IsIGluZGV4ID0gX2EuaW5kZXgsIG9wYWNpdHkgPSBfYS5vcGFjaXR5O1xuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgbnVsbCxcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1lc2hMYW1iZXJ0TWF0ZXJpYWxcIiwgeyBhdHRhY2g6IFwibWF0ZXJpYWxcIiwgY29sb3I6IGNvbG9yLCBwb2x5Z29uT2Zmc2V0OiB0cnVlLCBwb2x5Z29uT2Zmc2V0RmFjdG9yOiBpbmRleCAqIC0wLjEsIHRyYW5zcGFyZW50OiBvcGFjaXR5ICE9PSAxLjAgPyB0cnVlIDogZmFsc2UsIG9wYWNpdHk6IG9wYWNpdHkgPyBvcGFjaXR5IDogMS4wIH0pLFxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2hhcGVCdWZmZXJHZW9tZXRyeVwiLCB7IGF0dGFjaDogXCJnZW9tZXRyeVwiLCBhcmdzOiBbc2hhcGVdIH0pKSk7XG59O1xudmFyIFNWR0Fzc2V0ID0gUmVhY3RfX2RlZmF1bHQubWVtbyhmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgcGF0aHMgPSB1c2VMb2FkZXIoU1ZHTG9hZGVyLCBwcm9wcy51cmwpLnBhdGhzO1xuICAgIHZhciBzaGFwZXMgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhzLmZsYXRNYXAoZnVuY3Rpb24gKHBhdGgsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgICAgICAgICAgIC50b1NoYXBlcyh0cnVlKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNoYXBlKSB7IHJldHVybiAoeyBpbmRleDogaW5kZXgsIHNoYXBlOiBzaGFwZSwgY29sb3I6IHBhdGguY29sb3IgfSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbcGF0aHNdKTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7IGNoaWxkcmVuOiBzaGFwZXMubWFwKGZ1bmN0aW9uIChuZXdQcm9wcywga2V5KSB7IHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTVkdTaGFwZSwgX19hc3NpZ24oeyBrZXk6IGtleSwgb3BhY2l0eTogcHJvcHMub3BhY2l0eSB9LCBuZXdQcm9wcykpKTsgfSksIHNjYWxlOiBbXG4gICAgICAgICAgICAtMC4wMSAqIHByb3BzLnNjYWxlWzBdLFxuICAgICAgICAgICAgMC4wMSAqIHByb3BzLnNjYWxlWzFdLFxuICAgICAgICAgICAgMC4wMSAqIHByb3BzLnNjYWxlWzJdLFxuICAgICAgICBdLCBwb3NpdGlvbjogW3Byb3BzLnRbMF0sIHByb3BzLnRbMV0sIHByb3BzLnRbMl1dLCBxdWF0ZXJuaW9uOiBbcHJvcHMucVswXSwgcHJvcHMucVsxXSwgcHJvcHMucVsyXSwgcHJvcHMucVszXV0gfSkpO1xufSk7XG52YXIgTG9hZGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGV4dCA9IHByb3BzLmZpbGVuYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdXJsID0gcHJvcHMuZmlsZW5hbWU7XG4gICAgdXJsID0gXCJyZXRyaWV2ZS9cIiArIHVybDtcbiAgICBzd2l0Y2ggKGV4dCkge1xuICAgICAgICBjYXNlICdzdGwnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU1RMQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAnZ2x0Zic6XG4gICAgICAgIGNhc2UgJ2dsYic6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChHTFRGQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAnZGFlJzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbGxhZGFBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdvYmonOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoT0JKQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAnd3JsJzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFZSTUxBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdwY2QnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUENEQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgY2FzZSAncGx5JzpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFBMWUFzc2V0LCBfX2Fzc2lnbih7IHVybDogdXJsIH0sIHByb3BzKSk7XG4gICAgICAgIGNhc2UgJ2ZieCc6XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChGQlhBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU1ZHQXNzZXQsIF9fYXNzaWduKHsgdXJsOiB1cmwgfSwgcHJvcHMpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbGxhZGFBc3NldCwgX19hc3NpZ24oeyB1cmw6IHVybCB9LCBwcm9wcykpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlci0yYjljZDI5NC5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../react-swift/dist/Loader-2b9cd294.js\n");

/***/ })

}]);